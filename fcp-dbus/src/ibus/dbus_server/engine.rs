// This code was autogenerated with `dbus-codegen-rust -r --file ./interfaces_you_implement.xml -o you_impl.rs`, see https://github.com/diwic/dbus-rs
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus_crossroads as crossroads;

pub trait IBusEngine {
    fn process_key_event(&mut self, keyval: u32, keycode: u32, state: u32) -> Result<bool, dbus::MethodErr>;
    fn set_cursor_location(&mut self, x_: i32, y_: i32, w_: i32, h_: i32) -> Result<(), dbus::MethodErr>;
    fn process_hand_writing_event(&mut self, coordinates: Vec<f64>) -> Result<(), dbus::MethodErr>;
    fn cancel_hand_writing(&mut self, n_strokes: u32) -> Result<(), dbus::MethodErr>;
    fn set_capabilities(&mut self, caps: u32) -> Result<(), dbus::MethodErr>;
    fn property_activate(&mut self, name: String, state: u32) -> Result<(), dbus::MethodErr>;
    fn property_show(&mut self, name: String) -> Result<(), dbus::MethodErr>;
    fn property_hide(&mut self, name: String) -> Result<(), dbus::MethodErr>;
    fn candidate_clicked(&mut self, index: u32, button: u32, state: u32) -> Result<(), dbus::MethodErr>;
    fn focus_in(&mut self) -> Result<(), dbus::MethodErr>;
    fn focus_in_id(&mut self, object_path: String, client: String) -> Result<(), dbus::MethodErr>;
    fn focus_out(&mut self) -> Result<(), dbus::MethodErr>;
    fn focus_out_id(&mut self, object_path: String) -> Result<(), dbus::MethodErr>;
    fn reset(&mut self) -> Result<(), dbus::MethodErr>;
    fn enable(&mut self) -> Result<(), dbus::MethodErr>;
    fn disable(&mut self) -> Result<(), dbus::MethodErr>;
    fn page_up(&mut self) -> Result<(), dbus::MethodErr>;
    fn page_down(&mut self) -> Result<(), dbus::MethodErr>;
    fn cursor_up(&mut self) -> Result<(), dbus::MethodErr>;
    fn cursor_down(&mut self) -> Result<(), dbus::MethodErr>;
    fn set_surrounding_text(&mut self, text: arg::Variant<Box<dyn arg::RefArg + 'static>>, cursor_pos: u32, anchor_pos: u32) -> Result<(), dbus::MethodErr>;
    fn panel_extension_received(&mut self, event: arg::Variant<Box<dyn arg::RefArg + 'static>>) -> Result<(), dbus::MethodErr>;
    fn panel_extension_register_keys(&mut self, data: arg::Variant<Box<dyn arg::RefArg + 'static>>) -> Result<(), dbus::MethodErr>;
    fn set_content_type(&self, value: (u32, u32)) -> Result<(), dbus::MethodErr>;
    fn focus_id(&self) -> Result<(bool), dbus::MethodErr>;
    fn active_surrounding_text(&self) -> Result<(bool), dbus::MethodErr>;
}

#[derive(Debug)]
pub struct CommitText {
    pub text: arg::Variant<Box<dyn arg::RefArg + 'static>>,
}

impl arg::AppendAll for CommitText {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.text, i);
    }
}

impl arg::ReadAll for CommitText {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(CommitText {
            text: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for CommitText {
    const NAME: &'static str = "CommitText";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Engine";
}

#[derive(Debug)]
pub struct UpdatePreeditText {
    pub text: arg::Variant<Box<dyn arg::RefArg + 'static>>,
    pub cursor_pos: u32,
    pub visible: bool,
    pub mode: u32,
}

impl arg::AppendAll for UpdatePreeditText {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.text, i);
        arg::RefArg::append(&self.cursor_pos, i);
        arg::RefArg::append(&self.visible, i);
        arg::RefArg::append(&self.mode, i);
    }
}

impl arg::ReadAll for UpdatePreeditText {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(UpdatePreeditText {
            text: i.read()?,
            cursor_pos: i.read()?,
            visible: i.read()?,
            mode: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for UpdatePreeditText {
    const NAME: &'static str = "UpdatePreeditText";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Engine";
}

#[derive(Debug)]
pub struct UpdateAuxiliaryText {
    pub text: arg::Variant<Box<dyn arg::RefArg + 'static>>,
    pub visible: bool,
}

impl arg::AppendAll for UpdateAuxiliaryText {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.text, i);
        arg::RefArg::append(&self.visible, i);
    }
}

impl arg::ReadAll for UpdateAuxiliaryText {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(UpdateAuxiliaryText {
            text: i.read()?,
            visible: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for UpdateAuxiliaryText {
    const NAME: &'static str = "UpdateAuxiliaryText";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Engine";
}

#[derive(Debug)]
pub struct UpdateLookupTable {
    pub table: arg::Variant<Box<dyn arg::RefArg + 'static>>,
    pub visible: bool,
}

impl arg::AppendAll for UpdateLookupTable {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.table, i);
        arg::RefArg::append(&self.visible, i);
    }
}

impl arg::ReadAll for UpdateLookupTable {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(UpdateLookupTable {
            table: i.read()?,
            visible: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for UpdateLookupTable {
    const NAME: &'static str = "UpdateLookupTable";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Engine";
}

#[derive(Debug)]
pub struct RegisterProperties {
    pub props: arg::Variant<Box<dyn arg::RefArg + 'static>>,
}

impl arg::AppendAll for RegisterProperties {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.props, i);
    }
}

impl arg::ReadAll for RegisterProperties {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(RegisterProperties {
            props: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for RegisterProperties {
    const NAME: &'static str = "RegisterProperties";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Engine";
}

#[derive(Debug)]
pub struct UpdateProperty {
    pub prop: arg::Variant<Box<dyn arg::RefArg + 'static>>,
}

impl arg::AppendAll for UpdateProperty {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.prop, i);
    }
}

impl arg::ReadAll for UpdateProperty {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(UpdateProperty {
            prop: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for UpdateProperty {
    const NAME: &'static str = "UpdateProperty";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Engine";
}

#[derive(Debug)]
pub struct ForwardKeyEvent {
    pub keyval: u32,
    pub keycode: u32,
    pub state: u32,
}

impl arg::AppendAll for ForwardKeyEvent {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.keyval, i);
        arg::RefArg::append(&self.keycode, i);
        arg::RefArg::append(&self.state, i);
    }
}

impl arg::ReadAll for ForwardKeyEvent {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(ForwardKeyEvent {
            keyval: i.read()?,
            keycode: i.read()?,
            state: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for ForwardKeyEvent {
    const NAME: &'static str = "ForwardKeyEvent";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Engine";
}

#[derive(Debug)]
pub struct PanelExtension {
    pub data: arg::Variant<Box<dyn arg::RefArg + 'static>>,
}

impl arg::AppendAll for PanelExtension {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.data, i);
    }
}

impl arg::ReadAll for PanelExtension {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(PanelExtension {
            data: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for PanelExtension {
    const NAME: &'static str = "PanelExtension";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Engine";
}

pub fn register_org_freedesktop_ibus_engine<T>(cr: &mut crossroads::Crossroads) -> crossroads::IfaceToken<T>
where T: IBusEngine + Send + 'static
{
    cr.register("org.freedesktop.IBus.Engine", |b| {
        b.signal::<(arg::Variant<Box<dyn arg::RefArg + 'static>>,), _>("CommitText", ("text",));
        b.signal::<(arg::Variant<Box<dyn arg::RefArg + 'static>>,u32,bool,u32,), _>("UpdatePreeditText", ("text","cursor_pos","visible","mode",));
        b.signal::<(arg::Variant<Box<dyn arg::RefArg + 'static>>,bool,), _>("UpdateAuxiliaryText", ("text","visible",));
        b.signal::<(arg::Variant<Box<dyn arg::RefArg + 'static>>,bool,), _>("UpdateLookupTable", ("table","visible",));
        b.signal::<(arg::Variant<Box<dyn arg::RefArg + 'static>>,), _>("RegisterProperties", ("props",));
        b.signal::<(arg::Variant<Box<dyn arg::RefArg + 'static>>,), _>("UpdateProperty", ("prop",));
        b.signal::<(u32,u32,u32,), _>("ForwardKeyEvent", ("keyval","keycode","state",));
        b.signal::<(arg::Variant<Box<dyn arg::RefArg + 'static>>,), _>("PanelExtension", ("data",));
        b.method("ProcessKeyEvent", ("keyval","keycode","state",), ("",), |_, t: &mut T, (keyval,keycode,state,)| {
            t.process_key_event(keyval,keycode,state,)
                .map(|x| (x,))
        });
        b.method("SetCursorLocation", ("x","y","w","h",), (), |_, t: &mut T, (x,y,w,h,)| {
            t.set_cursor_location(x,y,w,h,)
        });
        b.method("ProcessHandWritingEvent", ("coordinates",), (), |_, t: &mut T, (coordinates,)| {
            t.process_hand_writing_event(coordinates,)
        });
        b.method("CancelHandWriting", ("n_strokes",), (), |_, t: &mut T, (n_strokes,)| {
            t.cancel_hand_writing(n_strokes,)
        });
        b.method("SetCapabilities", ("caps",), (), |_, t: &mut T, (caps,)| {
            t.set_capabilities(caps,)
        });
        b.method("PropertyActivate", ("name","state",), (), |_, t: &mut T, (name,state,)| {
            t.property_activate(name,state,)
        });
        b.method("PropertyShow", ("name",), (), |_, t: &mut T, (name,)| {
            t.property_show(name,)
        });
        b.method("PropertyHide", ("name",), (), |_, t: &mut T, (name,)| {
            t.property_hide(name,)
        });
        b.method("CandidateClicked", ("index","button","state",), (), |_, t: &mut T, (index,button,state,)| {
            t.candidate_clicked(index,button,state,)
        });
        b.method("FocusIn", (), (), |_, t: &mut T, ()| {
            t.focus_in()
        });
        b.method("FocusInId", ("object_path","client",), (), |_, t: &mut T, (object_path,client,)| {
            t.focus_in_id(object_path,client,)
        });
        b.method("FocusOut", (), (), |_, t: &mut T, ()| {
            t.focus_out()
        });
        b.method("FocusOutId", ("object_path",), (), |_, t: &mut T, (object_path,)| {
            t.focus_out_id(object_path,)
        });
        b.method("Reset", (), (), |_, t: &mut T, ()| {
            t.reset()
        });
        b.method("Enable", (), (), |_, t: &mut T, ()| {
            t.enable()
        });
        b.method("Disable", (), (), |_, t: &mut T, ()| {
            t.disable()
        });
        b.method("PageUp", (), (), |_, t: &mut T, ()| {
            t.page_up()
        });
        b.method("PageDown", (), (), |_, t: &mut T, ()| {
            t.page_down()
        });
        b.method("CursorUp", (), (), |_, t: &mut T, ()| {
            t.cursor_up()
        });
        b.method("CursorDown", (), (), |_, t: &mut T, ()| {
            t.cursor_down()
        });
        b.method("SetSurroundingText", ("text","cursor_pos","anchor_pos",), (), |_, t: &mut T, (text,cursor_pos,anchor_pos,)| {
            t.set_surrounding_text(text,cursor_pos,anchor_pos,)
        });
        b.method("PanelExtensionReceived", ("event",), (), |_, t: &mut T, (event,)| {
            t.panel_extension_received(event,)
        });
        b.method("PanelExtensionRegisterKeys", ("data",), (), |_, t: &mut T, (data,)| {
            t.panel_extension_register_keys(data,)
        });
        b.property::<(u32, u32), _>("ContentType")
            .set(|_, t, value| t.set_content_type(value).map(|_| None));
        b.property::<(bool), _>("FocusId")
            .get(|_, t| t.focus_id());
        b.property::<(bool), _>("ActiveSurroundingText")
            .get(|_, t| t.active_surrounding_text());
    })
}
