// This code was autogenerated with `dbus-codegen-rust -c blocking --file ./interfaces_you_call.xml -o you_call.rs`, see https://github.com/diwic/dbus-rs
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus::blocking;

pub trait IBusPanelProxy {
    fn update_preedit_text(&self, text: arg::Variant<Box<dyn arg::RefArg>>, cursor_pos: u32, visible: bool) -> Result<(), dbus::Error>;
    fn show_preedit_text(&self) -> Result<(), dbus::Error>;
    fn hide_preedit_text(&self) -> Result<(), dbus::Error>;
    fn update_auxiliary_text(&self, text: arg::Variant<Box<dyn arg::RefArg>>, visible: bool) -> Result<(), dbus::Error>;
    fn show_auxiliary_text(&self) -> Result<(), dbus::Error>;
    fn hide_auxiliary_text(&self) -> Result<(), dbus::Error>;
    fn update_lookup_table(&self, table: arg::Variant<Box<dyn arg::RefArg>>, visible: bool) -> Result<(), dbus::Error>;
    fn show_lookup_table(&self) -> Result<(), dbus::Error>;
    fn hide_lookup_table(&self) -> Result<(), dbus::Error>;
    fn cursor_up_lookup_table(&self) -> Result<(), dbus::Error>;
    fn cursor_down_lookup_table(&self) -> Result<(), dbus::Error>;
    fn page_up_lookup_table(&self) -> Result<(), dbus::Error>;
    fn page_down_lookup_table(&self) -> Result<(), dbus::Error>;
    fn candidate_clicked_lookup_table(&self, index: u32, button: u32, state: u32) -> Result<(), dbus::Error>;
    fn register_properties(&self, props: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error>;
    fn update_property(&self, prop: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error>;
    fn focus_in(&self, ic: dbus::Path) -> Result<(), dbus::Error>;
    fn focus_out(&self, ic: dbus::Path) -> Result<(), dbus::Error>;
    fn destroy_context(&self, ic: dbus::Path) -> Result<(), dbus::Error>;
    fn set_cursor_location(&self, x_: i32, y_: i32, w_: i32, h_: i32) -> Result<(), dbus::Error>;
    fn set_cursor_location_relative(&self, x_: i32, y_: i32, w_: i32, h_: i32) -> Result<(), dbus::Error>;
    fn reset(&self) -> Result<(), dbus::Error>;
    fn start_setup(&self) -> Result<(), dbus::Error>;
    fn state_changed(&self) -> Result<(), dbus::Error>;
    fn hide_language_bar(&self) -> Result<(), dbus::Error>;
    fn show_language_bar(&self) -> Result<(), dbus::Error>;
    fn content_type(&self, purpose: u32, hints: u32) -> Result<(), dbus::Error>;
    fn panel_extension_received(&self, event: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error>;
    fn process_key_event(&self, keyval: u32, keycode: u32, state: u32) -> Result<bool, dbus::Error>;
    fn commit_text_received(&self, text: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error>;
    fn panel_extension_register_keys(&self, data: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error>;
}

#[derive(Debug)]
pub struct CursorUp {
}

impl arg::AppendAll for CursorUp {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for CursorUp {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(CursorUp {
        })
    }
}

impl dbus::message::SignalArgs for CursorUp {
    const NAME: &'static str = "CursorUp";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

#[derive(Debug)]
pub struct CursorDown {
}

impl arg::AppendAll for CursorDown {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for CursorDown {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(CursorDown {
        })
    }
}

impl dbus::message::SignalArgs for CursorDown {
    const NAME: &'static str = "CursorDown";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

#[derive(Debug)]
pub struct PageUp {
}

impl arg::AppendAll for PageUp {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for PageUp {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(PageUp {
        })
    }
}

impl dbus::message::SignalArgs for PageUp {
    const NAME: &'static str = "PageUp";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

#[derive(Debug)]
pub struct PageDown {
}

impl arg::AppendAll for PageDown {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for PageDown {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(PageDown {
        })
    }
}

impl dbus::message::SignalArgs for PageDown {
    const NAME: &'static str = "PageDown";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

#[derive(Debug)]
pub struct PropertyActivate {
    pub prop_name: String,
    pub prop_state: i32,
}

impl arg::AppendAll for PropertyActivate {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.prop_name, i);
        arg::RefArg::append(&self.prop_state, i);
    }
}

impl arg::ReadAll for PropertyActivate {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(PropertyActivate {
            prop_name: i.read()?,
            prop_state: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for PropertyActivate {
    const NAME: &'static str = "PropertyActivate";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

#[derive(Debug)]
pub struct PropertyShow {
    pub prop_name: String,
}

impl arg::AppendAll for PropertyShow {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.prop_name, i);
    }
}

impl arg::ReadAll for PropertyShow {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(PropertyShow {
            prop_name: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for PropertyShow {
    const NAME: &'static str = "PropertyShow";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

#[derive(Debug)]
pub struct PropertyHide {
    pub prop_name: String,
}

impl arg::AppendAll for PropertyHide {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.prop_name, i);
    }
}

impl arg::ReadAll for PropertyHide {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(PropertyHide {
            prop_name: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for PropertyHide {
    const NAME: &'static str = "PropertyHide";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

#[derive(Debug)]
pub struct CandidateClicked {
    pub index: u32,
    pub button: u32,
    pub state: u32,
}

impl arg::AppendAll for CandidateClicked {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.index, i);
        arg::RefArg::append(&self.button, i);
        arg::RefArg::append(&self.state, i);
    }
}

impl arg::ReadAll for CandidateClicked {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(CandidateClicked {
            index: i.read()?,
            button: i.read()?,
            state: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for CandidateClicked {
    const NAME: &'static str = "CandidateClicked";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

#[derive(Debug)]
pub struct CommitText {
    pub text: arg::Variant<Box<dyn arg::RefArg + 'static>>,
}

impl arg::AppendAll for CommitText {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.text, i);
    }
}

impl arg::ReadAll for CommitText {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(CommitText {
            text: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for CommitText {
    const NAME: &'static str = "CommitText";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

#[derive(Debug)]
pub struct PanelExtension {
    pub event: arg::Variant<Box<dyn arg::RefArg + 'static>>,
}

impl arg::AppendAll for PanelExtension {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.event, i);
    }
}

impl arg::ReadAll for PanelExtension {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(PanelExtension {
            event: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for PanelExtension {
    const NAME: &'static str = "PanelExtension";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

#[derive(Debug)]
pub struct UpdatePreeditTextReceived {
    pub text: arg::Variant<Box<dyn arg::RefArg + 'static>>,
    pub cursor_pos: u32,
    pub visible: bool,
}

impl arg::AppendAll for UpdatePreeditTextReceived {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.text, i);
        arg::RefArg::append(&self.cursor_pos, i);
        arg::RefArg::append(&self.visible, i);
    }
}

impl arg::ReadAll for UpdatePreeditTextReceived {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(UpdatePreeditTextReceived {
            text: i.read()?,
            cursor_pos: i.read()?,
            visible: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for UpdatePreeditTextReceived {
    const NAME: &'static str = "UpdatePreeditTextReceived";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

#[derive(Debug)]
pub struct UpdateAuxiliaryTextReceived {
    pub text: arg::Variant<Box<dyn arg::RefArg + 'static>>,
    pub visible: bool,
}

impl arg::AppendAll for UpdateAuxiliaryTextReceived {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.text, i);
        arg::RefArg::append(&self.visible, i);
    }
}

impl arg::ReadAll for UpdateAuxiliaryTextReceived {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(UpdateAuxiliaryTextReceived {
            text: i.read()?,
            visible: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for UpdateAuxiliaryTextReceived {
    const NAME: &'static str = "UpdateAuxiliaryTextReceived";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

#[derive(Debug)]
pub struct UpdateLookupTableReceived {
    pub table: arg::Variant<Box<dyn arg::RefArg + 'static>>,
    pub visible: bool,
}

impl arg::AppendAll for UpdateLookupTableReceived {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.table, i);
        arg::RefArg::append(&self.visible, i);
    }
}

impl arg::ReadAll for UpdateLookupTableReceived {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(UpdateLookupTableReceived {
            table: i.read()?,
            visible: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for UpdateLookupTableReceived {
    const NAME: &'static str = "UpdateLookupTableReceived";
    const INTERFACE: &'static str = "org.freedesktop.IBus.Panel";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> IBusPanelProxy for blocking::Proxy<'a, C> {

    fn update_preedit_text(&self, text: arg::Variant<Box<dyn arg::RefArg>>, cursor_pos: u32, visible: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "UpdatePreeditText", (text, cursor_pos, visible, ))
    }

    fn show_preedit_text(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "ShowPreeditText", ())
    }

    fn hide_preedit_text(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "HidePreeditText", ())
    }

    fn update_auxiliary_text(&self, text: arg::Variant<Box<dyn arg::RefArg>>, visible: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "UpdateAuxiliaryText", (text, visible, ))
    }

    fn show_auxiliary_text(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "ShowAuxiliaryText", ())
    }

    fn hide_auxiliary_text(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "HideAuxiliaryText", ())
    }

    fn update_lookup_table(&self, table: arg::Variant<Box<dyn arg::RefArg>>, visible: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "UpdateLookupTable", (table, visible, ))
    }

    fn show_lookup_table(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "ShowLookupTable", ())
    }

    fn hide_lookup_table(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "HideLookupTable", ())
    }

    fn cursor_up_lookup_table(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "CursorUpLookupTable", ())
    }

    fn cursor_down_lookup_table(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "CursorDownLookupTable", ())
    }

    fn page_up_lookup_table(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "PageUpLookupTable", ())
    }

    fn page_down_lookup_table(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "PageDownLookupTable", ())
    }

    fn candidate_clicked_lookup_table(&self, index: u32, button: u32, state: u32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "CandidateClickedLookupTable", (index, button, state, ))
    }

    fn register_properties(&self, props: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "RegisterProperties", (props, ))
    }

    fn update_property(&self, prop: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "UpdateProperty", (prop, ))
    }

    fn focus_in(&self, ic: dbus::Path) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "FocusIn", (ic, ))
    }

    fn focus_out(&self, ic: dbus::Path) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "FocusOut", (ic, ))
    }

    fn destroy_context(&self, ic: dbus::Path) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "DestroyContext", (ic, ))
    }

    fn set_cursor_location(&self, x_: i32, y_: i32, w_: i32, h_: i32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "SetCursorLocation", (x_, y_, w_, h_, ))
    }

    fn set_cursor_location_relative(&self, x_: i32, y_: i32, w_: i32, h_: i32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "SetCursorLocationRelative", (x_, y_, w_, h_, ))
    }

    fn reset(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "Reset", ())
    }

    fn start_setup(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "StartSetup", ())
    }

    fn state_changed(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "StateChanged", ())
    }

    fn hide_language_bar(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "HideLanguageBar", ())
    }

    fn show_language_bar(&self) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "ShowLanguageBar", ())
    }

    fn content_type(&self, purpose: u32, hints: u32) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "ContentType", (purpose, hints, ))
    }

    fn panel_extension_received(&self, event: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "PanelExtensionReceived", (event, ))
    }

    fn process_key_event(&self, keyval: u32, keycode: u32, state: u32) -> Result<bool, dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "ProcessKeyEvent", (keyval, keycode, state, ))
            .and_then(|r: (bool, )| Ok(r.0, ))
    }

    fn commit_text_received(&self, text: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "CommitTextReceived", (text, ))
    }

    fn panel_extension_register_keys(&self, data: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus.Panel", "PanelExtensionRegisterKeys", (data, ))
    }
}