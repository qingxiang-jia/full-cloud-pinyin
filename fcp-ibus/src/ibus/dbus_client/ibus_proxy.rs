// This code was autogenerated with `dbus-codegen-rust -c blocking --file ./interfaces_you_call.xml -o you_call.rs`, see https://github.com/diwic/dbus-rs
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus::blocking;

pub trait IBusProxy {
    fn create_input_context(&self, client_name: &str) -> Result<dbus::Path<'static>, dbus::Error>;
    fn register_component(&self, component: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error>;
    fn get_engines_by_names(&self, names: Vec<&str>) -> Result<Vec<arg::Variant<Box<dyn arg::RefArg + 'static>>>, dbus::Error>;
    fn exit(&self, restart: bool) -> Result<(), dbus::Error>;
    fn ping(&self, data: arg::Variant<Box<dyn arg::RefArg>>) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error>;
    fn set_global_engine_(&self, engine_name: &str) -> Result<(), dbus::Error>;
    fn get_use_global_engine(&self) -> Result<bool, dbus::Error>;
    fn address(&self) -> Result<String, dbus::Error>;
    fn current_input_context(&self) -> Result<dbus::Path<'static>, dbus::Error>;
    fn engines(&self) -> Result<Vec<arg::Variant<Box<dyn arg::RefArg + 'static>>>, dbus::Error>;
    fn global_engine(&self) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error>;
    fn set_preload_engines(&self, value: Vec<String>) -> Result<(), dbus::Error>;
    fn embed_preedit_text(&self) -> Result<bool, dbus::Error>;
    fn set_embed_preedit_text(&self, value: bool) -> Result<(), dbus::Error>;
    fn active_engines(&self) -> Result<Vec<arg::Variant<Box<dyn arg::RefArg + 'static>>>, dbus::Error>;
}

#[derive(Debug)]
pub struct RegistryChanged {
}

impl arg::AppendAll for RegistryChanged {
    fn append(&self, _: &mut arg::IterAppend) {
    }
}

impl arg::ReadAll for RegistryChanged {
    fn read(_: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(RegistryChanged {
        })
    }
}

impl dbus::message::SignalArgs for RegistryChanged {
    const NAME: &'static str = "RegistryChanged";
    const INTERFACE: &'static str = "org.freedesktop.IBus";
}

#[derive(Debug)]
pub struct GlobalEngineChanged {
    pub engine_name: String,
}

impl arg::AppendAll for GlobalEngineChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.engine_name, i);
    }
}

impl arg::ReadAll for GlobalEngineChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(GlobalEngineChanged {
            engine_name: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for GlobalEngineChanged {
    const NAME: &'static str = "GlobalEngineChanged";
    const INTERFACE: &'static str = "org.freedesktop.IBus";
}

impl<'a, T: blocking::BlockingSender, C: ::std::ops::Deref<Target=T>> IBusProxy for blocking::Proxy<'a, C> {

    fn create_input_context(&self, client_name: &str) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.IBus", "CreateInputContext", (client_name, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn register_component(&self, component: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus", "RegisterComponent", (component, ))
    }

    fn get_engines_by_names(&self, names: Vec<&str>) -> Result<Vec<arg::Variant<Box<dyn arg::RefArg + 'static>>>, dbus::Error> {
        self.method_call("org.freedesktop.IBus", "GetEnginesByNames", (names, ))
            .and_then(|r: (Vec<arg::Variant<Box<dyn arg::RefArg + 'static>>>, )| Ok(r.0, ))
    }

    fn exit(&self, restart: bool) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus", "Exit", (restart, ))
    }

    fn ping(&self, data: arg::Variant<Box<dyn arg::RefArg>>) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error> {
        self.method_call("org.freedesktop.IBus", "Ping", (data, ))
            .and_then(|r: (arg::Variant<Box<dyn arg::RefArg + 'static>>, )| Ok(r.0, ))
    }

    fn set_global_engine_(&self, engine_name: &str) -> Result<(), dbus::Error> {
        self.method_call("org.freedesktop.IBus", "SetGlobalEngine", (engine_name, ))
    }

    fn get_use_global_engine(&self) -> Result<bool, dbus::Error> {
        self.method_call("org.freedesktop.IBus", "GetUseGlobalEngine", ())
            .and_then(|r: (bool, )| Ok(r.0, ))
    }

    fn address(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.IBus", "Address")
    }

    fn current_input_context(&self) -> Result<dbus::Path<'static>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.IBus", "CurrentInputContext")
    }

    fn engines(&self) -> Result<Vec<arg::Variant<Box<dyn arg::RefArg + 'static>>>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.IBus", "Engines")
    }

    fn global_engine(&self) -> Result<arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.IBus", "GlobalEngine")
    }

    fn embed_preedit_text(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.IBus", "EmbedPreeditText")
    }

    fn active_engines(&self) -> Result<Vec<arg::Variant<Box<dyn arg::RefArg + 'static>>>, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.IBus", "ActiveEngines")
    }

    fn set_preload_engines(&self, value: Vec<String>) -> Result<(), dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.IBus", "PreloadEngines", value)
    }

    fn set_embed_preedit_text(&self, value: bool) -> Result<(), dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.IBus", "EmbedPreeditText", value)
    }
}
