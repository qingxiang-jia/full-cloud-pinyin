//! # DBus interface proxies for: `org.freedesktop.IBus.Service`, `org.freedesktop.IBus.Factory`, `org.freedesktop.IBus.Service`, `org.freedesktop.IBus.Engine`, `org.freedesktop.IBus.Panel`
//!
//! This code was generated by `zbus-xmlgen` `3.1.0` from DBus introspection data.
//! Source: `interfaces.xml`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the
//! [Writing a client proxy](https://dbus.pages.freedesktop.org/zbus/client.html)
//! section of the zbus documentation.

impl<'a> ::zbus::ProxyDefault for ServiceProxyBlocking<'a> {
    const INTERFACE: &'static str = "org.freedesktop.IBus.Service";
    const DESTINATION: &'static str = "org.freedesktop.IBus.Service";
    const PATH: &'static str = "/org/freedesktop/Service";
}
pub struct ServiceProxyBlocking<'c>(::zbus::blocking::Proxy<'c>);
#[automatically_derived]
impl<'c> ::core::clone::Clone for ServiceProxyBlocking<'c> {
    #[inline]
    fn clone(&self) -> ServiceProxyBlocking<'c> {
        ServiceProxyBlocking(::core::clone::Clone::clone(&self.0))
    }
}
#[automatically_derived]
impl<'c> ::core::fmt::Debug for ServiceProxyBlocking<'c> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "ServiceProxyBlocking", &&self.0)
    }
}
impl<'c> ServiceProxyBlocking<'c> {
    #[doc = r" Creates a new proxy with the default service and path."]
    pub fn new(conn: &::zbus::blocking::Connection) -> ::zbus::Result<ServiceProxyBlocking<'c>> {
        Self::builder(conn).build()
    }
    #[doc = r" Returns a customizable builder for this proxy."]
    pub fn builder(
        conn: &::zbus::blocking::Connection,
    ) -> ::zbus::blocking::ProxyBuilder<'c, Self> {
        let mut builder = ::zbus::blocking::ProxyBuilder::new(conn);
        if false {
            let uncached = Vec::new();
            builder
                .cache_properties(::zbus::CacheProperties::default())
                .uncached_properties(&uncached)
        } else {
            builder.cache_properties(::zbus::CacheProperties::No)
        }
    }
    #[doc = r" Consumes `self`, returning the underlying `zbus::Proxy`."]
    pub fn into_inner(self) -> ::zbus::blocking::Proxy<'c> {
        self.0
    }
    #[doc = r" The reference to the underlying `zbus::Proxy`."]
    pub fn inner(&self) -> &::zbus::blocking::Proxy<'c> {
        &self.0
    }
    #[doc = " Destroy method"]
    pub fn destroy(&self) -> zbus::Result<()> {
        let reply = self.0.call("Destroy", &())?;
        ::std::result::Result::Ok(reply)
    }
}
impl<'c> ::std::convert::From<::zbus::Proxy<'c>> for ServiceProxyBlocking<'c> {
    fn from(proxy: ::zbus::Proxy<'c>) -> Self {
        ServiceProxyBlocking(::std::convert::Into::into(proxy))
    }
}
impl<'c> ::std::ops::Deref for ServiceProxyBlocking<'c> {
    type Target = ::zbus::blocking::Proxy<'c>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'c> ::std::ops::DerefMut for ServiceProxyBlocking<'c> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
impl<'c> ::std::convert::AsRef<::zbus::blocking::Proxy<'c>> for ServiceProxyBlocking<'c> {
    fn as_ref(&self) -> &::zbus::blocking::Proxy<'c> {
        &*self
    }
}
impl<'c> ::std::convert::AsMut<::zbus::blocking::Proxy<'c>> for ServiceProxyBlocking<'c> {
    fn as_mut(&mut self) -> &mut ::zbus::blocking::Proxy<'c> {
        &mut *self
    }
}
impl<'c> ::zbus::zvariant::Type for ServiceProxyBlocking<'c> {
    fn signature() -> ::zbus::zvariant::Signature<'static> {
        ::zbus::zvariant::OwnedObjectPath::signature()
    }
}
impl<'c> ::zbus::export::serde::ser::Serialize for ServiceProxyBlocking<'c> {
    fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
    where
        S: ::zbus::export::serde::ser::Serializer,
    {
        ::std::string::String::serialize(
            &::std::string::ToString::to_string(self.inner().path()),
            serializer,
        )
    }
}
impl<'a> ::zbus::ProxyDefault for ServiceProxy<'a> {
    const INTERFACE: &'static str = "org.freedesktop.IBus.Service";
    const DESTINATION: &'static str = "org.freedesktop.IBus.Service";
    const PATH: &'static str = "/org/freedesktop/Service";
}
pub struct ServiceProxy<'c>(::zbus::Proxy<'c>);
#[automatically_derived]
impl<'c> ::core::clone::Clone for ServiceProxy<'c> {
    #[inline]
    fn clone(&self) -> ServiceProxy<'c> {
        ServiceProxy(::core::clone::Clone::clone(&self.0))
    }
}
#[automatically_derived]
impl<'c> ::core::fmt::Debug for ServiceProxy<'c> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "ServiceProxy", &&self.0)
    }
}
impl<'c> ServiceProxy<'c> {
    #[doc = r" Creates a new proxy with the default service and path."]
    pub async fn new(conn: &::zbus::Connection) -> ::zbus::Result<ServiceProxy<'c>> {
        Self::builder(conn).build().await
    }
    #[doc = r" Returns a customizable builder for this proxy."]
    pub fn builder(conn: &::zbus::Connection) -> ::zbus::ProxyBuilder<'c, Self> {
        let mut builder = ::zbus::ProxyBuilder::new(conn);
        if false {
            let uncached = Vec::new();
            builder
                .cache_properties(::zbus::CacheProperties::default())
                .uncached_properties(&uncached)
        } else {
            builder.cache_properties(::zbus::CacheProperties::No)
        }
    }
    #[doc = r" Consumes `self`, returning the underlying `zbus::Proxy`."]
    pub fn into_inner(self) -> ::zbus::Proxy<'c> {
        self.0
    }
    #[doc = r" The reference to the underlying `zbus::Proxy`."]
    pub fn inner(&self) -> &::zbus::Proxy<'c> {
        &self.0
    }
    #[doc = " Destroy method"]
    pub async fn destroy(&self) -> zbus::Result<()> {
        let reply = self.0.call("Destroy", &()).await?;
        ::std::result::Result::Ok(reply)
    }
}
impl<'c> ::std::convert::From<::zbus::Proxy<'c>> for ServiceProxy<'c> {
    fn from(proxy: ::zbus::Proxy<'c>) -> Self {
        ServiceProxy(::std::convert::Into::into(proxy))
    }
}
impl<'c> ::std::ops::Deref for ServiceProxy<'c> {
    type Target = ::zbus::Proxy<'c>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'c> ::std::ops::DerefMut for ServiceProxy<'c> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
impl<'c> ::std::convert::AsRef<::zbus::Proxy<'c>> for ServiceProxy<'c> {
    fn as_ref(&self) -> &::zbus::Proxy<'c> {
        &*self
    }
}
impl<'c> ::std::convert::AsMut<::zbus::Proxy<'c>> for ServiceProxy<'c> {
    fn as_mut(&mut self) -> &mut ::zbus::Proxy<'c> {
        &mut *self
    }
}
impl<'c> ::zbus::zvariant::Type for ServiceProxy<'c> {
    fn signature() -> ::zbus::zvariant::Signature<'static> {
        ::zbus::zvariant::OwnedObjectPath::signature()
    }
}
impl<'c> ::zbus::export::serde::ser::Serialize for ServiceProxy<'c> {
    fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
    where
        S: ::zbus::export::serde::ser::Serializer,
    {
        ::std::string::String::serialize(
            &::std::string::ToString::to_string(self.inner().path()),
            serializer,
        )
    }
}
