/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const IBUS_MAJOR_VERSION: u32 = 1;
pub const IBUS_MINOR_VERSION: u32 = 5;
pub const IBUS_MICRO_VERSION: u32 = 28;
pub const G_ANALYZER_ANALYZING: u32 = 0;
pub const FALSE: u32 = 0;
pub const G_HAVE_GNUC_VISIBILITY: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const G_GINT16_MODIFIER: &[u8; 2usize] = b"h\0";
pub const G_GINT16_FORMAT: &[u8; 3usize] = b"hi\0";
pub const G_GUINT16_FORMAT: &[u8; 3usize] = b"hu\0";
pub const G_GINT32_MODIFIER: &[u8; 1usize] = b"\0";
pub const G_GINT32_FORMAT: &[u8; 2usize] = b"i\0";
pub const G_GUINT32_FORMAT: &[u8; 2usize] = b"u\0";
pub const G_HAVE_GINT64: u32 = 1;
pub const G_GINT64_MODIFIER: &[u8; 2usize] = b"l\0";
pub const G_GINT64_FORMAT: &[u8; 3usize] = b"li\0";
pub const G_GUINT64_FORMAT: &[u8; 3usize] = b"lu\0";
pub const GLIB_SIZEOF_VOID_P: u32 = 8;
pub const GLIB_SIZEOF_LONG: u32 = 8;
pub const GLIB_SIZEOF_SIZE_T: u32 = 8;
pub const GLIB_SIZEOF_SSIZE_T: u32 = 8;
pub const G_GSIZE_MODIFIER: &[u8; 2usize] = b"l\0";
pub const G_GSSIZE_MODIFIER: &[u8; 2usize] = b"l\0";
pub const G_GSIZE_FORMAT: &[u8; 3usize] = b"lu\0";
pub const G_GSSIZE_FORMAT: &[u8; 3usize] = b"li\0";
pub const G_GOFFSET_MODIFIER: &[u8; 2usize] = b"l\0";
pub const G_GOFFSET_FORMAT: &[u8; 3usize] = b"li\0";
pub const G_POLLFD_FORMAT: &[u8; 3usize] = b"%d\0";
pub const G_GINTPTR_MODIFIER: &[u8; 2usize] = b"l\0";
pub const G_GINTPTR_FORMAT: &[u8; 3usize] = b"li\0";
pub const G_GUINTPTR_FORMAT: &[u8; 3usize] = b"lu\0";
pub const GLIB_MAJOR_VERSION: u32 = 2;
pub const GLIB_MINOR_VERSION: u32 = 76;
pub const GLIB_MICRO_VERSION: u32 = 2;
pub const G_VA_COPY_AS_ARRAY: u32 = 1;
pub const G_HAVE_ISO_VARARGS: u32 = 1;
pub const G_HAVE_GROWING_STACK: u32 = 0;
pub const G_HAVE_GNUC_VARARGS: u32 = 1;
pub const G_MODULE_SUFFIX: &[u8; 3usize] = b"so\0";
pub const G_PID_FORMAT: &[u8; 2usize] = b"i\0";
pub const GLIB_SYSDEF_AF_UNIX: u32 = 1;
pub const GLIB_SYSDEF_AF_INET: u32 = 2;
pub const GLIB_SYSDEF_AF_INET6: u32 = 10;
pub const GLIB_SYSDEF_MSG_OOB: u32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: u32 = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: u32 = 4;
pub const G_DIR_SEPARATOR: u8 = 47u8;
pub const G_DIR_SEPARATOR_S: &[u8; 2usize] = b"/\0";
pub const G_SEARCHPATH_SEPARATOR: u8 = 58u8;
pub const G_SEARCHPATH_SEPARATOR_S: &[u8; 2usize] = b":\0";
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: u32 = 1234;
pub const G_BIG_ENDIAN: u32 = 4321;
pub const G_PDP_ENDIAN: u32 = 3412;
pub const G_IEEE754_FLOAT_BIAS: u32 = 127;
pub const G_IEEE754_DOUBLE_BIAS: u32 = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGIOT: u32 = 6;
pub const _BITS_SIGNUM_ARCH_H: u32 = 1;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const SIGBUS: u32 = 7;
pub const SIGSYS: u32 = 31;
pub const SIGURG: u32 = 23;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGCONT: u32 = 18;
pub const SIGCHLD: u32 = 17;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 29;
pub const SIGXFSZ: u32 = 25;
pub const SIGXCPU: u32 = 24;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 10;
pub const SIGUSR2: u32 = 12;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGCLD: u32 = 17;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 65;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const G_DATALIST_FLAGS_MASK: u32 = 3;
pub const G_DATE_BAD_JULIAN: u32 = 0;
pub const G_DATE_BAD_DAY: u32 = 0;
pub const G_DATE_BAD_YEAR: u32 = 0;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const MAXNAMLEN: u32 = 255;
pub const G_MEM_ALIGN: u32 = 8;
pub const G_HOOK_FLAG_USER_SHIFT: u32 = 4;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_DEFAULT: u32 = 0;
pub const G_PRIORITY_HIGH_IDLE: u32 = 100;
pub const G_PRIORITY_DEFAULT_IDLE: u32 = 200;
pub const G_PRIORITY_LOW: u32 = 300;
pub const G_SOURCE_REMOVE: u32 = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: u32 = 18;
pub const G_STR_DELIMITERS: &[u8; 8usize] = b"_-|> <.\0";
pub const G_ASCII_DTOSTR_BUF_SIZE: u32 = 39;
pub const G_KEY_FILE_DESKTOP_GROUP: &[u8; 14usize] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &[u8; 5usize] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &[u8; 8usize] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &[u8; 5usize] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &[u8; 12usize] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &[u8; 10usize] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &[u8; 8usize] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &[u8; 5usize] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &[u8; 7usize] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &[u8; 11usize] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &[u8; 10usize] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &[u8; 8usize] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &[u8; 5usize] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &[u8; 5usize] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &[u8; 9usize] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &[u8; 9usize] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &[u8; 11usize] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &[u8; 14usize] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &[u8; 15usize] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &[u8; 4usize] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &[u8; 16usize] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &[u8; 8usize] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &[u8; 12usize] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &[u8; 5usize] = b"Link\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &[u8; 10usize] = b"Directory\0";
pub const G_LOG_LEVEL_USER_SHIFT: u32 = 8;
pub const G_OPTION_REMAINING: &[u8; 1usize] = b"\0";
pub const G_CSET_A_2_Z: &[u8; 27usize] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_a_2_z: &[u8; 27usize] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_CSET_DIGITS: &[u8; 11usize] = b"0123456789\0";
pub const G_CSET_LATINC: [u8; 31usize] = [
    192u8, 193u8, 194u8, 195u8, 196u8, 197u8, 198u8, 199u8, 200u8, 201u8, 202u8, 203u8, 204u8,
    205u8, 206u8, 207u8, 208u8, 209u8, 210u8, 211u8, 212u8, 213u8, 214u8, 216u8, 217u8, 218u8,
    219u8, 220u8, 221u8, 222u8, 0u8,
];
pub const G_CSET_LATINS: [u8; 33usize] = [
    223u8, 224u8, 225u8, 226u8, 227u8, 228u8, 229u8, 230u8, 231u8, 232u8, 233u8, 234u8, 235u8,
    236u8, 237u8, 238u8, 239u8, 240u8, 241u8, 242u8, 243u8, 244u8, 245u8, 246u8, 248u8, 249u8,
    250u8, 251u8, 252u8, 253u8, 254u8, 255u8, 0u8,
];
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const G_TEST_OPTION_ISOLATE_DIRS: &[u8; 13usize] = b"isolate_dirs\0";
pub const G_USEC_PER_SEC: u32 = 1000000;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &[u8; 8usize] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &[u8; 12usize] = b"!$&'()*+,;=\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &[u8; 14usize] = b"!$&'()*+,;=:@\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &[u8; 15usize] = b"!$&'()*+,;=:@/\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &[u8; 13usize] = b"!$&'()*+,;=:\0";
pub const G_ALLOC_ONLY: u32 = 1;
pub const G_ALLOC_AND_FREE: u32 = 2;
pub const G_ALLOCATOR_LIST: u32 = 1;
pub const G_ALLOCATOR_SLIST: u32 = 2;
pub const G_ALLOCATOR_NODE: u32 = 3;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const IBUS_SERVICE_IBUS: &[u8; 21usize] = b"org.freedesktop.IBus\0";
pub const IBUS_SERVICE_PORTAL: &[u8; 28usize] = b"org.freedesktop.portal.IBus\0";
pub const IBUS_SERVICE_PANEL: &[u8; 27usize] = b"org.freedesktop.IBus.Panel\0";
pub const IBUS_SERVICE_PANEL_EXTENSION: &[u8; 37usize] = b"org.freedesktop.IBus.Panel.Extension\0";
pub const IBUS_SERVICE_PANEL_EXTENSION_EMOJI: &[u8; 43usize] =
    b"org.freedesktop.IBus.Panel.Extension.Emoji\0";
pub const IBUS_SERVICE_CONFIG: &[u8; 28usize] = b"org.freedesktop.IBus.Config\0";
pub const IBUS_SERVICE_NOTIFICATIONS: &[u8; 35usize] = b"org.freedesktop.IBus.Notifications\0";
pub const IBUS_PATH_IBUS: &[u8; 22usize] = b"/org/freedesktop/IBus\0";
pub const IBUS_PATH_FACTORY: &[u8; 30usize] = b"/org/freedesktop/IBus/Factory\0";
pub const IBUS_PATH_PANEL: &[u8; 28usize] = b"/org/freedesktop/IBus/Panel\0";
pub const IBUS_PATH_PANEL_EXTENSION_EMOJI: &[u8; 44usize] =
    b"/org/freedesktop/IBus/Panel/Extension/Emoji\0";
pub const IBUS_PATH_CONFIG: &[u8; 29usize] = b"/org/freedesktop/IBus/Config\0";
pub const IBUS_PATH_NOTIFICATIONS: &[u8; 36usize] = b"/org/freedesktop/IBus/Notifications\0";
pub const IBUS_PATH_INPUT_CONTEXT: &[u8; 38usize] = b"/org/freedesktop/IBus/InputContext_%d\0";
pub const IBUS_INTERFACE_IBUS: &[u8; 21usize] = b"org.freedesktop.IBus\0";
pub const IBUS_INTERFACE_PORTAL: &[u8; 28usize] = b"org.freedesktop.IBus.Portal\0";
pub const IBUS_INTERFACE_INPUT_CONTEXT: &[u8; 34usize] = b"org.freedesktop.IBus.InputContext\0";
pub const IBUS_INTERFACE_FACTORY: &[u8; 29usize] = b"org.freedesktop.IBus.Factory\0";
pub const IBUS_INTERFACE_ENGINE: &[u8; 28usize] = b"org.freedesktop.IBus.Engine\0";
pub const IBUS_INTERFACE_PANEL: &[u8; 27usize] = b"org.freedesktop.IBus.Panel\0";
pub const IBUS_INTERFACE_CONFIG: &[u8; 28usize] = b"org.freedesktop.IBus.Config\0";
pub const IBUS_INTERFACE_NOTIFICATIONS: &[u8; 35usize] = b"org.freedesktop.IBus.Notifications\0";
pub const G_TYPE_FUNDAMENTAL_SHIFT: u32 = 2;
pub const G_TYPE_RESERVED_GLIB_FIRST: u32 = 22;
pub const G_TYPE_RESERVED_GLIB_LAST: u32 = 31;
pub const G_TYPE_RESERVED_BSE_FIRST: u32 = 32;
pub const G_TYPE_RESERVED_BSE_LAST: u32 = 48;
pub const G_TYPE_RESERVED_USER_FIRST: u32 = 49;
pub const G_VALUE_NOCOPY_CONTENTS: u32 = 134217728;
pub const G_PARAM_MASK: u32 = 255;
pub const G_PARAM_USER_SHIFT: u32 = 8;
pub const G_SIGNAL_FLAGS_MASK: u32 = 511;
pub const G_SIGNAL_MATCH_MASK: u32 = 63;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const G_DEBUG_CONTROLLER_EXTENSION_POINT_NAME: &[u8; 21usize] = b"gio-debug-controller\0";
pub const G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE: &[u8; 12usize] = b"unix-device\0";
pub const G_FILE_ATTRIBUTE_STANDARD_TYPE: &[u8; 15usize] = b"standard::type\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: &[u8; 20usize] = b"standard::is-hidden\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP: &[u8; 20usize] = b"standard::is-backup\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: &[u8; 21usize] = b"standard::is-symlink\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: &[u8; 21usize] = b"standard::is-virtual\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: &[u8; 22usize] = b"standard::is-volatile\0";
pub const G_FILE_ATTRIBUTE_STANDARD_NAME: &[u8; 15usize] = b"standard::name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: &[u8; 23usize] = b"standard::display-name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME: &[u8; 20usize] = b"standard::edit-name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_COPY_NAME: &[u8; 20usize] = b"standard::copy-name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION: &[u8; 22usize] = b"standard::description\0";
pub const G_FILE_ATTRIBUTE_STANDARD_ICON: &[u8; 15usize] = b"standard::icon\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: &[u8; 24usize] = b"standard::symbolic-icon\0";
pub const G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: &[u8; 23usize] = b"standard::content-type\0";
pub const G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: &[u8; 28usize] =
    b"standard::fast-content-type\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SIZE: &[u8; 15usize] = b"standard::size\0";
pub const G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: &[u8; 25usize] = b"standard::allocated-size\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: &[u8; 25usize] = b"standard::symlink-target\0";
pub const G_FILE_ATTRIBUTE_STANDARD_TARGET_URI: &[u8; 21usize] = b"standard::target-uri\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER: &[u8; 21usize] = b"standard::sort-order\0";
pub const G_FILE_ATTRIBUTE_ETAG_VALUE: &[u8; 12usize] = b"etag::value\0";
pub const G_FILE_ATTRIBUTE_ID_FILE: &[u8; 9usize] = b"id::file\0";
pub const G_FILE_ATTRIBUTE_ID_FILESYSTEM: &[u8; 15usize] = b"id::filesystem\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_READ: &[u8; 17usize] = b"access::can-read\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE: &[u8; 18usize] = b"access::can-write\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: &[u8; 20usize] = b"access::can-execute\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE: &[u8; 19usize] = b"access::can-delete\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH: &[u8; 18usize] = b"access::can-trash\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME: &[u8; 19usize] = b"access::can-rename\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: &[u8; 21usize] = b"mountable::can-mount\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: &[u8; 23usize] = b"mountable::can-unmount\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: &[u8; 21usize] = b"mountable::can-eject\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: &[u8; 23usize] = b"mountable::unix-device\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: &[u8; 28usize] =
    b"mountable::unix-device-file\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: &[u8; 19usize] = b"mountable::hal-udi\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START: &[u8; 21usize] = b"mountable::can-start\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: &[u8; 30usize] =
    b"mountable::can-start-degraded\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: &[u8; 20usize] = b"mountable::can-stop\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: &[u8; 27usize] =
    b"mountable::start-stop-type\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: &[u8; 20usize] = b"mountable::can-poll\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: &[u8; 36usize] =
    b"mountable::is-media-check-automatic\0";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED: &[u8; 15usize] = b"time::modified\0";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC: &[u8; 20usize] = b"time::modified-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_NSEC: &[u8; 20usize] = b"time::modified-nsec\0";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS: &[u8; 13usize] = b"time::access\0";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS_USEC: &[u8; 18usize] = b"time::access-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS_NSEC: &[u8; 18usize] = b"time::access-nsec\0";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED: &[u8; 14usize] = b"time::changed\0";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED_USEC: &[u8; 19usize] = b"time::changed-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED_NSEC: &[u8; 19usize] = b"time::changed-nsec\0";
pub const G_FILE_ATTRIBUTE_TIME_CREATED: &[u8; 14usize] = b"time::created\0";
pub const G_FILE_ATTRIBUTE_TIME_CREATED_USEC: &[u8; 19usize] = b"time::created-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_CREATED_NSEC: &[u8; 19usize] = b"time::created-nsec\0";
pub const G_FILE_ATTRIBUTE_UNIX_DEVICE: &[u8; 13usize] = b"unix::device\0";
pub const G_FILE_ATTRIBUTE_UNIX_INODE: &[u8; 12usize] = b"unix::inode\0";
pub const G_FILE_ATTRIBUTE_UNIX_MODE: &[u8; 11usize] = b"unix::mode\0";
pub const G_FILE_ATTRIBUTE_UNIX_NLINK: &[u8; 12usize] = b"unix::nlink\0";
pub const G_FILE_ATTRIBUTE_UNIX_UID: &[u8; 10usize] = b"unix::uid\0";
pub const G_FILE_ATTRIBUTE_UNIX_GID: &[u8; 10usize] = b"unix::gid\0";
pub const G_FILE_ATTRIBUTE_UNIX_RDEV: &[u8; 11usize] = b"unix::rdev\0";
pub const G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: &[u8; 17usize] = b"unix::block-size\0";
pub const G_FILE_ATTRIBUTE_UNIX_BLOCKS: &[u8; 13usize] = b"unix::blocks\0";
pub const G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: &[u8; 20usize] = b"unix::is-mountpoint\0";
pub const G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE: &[u8; 16usize] = b"dos::is-archive\0";
pub const G_FILE_ATTRIBUTE_DOS_IS_SYSTEM: &[u8; 15usize] = b"dos::is-system\0";
pub const G_FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT: &[u8; 19usize] = b"dos::is-mountpoint\0";
pub const G_FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG: &[u8; 23usize] = b"dos::reparse-point-tag\0";
pub const G_FILE_ATTRIBUTE_OWNER_USER: &[u8; 12usize] = b"owner::user\0";
pub const G_FILE_ATTRIBUTE_OWNER_USER_REAL: &[u8; 17usize] = b"owner::user-real\0";
pub const G_FILE_ATTRIBUTE_OWNER_GROUP: &[u8; 13usize] = b"owner::group\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH: &[u8; 16usize] = b"thumbnail::path\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED: &[u8; 18usize] = b"thumbnail::failed\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: &[u8; 20usize] = b"thumbnail::is-valid\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_NORMAL: &[u8; 23usize] = b"thumbnail::path-normal\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_NORMAL: &[u8; 25usize] =
    b"thumbnail::failed-normal\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_NORMAL: &[u8; 27usize] =
    b"thumbnail::is-valid-normal\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_LARGE: &[u8; 22usize] = b"thumbnail::path-large\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_LARGE: &[u8; 24usize] = b"thumbnail::failed-large\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_LARGE: &[u8; 26usize] =
    b"thumbnail::is-valid-large\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_XLARGE: &[u8; 23usize] = b"thumbnail::path-xlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XLARGE: &[u8; 25usize] =
    b"thumbnail::failed-xlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XLARGE: &[u8; 27usize] =
    b"thumbnail::is-valid-xlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH_XXLARGE: &[u8; 24usize] = b"thumbnail::path-xxlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED_XXLARGE: &[u8; 26usize] =
    b"thumbnail::failed-xxlarge\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID_XXLARGE: &[u8; 28usize] =
    b"thumbnail::is-valid-xxlarge\0";
pub const G_FILE_ATTRIBUTE_PREVIEW_ICON: &[u8; 14usize] = b"preview::icon\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_SIZE: &[u8; 17usize] = b"filesystem::size\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_FREE: &[u8; 17usize] = b"filesystem::free\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USED: &[u8; 17usize] = b"filesystem::used\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_TYPE: &[u8; 17usize] = b"filesystem::type\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_READONLY: &[u8; 21usize] = b"filesystem::readonly\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: &[u8; 24usize] = b"filesystem::use-preview\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE: &[u8; 19usize] = b"filesystem::remote\0";
pub const G_FILE_ATTRIBUTE_GVFS_BACKEND: &[u8; 14usize] = b"gvfs::backend\0";
pub const G_FILE_ATTRIBUTE_SELINUX_CONTEXT: &[u8; 17usize] = b"selinux::context\0";
pub const G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT: &[u8; 18usize] = b"trash::item-count\0";
pub const G_FILE_ATTRIBUTE_TRASH_ORIG_PATH: &[u8; 17usize] = b"trash::orig-path\0";
pub const G_FILE_ATTRIBUTE_TRASH_DELETION_DATE: &[u8; 21usize] = b"trash::deletion-date\0";
pub const G_FILE_ATTRIBUTE_RECENT_MODIFIED: &[u8; 17usize] = b"recent::modified\0";
pub const G_MEMORY_MONITOR_EXTENSION_POINT_NAME: &[u8; 19usize] = b"gio-memory-monitor\0";
pub const G_MENU_ATTRIBUTE_ACTION: &[u8; 7usize] = b"action\0";
pub const G_MENU_ATTRIBUTE_ACTION_NAMESPACE: &[u8; 17usize] = b"action-namespace\0";
pub const G_MENU_ATTRIBUTE_TARGET: &[u8; 7usize] = b"target\0";
pub const G_MENU_ATTRIBUTE_LABEL: &[u8; 6usize] = b"label\0";
pub const G_MENU_ATTRIBUTE_ICON: &[u8; 5usize] = b"icon\0";
pub const G_MENU_LINK_SUBMENU: &[u8; 8usize] = b"submenu\0";
pub const G_MENU_LINK_SECTION: &[u8; 8usize] = b"section\0";
pub const G_VOLUME_MONITOR_EXTENSION_POINT_NAME: &[u8; 19usize] = b"gio-volume-monitor\0";
pub const G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: &[u8; 26usize] =
    b"gio-native-volume-monitor\0";
pub const G_NETWORK_MONITOR_EXTENSION_POINT_NAME: &[u8; 20usize] = b"gio-network-monitor\0";
pub const G_POWER_PROFILE_MONITOR_EXTENSION_POINT_NAME: &[u8; 26usize] =
    b"gio-power-profile-monitor\0";
pub const G_PROXY_EXTENSION_POINT_NAME: &[u8; 10usize] = b"gio-proxy\0";
pub const G_PROXY_RESOLVER_EXTENSION_POINT_NAME: &[u8; 19usize] = b"gio-proxy-resolver\0";
pub const G_TLS_BACKEND_EXTENSION_POINT_NAME: &[u8; 16usize] = b"gio-tls-backend\0";
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: &[u8; 18usize] = b"1.3.6.1.5.5.7.3.1\0";
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: &[u8; 18usize] = b"1.3.6.1.5.5.7.3.2\0";
pub const G_VFS_EXTENSION_POINT_NAME: &[u8; 8usize] = b"gio-vfs\0";
pub const G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: &[u8; 12usize] = b"unix-device\0";
pub const G_VOLUME_IDENTIFIER_KIND_LABEL: &[u8; 6usize] = b"label\0";
pub const G_VOLUME_IDENTIFIER_KIND_UUID: &[u8; 5usize] = b"uuid\0";
pub const G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT: &[u8; 10usize] = b"nfs-mount\0";
pub const G_VOLUME_IDENTIFIER_KIND_CLASS: &[u8; 6usize] = b"class\0";
pub const IBUS_KEY_VoidSymbol: u32 = 16777215;
pub const IBUS_KEY_BackSpace: u32 = 65288;
pub const IBUS_KEY_Tab: u32 = 65289;
pub const IBUS_KEY_Linefeed: u32 = 65290;
pub const IBUS_KEY_Clear: u32 = 65291;
pub const IBUS_KEY_Return: u32 = 65293;
pub const IBUS_KEY_Pause: u32 = 65299;
pub const IBUS_KEY_Scroll_Lock: u32 = 65300;
pub const IBUS_KEY_Sys_Req: u32 = 65301;
pub const IBUS_KEY_Escape: u32 = 65307;
pub const IBUS_KEY_Delete: u32 = 65535;
pub const IBUS_KEY_Multi_key: u32 = 65312;
pub const IBUS_KEY_Codeinput: u32 = 65335;
pub const IBUS_KEY_SingleCandidate: u32 = 65340;
pub const IBUS_KEY_MultipleCandidate: u32 = 65341;
pub const IBUS_KEY_PreviousCandidate: u32 = 65342;
pub const IBUS_KEY_Kanji: u32 = 65313;
pub const IBUS_KEY_Muhenkan: u32 = 65314;
pub const IBUS_KEY_Henkan_Mode: u32 = 65315;
pub const IBUS_KEY_Henkan: u32 = 65315;
pub const IBUS_KEY_Romaji: u32 = 65316;
pub const IBUS_KEY_Hiragana: u32 = 65317;
pub const IBUS_KEY_Katakana: u32 = 65318;
pub const IBUS_KEY_Hiragana_Katakana: u32 = 65319;
pub const IBUS_KEY_Zenkaku: u32 = 65320;
pub const IBUS_KEY_Hankaku: u32 = 65321;
pub const IBUS_KEY_Zenkaku_Hankaku: u32 = 65322;
pub const IBUS_KEY_Touroku: u32 = 65323;
pub const IBUS_KEY_Massyo: u32 = 65324;
pub const IBUS_KEY_Kana_Lock: u32 = 65325;
pub const IBUS_KEY_Kana_Shift: u32 = 65326;
pub const IBUS_KEY_Eisu_Shift: u32 = 65327;
pub const IBUS_KEY_Eisu_toggle: u32 = 65328;
pub const IBUS_KEY_Kanji_Bangou: u32 = 65335;
pub const IBUS_KEY_Zen_Koho: u32 = 65341;
pub const IBUS_KEY_Mae_Koho: u32 = 65342;
pub const IBUS_KEY_Home: u32 = 65360;
pub const IBUS_KEY_Left: u32 = 65361;
pub const IBUS_KEY_Up: u32 = 65362;
pub const IBUS_KEY_Right: u32 = 65363;
pub const IBUS_KEY_Down: u32 = 65364;
pub const IBUS_KEY_Prior: u32 = 65365;
pub const IBUS_KEY_Page_Up: u32 = 65365;
pub const IBUS_KEY_Next: u32 = 65366;
pub const IBUS_KEY_Page_Down: u32 = 65366;
pub const IBUS_KEY_End: u32 = 65367;
pub const IBUS_KEY_Begin: u32 = 65368;
pub const IBUS_KEY_Select: u32 = 65376;
pub const IBUS_KEY_Print: u32 = 65377;
pub const IBUS_KEY_Execute: u32 = 65378;
pub const IBUS_KEY_Insert: u32 = 65379;
pub const IBUS_KEY_Undo: u32 = 65381;
pub const IBUS_KEY_Redo: u32 = 65382;
pub const IBUS_KEY_Menu: u32 = 65383;
pub const IBUS_KEY_Find: u32 = 65384;
pub const IBUS_KEY_Cancel: u32 = 65385;
pub const IBUS_KEY_Help: u32 = 65386;
pub const IBUS_KEY_Break: u32 = 65387;
pub const IBUS_KEY_Mode_switch: u32 = 65406;
pub const IBUS_KEY_script_switch: u32 = 65406;
pub const IBUS_KEY_Num_Lock: u32 = 65407;
pub const IBUS_KEY_KP_Space: u32 = 65408;
pub const IBUS_KEY_KP_Tab: u32 = 65417;
pub const IBUS_KEY_KP_Enter: u32 = 65421;
pub const IBUS_KEY_KP_F1: u32 = 65425;
pub const IBUS_KEY_KP_F2: u32 = 65426;
pub const IBUS_KEY_KP_F3: u32 = 65427;
pub const IBUS_KEY_KP_F4: u32 = 65428;
pub const IBUS_KEY_KP_Home: u32 = 65429;
pub const IBUS_KEY_KP_Left: u32 = 65430;
pub const IBUS_KEY_KP_Up: u32 = 65431;
pub const IBUS_KEY_KP_Right: u32 = 65432;
pub const IBUS_KEY_KP_Down: u32 = 65433;
pub const IBUS_KEY_KP_Prior: u32 = 65434;
pub const IBUS_KEY_KP_Page_Up: u32 = 65434;
pub const IBUS_KEY_KP_Next: u32 = 65435;
pub const IBUS_KEY_KP_Page_Down: u32 = 65435;
pub const IBUS_KEY_KP_End: u32 = 65436;
pub const IBUS_KEY_KP_Begin: u32 = 65437;
pub const IBUS_KEY_KP_Insert: u32 = 65438;
pub const IBUS_KEY_KP_Delete: u32 = 65439;
pub const IBUS_KEY_KP_Equal: u32 = 65469;
pub const IBUS_KEY_KP_Multiply: u32 = 65450;
pub const IBUS_KEY_KP_Add: u32 = 65451;
pub const IBUS_KEY_KP_Separator: u32 = 65452;
pub const IBUS_KEY_KP_Subtract: u32 = 65453;
pub const IBUS_KEY_KP_Decimal: u32 = 65454;
pub const IBUS_KEY_KP_Divide: u32 = 65455;
pub const IBUS_KEY_KP_0: u32 = 65456;
pub const IBUS_KEY_KP_1: u32 = 65457;
pub const IBUS_KEY_KP_2: u32 = 65458;
pub const IBUS_KEY_KP_3: u32 = 65459;
pub const IBUS_KEY_KP_4: u32 = 65460;
pub const IBUS_KEY_KP_5: u32 = 65461;
pub const IBUS_KEY_KP_6: u32 = 65462;
pub const IBUS_KEY_KP_7: u32 = 65463;
pub const IBUS_KEY_KP_8: u32 = 65464;
pub const IBUS_KEY_KP_9: u32 = 65465;
pub const IBUS_KEY_F1: u32 = 65470;
pub const IBUS_KEY_F2: u32 = 65471;
pub const IBUS_KEY_F3: u32 = 65472;
pub const IBUS_KEY_F4: u32 = 65473;
pub const IBUS_KEY_F5: u32 = 65474;
pub const IBUS_KEY_F6: u32 = 65475;
pub const IBUS_KEY_F7: u32 = 65476;
pub const IBUS_KEY_F8: u32 = 65477;
pub const IBUS_KEY_F9: u32 = 65478;
pub const IBUS_KEY_F10: u32 = 65479;
pub const IBUS_KEY_F11: u32 = 65480;
pub const IBUS_KEY_L1: u32 = 65480;
pub const IBUS_KEY_F12: u32 = 65481;
pub const IBUS_KEY_L2: u32 = 65481;
pub const IBUS_KEY_F13: u32 = 65482;
pub const IBUS_KEY_L3: u32 = 65482;
pub const IBUS_KEY_F14: u32 = 65483;
pub const IBUS_KEY_L4: u32 = 65483;
pub const IBUS_KEY_F15: u32 = 65484;
pub const IBUS_KEY_L5: u32 = 65484;
pub const IBUS_KEY_F16: u32 = 65485;
pub const IBUS_KEY_L6: u32 = 65485;
pub const IBUS_KEY_F17: u32 = 65486;
pub const IBUS_KEY_L7: u32 = 65486;
pub const IBUS_KEY_F18: u32 = 65487;
pub const IBUS_KEY_L8: u32 = 65487;
pub const IBUS_KEY_F19: u32 = 65488;
pub const IBUS_KEY_L9: u32 = 65488;
pub const IBUS_KEY_F20: u32 = 65489;
pub const IBUS_KEY_L10: u32 = 65489;
pub const IBUS_KEY_F21: u32 = 65490;
pub const IBUS_KEY_R1: u32 = 65490;
pub const IBUS_KEY_F22: u32 = 65491;
pub const IBUS_KEY_R2: u32 = 65491;
pub const IBUS_KEY_F23: u32 = 65492;
pub const IBUS_KEY_R3: u32 = 65492;
pub const IBUS_KEY_F24: u32 = 65493;
pub const IBUS_KEY_R4: u32 = 65493;
pub const IBUS_KEY_F25: u32 = 65494;
pub const IBUS_KEY_R5: u32 = 65494;
pub const IBUS_KEY_F26: u32 = 65495;
pub const IBUS_KEY_R6: u32 = 65495;
pub const IBUS_KEY_F27: u32 = 65496;
pub const IBUS_KEY_R7: u32 = 65496;
pub const IBUS_KEY_F28: u32 = 65497;
pub const IBUS_KEY_R8: u32 = 65497;
pub const IBUS_KEY_F29: u32 = 65498;
pub const IBUS_KEY_R9: u32 = 65498;
pub const IBUS_KEY_F30: u32 = 65499;
pub const IBUS_KEY_R10: u32 = 65499;
pub const IBUS_KEY_F31: u32 = 65500;
pub const IBUS_KEY_R11: u32 = 65500;
pub const IBUS_KEY_F32: u32 = 65501;
pub const IBUS_KEY_R12: u32 = 65501;
pub const IBUS_KEY_F33: u32 = 65502;
pub const IBUS_KEY_R13: u32 = 65502;
pub const IBUS_KEY_F34: u32 = 65503;
pub const IBUS_KEY_R14: u32 = 65503;
pub const IBUS_KEY_F35: u32 = 65504;
pub const IBUS_KEY_R15: u32 = 65504;
pub const IBUS_KEY_Shift_L: u32 = 65505;
pub const IBUS_KEY_Shift_R: u32 = 65506;
pub const IBUS_KEY_Control_L: u32 = 65507;
pub const IBUS_KEY_Control_R: u32 = 65508;
pub const IBUS_KEY_Caps_Lock: u32 = 65509;
pub const IBUS_KEY_Shift_Lock: u32 = 65510;
pub const IBUS_KEY_Meta_L: u32 = 65511;
pub const IBUS_KEY_Meta_R: u32 = 65512;
pub const IBUS_KEY_Alt_L: u32 = 65513;
pub const IBUS_KEY_Alt_R: u32 = 65514;
pub const IBUS_KEY_Super_L: u32 = 65515;
pub const IBUS_KEY_Super_R: u32 = 65516;
pub const IBUS_KEY_Hyper_L: u32 = 65517;
pub const IBUS_KEY_Hyper_R: u32 = 65518;
pub const IBUS_KEY_ISO_Lock: u32 = 65025;
pub const IBUS_KEY_ISO_Level2_Latch: u32 = 65026;
pub const IBUS_KEY_ISO_Level3_Shift: u32 = 65027;
pub const IBUS_KEY_ISO_Level3_Latch: u32 = 65028;
pub const IBUS_KEY_ISO_Level3_Lock: u32 = 65029;
pub const IBUS_KEY_ISO_Level5_Shift: u32 = 65041;
pub const IBUS_KEY_ISO_Level5_Latch: u32 = 65042;
pub const IBUS_KEY_ISO_Level5_Lock: u32 = 65043;
pub const IBUS_KEY_ISO_Group_Shift: u32 = 65406;
pub const IBUS_KEY_ISO_Group_Latch: u32 = 65030;
pub const IBUS_KEY_ISO_Group_Lock: u32 = 65031;
pub const IBUS_KEY_ISO_Next_Group: u32 = 65032;
pub const IBUS_KEY_ISO_Next_Group_Lock: u32 = 65033;
pub const IBUS_KEY_ISO_Prev_Group: u32 = 65034;
pub const IBUS_KEY_ISO_Prev_Group_Lock: u32 = 65035;
pub const IBUS_KEY_ISO_First_Group: u32 = 65036;
pub const IBUS_KEY_ISO_First_Group_Lock: u32 = 65037;
pub const IBUS_KEY_ISO_Last_Group: u32 = 65038;
pub const IBUS_KEY_ISO_Last_Group_Lock: u32 = 65039;
pub const IBUS_KEY_ISO_Left_Tab: u32 = 65056;
pub const IBUS_KEY_ISO_Move_Line_Up: u32 = 65057;
pub const IBUS_KEY_ISO_Move_Line_Down: u32 = 65058;
pub const IBUS_KEY_ISO_Partial_Line_Up: u32 = 65059;
pub const IBUS_KEY_ISO_Partial_Line_Down: u32 = 65060;
pub const IBUS_KEY_ISO_Partial_Space_Left: u32 = 65061;
pub const IBUS_KEY_ISO_Partial_Space_Right: u32 = 65062;
pub const IBUS_KEY_ISO_Set_Margin_Left: u32 = 65063;
pub const IBUS_KEY_ISO_Set_Margin_Right: u32 = 65064;
pub const IBUS_KEY_ISO_Release_Margin_Left: u32 = 65065;
pub const IBUS_KEY_ISO_Release_Margin_Right: u32 = 65066;
pub const IBUS_KEY_ISO_Release_Both_Margins: u32 = 65067;
pub const IBUS_KEY_ISO_Fast_Cursor_Left: u32 = 65068;
pub const IBUS_KEY_ISO_Fast_Cursor_Right: u32 = 65069;
pub const IBUS_KEY_ISO_Fast_Cursor_Up: u32 = 65070;
pub const IBUS_KEY_ISO_Fast_Cursor_Down: u32 = 65071;
pub const IBUS_KEY_ISO_Continuous_Underline: u32 = 65072;
pub const IBUS_KEY_ISO_Discontinuous_Underline: u32 = 65073;
pub const IBUS_KEY_ISO_Emphasize: u32 = 65074;
pub const IBUS_KEY_ISO_Center_Object: u32 = 65075;
pub const IBUS_KEY_ISO_Enter: u32 = 65076;
pub const IBUS_KEY_dead_grave: u32 = 65104;
pub const IBUS_KEY_dead_acute: u32 = 65105;
pub const IBUS_KEY_dead_circumflex: u32 = 65106;
pub const IBUS_KEY_dead_tilde: u32 = 65107;
pub const IBUS_KEY_dead_perispomeni: u32 = 65107;
pub const IBUS_KEY_dead_macron: u32 = 65108;
pub const IBUS_KEY_dead_breve: u32 = 65109;
pub const IBUS_KEY_dead_abovedot: u32 = 65110;
pub const IBUS_KEY_dead_diaeresis: u32 = 65111;
pub const IBUS_KEY_dead_abovering: u32 = 65112;
pub const IBUS_KEY_dead_doubleacute: u32 = 65113;
pub const IBUS_KEY_dead_caron: u32 = 65114;
pub const IBUS_KEY_dead_cedilla: u32 = 65115;
pub const IBUS_KEY_dead_ogonek: u32 = 65116;
pub const IBUS_KEY_dead_iota: u32 = 65117;
pub const IBUS_KEY_dead_voiced_sound: u32 = 65118;
pub const IBUS_KEY_dead_semivoiced_sound: u32 = 65119;
pub const IBUS_KEY_dead_belowdot: u32 = 65120;
pub const IBUS_KEY_dead_hook: u32 = 65121;
pub const IBUS_KEY_dead_horn: u32 = 65122;
pub const IBUS_KEY_dead_stroke: u32 = 65123;
pub const IBUS_KEY_dead_abovecomma: u32 = 65124;
pub const IBUS_KEY_dead_psili: u32 = 65124;
pub const IBUS_KEY_dead_abovereversedcomma: u32 = 65125;
pub const IBUS_KEY_dead_dasia: u32 = 65125;
pub const IBUS_KEY_dead_doublegrave: u32 = 65126;
pub const IBUS_KEY_dead_belowring: u32 = 65127;
pub const IBUS_KEY_dead_belowmacron: u32 = 65128;
pub const IBUS_KEY_dead_belowcircumflex: u32 = 65129;
pub const IBUS_KEY_dead_belowtilde: u32 = 65130;
pub const IBUS_KEY_dead_belowbreve: u32 = 65131;
pub const IBUS_KEY_dead_belowdiaeresis: u32 = 65132;
pub const IBUS_KEY_dead_invertedbreve: u32 = 65133;
pub const IBUS_KEY_dead_belowcomma: u32 = 65134;
pub const IBUS_KEY_dead_currency: u32 = 65135;
pub const IBUS_KEY_dead_lowline: u32 = 65168;
pub const IBUS_KEY_dead_aboveverticalline: u32 = 65169;
pub const IBUS_KEY_dead_belowverticalline: u32 = 65170;
pub const IBUS_KEY_dead_longsolidusoverlay: u32 = 65171;
pub const IBUS_KEY_dead_a: u32 = 65152;
pub const IBUS_KEY_dead_A: u32 = 65153;
pub const IBUS_KEY_dead_e: u32 = 65154;
pub const IBUS_KEY_dead_E: u32 = 65155;
pub const IBUS_KEY_dead_i: u32 = 65156;
pub const IBUS_KEY_dead_I: u32 = 65157;
pub const IBUS_KEY_dead_o: u32 = 65158;
pub const IBUS_KEY_dead_O: u32 = 65159;
pub const IBUS_KEY_dead_u: u32 = 65160;
pub const IBUS_KEY_dead_U: u32 = 65161;
pub const IBUS_KEY_dead_small_schwa: u32 = 65162;
pub const IBUS_KEY_dead_capital_schwa: u32 = 65163;
pub const IBUS_KEY_dead_greek: u32 = 65164;
pub const IBUS_KEY_First_Virtual_Screen: u32 = 65232;
pub const IBUS_KEY_Prev_Virtual_Screen: u32 = 65233;
pub const IBUS_KEY_Next_Virtual_Screen: u32 = 65234;
pub const IBUS_KEY_Last_Virtual_Screen: u32 = 65236;
pub const IBUS_KEY_Terminate_Server: u32 = 65237;
pub const IBUS_KEY_AccessX_Enable: u32 = 65136;
pub const IBUS_KEY_AccessX_Feedback_Enable: u32 = 65137;
pub const IBUS_KEY_RepeatKeys_Enable: u32 = 65138;
pub const IBUS_KEY_SlowKeys_Enable: u32 = 65139;
pub const IBUS_KEY_BounceKeys_Enable: u32 = 65140;
pub const IBUS_KEY_StickyKeys_Enable: u32 = 65141;
pub const IBUS_KEY_MouseKeys_Enable: u32 = 65142;
pub const IBUS_KEY_MouseKeys_Accel_Enable: u32 = 65143;
pub const IBUS_KEY_Overlay1_Enable: u32 = 65144;
pub const IBUS_KEY_Overlay2_Enable: u32 = 65145;
pub const IBUS_KEY_AudibleBell_Enable: u32 = 65146;
pub const IBUS_KEY_Pointer_Left: u32 = 65248;
pub const IBUS_KEY_Pointer_Right: u32 = 65249;
pub const IBUS_KEY_Pointer_Up: u32 = 65250;
pub const IBUS_KEY_Pointer_Down: u32 = 65251;
pub const IBUS_KEY_Pointer_UpLeft: u32 = 65252;
pub const IBUS_KEY_Pointer_UpRight: u32 = 65253;
pub const IBUS_KEY_Pointer_DownLeft: u32 = 65254;
pub const IBUS_KEY_Pointer_DownRight: u32 = 65255;
pub const IBUS_KEY_Pointer_Button_Dflt: u32 = 65256;
pub const IBUS_KEY_Pointer_Button1: u32 = 65257;
pub const IBUS_KEY_Pointer_Button2: u32 = 65258;
pub const IBUS_KEY_Pointer_Button3: u32 = 65259;
pub const IBUS_KEY_Pointer_Button4: u32 = 65260;
pub const IBUS_KEY_Pointer_Button5: u32 = 65261;
pub const IBUS_KEY_Pointer_DblClick_Dflt: u32 = 65262;
pub const IBUS_KEY_Pointer_DblClick1: u32 = 65263;
pub const IBUS_KEY_Pointer_DblClick2: u32 = 65264;
pub const IBUS_KEY_Pointer_DblClick3: u32 = 65265;
pub const IBUS_KEY_Pointer_DblClick4: u32 = 65266;
pub const IBUS_KEY_Pointer_DblClick5: u32 = 65267;
pub const IBUS_KEY_Pointer_Drag_Dflt: u32 = 65268;
pub const IBUS_KEY_Pointer_Drag1: u32 = 65269;
pub const IBUS_KEY_Pointer_Drag2: u32 = 65270;
pub const IBUS_KEY_Pointer_Drag3: u32 = 65271;
pub const IBUS_KEY_Pointer_Drag4: u32 = 65272;
pub const IBUS_KEY_Pointer_Drag5: u32 = 65277;
pub const IBUS_KEY_Pointer_EnableKeys: u32 = 65273;
pub const IBUS_KEY_Pointer_Accelerate: u32 = 65274;
pub const IBUS_KEY_Pointer_DfltBtnNext: u32 = 65275;
pub const IBUS_KEY_Pointer_DfltBtnPrev: u32 = 65276;
pub const IBUS_KEY_ch: u32 = 65184;
pub const IBUS_KEY_Ch: u32 = 65185;
pub const IBUS_KEY_CH: u32 = 65186;
pub const IBUS_KEY_c_h: u32 = 65187;
pub const IBUS_KEY_C_h: u32 = 65188;
pub const IBUS_KEY_C_H: u32 = 65189;
pub const IBUS_KEY_3270_Duplicate: u32 = 64769;
pub const IBUS_KEY_3270_FieldMark: u32 = 64770;
pub const IBUS_KEY_3270_Right2: u32 = 64771;
pub const IBUS_KEY_3270_Left2: u32 = 64772;
pub const IBUS_KEY_3270_BackTab: u32 = 64773;
pub const IBUS_KEY_3270_EraseEOF: u32 = 64774;
pub const IBUS_KEY_3270_EraseInput: u32 = 64775;
pub const IBUS_KEY_3270_Reset: u32 = 64776;
pub const IBUS_KEY_3270_Quit: u32 = 64777;
pub const IBUS_KEY_3270_PA1: u32 = 64778;
pub const IBUS_KEY_3270_PA2: u32 = 64779;
pub const IBUS_KEY_3270_PA3: u32 = 64780;
pub const IBUS_KEY_3270_Test: u32 = 64781;
pub const IBUS_KEY_3270_Attn: u32 = 64782;
pub const IBUS_KEY_3270_CursorBlink: u32 = 64783;
pub const IBUS_KEY_3270_AltCursor: u32 = 64784;
pub const IBUS_KEY_3270_KeyClick: u32 = 64785;
pub const IBUS_KEY_3270_Jump: u32 = 64786;
pub const IBUS_KEY_3270_Ident: u32 = 64787;
pub const IBUS_KEY_3270_Rule: u32 = 64788;
pub const IBUS_KEY_3270_Copy: u32 = 64789;
pub const IBUS_KEY_3270_Play: u32 = 64790;
pub const IBUS_KEY_3270_Setup: u32 = 64791;
pub const IBUS_KEY_3270_Record: u32 = 64792;
pub const IBUS_KEY_3270_ChangeScreen: u32 = 64793;
pub const IBUS_KEY_3270_DeleteWord: u32 = 64794;
pub const IBUS_KEY_3270_ExSelect: u32 = 64795;
pub const IBUS_KEY_3270_CursorSelect: u32 = 64796;
pub const IBUS_KEY_3270_PrintScreen: u32 = 64797;
pub const IBUS_KEY_3270_Enter: u32 = 64798;
pub const IBUS_KEY_space: u32 = 32;
pub const IBUS_KEY_exclam: u32 = 33;
pub const IBUS_KEY_quotedbl: u32 = 34;
pub const IBUS_KEY_numbersign: u32 = 35;
pub const IBUS_KEY_dollar: u32 = 36;
pub const IBUS_KEY_percent: u32 = 37;
pub const IBUS_KEY_ampersand: u32 = 38;
pub const IBUS_KEY_apostrophe: u32 = 39;
pub const IBUS_KEY_quoteright: u32 = 39;
pub const IBUS_KEY_parenleft: u32 = 40;
pub const IBUS_KEY_parenright: u32 = 41;
pub const IBUS_KEY_asterisk: u32 = 42;
pub const IBUS_KEY_plus: u32 = 43;
pub const IBUS_KEY_comma: u32 = 44;
pub const IBUS_KEY_minus: u32 = 45;
pub const IBUS_KEY_period: u32 = 46;
pub const IBUS_KEY_slash: u32 = 47;
pub const IBUS_KEY_0: u32 = 48;
pub const IBUS_KEY_1: u32 = 49;
pub const IBUS_KEY_2: u32 = 50;
pub const IBUS_KEY_3: u32 = 51;
pub const IBUS_KEY_4: u32 = 52;
pub const IBUS_KEY_5: u32 = 53;
pub const IBUS_KEY_6: u32 = 54;
pub const IBUS_KEY_7: u32 = 55;
pub const IBUS_KEY_8: u32 = 56;
pub const IBUS_KEY_9: u32 = 57;
pub const IBUS_KEY_colon: u32 = 58;
pub const IBUS_KEY_semicolon: u32 = 59;
pub const IBUS_KEY_less: u32 = 60;
pub const IBUS_KEY_equal: u32 = 61;
pub const IBUS_KEY_greater: u32 = 62;
pub const IBUS_KEY_question: u32 = 63;
pub const IBUS_KEY_at: u32 = 64;
pub const IBUS_KEY_A: u32 = 65;
pub const IBUS_KEY_B: u32 = 66;
pub const IBUS_KEY_C: u32 = 67;
pub const IBUS_KEY_D: u32 = 68;
pub const IBUS_KEY_E: u32 = 69;
pub const IBUS_KEY_F: u32 = 70;
pub const IBUS_KEY_G: u32 = 71;
pub const IBUS_KEY_H: u32 = 72;
pub const IBUS_KEY_I: u32 = 73;
pub const IBUS_KEY_J: u32 = 74;
pub const IBUS_KEY_K: u32 = 75;
pub const IBUS_KEY_L: u32 = 76;
pub const IBUS_KEY_M: u32 = 77;
pub const IBUS_KEY_N: u32 = 78;
pub const IBUS_KEY_O: u32 = 79;
pub const IBUS_KEY_P: u32 = 80;
pub const IBUS_KEY_Q: u32 = 81;
pub const IBUS_KEY_R: u32 = 82;
pub const IBUS_KEY_S: u32 = 83;
pub const IBUS_KEY_T: u32 = 84;
pub const IBUS_KEY_U: u32 = 85;
pub const IBUS_KEY_V: u32 = 86;
pub const IBUS_KEY_W: u32 = 87;
pub const IBUS_KEY_X: u32 = 88;
pub const IBUS_KEY_Y: u32 = 89;
pub const IBUS_KEY_Z: u32 = 90;
pub const IBUS_KEY_bracketleft: u32 = 91;
pub const IBUS_KEY_backslash: u32 = 92;
pub const IBUS_KEY_bracketright: u32 = 93;
pub const IBUS_KEY_asciicircum: u32 = 94;
pub const IBUS_KEY_underscore: u32 = 95;
pub const IBUS_KEY_grave: u32 = 96;
pub const IBUS_KEY_quoteleft: u32 = 96;
pub const IBUS_KEY_a: u32 = 97;
pub const IBUS_KEY_b: u32 = 98;
pub const IBUS_KEY_c: u32 = 99;
pub const IBUS_KEY_d: u32 = 100;
pub const IBUS_KEY_e: u32 = 101;
pub const IBUS_KEY_f: u32 = 102;
pub const IBUS_KEY_g: u32 = 103;
pub const IBUS_KEY_h: u32 = 104;
pub const IBUS_KEY_i: u32 = 105;
pub const IBUS_KEY_j: u32 = 106;
pub const IBUS_KEY_k: u32 = 107;
pub const IBUS_KEY_l: u32 = 108;
pub const IBUS_KEY_m: u32 = 109;
pub const IBUS_KEY_n: u32 = 110;
pub const IBUS_KEY_o: u32 = 111;
pub const IBUS_KEY_p: u32 = 112;
pub const IBUS_KEY_q: u32 = 113;
pub const IBUS_KEY_r: u32 = 114;
pub const IBUS_KEY_s: u32 = 115;
pub const IBUS_KEY_t: u32 = 116;
pub const IBUS_KEY_u: u32 = 117;
pub const IBUS_KEY_v: u32 = 118;
pub const IBUS_KEY_w: u32 = 119;
pub const IBUS_KEY_x: u32 = 120;
pub const IBUS_KEY_y: u32 = 121;
pub const IBUS_KEY_z: u32 = 122;
pub const IBUS_KEY_braceleft: u32 = 123;
pub const IBUS_KEY_bar: u32 = 124;
pub const IBUS_KEY_braceright: u32 = 125;
pub const IBUS_KEY_asciitilde: u32 = 126;
pub const IBUS_KEY_nobreakspace: u32 = 160;
pub const IBUS_KEY_exclamdown: u32 = 161;
pub const IBUS_KEY_cent: u32 = 162;
pub const IBUS_KEY_sterling: u32 = 163;
pub const IBUS_KEY_currency: u32 = 164;
pub const IBUS_KEY_yen: u32 = 165;
pub const IBUS_KEY_brokenbar: u32 = 166;
pub const IBUS_KEY_section: u32 = 167;
pub const IBUS_KEY_diaeresis: u32 = 168;
pub const IBUS_KEY_copyright: u32 = 169;
pub const IBUS_KEY_ordfeminine: u32 = 170;
pub const IBUS_KEY_guillemotleft: u32 = 171;
pub const IBUS_KEY_notsign: u32 = 172;
pub const IBUS_KEY_hyphen: u32 = 173;
pub const IBUS_KEY_registered: u32 = 174;
pub const IBUS_KEY_macron: u32 = 175;
pub const IBUS_KEY_degree: u32 = 176;
pub const IBUS_KEY_plusminus: u32 = 177;
pub const IBUS_KEY_twosuperior: u32 = 178;
pub const IBUS_KEY_threesuperior: u32 = 179;
pub const IBUS_KEY_acute: u32 = 180;
pub const IBUS_KEY_mu: u32 = 181;
pub const IBUS_KEY_paragraph: u32 = 182;
pub const IBUS_KEY_periodcentered: u32 = 183;
pub const IBUS_KEY_cedilla: u32 = 184;
pub const IBUS_KEY_onesuperior: u32 = 185;
pub const IBUS_KEY_masculine: u32 = 186;
pub const IBUS_KEY_guillemotright: u32 = 187;
pub const IBUS_KEY_onequarter: u32 = 188;
pub const IBUS_KEY_onehalf: u32 = 189;
pub const IBUS_KEY_threequarters: u32 = 190;
pub const IBUS_KEY_questiondown: u32 = 191;
pub const IBUS_KEY_Agrave: u32 = 192;
pub const IBUS_KEY_Aacute: u32 = 193;
pub const IBUS_KEY_Acircumflex: u32 = 194;
pub const IBUS_KEY_Atilde: u32 = 195;
pub const IBUS_KEY_Adiaeresis: u32 = 196;
pub const IBUS_KEY_Aring: u32 = 197;
pub const IBUS_KEY_AE: u32 = 198;
pub const IBUS_KEY_Ccedilla: u32 = 199;
pub const IBUS_KEY_Egrave: u32 = 200;
pub const IBUS_KEY_Eacute: u32 = 201;
pub const IBUS_KEY_Ecircumflex: u32 = 202;
pub const IBUS_KEY_Ediaeresis: u32 = 203;
pub const IBUS_KEY_Igrave: u32 = 204;
pub const IBUS_KEY_Iacute: u32 = 205;
pub const IBUS_KEY_Icircumflex: u32 = 206;
pub const IBUS_KEY_Idiaeresis: u32 = 207;
pub const IBUS_KEY_ETH: u32 = 208;
pub const IBUS_KEY_Eth: u32 = 208;
pub const IBUS_KEY_Ntilde: u32 = 209;
pub const IBUS_KEY_Ograve: u32 = 210;
pub const IBUS_KEY_Oacute: u32 = 211;
pub const IBUS_KEY_Ocircumflex: u32 = 212;
pub const IBUS_KEY_Otilde: u32 = 213;
pub const IBUS_KEY_Odiaeresis: u32 = 214;
pub const IBUS_KEY_multiply: u32 = 215;
pub const IBUS_KEY_Oslash: u32 = 216;
pub const IBUS_KEY_Ooblique: u32 = 216;
pub const IBUS_KEY_Ugrave: u32 = 217;
pub const IBUS_KEY_Uacute: u32 = 218;
pub const IBUS_KEY_Ucircumflex: u32 = 219;
pub const IBUS_KEY_Udiaeresis: u32 = 220;
pub const IBUS_KEY_Yacute: u32 = 221;
pub const IBUS_KEY_THORN: u32 = 222;
pub const IBUS_KEY_Thorn: u32 = 222;
pub const IBUS_KEY_ssharp: u32 = 223;
pub const IBUS_KEY_agrave: u32 = 224;
pub const IBUS_KEY_aacute: u32 = 225;
pub const IBUS_KEY_acircumflex: u32 = 226;
pub const IBUS_KEY_atilde: u32 = 227;
pub const IBUS_KEY_adiaeresis: u32 = 228;
pub const IBUS_KEY_aring: u32 = 229;
pub const IBUS_KEY_ae: u32 = 230;
pub const IBUS_KEY_ccedilla: u32 = 231;
pub const IBUS_KEY_egrave: u32 = 232;
pub const IBUS_KEY_eacute: u32 = 233;
pub const IBUS_KEY_ecircumflex: u32 = 234;
pub const IBUS_KEY_ediaeresis: u32 = 235;
pub const IBUS_KEY_igrave: u32 = 236;
pub const IBUS_KEY_iacute: u32 = 237;
pub const IBUS_KEY_icircumflex: u32 = 238;
pub const IBUS_KEY_idiaeresis: u32 = 239;
pub const IBUS_KEY_eth: u32 = 240;
pub const IBUS_KEY_ntilde: u32 = 241;
pub const IBUS_KEY_ograve: u32 = 242;
pub const IBUS_KEY_oacute: u32 = 243;
pub const IBUS_KEY_ocircumflex: u32 = 244;
pub const IBUS_KEY_otilde: u32 = 245;
pub const IBUS_KEY_odiaeresis: u32 = 246;
pub const IBUS_KEY_division: u32 = 247;
pub const IBUS_KEY_oslash: u32 = 248;
pub const IBUS_KEY_ooblique: u32 = 248;
pub const IBUS_KEY_ugrave: u32 = 249;
pub const IBUS_KEY_uacute: u32 = 250;
pub const IBUS_KEY_ucircumflex: u32 = 251;
pub const IBUS_KEY_udiaeresis: u32 = 252;
pub const IBUS_KEY_yacute: u32 = 253;
pub const IBUS_KEY_thorn: u32 = 254;
pub const IBUS_KEY_ydiaeresis: u32 = 255;
pub const IBUS_KEY_Aogonek: u32 = 417;
pub const IBUS_KEY_breve: u32 = 418;
pub const IBUS_KEY_Lstroke: u32 = 419;
pub const IBUS_KEY_Lcaron: u32 = 421;
pub const IBUS_KEY_Sacute: u32 = 422;
pub const IBUS_KEY_Scaron: u32 = 425;
pub const IBUS_KEY_Scedilla: u32 = 426;
pub const IBUS_KEY_Tcaron: u32 = 427;
pub const IBUS_KEY_Zacute: u32 = 428;
pub const IBUS_KEY_Zcaron: u32 = 430;
pub const IBUS_KEY_Zabovedot: u32 = 431;
pub const IBUS_KEY_aogonek: u32 = 433;
pub const IBUS_KEY_ogonek: u32 = 434;
pub const IBUS_KEY_lstroke: u32 = 435;
pub const IBUS_KEY_lcaron: u32 = 437;
pub const IBUS_KEY_sacute: u32 = 438;
pub const IBUS_KEY_caron: u32 = 439;
pub const IBUS_KEY_scaron: u32 = 441;
pub const IBUS_KEY_scedilla: u32 = 442;
pub const IBUS_KEY_tcaron: u32 = 443;
pub const IBUS_KEY_zacute: u32 = 444;
pub const IBUS_KEY_doubleacute: u32 = 445;
pub const IBUS_KEY_zcaron: u32 = 446;
pub const IBUS_KEY_zabovedot: u32 = 447;
pub const IBUS_KEY_Racute: u32 = 448;
pub const IBUS_KEY_Abreve: u32 = 451;
pub const IBUS_KEY_Lacute: u32 = 453;
pub const IBUS_KEY_Cacute: u32 = 454;
pub const IBUS_KEY_Ccaron: u32 = 456;
pub const IBUS_KEY_Eogonek: u32 = 458;
pub const IBUS_KEY_Ecaron: u32 = 460;
pub const IBUS_KEY_Dcaron: u32 = 463;
pub const IBUS_KEY_Dstroke: u32 = 464;
pub const IBUS_KEY_Nacute: u32 = 465;
pub const IBUS_KEY_Ncaron: u32 = 466;
pub const IBUS_KEY_Odoubleacute: u32 = 469;
pub const IBUS_KEY_Rcaron: u32 = 472;
pub const IBUS_KEY_Uring: u32 = 473;
pub const IBUS_KEY_Udoubleacute: u32 = 475;
pub const IBUS_KEY_Tcedilla: u32 = 478;
pub const IBUS_KEY_racute: u32 = 480;
pub const IBUS_KEY_abreve: u32 = 483;
pub const IBUS_KEY_lacute: u32 = 485;
pub const IBUS_KEY_cacute: u32 = 486;
pub const IBUS_KEY_ccaron: u32 = 488;
pub const IBUS_KEY_eogonek: u32 = 490;
pub const IBUS_KEY_ecaron: u32 = 492;
pub const IBUS_KEY_dcaron: u32 = 495;
pub const IBUS_KEY_dstroke: u32 = 496;
pub const IBUS_KEY_nacute: u32 = 497;
pub const IBUS_KEY_ncaron: u32 = 498;
pub const IBUS_KEY_odoubleacute: u32 = 501;
pub const IBUS_KEY_rcaron: u32 = 504;
pub const IBUS_KEY_uring: u32 = 505;
pub const IBUS_KEY_udoubleacute: u32 = 507;
pub const IBUS_KEY_tcedilla: u32 = 510;
pub const IBUS_KEY_abovedot: u32 = 511;
pub const IBUS_KEY_Hstroke: u32 = 673;
pub const IBUS_KEY_Hcircumflex: u32 = 678;
pub const IBUS_KEY_Iabovedot: u32 = 681;
pub const IBUS_KEY_Gbreve: u32 = 683;
pub const IBUS_KEY_Jcircumflex: u32 = 684;
pub const IBUS_KEY_hstroke: u32 = 689;
pub const IBUS_KEY_hcircumflex: u32 = 694;
pub const IBUS_KEY_idotless: u32 = 697;
pub const IBUS_KEY_gbreve: u32 = 699;
pub const IBUS_KEY_jcircumflex: u32 = 700;
pub const IBUS_KEY_Cabovedot: u32 = 709;
pub const IBUS_KEY_Ccircumflex: u32 = 710;
pub const IBUS_KEY_Gabovedot: u32 = 725;
pub const IBUS_KEY_Gcircumflex: u32 = 728;
pub const IBUS_KEY_Ubreve: u32 = 733;
pub const IBUS_KEY_Scircumflex: u32 = 734;
pub const IBUS_KEY_cabovedot: u32 = 741;
pub const IBUS_KEY_ccircumflex: u32 = 742;
pub const IBUS_KEY_gabovedot: u32 = 757;
pub const IBUS_KEY_gcircumflex: u32 = 760;
pub const IBUS_KEY_ubreve: u32 = 765;
pub const IBUS_KEY_scircumflex: u32 = 766;
pub const IBUS_KEY_kra: u32 = 930;
pub const IBUS_KEY_kappa: u32 = 930;
pub const IBUS_KEY_Rcedilla: u32 = 931;
pub const IBUS_KEY_Itilde: u32 = 933;
pub const IBUS_KEY_Lcedilla: u32 = 934;
pub const IBUS_KEY_Emacron: u32 = 938;
pub const IBUS_KEY_Gcedilla: u32 = 939;
pub const IBUS_KEY_Tslash: u32 = 940;
pub const IBUS_KEY_rcedilla: u32 = 947;
pub const IBUS_KEY_itilde: u32 = 949;
pub const IBUS_KEY_lcedilla: u32 = 950;
pub const IBUS_KEY_emacron: u32 = 954;
pub const IBUS_KEY_gcedilla: u32 = 955;
pub const IBUS_KEY_tslash: u32 = 956;
pub const IBUS_KEY_ENG: u32 = 957;
pub const IBUS_KEY_eng: u32 = 959;
pub const IBUS_KEY_Amacron: u32 = 960;
pub const IBUS_KEY_Iogonek: u32 = 967;
pub const IBUS_KEY_Eabovedot: u32 = 972;
pub const IBUS_KEY_Imacron: u32 = 975;
pub const IBUS_KEY_Ncedilla: u32 = 977;
pub const IBUS_KEY_Omacron: u32 = 978;
pub const IBUS_KEY_Kcedilla: u32 = 979;
pub const IBUS_KEY_Uogonek: u32 = 985;
pub const IBUS_KEY_Utilde: u32 = 989;
pub const IBUS_KEY_Umacron: u32 = 990;
pub const IBUS_KEY_amacron: u32 = 992;
pub const IBUS_KEY_iogonek: u32 = 999;
pub const IBUS_KEY_eabovedot: u32 = 1004;
pub const IBUS_KEY_imacron: u32 = 1007;
pub const IBUS_KEY_ncedilla: u32 = 1009;
pub const IBUS_KEY_omacron: u32 = 1010;
pub const IBUS_KEY_kcedilla: u32 = 1011;
pub const IBUS_KEY_uogonek: u32 = 1017;
pub const IBUS_KEY_utilde: u32 = 1021;
pub const IBUS_KEY_umacron: u32 = 1022;
pub const IBUS_KEY_Wcircumflex: u32 = 16777588;
pub const IBUS_KEY_wcircumflex: u32 = 16777589;
pub const IBUS_KEY_Ycircumflex: u32 = 16777590;
pub const IBUS_KEY_ycircumflex: u32 = 16777591;
pub const IBUS_KEY_Babovedot: u32 = 16784898;
pub const IBUS_KEY_babovedot: u32 = 16784899;
pub const IBUS_KEY_Dabovedot: u32 = 16784906;
pub const IBUS_KEY_dabovedot: u32 = 16784907;
pub const IBUS_KEY_Fabovedot: u32 = 16784926;
pub const IBUS_KEY_fabovedot: u32 = 16784927;
pub const IBUS_KEY_Mabovedot: u32 = 16784960;
pub const IBUS_KEY_mabovedot: u32 = 16784961;
pub const IBUS_KEY_Pabovedot: u32 = 16784982;
pub const IBUS_KEY_pabovedot: u32 = 16784983;
pub const IBUS_KEY_Sabovedot: u32 = 16784992;
pub const IBUS_KEY_sabovedot: u32 = 16784993;
pub const IBUS_KEY_Tabovedot: u32 = 16785002;
pub const IBUS_KEY_tabovedot: u32 = 16785003;
pub const IBUS_KEY_Wgrave: u32 = 16785024;
pub const IBUS_KEY_wgrave: u32 = 16785025;
pub const IBUS_KEY_Wacute: u32 = 16785026;
pub const IBUS_KEY_wacute: u32 = 16785027;
pub const IBUS_KEY_Wdiaeresis: u32 = 16785028;
pub const IBUS_KEY_wdiaeresis: u32 = 16785029;
pub const IBUS_KEY_Ygrave: u32 = 16785138;
pub const IBUS_KEY_ygrave: u32 = 16785139;
pub const IBUS_KEY_OE: u32 = 5052;
pub const IBUS_KEY_oe: u32 = 5053;
pub const IBUS_KEY_Ydiaeresis: u32 = 5054;
pub const IBUS_KEY_overline: u32 = 1150;
pub const IBUS_KEY_kana_fullstop: u32 = 1185;
pub const IBUS_KEY_kana_openingbracket: u32 = 1186;
pub const IBUS_KEY_kana_closingbracket: u32 = 1187;
pub const IBUS_KEY_kana_comma: u32 = 1188;
pub const IBUS_KEY_kana_conjunctive: u32 = 1189;
pub const IBUS_KEY_kana_middledot: u32 = 1189;
pub const IBUS_KEY_kana_WO: u32 = 1190;
pub const IBUS_KEY_kana_a: u32 = 1191;
pub const IBUS_KEY_kana_i: u32 = 1192;
pub const IBUS_KEY_kana_u: u32 = 1193;
pub const IBUS_KEY_kana_e: u32 = 1194;
pub const IBUS_KEY_kana_o: u32 = 1195;
pub const IBUS_KEY_kana_ya: u32 = 1196;
pub const IBUS_KEY_kana_yu: u32 = 1197;
pub const IBUS_KEY_kana_yo: u32 = 1198;
pub const IBUS_KEY_kana_tsu: u32 = 1199;
pub const IBUS_KEY_kana_tu: u32 = 1199;
pub const IBUS_KEY_prolongedsound: u32 = 1200;
pub const IBUS_KEY_kana_A: u32 = 1201;
pub const IBUS_KEY_kana_I: u32 = 1202;
pub const IBUS_KEY_kana_U: u32 = 1203;
pub const IBUS_KEY_kana_E: u32 = 1204;
pub const IBUS_KEY_kana_O: u32 = 1205;
pub const IBUS_KEY_kana_KA: u32 = 1206;
pub const IBUS_KEY_kana_KI: u32 = 1207;
pub const IBUS_KEY_kana_KU: u32 = 1208;
pub const IBUS_KEY_kana_KE: u32 = 1209;
pub const IBUS_KEY_kana_KO: u32 = 1210;
pub const IBUS_KEY_kana_SA: u32 = 1211;
pub const IBUS_KEY_kana_SHI: u32 = 1212;
pub const IBUS_KEY_kana_SU: u32 = 1213;
pub const IBUS_KEY_kana_SE: u32 = 1214;
pub const IBUS_KEY_kana_SO: u32 = 1215;
pub const IBUS_KEY_kana_TA: u32 = 1216;
pub const IBUS_KEY_kana_CHI: u32 = 1217;
pub const IBUS_KEY_kana_TI: u32 = 1217;
pub const IBUS_KEY_kana_TSU: u32 = 1218;
pub const IBUS_KEY_kana_TU: u32 = 1218;
pub const IBUS_KEY_kana_TE: u32 = 1219;
pub const IBUS_KEY_kana_TO: u32 = 1220;
pub const IBUS_KEY_kana_NA: u32 = 1221;
pub const IBUS_KEY_kana_NI: u32 = 1222;
pub const IBUS_KEY_kana_NU: u32 = 1223;
pub const IBUS_KEY_kana_NE: u32 = 1224;
pub const IBUS_KEY_kana_NO: u32 = 1225;
pub const IBUS_KEY_kana_HA: u32 = 1226;
pub const IBUS_KEY_kana_HI: u32 = 1227;
pub const IBUS_KEY_kana_FU: u32 = 1228;
pub const IBUS_KEY_kana_HU: u32 = 1228;
pub const IBUS_KEY_kana_HE: u32 = 1229;
pub const IBUS_KEY_kana_HO: u32 = 1230;
pub const IBUS_KEY_kana_MA: u32 = 1231;
pub const IBUS_KEY_kana_MI: u32 = 1232;
pub const IBUS_KEY_kana_MU: u32 = 1233;
pub const IBUS_KEY_kana_ME: u32 = 1234;
pub const IBUS_KEY_kana_MO: u32 = 1235;
pub const IBUS_KEY_kana_YA: u32 = 1236;
pub const IBUS_KEY_kana_YU: u32 = 1237;
pub const IBUS_KEY_kana_YO: u32 = 1238;
pub const IBUS_KEY_kana_RA: u32 = 1239;
pub const IBUS_KEY_kana_RI: u32 = 1240;
pub const IBUS_KEY_kana_RU: u32 = 1241;
pub const IBUS_KEY_kana_RE: u32 = 1242;
pub const IBUS_KEY_kana_RO: u32 = 1243;
pub const IBUS_KEY_kana_WA: u32 = 1244;
pub const IBUS_KEY_kana_N: u32 = 1245;
pub const IBUS_KEY_voicedsound: u32 = 1246;
pub const IBUS_KEY_semivoicedsound: u32 = 1247;
pub const IBUS_KEY_kana_switch: u32 = 65406;
pub const IBUS_KEY_Farsi_0: u32 = 16778992;
pub const IBUS_KEY_Farsi_1: u32 = 16778993;
pub const IBUS_KEY_Farsi_2: u32 = 16778994;
pub const IBUS_KEY_Farsi_3: u32 = 16778995;
pub const IBUS_KEY_Farsi_4: u32 = 16778996;
pub const IBUS_KEY_Farsi_5: u32 = 16778997;
pub const IBUS_KEY_Farsi_6: u32 = 16778998;
pub const IBUS_KEY_Farsi_7: u32 = 16778999;
pub const IBUS_KEY_Farsi_8: u32 = 16779000;
pub const IBUS_KEY_Farsi_9: u32 = 16779001;
pub const IBUS_KEY_Arabic_percent: u32 = 16778858;
pub const IBUS_KEY_Arabic_superscript_alef: u32 = 16778864;
pub const IBUS_KEY_Arabic_tteh: u32 = 16778873;
pub const IBUS_KEY_Arabic_peh: u32 = 16778878;
pub const IBUS_KEY_Arabic_tcheh: u32 = 16778886;
pub const IBUS_KEY_Arabic_ddal: u32 = 16778888;
pub const IBUS_KEY_Arabic_rreh: u32 = 16778897;
pub const IBUS_KEY_Arabic_comma: u32 = 1452;
pub const IBUS_KEY_Arabic_fullstop: u32 = 16778964;
pub const IBUS_KEY_Arabic_0: u32 = 16778848;
pub const IBUS_KEY_Arabic_1: u32 = 16778849;
pub const IBUS_KEY_Arabic_2: u32 = 16778850;
pub const IBUS_KEY_Arabic_3: u32 = 16778851;
pub const IBUS_KEY_Arabic_4: u32 = 16778852;
pub const IBUS_KEY_Arabic_5: u32 = 16778853;
pub const IBUS_KEY_Arabic_6: u32 = 16778854;
pub const IBUS_KEY_Arabic_7: u32 = 16778855;
pub const IBUS_KEY_Arabic_8: u32 = 16778856;
pub const IBUS_KEY_Arabic_9: u32 = 16778857;
pub const IBUS_KEY_Arabic_semicolon: u32 = 1467;
pub const IBUS_KEY_Arabic_question_mark: u32 = 1471;
pub const IBUS_KEY_Arabic_hamza: u32 = 1473;
pub const IBUS_KEY_Arabic_maddaonalef: u32 = 1474;
pub const IBUS_KEY_Arabic_hamzaonalef: u32 = 1475;
pub const IBUS_KEY_Arabic_hamzaonwaw: u32 = 1476;
pub const IBUS_KEY_Arabic_hamzaunderalef: u32 = 1477;
pub const IBUS_KEY_Arabic_hamzaonyeh: u32 = 1478;
pub const IBUS_KEY_Arabic_alef: u32 = 1479;
pub const IBUS_KEY_Arabic_beh: u32 = 1480;
pub const IBUS_KEY_Arabic_tehmarbuta: u32 = 1481;
pub const IBUS_KEY_Arabic_teh: u32 = 1482;
pub const IBUS_KEY_Arabic_theh: u32 = 1483;
pub const IBUS_KEY_Arabic_jeem: u32 = 1484;
pub const IBUS_KEY_Arabic_hah: u32 = 1485;
pub const IBUS_KEY_Arabic_khah: u32 = 1486;
pub const IBUS_KEY_Arabic_dal: u32 = 1487;
pub const IBUS_KEY_Arabic_thal: u32 = 1488;
pub const IBUS_KEY_Arabic_ra: u32 = 1489;
pub const IBUS_KEY_Arabic_zain: u32 = 1490;
pub const IBUS_KEY_Arabic_seen: u32 = 1491;
pub const IBUS_KEY_Arabic_sheen: u32 = 1492;
pub const IBUS_KEY_Arabic_sad: u32 = 1493;
pub const IBUS_KEY_Arabic_dad: u32 = 1494;
pub const IBUS_KEY_Arabic_tah: u32 = 1495;
pub const IBUS_KEY_Arabic_zah: u32 = 1496;
pub const IBUS_KEY_Arabic_ain: u32 = 1497;
pub const IBUS_KEY_Arabic_ghain: u32 = 1498;
pub const IBUS_KEY_Arabic_tatweel: u32 = 1504;
pub const IBUS_KEY_Arabic_feh: u32 = 1505;
pub const IBUS_KEY_Arabic_qaf: u32 = 1506;
pub const IBUS_KEY_Arabic_kaf: u32 = 1507;
pub const IBUS_KEY_Arabic_lam: u32 = 1508;
pub const IBUS_KEY_Arabic_meem: u32 = 1509;
pub const IBUS_KEY_Arabic_noon: u32 = 1510;
pub const IBUS_KEY_Arabic_ha: u32 = 1511;
pub const IBUS_KEY_Arabic_heh: u32 = 1511;
pub const IBUS_KEY_Arabic_waw: u32 = 1512;
pub const IBUS_KEY_Arabic_alefmaksura: u32 = 1513;
pub const IBUS_KEY_Arabic_yeh: u32 = 1514;
pub const IBUS_KEY_Arabic_fathatan: u32 = 1515;
pub const IBUS_KEY_Arabic_dammatan: u32 = 1516;
pub const IBUS_KEY_Arabic_kasratan: u32 = 1517;
pub const IBUS_KEY_Arabic_fatha: u32 = 1518;
pub const IBUS_KEY_Arabic_damma: u32 = 1519;
pub const IBUS_KEY_Arabic_kasra: u32 = 1520;
pub const IBUS_KEY_Arabic_shadda: u32 = 1521;
pub const IBUS_KEY_Arabic_sukun: u32 = 1522;
pub const IBUS_KEY_Arabic_madda_above: u32 = 16778835;
pub const IBUS_KEY_Arabic_hamza_above: u32 = 16778836;
pub const IBUS_KEY_Arabic_hamza_below: u32 = 16778837;
pub const IBUS_KEY_Arabic_jeh: u32 = 16778904;
pub const IBUS_KEY_Arabic_veh: u32 = 16778916;
pub const IBUS_KEY_Arabic_keheh: u32 = 16778921;
pub const IBUS_KEY_Arabic_gaf: u32 = 16778927;
pub const IBUS_KEY_Arabic_noon_ghunna: u32 = 16778938;
pub const IBUS_KEY_Arabic_heh_doachashmee: u32 = 16778942;
pub const IBUS_KEY_Farsi_yeh: u32 = 16778956;
pub const IBUS_KEY_Arabic_farsi_yeh: u32 = 16778956;
pub const IBUS_KEY_Arabic_yeh_baree: u32 = 16778962;
pub const IBUS_KEY_Arabic_heh_goal: u32 = 16778945;
pub const IBUS_KEY_Arabic_switch: u32 = 65406;
pub const IBUS_KEY_Cyrillic_GHE_bar: u32 = 16778386;
pub const IBUS_KEY_Cyrillic_ghe_bar: u32 = 16778387;
pub const IBUS_KEY_Cyrillic_ZHE_descender: u32 = 16778390;
pub const IBUS_KEY_Cyrillic_zhe_descender: u32 = 16778391;
pub const IBUS_KEY_Cyrillic_KA_descender: u32 = 16778394;
pub const IBUS_KEY_Cyrillic_ka_descender: u32 = 16778395;
pub const IBUS_KEY_Cyrillic_KA_vertstroke: u32 = 16778396;
pub const IBUS_KEY_Cyrillic_ka_vertstroke: u32 = 16778397;
pub const IBUS_KEY_Cyrillic_EN_descender: u32 = 16778402;
pub const IBUS_KEY_Cyrillic_en_descender: u32 = 16778403;
pub const IBUS_KEY_Cyrillic_U_straight: u32 = 16778414;
pub const IBUS_KEY_Cyrillic_u_straight: u32 = 16778415;
pub const IBUS_KEY_Cyrillic_U_straight_bar: u32 = 16778416;
pub const IBUS_KEY_Cyrillic_u_straight_bar: u32 = 16778417;
pub const IBUS_KEY_Cyrillic_HA_descender: u32 = 16778418;
pub const IBUS_KEY_Cyrillic_ha_descender: u32 = 16778419;
pub const IBUS_KEY_Cyrillic_CHE_descender: u32 = 16778422;
pub const IBUS_KEY_Cyrillic_che_descender: u32 = 16778423;
pub const IBUS_KEY_Cyrillic_CHE_vertstroke: u32 = 16778424;
pub const IBUS_KEY_Cyrillic_che_vertstroke: u32 = 16778425;
pub const IBUS_KEY_Cyrillic_SHHA: u32 = 16778426;
pub const IBUS_KEY_Cyrillic_shha: u32 = 16778427;
pub const IBUS_KEY_Cyrillic_SCHWA: u32 = 16778456;
pub const IBUS_KEY_Cyrillic_schwa: u32 = 16778457;
pub const IBUS_KEY_Cyrillic_I_macron: u32 = 16778466;
pub const IBUS_KEY_Cyrillic_i_macron: u32 = 16778467;
pub const IBUS_KEY_Cyrillic_O_bar: u32 = 16778472;
pub const IBUS_KEY_Cyrillic_o_bar: u32 = 16778473;
pub const IBUS_KEY_Cyrillic_U_macron: u32 = 16778478;
pub const IBUS_KEY_Cyrillic_u_macron: u32 = 16778479;
pub const IBUS_KEY_Serbian_dje: u32 = 1697;
pub const IBUS_KEY_Macedonia_gje: u32 = 1698;
pub const IBUS_KEY_Cyrillic_io: u32 = 1699;
pub const IBUS_KEY_Ukrainian_ie: u32 = 1700;
pub const IBUS_KEY_Ukranian_je: u32 = 1700;
pub const IBUS_KEY_Macedonia_dse: u32 = 1701;
pub const IBUS_KEY_Ukrainian_i: u32 = 1702;
pub const IBUS_KEY_Ukranian_i: u32 = 1702;
pub const IBUS_KEY_Ukrainian_yi: u32 = 1703;
pub const IBUS_KEY_Ukranian_yi: u32 = 1703;
pub const IBUS_KEY_Cyrillic_je: u32 = 1704;
pub const IBUS_KEY_Serbian_je: u32 = 1704;
pub const IBUS_KEY_Cyrillic_lje: u32 = 1705;
pub const IBUS_KEY_Serbian_lje: u32 = 1705;
pub const IBUS_KEY_Cyrillic_nje: u32 = 1706;
pub const IBUS_KEY_Serbian_nje: u32 = 1706;
pub const IBUS_KEY_Serbian_tshe: u32 = 1707;
pub const IBUS_KEY_Macedonia_kje: u32 = 1708;
pub const IBUS_KEY_Ukrainian_ghe_with_upturn: u32 = 1709;
pub const IBUS_KEY_Byelorussian_shortu: u32 = 1710;
pub const IBUS_KEY_Cyrillic_dzhe: u32 = 1711;
pub const IBUS_KEY_Serbian_dze: u32 = 1711;
pub const IBUS_KEY_numerosign: u32 = 1712;
pub const IBUS_KEY_Serbian_DJE: u32 = 1713;
pub const IBUS_KEY_Macedonia_GJE: u32 = 1714;
pub const IBUS_KEY_Cyrillic_IO: u32 = 1715;
pub const IBUS_KEY_Ukrainian_IE: u32 = 1716;
pub const IBUS_KEY_Ukranian_JE: u32 = 1716;
pub const IBUS_KEY_Macedonia_DSE: u32 = 1717;
pub const IBUS_KEY_Ukrainian_I: u32 = 1718;
pub const IBUS_KEY_Ukranian_I: u32 = 1718;
pub const IBUS_KEY_Ukrainian_YI: u32 = 1719;
pub const IBUS_KEY_Ukranian_YI: u32 = 1719;
pub const IBUS_KEY_Cyrillic_JE: u32 = 1720;
pub const IBUS_KEY_Serbian_JE: u32 = 1720;
pub const IBUS_KEY_Cyrillic_LJE: u32 = 1721;
pub const IBUS_KEY_Serbian_LJE: u32 = 1721;
pub const IBUS_KEY_Cyrillic_NJE: u32 = 1722;
pub const IBUS_KEY_Serbian_NJE: u32 = 1722;
pub const IBUS_KEY_Serbian_TSHE: u32 = 1723;
pub const IBUS_KEY_Macedonia_KJE: u32 = 1724;
pub const IBUS_KEY_Ukrainian_GHE_WITH_UPTURN: u32 = 1725;
pub const IBUS_KEY_Byelorussian_SHORTU: u32 = 1726;
pub const IBUS_KEY_Cyrillic_DZHE: u32 = 1727;
pub const IBUS_KEY_Serbian_DZE: u32 = 1727;
pub const IBUS_KEY_Cyrillic_yu: u32 = 1728;
pub const IBUS_KEY_Cyrillic_a: u32 = 1729;
pub const IBUS_KEY_Cyrillic_be: u32 = 1730;
pub const IBUS_KEY_Cyrillic_tse: u32 = 1731;
pub const IBUS_KEY_Cyrillic_de: u32 = 1732;
pub const IBUS_KEY_Cyrillic_ie: u32 = 1733;
pub const IBUS_KEY_Cyrillic_ef: u32 = 1734;
pub const IBUS_KEY_Cyrillic_ghe: u32 = 1735;
pub const IBUS_KEY_Cyrillic_ha: u32 = 1736;
pub const IBUS_KEY_Cyrillic_i: u32 = 1737;
pub const IBUS_KEY_Cyrillic_shorti: u32 = 1738;
pub const IBUS_KEY_Cyrillic_ka: u32 = 1739;
pub const IBUS_KEY_Cyrillic_el: u32 = 1740;
pub const IBUS_KEY_Cyrillic_em: u32 = 1741;
pub const IBUS_KEY_Cyrillic_en: u32 = 1742;
pub const IBUS_KEY_Cyrillic_o: u32 = 1743;
pub const IBUS_KEY_Cyrillic_pe: u32 = 1744;
pub const IBUS_KEY_Cyrillic_ya: u32 = 1745;
pub const IBUS_KEY_Cyrillic_er: u32 = 1746;
pub const IBUS_KEY_Cyrillic_es: u32 = 1747;
pub const IBUS_KEY_Cyrillic_te: u32 = 1748;
pub const IBUS_KEY_Cyrillic_u: u32 = 1749;
pub const IBUS_KEY_Cyrillic_zhe: u32 = 1750;
pub const IBUS_KEY_Cyrillic_ve: u32 = 1751;
pub const IBUS_KEY_Cyrillic_softsign: u32 = 1752;
pub const IBUS_KEY_Cyrillic_yeru: u32 = 1753;
pub const IBUS_KEY_Cyrillic_ze: u32 = 1754;
pub const IBUS_KEY_Cyrillic_sha: u32 = 1755;
pub const IBUS_KEY_Cyrillic_e: u32 = 1756;
pub const IBUS_KEY_Cyrillic_shcha: u32 = 1757;
pub const IBUS_KEY_Cyrillic_che: u32 = 1758;
pub const IBUS_KEY_Cyrillic_hardsign: u32 = 1759;
pub const IBUS_KEY_Cyrillic_YU: u32 = 1760;
pub const IBUS_KEY_Cyrillic_A: u32 = 1761;
pub const IBUS_KEY_Cyrillic_BE: u32 = 1762;
pub const IBUS_KEY_Cyrillic_TSE: u32 = 1763;
pub const IBUS_KEY_Cyrillic_DE: u32 = 1764;
pub const IBUS_KEY_Cyrillic_IE: u32 = 1765;
pub const IBUS_KEY_Cyrillic_EF: u32 = 1766;
pub const IBUS_KEY_Cyrillic_GHE: u32 = 1767;
pub const IBUS_KEY_Cyrillic_HA: u32 = 1768;
pub const IBUS_KEY_Cyrillic_I: u32 = 1769;
pub const IBUS_KEY_Cyrillic_SHORTI: u32 = 1770;
pub const IBUS_KEY_Cyrillic_KA: u32 = 1771;
pub const IBUS_KEY_Cyrillic_EL: u32 = 1772;
pub const IBUS_KEY_Cyrillic_EM: u32 = 1773;
pub const IBUS_KEY_Cyrillic_EN: u32 = 1774;
pub const IBUS_KEY_Cyrillic_O: u32 = 1775;
pub const IBUS_KEY_Cyrillic_PE: u32 = 1776;
pub const IBUS_KEY_Cyrillic_YA: u32 = 1777;
pub const IBUS_KEY_Cyrillic_ER: u32 = 1778;
pub const IBUS_KEY_Cyrillic_ES: u32 = 1779;
pub const IBUS_KEY_Cyrillic_TE: u32 = 1780;
pub const IBUS_KEY_Cyrillic_U: u32 = 1781;
pub const IBUS_KEY_Cyrillic_ZHE: u32 = 1782;
pub const IBUS_KEY_Cyrillic_VE: u32 = 1783;
pub const IBUS_KEY_Cyrillic_SOFTSIGN: u32 = 1784;
pub const IBUS_KEY_Cyrillic_YERU: u32 = 1785;
pub const IBUS_KEY_Cyrillic_ZE: u32 = 1786;
pub const IBUS_KEY_Cyrillic_SHA: u32 = 1787;
pub const IBUS_KEY_Cyrillic_E: u32 = 1788;
pub const IBUS_KEY_Cyrillic_SHCHA: u32 = 1789;
pub const IBUS_KEY_Cyrillic_CHE: u32 = 1790;
pub const IBUS_KEY_Cyrillic_HARDSIGN: u32 = 1791;
pub const IBUS_KEY_Greek_ALPHAaccent: u32 = 1953;
pub const IBUS_KEY_Greek_EPSILONaccent: u32 = 1954;
pub const IBUS_KEY_Greek_ETAaccent: u32 = 1955;
pub const IBUS_KEY_Greek_IOTAaccent: u32 = 1956;
pub const IBUS_KEY_Greek_IOTAdieresis: u32 = 1957;
pub const IBUS_KEY_Greek_IOTAdiaeresis: u32 = 1957;
pub const IBUS_KEY_Greek_OMICRONaccent: u32 = 1959;
pub const IBUS_KEY_Greek_UPSILONaccent: u32 = 1960;
pub const IBUS_KEY_Greek_UPSILONdieresis: u32 = 1961;
pub const IBUS_KEY_Greek_OMEGAaccent: u32 = 1963;
pub const IBUS_KEY_Greek_accentdieresis: u32 = 1966;
pub const IBUS_KEY_Greek_horizbar: u32 = 1967;
pub const IBUS_KEY_Greek_alphaaccent: u32 = 1969;
pub const IBUS_KEY_Greek_epsilonaccent: u32 = 1970;
pub const IBUS_KEY_Greek_etaaccent: u32 = 1971;
pub const IBUS_KEY_Greek_iotaaccent: u32 = 1972;
pub const IBUS_KEY_Greek_iotadieresis: u32 = 1973;
pub const IBUS_KEY_Greek_iotaaccentdieresis: u32 = 1974;
pub const IBUS_KEY_Greek_omicronaccent: u32 = 1975;
pub const IBUS_KEY_Greek_upsilonaccent: u32 = 1976;
pub const IBUS_KEY_Greek_upsilondieresis: u32 = 1977;
pub const IBUS_KEY_Greek_upsilonaccentdieresis: u32 = 1978;
pub const IBUS_KEY_Greek_omegaaccent: u32 = 1979;
pub const IBUS_KEY_Greek_ALPHA: u32 = 1985;
pub const IBUS_KEY_Greek_BETA: u32 = 1986;
pub const IBUS_KEY_Greek_GAMMA: u32 = 1987;
pub const IBUS_KEY_Greek_DELTA: u32 = 1988;
pub const IBUS_KEY_Greek_EPSILON: u32 = 1989;
pub const IBUS_KEY_Greek_ZETA: u32 = 1990;
pub const IBUS_KEY_Greek_ETA: u32 = 1991;
pub const IBUS_KEY_Greek_THETA: u32 = 1992;
pub const IBUS_KEY_Greek_IOTA: u32 = 1993;
pub const IBUS_KEY_Greek_KAPPA: u32 = 1994;
pub const IBUS_KEY_Greek_LAMDA: u32 = 1995;
pub const IBUS_KEY_Greek_LAMBDA: u32 = 1995;
pub const IBUS_KEY_Greek_MU: u32 = 1996;
pub const IBUS_KEY_Greek_NU: u32 = 1997;
pub const IBUS_KEY_Greek_XI: u32 = 1998;
pub const IBUS_KEY_Greek_OMICRON: u32 = 1999;
pub const IBUS_KEY_Greek_PI: u32 = 2000;
pub const IBUS_KEY_Greek_RHO: u32 = 2001;
pub const IBUS_KEY_Greek_SIGMA: u32 = 2002;
pub const IBUS_KEY_Greek_TAU: u32 = 2004;
pub const IBUS_KEY_Greek_UPSILON: u32 = 2005;
pub const IBUS_KEY_Greek_PHI: u32 = 2006;
pub const IBUS_KEY_Greek_CHI: u32 = 2007;
pub const IBUS_KEY_Greek_PSI: u32 = 2008;
pub const IBUS_KEY_Greek_OMEGA: u32 = 2009;
pub const IBUS_KEY_Greek_alpha: u32 = 2017;
pub const IBUS_KEY_Greek_beta: u32 = 2018;
pub const IBUS_KEY_Greek_gamma: u32 = 2019;
pub const IBUS_KEY_Greek_delta: u32 = 2020;
pub const IBUS_KEY_Greek_epsilon: u32 = 2021;
pub const IBUS_KEY_Greek_zeta: u32 = 2022;
pub const IBUS_KEY_Greek_eta: u32 = 2023;
pub const IBUS_KEY_Greek_theta: u32 = 2024;
pub const IBUS_KEY_Greek_iota: u32 = 2025;
pub const IBUS_KEY_Greek_kappa: u32 = 2026;
pub const IBUS_KEY_Greek_lamda: u32 = 2027;
pub const IBUS_KEY_Greek_lambda: u32 = 2027;
pub const IBUS_KEY_Greek_mu: u32 = 2028;
pub const IBUS_KEY_Greek_nu: u32 = 2029;
pub const IBUS_KEY_Greek_xi: u32 = 2030;
pub const IBUS_KEY_Greek_omicron: u32 = 2031;
pub const IBUS_KEY_Greek_pi: u32 = 2032;
pub const IBUS_KEY_Greek_rho: u32 = 2033;
pub const IBUS_KEY_Greek_sigma: u32 = 2034;
pub const IBUS_KEY_Greek_finalsmallsigma: u32 = 2035;
pub const IBUS_KEY_Greek_tau: u32 = 2036;
pub const IBUS_KEY_Greek_upsilon: u32 = 2037;
pub const IBUS_KEY_Greek_phi: u32 = 2038;
pub const IBUS_KEY_Greek_chi: u32 = 2039;
pub const IBUS_KEY_Greek_psi: u32 = 2040;
pub const IBUS_KEY_Greek_omega: u32 = 2041;
pub const IBUS_KEY_Greek_switch: u32 = 65406;
pub const IBUS_KEY_leftradical: u32 = 2209;
pub const IBUS_KEY_topleftradical: u32 = 2210;
pub const IBUS_KEY_horizconnector: u32 = 2211;
pub const IBUS_KEY_topintegral: u32 = 2212;
pub const IBUS_KEY_botintegral: u32 = 2213;
pub const IBUS_KEY_vertconnector: u32 = 2214;
pub const IBUS_KEY_topleftsqbracket: u32 = 2215;
pub const IBUS_KEY_botleftsqbracket: u32 = 2216;
pub const IBUS_KEY_toprightsqbracket: u32 = 2217;
pub const IBUS_KEY_botrightsqbracket: u32 = 2218;
pub const IBUS_KEY_topleftparens: u32 = 2219;
pub const IBUS_KEY_botleftparens: u32 = 2220;
pub const IBUS_KEY_toprightparens: u32 = 2221;
pub const IBUS_KEY_botrightparens: u32 = 2222;
pub const IBUS_KEY_leftmiddlecurlybrace: u32 = 2223;
pub const IBUS_KEY_rightmiddlecurlybrace: u32 = 2224;
pub const IBUS_KEY_topleftsummation: u32 = 2225;
pub const IBUS_KEY_botleftsummation: u32 = 2226;
pub const IBUS_KEY_topvertsummationconnector: u32 = 2227;
pub const IBUS_KEY_botvertsummationconnector: u32 = 2228;
pub const IBUS_KEY_toprightsummation: u32 = 2229;
pub const IBUS_KEY_botrightsummation: u32 = 2230;
pub const IBUS_KEY_rightmiddlesummation: u32 = 2231;
pub const IBUS_KEY_lessthanequal: u32 = 2236;
pub const IBUS_KEY_notequal: u32 = 2237;
pub const IBUS_KEY_greaterthanequal: u32 = 2238;
pub const IBUS_KEY_integral: u32 = 2239;
pub const IBUS_KEY_therefore: u32 = 2240;
pub const IBUS_KEY_variation: u32 = 2241;
pub const IBUS_KEY_infinity: u32 = 2242;
pub const IBUS_KEY_nabla: u32 = 2245;
pub const IBUS_KEY_approximate: u32 = 2248;
pub const IBUS_KEY_similarequal: u32 = 2249;
pub const IBUS_KEY_ifonlyif: u32 = 2253;
pub const IBUS_KEY_implies: u32 = 2254;
pub const IBUS_KEY_identical: u32 = 2255;
pub const IBUS_KEY_radical: u32 = 2262;
pub const IBUS_KEY_includedin: u32 = 2266;
pub const IBUS_KEY_includes: u32 = 2267;
pub const IBUS_KEY_intersection: u32 = 2268;
pub const IBUS_KEY_union: u32 = 2269;
pub const IBUS_KEY_logicaland: u32 = 2270;
pub const IBUS_KEY_logicalor: u32 = 2271;
pub const IBUS_KEY_partialderivative: u32 = 2287;
pub const IBUS_KEY_function: u32 = 2294;
pub const IBUS_KEY_leftarrow: u32 = 2299;
pub const IBUS_KEY_uparrow: u32 = 2300;
pub const IBUS_KEY_rightarrow: u32 = 2301;
pub const IBUS_KEY_downarrow: u32 = 2302;
pub const IBUS_KEY_blank: u32 = 2527;
pub const IBUS_KEY_soliddiamond: u32 = 2528;
pub const IBUS_KEY_checkerboard: u32 = 2529;
pub const IBUS_KEY_ht: u32 = 2530;
pub const IBUS_KEY_ff: u32 = 2531;
pub const IBUS_KEY_cr: u32 = 2532;
pub const IBUS_KEY_lf: u32 = 2533;
pub const IBUS_KEY_nl: u32 = 2536;
pub const IBUS_KEY_vt: u32 = 2537;
pub const IBUS_KEY_lowrightcorner: u32 = 2538;
pub const IBUS_KEY_uprightcorner: u32 = 2539;
pub const IBUS_KEY_upleftcorner: u32 = 2540;
pub const IBUS_KEY_lowleftcorner: u32 = 2541;
pub const IBUS_KEY_crossinglines: u32 = 2542;
pub const IBUS_KEY_horizlinescan1: u32 = 2543;
pub const IBUS_KEY_horizlinescan3: u32 = 2544;
pub const IBUS_KEY_horizlinescan5: u32 = 2545;
pub const IBUS_KEY_horizlinescan7: u32 = 2546;
pub const IBUS_KEY_horizlinescan9: u32 = 2547;
pub const IBUS_KEY_leftt: u32 = 2548;
pub const IBUS_KEY_rightt: u32 = 2549;
pub const IBUS_KEY_bott: u32 = 2550;
pub const IBUS_KEY_topt: u32 = 2551;
pub const IBUS_KEY_vertbar: u32 = 2552;
pub const IBUS_KEY_emspace: u32 = 2721;
pub const IBUS_KEY_enspace: u32 = 2722;
pub const IBUS_KEY_em3space: u32 = 2723;
pub const IBUS_KEY_em4space: u32 = 2724;
pub const IBUS_KEY_digitspace: u32 = 2725;
pub const IBUS_KEY_punctspace: u32 = 2726;
pub const IBUS_KEY_thinspace: u32 = 2727;
pub const IBUS_KEY_hairspace: u32 = 2728;
pub const IBUS_KEY_emdash: u32 = 2729;
pub const IBUS_KEY_endash: u32 = 2730;
pub const IBUS_KEY_signifblank: u32 = 2732;
pub const IBUS_KEY_ellipsis: u32 = 2734;
pub const IBUS_KEY_doubbaselinedot: u32 = 2735;
pub const IBUS_KEY_onethird: u32 = 2736;
pub const IBUS_KEY_twothirds: u32 = 2737;
pub const IBUS_KEY_onefifth: u32 = 2738;
pub const IBUS_KEY_twofifths: u32 = 2739;
pub const IBUS_KEY_threefifths: u32 = 2740;
pub const IBUS_KEY_fourfifths: u32 = 2741;
pub const IBUS_KEY_onesixth: u32 = 2742;
pub const IBUS_KEY_fivesixths: u32 = 2743;
pub const IBUS_KEY_careof: u32 = 2744;
pub const IBUS_KEY_figdash: u32 = 2747;
pub const IBUS_KEY_leftanglebracket: u32 = 2748;
pub const IBUS_KEY_decimalpoint: u32 = 2749;
pub const IBUS_KEY_rightanglebracket: u32 = 2750;
pub const IBUS_KEY_marker: u32 = 2751;
pub const IBUS_KEY_oneeighth: u32 = 2755;
pub const IBUS_KEY_threeeighths: u32 = 2756;
pub const IBUS_KEY_fiveeighths: u32 = 2757;
pub const IBUS_KEY_seveneighths: u32 = 2758;
pub const IBUS_KEY_trademark: u32 = 2761;
pub const IBUS_KEY_signaturemark: u32 = 2762;
pub const IBUS_KEY_trademarkincircle: u32 = 2763;
pub const IBUS_KEY_leftopentriangle: u32 = 2764;
pub const IBUS_KEY_rightopentriangle: u32 = 2765;
pub const IBUS_KEY_emopencircle: u32 = 2766;
pub const IBUS_KEY_emopenrectangle: u32 = 2767;
pub const IBUS_KEY_leftsinglequotemark: u32 = 2768;
pub const IBUS_KEY_rightsinglequotemark: u32 = 2769;
pub const IBUS_KEY_leftdoublequotemark: u32 = 2770;
pub const IBUS_KEY_rightdoublequotemark: u32 = 2771;
pub const IBUS_KEY_prescription: u32 = 2772;
pub const IBUS_KEY_permille: u32 = 2773;
pub const IBUS_KEY_minutes: u32 = 2774;
pub const IBUS_KEY_seconds: u32 = 2775;
pub const IBUS_KEY_latincross: u32 = 2777;
pub const IBUS_KEY_hexagram: u32 = 2778;
pub const IBUS_KEY_filledrectbullet: u32 = 2779;
pub const IBUS_KEY_filledlefttribullet: u32 = 2780;
pub const IBUS_KEY_filledrighttribullet: u32 = 2781;
pub const IBUS_KEY_emfilledcircle: u32 = 2782;
pub const IBUS_KEY_emfilledrect: u32 = 2783;
pub const IBUS_KEY_enopencircbullet: u32 = 2784;
pub const IBUS_KEY_enopensquarebullet: u32 = 2785;
pub const IBUS_KEY_openrectbullet: u32 = 2786;
pub const IBUS_KEY_opentribulletup: u32 = 2787;
pub const IBUS_KEY_opentribulletdown: u32 = 2788;
pub const IBUS_KEY_openstar: u32 = 2789;
pub const IBUS_KEY_enfilledcircbullet: u32 = 2790;
pub const IBUS_KEY_enfilledsqbullet: u32 = 2791;
pub const IBUS_KEY_filledtribulletup: u32 = 2792;
pub const IBUS_KEY_filledtribulletdown: u32 = 2793;
pub const IBUS_KEY_leftpointer: u32 = 2794;
pub const IBUS_KEY_rightpointer: u32 = 2795;
pub const IBUS_KEY_club: u32 = 2796;
pub const IBUS_KEY_diamond: u32 = 2797;
pub const IBUS_KEY_heart: u32 = 2798;
pub const IBUS_KEY_maltesecross: u32 = 2800;
pub const IBUS_KEY_dagger: u32 = 2801;
pub const IBUS_KEY_doubledagger: u32 = 2802;
pub const IBUS_KEY_checkmark: u32 = 2803;
pub const IBUS_KEY_ballotcross: u32 = 2804;
pub const IBUS_KEY_musicalsharp: u32 = 2805;
pub const IBUS_KEY_musicalflat: u32 = 2806;
pub const IBUS_KEY_malesymbol: u32 = 2807;
pub const IBUS_KEY_femalesymbol: u32 = 2808;
pub const IBUS_KEY_telephone: u32 = 2809;
pub const IBUS_KEY_telephonerecorder: u32 = 2810;
pub const IBUS_KEY_phonographcopyright: u32 = 2811;
pub const IBUS_KEY_caret: u32 = 2812;
pub const IBUS_KEY_singlelowquotemark: u32 = 2813;
pub const IBUS_KEY_doublelowquotemark: u32 = 2814;
pub const IBUS_KEY_cursor: u32 = 2815;
pub const IBUS_KEY_leftcaret: u32 = 2979;
pub const IBUS_KEY_rightcaret: u32 = 2982;
pub const IBUS_KEY_downcaret: u32 = 2984;
pub const IBUS_KEY_upcaret: u32 = 2985;
pub const IBUS_KEY_overbar: u32 = 3008;
pub const IBUS_KEY_downtack: u32 = 3010;
pub const IBUS_KEY_upshoe: u32 = 3011;
pub const IBUS_KEY_downstile: u32 = 3012;
pub const IBUS_KEY_underbar: u32 = 3014;
pub const IBUS_KEY_jot: u32 = 3018;
pub const IBUS_KEY_quad: u32 = 3020;
pub const IBUS_KEY_uptack: u32 = 3022;
pub const IBUS_KEY_circle: u32 = 3023;
pub const IBUS_KEY_upstile: u32 = 3027;
pub const IBUS_KEY_downshoe: u32 = 3030;
pub const IBUS_KEY_rightshoe: u32 = 3032;
pub const IBUS_KEY_leftshoe: u32 = 3034;
pub const IBUS_KEY_lefttack: u32 = 3036;
pub const IBUS_KEY_righttack: u32 = 3068;
pub const IBUS_KEY_hebrew_doublelowline: u32 = 3295;
pub const IBUS_KEY_hebrew_aleph: u32 = 3296;
pub const IBUS_KEY_hebrew_bet: u32 = 3297;
pub const IBUS_KEY_hebrew_beth: u32 = 3297;
pub const IBUS_KEY_hebrew_gimel: u32 = 3298;
pub const IBUS_KEY_hebrew_gimmel: u32 = 3298;
pub const IBUS_KEY_hebrew_dalet: u32 = 3299;
pub const IBUS_KEY_hebrew_daleth: u32 = 3299;
pub const IBUS_KEY_hebrew_he: u32 = 3300;
pub const IBUS_KEY_hebrew_waw: u32 = 3301;
pub const IBUS_KEY_hebrew_zain: u32 = 3302;
pub const IBUS_KEY_hebrew_zayin: u32 = 3302;
pub const IBUS_KEY_hebrew_chet: u32 = 3303;
pub const IBUS_KEY_hebrew_het: u32 = 3303;
pub const IBUS_KEY_hebrew_tet: u32 = 3304;
pub const IBUS_KEY_hebrew_teth: u32 = 3304;
pub const IBUS_KEY_hebrew_yod: u32 = 3305;
pub const IBUS_KEY_hebrew_finalkaph: u32 = 3306;
pub const IBUS_KEY_hebrew_kaph: u32 = 3307;
pub const IBUS_KEY_hebrew_lamed: u32 = 3308;
pub const IBUS_KEY_hebrew_finalmem: u32 = 3309;
pub const IBUS_KEY_hebrew_mem: u32 = 3310;
pub const IBUS_KEY_hebrew_finalnun: u32 = 3311;
pub const IBUS_KEY_hebrew_nun: u32 = 3312;
pub const IBUS_KEY_hebrew_samech: u32 = 3313;
pub const IBUS_KEY_hebrew_samekh: u32 = 3313;
pub const IBUS_KEY_hebrew_ayin: u32 = 3314;
pub const IBUS_KEY_hebrew_finalpe: u32 = 3315;
pub const IBUS_KEY_hebrew_pe: u32 = 3316;
pub const IBUS_KEY_hebrew_finalzade: u32 = 3317;
pub const IBUS_KEY_hebrew_finalzadi: u32 = 3317;
pub const IBUS_KEY_hebrew_zade: u32 = 3318;
pub const IBUS_KEY_hebrew_zadi: u32 = 3318;
pub const IBUS_KEY_hebrew_qoph: u32 = 3319;
pub const IBUS_KEY_hebrew_kuf: u32 = 3319;
pub const IBUS_KEY_hebrew_resh: u32 = 3320;
pub const IBUS_KEY_hebrew_shin: u32 = 3321;
pub const IBUS_KEY_hebrew_taw: u32 = 3322;
pub const IBUS_KEY_hebrew_taf: u32 = 3322;
pub const IBUS_KEY_Hebrew_switch: u32 = 65406;
pub const IBUS_KEY_Thai_kokai: u32 = 3489;
pub const IBUS_KEY_Thai_khokhai: u32 = 3490;
pub const IBUS_KEY_Thai_khokhuat: u32 = 3491;
pub const IBUS_KEY_Thai_khokhwai: u32 = 3492;
pub const IBUS_KEY_Thai_khokhon: u32 = 3493;
pub const IBUS_KEY_Thai_khorakhang: u32 = 3494;
pub const IBUS_KEY_Thai_ngongu: u32 = 3495;
pub const IBUS_KEY_Thai_chochan: u32 = 3496;
pub const IBUS_KEY_Thai_choching: u32 = 3497;
pub const IBUS_KEY_Thai_chochang: u32 = 3498;
pub const IBUS_KEY_Thai_soso: u32 = 3499;
pub const IBUS_KEY_Thai_chochoe: u32 = 3500;
pub const IBUS_KEY_Thai_yoying: u32 = 3501;
pub const IBUS_KEY_Thai_dochada: u32 = 3502;
pub const IBUS_KEY_Thai_topatak: u32 = 3503;
pub const IBUS_KEY_Thai_thothan: u32 = 3504;
pub const IBUS_KEY_Thai_thonangmontho: u32 = 3505;
pub const IBUS_KEY_Thai_thophuthao: u32 = 3506;
pub const IBUS_KEY_Thai_nonen: u32 = 3507;
pub const IBUS_KEY_Thai_dodek: u32 = 3508;
pub const IBUS_KEY_Thai_totao: u32 = 3509;
pub const IBUS_KEY_Thai_thothung: u32 = 3510;
pub const IBUS_KEY_Thai_thothahan: u32 = 3511;
pub const IBUS_KEY_Thai_thothong: u32 = 3512;
pub const IBUS_KEY_Thai_nonu: u32 = 3513;
pub const IBUS_KEY_Thai_bobaimai: u32 = 3514;
pub const IBUS_KEY_Thai_popla: u32 = 3515;
pub const IBUS_KEY_Thai_phophung: u32 = 3516;
pub const IBUS_KEY_Thai_fofa: u32 = 3517;
pub const IBUS_KEY_Thai_phophan: u32 = 3518;
pub const IBUS_KEY_Thai_fofan: u32 = 3519;
pub const IBUS_KEY_Thai_phosamphao: u32 = 3520;
pub const IBUS_KEY_Thai_moma: u32 = 3521;
pub const IBUS_KEY_Thai_yoyak: u32 = 3522;
pub const IBUS_KEY_Thai_rorua: u32 = 3523;
pub const IBUS_KEY_Thai_ru: u32 = 3524;
pub const IBUS_KEY_Thai_loling: u32 = 3525;
pub const IBUS_KEY_Thai_lu: u32 = 3526;
pub const IBUS_KEY_Thai_wowaen: u32 = 3527;
pub const IBUS_KEY_Thai_sosala: u32 = 3528;
pub const IBUS_KEY_Thai_sorusi: u32 = 3529;
pub const IBUS_KEY_Thai_sosua: u32 = 3530;
pub const IBUS_KEY_Thai_hohip: u32 = 3531;
pub const IBUS_KEY_Thai_lochula: u32 = 3532;
pub const IBUS_KEY_Thai_oang: u32 = 3533;
pub const IBUS_KEY_Thai_honokhuk: u32 = 3534;
pub const IBUS_KEY_Thai_paiyannoi: u32 = 3535;
pub const IBUS_KEY_Thai_saraa: u32 = 3536;
pub const IBUS_KEY_Thai_maihanakat: u32 = 3537;
pub const IBUS_KEY_Thai_saraaa: u32 = 3538;
pub const IBUS_KEY_Thai_saraam: u32 = 3539;
pub const IBUS_KEY_Thai_sarai: u32 = 3540;
pub const IBUS_KEY_Thai_saraii: u32 = 3541;
pub const IBUS_KEY_Thai_saraue: u32 = 3542;
pub const IBUS_KEY_Thai_sarauee: u32 = 3543;
pub const IBUS_KEY_Thai_sarau: u32 = 3544;
pub const IBUS_KEY_Thai_sarauu: u32 = 3545;
pub const IBUS_KEY_Thai_phinthu: u32 = 3546;
pub const IBUS_KEY_Thai_maihanakat_maitho: u32 = 3550;
pub const IBUS_KEY_Thai_baht: u32 = 3551;
pub const IBUS_KEY_Thai_sarae: u32 = 3552;
pub const IBUS_KEY_Thai_saraae: u32 = 3553;
pub const IBUS_KEY_Thai_sarao: u32 = 3554;
pub const IBUS_KEY_Thai_saraaimaimuan: u32 = 3555;
pub const IBUS_KEY_Thai_saraaimaimalai: u32 = 3556;
pub const IBUS_KEY_Thai_lakkhangyao: u32 = 3557;
pub const IBUS_KEY_Thai_maiyamok: u32 = 3558;
pub const IBUS_KEY_Thai_maitaikhu: u32 = 3559;
pub const IBUS_KEY_Thai_maiek: u32 = 3560;
pub const IBUS_KEY_Thai_maitho: u32 = 3561;
pub const IBUS_KEY_Thai_maitri: u32 = 3562;
pub const IBUS_KEY_Thai_maichattawa: u32 = 3563;
pub const IBUS_KEY_Thai_thanthakhat: u32 = 3564;
pub const IBUS_KEY_Thai_nikhahit: u32 = 3565;
pub const IBUS_KEY_Thai_leksun: u32 = 3568;
pub const IBUS_KEY_Thai_leknung: u32 = 3569;
pub const IBUS_KEY_Thai_leksong: u32 = 3570;
pub const IBUS_KEY_Thai_leksam: u32 = 3571;
pub const IBUS_KEY_Thai_leksi: u32 = 3572;
pub const IBUS_KEY_Thai_lekha: u32 = 3573;
pub const IBUS_KEY_Thai_lekhok: u32 = 3574;
pub const IBUS_KEY_Thai_lekchet: u32 = 3575;
pub const IBUS_KEY_Thai_lekpaet: u32 = 3576;
pub const IBUS_KEY_Thai_lekkao: u32 = 3577;
pub const IBUS_KEY_Hangul: u32 = 65329;
pub const IBUS_KEY_Hangul_Start: u32 = 65330;
pub const IBUS_KEY_Hangul_End: u32 = 65331;
pub const IBUS_KEY_Hangul_Hanja: u32 = 65332;
pub const IBUS_KEY_Hangul_Jamo: u32 = 65333;
pub const IBUS_KEY_Hangul_Romaja: u32 = 65334;
pub const IBUS_KEY_Hangul_Codeinput: u32 = 65335;
pub const IBUS_KEY_Hangul_Jeonja: u32 = 65336;
pub const IBUS_KEY_Hangul_Banja: u32 = 65337;
pub const IBUS_KEY_Hangul_PreHanja: u32 = 65338;
pub const IBUS_KEY_Hangul_PostHanja: u32 = 65339;
pub const IBUS_KEY_Hangul_SingleCandidate: u32 = 65340;
pub const IBUS_KEY_Hangul_MultipleCandidate: u32 = 65341;
pub const IBUS_KEY_Hangul_PreviousCandidate: u32 = 65342;
pub const IBUS_KEY_Hangul_Special: u32 = 65343;
pub const IBUS_KEY_Hangul_switch: u32 = 65406;
pub const IBUS_KEY_Hangul_Kiyeog: u32 = 3745;
pub const IBUS_KEY_Hangul_SsangKiyeog: u32 = 3746;
pub const IBUS_KEY_Hangul_KiyeogSios: u32 = 3747;
pub const IBUS_KEY_Hangul_Nieun: u32 = 3748;
pub const IBUS_KEY_Hangul_NieunJieuj: u32 = 3749;
pub const IBUS_KEY_Hangul_NieunHieuh: u32 = 3750;
pub const IBUS_KEY_Hangul_Dikeud: u32 = 3751;
pub const IBUS_KEY_Hangul_SsangDikeud: u32 = 3752;
pub const IBUS_KEY_Hangul_Rieul: u32 = 3753;
pub const IBUS_KEY_Hangul_RieulKiyeog: u32 = 3754;
pub const IBUS_KEY_Hangul_RieulMieum: u32 = 3755;
pub const IBUS_KEY_Hangul_RieulPieub: u32 = 3756;
pub const IBUS_KEY_Hangul_RieulSios: u32 = 3757;
pub const IBUS_KEY_Hangul_RieulTieut: u32 = 3758;
pub const IBUS_KEY_Hangul_RieulPhieuf: u32 = 3759;
pub const IBUS_KEY_Hangul_RieulHieuh: u32 = 3760;
pub const IBUS_KEY_Hangul_Mieum: u32 = 3761;
pub const IBUS_KEY_Hangul_Pieub: u32 = 3762;
pub const IBUS_KEY_Hangul_SsangPieub: u32 = 3763;
pub const IBUS_KEY_Hangul_PieubSios: u32 = 3764;
pub const IBUS_KEY_Hangul_Sios: u32 = 3765;
pub const IBUS_KEY_Hangul_SsangSios: u32 = 3766;
pub const IBUS_KEY_Hangul_Ieung: u32 = 3767;
pub const IBUS_KEY_Hangul_Jieuj: u32 = 3768;
pub const IBUS_KEY_Hangul_SsangJieuj: u32 = 3769;
pub const IBUS_KEY_Hangul_Cieuc: u32 = 3770;
pub const IBUS_KEY_Hangul_Khieuq: u32 = 3771;
pub const IBUS_KEY_Hangul_Tieut: u32 = 3772;
pub const IBUS_KEY_Hangul_Phieuf: u32 = 3773;
pub const IBUS_KEY_Hangul_Hieuh: u32 = 3774;
pub const IBUS_KEY_Hangul_A: u32 = 3775;
pub const IBUS_KEY_Hangul_AE: u32 = 3776;
pub const IBUS_KEY_Hangul_YA: u32 = 3777;
pub const IBUS_KEY_Hangul_YAE: u32 = 3778;
pub const IBUS_KEY_Hangul_EO: u32 = 3779;
pub const IBUS_KEY_Hangul_E: u32 = 3780;
pub const IBUS_KEY_Hangul_YEO: u32 = 3781;
pub const IBUS_KEY_Hangul_YE: u32 = 3782;
pub const IBUS_KEY_Hangul_O: u32 = 3783;
pub const IBUS_KEY_Hangul_WA: u32 = 3784;
pub const IBUS_KEY_Hangul_WAE: u32 = 3785;
pub const IBUS_KEY_Hangul_OE: u32 = 3786;
pub const IBUS_KEY_Hangul_YO: u32 = 3787;
pub const IBUS_KEY_Hangul_U: u32 = 3788;
pub const IBUS_KEY_Hangul_WEO: u32 = 3789;
pub const IBUS_KEY_Hangul_WE: u32 = 3790;
pub const IBUS_KEY_Hangul_WI: u32 = 3791;
pub const IBUS_KEY_Hangul_YU: u32 = 3792;
pub const IBUS_KEY_Hangul_EU: u32 = 3793;
pub const IBUS_KEY_Hangul_YI: u32 = 3794;
pub const IBUS_KEY_Hangul_I: u32 = 3795;
pub const IBUS_KEY_Hangul_J_Kiyeog: u32 = 3796;
pub const IBUS_KEY_Hangul_J_SsangKiyeog: u32 = 3797;
pub const IBUS_KEY_Hangul_J_KiyeogSios: u32 = 3798;
pub const IBUS_KEY_Hangul_J_Nieun: u32 = 3799;
pub const IBUS_KEY_Hangul_J_NieunJieuj: u32 = 3800;
pub const IBUS_KEY_Hangul_J_NieunHieuh: u32 = 3801;
pub const IBUS_KEY_Hangul_J_Dikeud: u32 = 3802;
pub const IBUS_KEY_Hangul_J_Rieul: u32 = 3803;
pub const IBUS_KEY_Hangul_J_RieulKiyeog: u32 = 3804;
pub const IBUS_KEY_Hangul_J_RieulMieum: u32 = 3805;
pub const IBUS_KEY_Hangul_J_RieulPieub: u32 = 3806;
pub const IBUS_KEY_Hangul_J_RieulSios: u32 = 3807;
pub const IBUS_KEY_Hangul_J_RieulTieut: u32 = 3808;
pub const IBUS_KEY_Hangul_J_RieulPhieuf: u32 = 3809;
pub const IBUS_KEY_Hangul_J_RieulHieuh: u32 = 3810;
pub const IBUS_KEY_Hangul_J_Mieum: u32 = 3811;
pub const IBUS_KEY_Hangul_J_Pieub: u32 = 3812;
pub const IBUS_KEY_Hangul_J_PieubSios: u32 = 3813;
pub const IBUS_KEY_Hangul_J_Sios: u32 = 3814;
pub const IBUS_KEY_Hangul_J_SsangSios: u32 = 3815;
pub const IBUS_KEY_Hangul_J_Ieung: u32 = 3816;
pub const IBUS_KEY_Hangul_J_Jieuj: u32 = 3817;
pub const IBUS_KEY_Hangul_J_Cieuc: u32 = 3818;
pub const IBUS_KEY_Hangul_J_Khieuq: u32 = 3819;
pub const IBUS_KEY_Hangul_J_Tieut: u32 = 3820;
pub const IBUS_KEY_Hangul_J_Phieuf: u32 = 3821;
pub const IBUS_KEY_Hangul_J_Hieuh: u32 = 3822;
pub const IBUS_KEY_Hangul_RieulYeorinHieuh: u32 = 3823;
pub const IBUS_KEY_Hangul_SunkyeongeumMieum: u32 = 3824;
pub const IBUS_KEY_Hangul_SunkyeongeumPieub: u32 = 3825;
pub const IBUS_KEY_Hangul_PanSios: u32 = 3826;
pub const IBUS_KEY_Hangul_KkogjiDalrinIeung: u32 = 3827;
pub const IBUS_KEY_Hangul_SunkyeongeumPhieuf: u32 = 3828;
pub const IBUS_KEY_Hangul_YeorinHieuh: u32 = 3829;
pub const IBUS_KEY_Hangul_AraeA: u32 = 3830;
pub const IBUS_KEY_Hangul_AraeAE: u32 = 3831;
pub const IBUS_KEY_Hangul_J_PanSios: u32 = 3832;
pub const IBUS_KEY_Hangul_J_KkogjiDalrinIeung: u32 = 3833;
pub const IBUS_KEY_Hangul_J_YeorinHieuh: u32 = 3834;
pub const IBUS_KEY_Korean_Won: u32 = 3839;
pub const IBUS_KEY_Armenian_ligature_ew: u32 = 16778631;
pub const IBUS_KEY_Armenian_full_stop: u32 = 16778633;
pub const IBUS_KEY_Armenian_verjaket: u32 = 16778633;
pub const IBUS_KEY_Armenian_separation_mark: u32 = 16778589;
pub const IBUS_KEY_Armenian_but: u32 = 16778589;
pub const IBUS_KEY_Armenian_hyphen: u32 = 16778634;
pub const IBUS_KEY_Armenian_yentamna: u32 = 16778634;
pub const IBUS_KEY_Armenian_exclam: u32 = 16778588;
pub const IBUS_KEY_Armenian_amanak: u32 = 16778588;
pub const IBUS_KEY_Armenian_accent: u32 = 16778587;
pub const IBUS_KEY_Armenian_shesht: u32 = 16778587;
pub const IBUS_KEY_Armenian_question: u32 = 16778590;
pub const IBUS_KEY_Armenian_paruyk: u32 = 16778590;
pub const IBUS_KEY_Armenian_AYB: u32 = 16778545;
pub const IBUS_KEY_Armenian_ayb: u32 = 16778593;
pub const IBUS_KEY_Armenian_BEN: u32 = 16778546;
pub const IBUS_KEY_Armenian_ben: u32 = 16778594;
pub const IBUS_KEY_Armenian_GIM: u32 = 16778547;
pub const IBUS_KEY_Armenian_gim: u32 = 16778595;
pub const IBUS_KEY_Armenian_DA: u32 = 16778548;
pub const IBUS_KEY_Armenian_da: u32 = 16778596;
pub const IBUS_KEY_Armenian_YECH: u32 = 16778549;
pub const IBUS_KEY_Armenian_yech: u32 = 16778597;
pub const IBUS_KEY_Armenian_ZA: u32 = 16778550;
pub const IBUS_KEY_Armenian_za: u32 = 16778598;
pub const IBUS_KEY_Armenian_E: u32 = 16778551;
pub const IBUS_KEY_Armenian_e: u32 = 16778599;
pub const IBUS_KEY_Armenian_AT: u32 = 16778552;
pub const IBUS_KEY_Armenian_at: u32 = 16778600;
pub const IBUS_KEY_Armenian_TO: u32 = 16778553;
pub const IBUS_KEY_Armenian_to: u32 = 16778601;
pub const IBUS_KEY_Armenian_ZHE: u32 = 16778554;
pub const IBUS_KEY_Armenian_zhe: u32 = 16778602;
pub const IBUS_KEY_Armenian_INI: u32 = 16778555;
pub const IBUS_KEY_Armenian_ini: u32 = 16778603;
pub const IBUS_KEY_Armenian_LYUN: u32 = 16778556;
pub const IBUS_KEY_Armenian_lyun: u32 = 16778604;
pub const IBUS_KEY_Armenian_KHE: u32 = 16778557;
pub const IBUS_KEY_Armenian_khe: u32 = 16778605;
pub const IBUS_KEY_Armenian_TSA: u32 = 16778558;
pub const IBUS_KEY_Armenian_tsa: u32 = 16778606;
pub const IBUS_KEY_Armenian_KEN: u32 = 16778559;
pub const IBUS_KEY_Armenian_ken: u32 = 16778607;
pub const IBUS_KEY_Armenian_HO: u32 = 16778560;
pub const IBUS_KEY_Armenian_ho: u32 = 16778608;
pub const IBUS_KEY_Armenian_DZA: u32 = 16778561;
pub const IBUS_KEY_Armenian_dza: u32 = 16778609;
pub const IBUS_KEY_Armenian_GHAT: u32 = 16778562;
pub const IBUS_KEY_Armenian_ghat: u32 = 16778610;
pub const IBUS_KEY_Armenian_TCHE: u32 = 16778563;
pub const IBUS_KEY_Armenian_tche: u32 = 16778611;
pub const IBUS_KEY_Armenian_MEN: u32 = 16778564;
pub const IBUS_KEY_Armenian_men: u32 = 16778612;
pub const IBUS_KEY_Armenian_HI: u32 = 16778565;
pub const IBUS_KEY_Armenian_hi: u32 = 16778613;
pub const IBUS_KEY_Armenian_NU: u32 = 16778566;
pub const IBUS_KEY_Armenian_nu: u32 = 16778614;
pub const IBUS_KEY_Armenian_SHA: u32 = 16778567;
pub const IBUS_KEY_Armenian_sha: u32 = 16778615;
pub const IBUS_KEY_Armenian_VO: u32 = 16778568;
pub const IBUS_KEY_Armenian_vo: u32 = 16778616;
pub const IBUS_KEY_Armenian_CHA: u32 = 16778569;
pub const IBUS_KEY_Armenian_cha: u32 = 16778617;
pub const IBUS_KEY_Armenian_PE: u32 = 16778570;
pub const IBUS_KEY_Armenian_pe: u32 = 16778618;
pub const IBUS_KEY_Armenian_JE: u32 = 16778571;
pub const IBUS_KEY_Armenian_je: u32 = 16778619;
pub const IBUS_KEY_Armenian_RA: u32 = 16778572;
pub const IBUS_KEY_Armenian_ra: u32 = 16778620;
pub const IBUS_KEY_Armenian_SE: u32 = 16778573;
pub const IBUS_KEY_Armenian_se: u32 = 16778621;
pub const IBUS_KEY_Armenian_VEV: u32 = 16778574;
pub const IBUS_KEY_Armenian_vev: u32 = 16778622;
pub const IBUS_KEY_Armenian_TYUN: u32 = 16778575;
pub const IBUS_KEY_Armenian_tyun: u32 = 16778623;
pub const IBUS_KEY_Armenian_RE: u32 = 16778576;
pub const IBUS_KEY_Armenian_re: u32 = 16778624;
pub const IBUS_KEY_Armenian_TSO: u32 = 16778577;
pub const IBUS_KEY_Armenian_tso: u32 = 16778625;
pub const IBUS_KEY_Armenian_VYUN: u32 = 16778578;
pub const IBUS_KEY_Armenian_vyun: u32 = 16778626;
pub const IBUS_KEY_Armenian_PYUR: u32 = 16778579;
pub const IBUS_KEY_Armenian_pyur: u32 = 16778627;
pub const IBUS_KEY_Armenian_KE: u32 = 16778580;
pub const IBUS_KEY_Armenian_ke: u32 = 16778628;
pub const IBUS_KEY_Armenian_O: u32 = 16778581;
pub const IBUS_KEY_Armenian_o: u32 = 16778629;
pub const IBUS_KEY_Armenian_FE: u32 = 16778582;
pub const IBUS_KEY_Armenian_fe: u32 = 16778630;
pub const IBUS_KEY_Armenian_apostrophe: u32 = 16778586;
pub const IBUS_KEY_Georgian_an: u32 = 16781520;
pub const IBUS_KEY_Georgian_ban: u32 = 16781521;
pub const IBUS_KEY_Georgian_gan: u32 = 16781522;
pub const IBUS_KEY_Georgian_don: u32 = 16781523;
pub const IBUS_KEY_Georgian_en: u32 = 16781524;
pub const IBUS_KEY_Georgian_vin: u32 = 16781525;
pub const IBUS_KEY_Georgian_zen: u32 = 16781526;
pub const IBUS_KEY_Georgian_tan: u32 = 16781527;
pub const IBUS_KEY_Georgian_in: u32 = 16781528;
pub const IBUS_KEY_Georgian_kan: u32 = 16781529;
pub const IBUS_KEY_Georgian_las: u32 = 16781530;
pub const IBUS_KEY_Georgian_man: u32 = 16781531;
pub const IBUS_KEY_Georgian_nar: u32 = 16781532;
pub const IBUS_KEY_Georgian_on: u32 = 16781533;
pub const IBUS_KEY_Georgian_par: u32 = 16781534;
pub const IBUS_KEY_Georgian_zhar: u32 = 16781535;
pub const IBUS_KEY_Georgian_rae: u32 = 16781536;
pub const IBUS_KEY_Georgian_san: u32 = 16781537;
pub const IBUS_KEY_Georgian_tar: u32 = 16781538;
pub const IBUS_KEY_Georgian_un: u32 = 16781539;
pub const IBUS_KEY_Georgian_phar: u32 = 16781540;
pub const IBUS_KEY_Georgian_khar: u32 = 16781541;
pub const IBUS_KEY_Georgian_ghan: u32 = 16781542;
pub const IBUS_KEY_Georgian_qar: u32 = 16781543;
pub const IBUS_KEY_Georgian_shin: u32 = 16781544;
pub const IBUS_KEY_Georgian_chin: u32 = 16781545;
pub const IBUS_KEY_Georgian_can: u32 = 16781546;
pub const IBUS_KEY_Georgian_jil: u32 = 16781547;
pub const IBUS_KEY_Georgian_cil: u32 = 16781548;
pub const IBUS_KEY_Georgian_char: u32 = 16781549;
pub const IBUS_KEY_Georgian_xan: u32 = 16781550;
pub const IBUS_KEY_Georgian_jhan: u32 = 16781551;
pub const IBUS_KEY_Georgian_hae: u32 = 16781552;
pub const IBUS_KEY_Georgian_he: u32 = 16781553;
pub const IBUS_KEY_Georgian_hie: u32 = 16781554;
pub const IBUS_KEY_Georgian_we: u32 = 16781555;
pub const IBUS_KEY_Georgian_har: u32 = 16781556;
pub const IBUS_KEY_Georgian_hoe: u32 = 16781557;
pub const IBUS_KEY_Georgian_fi: u32 = 16781558;
pub const IBUS_KEY_Xabovedot: u32 = 16785034;
pub const IBUS_KEY_Ibreve: u32 = 16777516;
pub const IBUS_KEY_Zstroke: u32 = 16777653;
pub const IBUS_KEY_Gcaron: u32 = 16777702;
pub const IBUS_KEY_Ocaron: u32 = 16777681;
pub const IBUS_KEY_Obarred: u32 = 16777631;
pub const IBUS_KEY_xabovedot: u32 = 16785035;
pub const IBUS_KEY_ibreve: u32 = 16777517;
pub const IBUS_KEY_zstroke: u32 = 16777654;
pub const IBUS_KEY_gcaron: u32 = 16777703;
pub const IBUS_KEY_ocaron: u32 = 16777682;
pub const IBUS_KEY_obarred: u32 = 16777845;
pub const IBUS_KEY_SCHWA: u32 = 16777615;
pub const IBUS_KEY_schwa: u32 = 16777817;
pub const IBUS_KEY_EZH: u32 = 16777655;
pub const IBUS_KEY_ezh: u32 = 16777874;
pub const IBUS_KEY_Lbelowdot: u32 = 16784950;
pub const IBUS_KEY_lbelowdot: u32 = 16784951;
pub const IBUS_KEY_Abelowdot: u32 = 16785056;
pub const IBUS_KEY_abelowdot: u32 = 16785057;
pub const IBUS_KEY_Ahook: u32 = 16785058;
pub const IBUS_KEY_ahook: u32 = 16785059;
pub const IBUS_KEY_Acircumflexacute: u32 = 16785060;
pub const IBUS_KEY_acircumflexacute: u32 = 16785061;
pub const IBUS_KEY_Acircumflexgrave: u32 = 16785062;
pub const IBUS_KEY_acircumflexgrave: u32 = 16785063;
pub const IBUS_KEY_Acircumflexhook: u32 = 16785064;
pub const IBUS_KEY_acircumflexhook: u32 = 16785065;
pub const IBUS_KEY_Acircumflextilde: u32 = 16785066;
pub const IBUS_KEY_acircumflextilde: u32 = 16785067;
pub const IBUS_KEY_Acircumflexbelowdot: u32 = 16785068;
pub const IBUS_KEY_acircumflexbelowdot: u32 = 16785069;
pub const IBUS_KEY_Abreveacute: u32 = 16785070;
pub const IBUS_KEY_abreveacute: u32 = 16785071;
pub const IBUS_KEY_Abrevegrave: u32 = 16785072;
pub const IBUS_KEY_abrevegrave: u32 = 16785073;
pub const IBUS_KEY_Abrevehook: u32 = 16785074;
pub const IBUS_KEY_abrevehook: u32 = 16785075;
pub const IBUS_KEY_Abrevetilde: u32 = 16785076;
pub const IBUS_KEY_abrevetilde: u32 = 16785077;
pub const IBUS_KEY_Abrevebelowdot: u32 = 16785078;
pub const IBUS_KEY_abrevebelowdot: u32 = 16785079;
pub const IBUS_KEY_Ebelowdot: u32 = 16785080;
pub const IBUS_KEY_ebelowdot: u32 = 16785081;
pub const IBUS_KEY_Ehook: u32 = 16785082;
pub const IBUS_KEY_ehook: u32 = 16785083;
pub const IBUS_KEY_Etilde: u32 = 16785084;
pub const IBUS_KEY_etilde: u32 = 16785085;
pub const IBUS_KEY_Ecircumflexacute: u32 = 16785086;
pub const IBUS_KEY_ecircumflexacute: u32 = 16785087;
pub const IBUS_KEY_Ecircumflexgrave: u32 = 16785088;
pub const IBUS_KEY_ecircumflexgrave: u32 = 16785089;
pub const IBUS_KEY_Ecircumflexhook: u32 = 16785090;
pub const IBUS_KEY_ecircumflexhook: u32 = 16785091;
pub const IBUS_KEY_Ecircumflextilde: u32 = 16785092;
pub const IBUS_KEY_ecircumflextilde: u32 = 16785093;
pub const IBUS_KEY_Ecircumflexbelowdot: u32 = 16785094;
pub const IBUS_KEY_ecircumflexbelowdot: u32 = 16785095;
pub const IBUS_KEY_Ihook: u32 = 16785096;
pub const IBUS_KEY_ihook: u32 = 16785097;
pub const IBUS_KEY_Ibelowdot: u32 = 16785098;
pub const IBUS_KEY_ibelowdot: u32 = 16785099;
pub const IBUS_KEY_Obelowdot: u32 = 16785100;
pub const IBUS_KEY_obelowdot: u32 = 16785101;
pub const IBUS_KEY_Ohook: u32 = 16785102;
pub const IBUS_KEY_ohook: u32 = 16785103;
pub const IBUS_KEY_Ocircumflexacute: u32 = 16785104;
pub const IBUS_KEY_ocircumflexacute: u32 = 16785105;
pub const IBUS_KEY_Ocircumflexgrave: u32 = 16785106;
pub const IBUS_KEY_ocircumflexgrave: u32 = 16785107;
pub const IBUS_KEY_Ocircumflexhook: u32 = 16785108;
pub const IBUS_KEY_ocircumflexhook: u32 = 16785109;
pub const IBUS_KEY_Ocircumflextilde: u32 = 16785110;
pub const IBUS_KEY_ocircumflextilde: u32 = 16785111;
pub const IBUS_KEY_Ocircumflexbelowdot: u32 = 16785112;
pub const IBUS_KEY_ocircumflexbelowdot: u32 = 16785113;
pub const IBUS_KEY_Ohornacute: u32 = 16785114;
pub const IBUS_KEY_ohornacute: u32 = 16785115;
pub const IBUS_KEY_Ohorngrave: u32 = 16785116;
pub const IBUS_KEY_ohorngrave: u32 = 16785117;
pub const IBUS_KEY_Ohornhook: u32 = 16785118;
pub const IBUS_KEY_ohornhook: u32 = 16785119;
pub const IBUS_KEY_Ohorntilde: u32 = 16785120;
pub const IBUS_KEY_ohorntilde: u32 = 16785121;
pub const IBUS_KEY_Ohornbelowdot: u32 = 16785122;
pub const IBUS_KEY_ohornbelowdot: u32 = 16785123;
pub const IBUS_KEY_Ubelowdot: u32 = 16785124;
pub const IBUS_KEY_ubelowdot: u32 = 16785125;
pub const IBUS_KEY_Uhook: u32 = 16785126;
pub const IBUS_KEY_uhook: u32 = 16785127;
pub const IBUS_KEY_Uhornacute: u32 = 16785128;
pub const IBUS_KEY_uhornacute: u32 = 16785129;
pub const IBUS_KEY_Uhorngrave: u32 = 16785130;
pub const IBUS_KEY_uhorngrave: u32 = 16785131;
pub const IBUS_KEY_Uhornhook: u32 = 16785132;
pub const IBUS_KEY_uhornhook: u32 = 16785133;
pub const IBUS_KEY_Uhorntilde: u32 = 16785134;
pub const IBUS_KEY_uhorntilde: u32 = 16785135;
pub const IBUS_KEY_Uhornbelowdot: u32 = 16785136;
pub const IBUS_KEY_uhornbelowdot: u32 = 16785137;
pub const IBUS_KEY_Ybelowdot: u32 = 16785140;
pub const IBUS_KEY_ybelowdot: u32 = 16785141;
pub const IBUS_KEY_Yhook: u32 = 16785142;
pub const IBUS_KEY_yhook: u32 = 16785143;
pub const IBUS_KEY_Ytilde: u32 = 16785144;
pub const IBUS_KEY_ytilde: u32 = 16785145;
pub const IBUS_KEY_Ohorn: u32 = 16777632;
pub const IBUS_KEY_ohorn: u32 = 16777633;
pub const IBUS_KEY_Uhorn: u32 = 16777647;
pub const IBUS_KEY_uhorn: u32 = 16777648;
pub const IBUS_KEY_EcuSign: u32 = 16785568;
pub const IBUS_KEY_ColonSign: u32 = 16785569;
pub const IBUS_KEY_CruzeiroSign: u32 = 16785570;
pub const IBUS_KEY_FFrancSign: u32 = 16785571;
pub const IBUS_KEY_LiraSign: u32 = 16785572;
pub const IBUS_KEY_MillSign: u32 = 16785573;
pub const IBUS_KEY_NairaSign: u32 = 16785574;
pub const IBUS_KEY_PesetaSign: u32 = 16785575;
pub const IBUS_KEY_RupeeSign: u32 = 16785576;
pub const IBUS_KEY_WonSign: u32 = 16785577;
pub const IBUS_KEY_NewSheqelSign: u32 = 16785578;
pub const IBUS_KEY_DongSign: u32 = 16785579;
pub const IBUS_KEY_EuroSign: u32 = 8364;
pub const IBUS_KEY_zerosuperior: u32 = 16785520;
pub const IBUS_KEY_foursuperior: u32 = 16785524;
pub const IBUS_KEY_fivesuperior: u32 = 16785525;
pub const IBUS_KEY_sixsuperior: u32 = 16785526;
pub const IBUS_KEY_sevensuperior: u32 = 16785527;
pub const IBUS_KEY_eightsuperior: u32 = 16785528;
pub const IBUS_KEY_ninesuperior: u32 = 16785529;
pub const IBUS_KEY_zerosubscript: u32 = 16785536;
pub const IBUS_KEY_onesubscript: u32 = 16785537;
pub const IBUS_KEY_twosubscript: u32 = 16785538;
pub const IBUS_KEY_threesubscript: u32 = 16785539;
pub const IBUS_KEY_foursubscript: u32 = 16785540;
pub const IBUS_KEY_fivesubscript: u32 = 16785541;
pub const IBUS_KEY_sixsubscript: u32 = 16785542;
pub const IBUS_KEY_sevensubscript: u32 = 16785543;
pub const IBUS_KEY_eightsubscript: u32 = 16785544;
pub const IBUS_KEY_ninesubscript: u32 = 16785545;
pub const IBUS_KEY_partdifferential: u32 = 16785922;
pub const IBUS_KEY_emptyset: u32 = 16785925;
pub const IBUS_KEY_elementof: u32 = 16785928;
pub const IBUS_KEY_notelementof: u32 = 16785929;
pub const IBUS_KEY_containsas: u32 = 16785931;
pub const IBUS_KEY_squareroot: u32 = 16785946;
pub const IBUS_KEY_cuberoot: u32 = 16785947;
pub const IBUS_KEY_fourthroot: u32 = 16785948;
pub const IBUS_KEY_dintegral: u32 = 16785964;
pub const IBUS_KEY_tintegral: u32 = 16785965;
pub const IBUS_KEY_because: u32 = 16785973;
pub const IBUS_KEY_approxeq: u32 = 16785992;
pub const IBUS_KEY_notapproxeq: u32 = 16785991;
pub const IBUS_KEY_notidentical: u32 = 16786018;
pub const IBUS_KEY_stricteq: u32 = 16786019;
pub const IBUS_KEY_braille_dot_1: u32 = 65521;
pub const IBUS_KEY_braille_dot_2: u32 = 65522;
pub const IBUS_KEY_braille_dot_3: u32 = 65523;
pub const IBUS_KEY_braille_dot_4: u32 = 65524;
pub const IBUS_KEY_braille_dot_5: u32 = 65525;
pub const IBUS_KEY_braille_dot_6: u32 = 65526;
pub const IBUS_KEY_braille_dot_7: u32 = 65527;
pub const IBUS_KEY_braille_dot_8: u32 = 65528;
pub const IBUS_KEY_braille_dot_9: u32 = 65529;
pub const IBUS_KEY_braille_dot_10: u32 = 65530;
pub const IBUS_KEY_braille_blank: u32 = 16787456;
pub const IBUS_KEY_braille_dots_1: u32 = 16787457;
pub const IBUS_KEY_braille_dots_2: u32 = 16787458;
pub const IBUS_KEY_braille_dots_12: u32 = 16787459;
pub const IBUS_KEY_braille_dots_3: u32 = 16787460;
pub const IBUS_KEY_braille_dots_13: u32 = 16787461;
pub const IBUS_KEY_braille_dots_23: u32 = 16787462;
pub const IBUS_KEY_braille_dots_123: u32 = 16787463;
pub const IBUS_KEY_braille_dots_4: u32 = 16787464;
pub const IBUS_KEY_braille_dots_14: u32 = 16787465;
pub const IBUS_KEY_braille_dots_24: u32 = 16787466;
pub const IBUS_KEY_braille_dots_124: u32 = 16787467;
pub const IBUS_KEY_braille_dots_34: u32 = 16787468;
pub const IBUS_KEY_braille_dots_134: u32 = 16787469;
pub const IBUS_KEY_braille_dots_234: u32 = 16787470;
pub const IBUS_KEY_braille_dots_1234: u32 = 16787471;
pub const IBUS_KEY_braille_dots_5: u32 = 16787472;
pub const IBUS_KEY_braille_dots_15: u32 = 16787473;
pub const IBUS_KEY_braille_dots_25: u32 = 16787474;
pub const IBUS_KEY_braille_dots_125: u32 = 16787475;
pub const IBUS_KEY_braille_dots_35: u32 = 16787476;
pub const IBUS_KEY_braille_dots_135: u32 = 16787477;
pub const IBUS_KEY_braille_dots_235: u32 = 16787478;
pub const IBUS_KEY_braille_dots_1235: u32 = 16787479;
pub const IBUS_KEY_braille_dots_45: u32 = 16787480;
pub const IBUS_KEY_braille_dots_145: u32 = 16787481;
pub const IBUS_KEY_braille_dots_245: u32 = 16787482;
pub const IBUS_KEY_braille_dots_1245: u32 = 16787483;
pub const IBUS_KEY_braille_dots_345: u32 = 16787484;
pub const IBUS_KEY_braille_dots_1345: u32 = 16787485;
pub const IBUS_KEY_braille_dots_2345: u32 = 16787486;
pub const IBUS_KEY_braille_dots_12345: u32 = 16787487;
pub const IBUS_KEY_braille_dots_6: u32 = 16787488;
pub const IBUS_KEY_braille_dots_16: u32 = 16787489;
pub const IBUS_KEY_braille_dots_26: u32 = 16787490;
pub const IBUS_KEY_braille_dots_126: u32 = 16787491;
pub const IBUS_KEY_braille_dots_36: u32 = 16787492;
pub const IBUS_KEY_braille_dots_136: u32 = 16787493;
pub const IBUS_KEY_braille_dots_236: u32 = 16787494;
pub const IBUS_KEY_braille_dots_1236: u32 = 16787495;
pub const IBUS_KEY_braille_dots_46: u32 = 16787496;
pub const IBUS_KEY_braille_dots_146: u32 = 16787497;
pub const IBUS_KEY_braille_dots_246: u32 = 16787498;
pub const IBUS_KEY_braille_dots_1246: u32 = 16787499;
pub const IBUS_KEY_braille_dots_346: u32 = 16787500;
pub const IBUS_KEY_braille_dots_1346: u32 = 16787501;
pub const IBUS_KEY_braille_dots_2346: u32 = 16787502;
pub const IBUS_KEY_braille_dots_12346: u32 = 16787503;
pub const IBUS_KEY_braille_dots_56: u32 = 16787504;
pub const IBUS_KEY_braille_dots_156: u32 = 16787505;
pub const IBUS_KEY_braille_dots_256: u32 = 16787506;
pub const IBUS_KEY_braille_dots_1256: u32 = 16787507;
pub const IBUS_KEY_braille_dots_356: u32 = 16787508;
pub const IBUS_KEY_braille_dots_1356: u32 = 16787509;
pub const IBUS_KEY_braille_dots_2356: u32 = 16787510;
pub const IBUS_KEY_braille_dots_12356: u32 = 16787511;
pub const IBUS_KEY_braille_dots_456: u32 = 16787512;
pub const IBUS_KEY_braille_dots_1456: u32 = 16787513;
pub const IBUS_KEY_braille_dots_2456: u32 = 16787514;
pub const IBUS_KEY_braille_dots_12456: u32 = 16787515;
pub const IBUS_KEY_braille_dots_3456: u32 = 16787516;
pub const IBUS_KEY_braille_dots_13456: u32 = 16787517;
pub const IBUS_KEY_braille_dots_23456: u32 = 16787518;
pub const IBUS_KEY_braille_dots_123456: u32 = 16787519;
pub const IBUS_KEY_braille_dots_7: u32 = 16787520;
pub const IBUS_KEY_braille_dots_17: u32 = 16787521;
pub const IBUS_KEY_braille_dots_27: u32 = 16787522;
pub const IBUS_KEY_braille_dots_127: u32 = 16787523;
pub const IBUS_KEY_braille_dots_37: u32 = 16787524;
pub const IBUS_KEY_braille_dots_137: u32 = 16787525;
pub const IBUS_KEY_braille_dots_237: u32 = 16787526;
pub const IBUS_KEY_braille_dots_1237: u32 = 16787527;
pub const IBUS_KEY_braille_dots_47: u32 = 16787528;
pub const IBUS_KEY_braille_dots_147: u32 = 16787529;
pub const IBUS_KEY_braille_dots_247: u32 = 16787530;
pub const IBUS_KEY_braille_dots_1247: u32 = 16787531;
pub const IBUS_KEY_braille_dots_347: u32 = 16787532;
pub const IBUS_KEY_braille_dots_1347: u32 = 16787533;
pub const IBUS_KEY_braille_dots_2347: u32 = 16787534;
pub const IBUS_KEY_braille_dots_12347: u32 = 16787535;
pub const IBUS_KEY_braille_dots_57: u32 = 16787536;
pub const IBUS_KEY_braille_dots_157: u32 = 16787537;
pub const IBUS_KEY_braille_dots_257: u32 = 16787538;
pub const IBUS_KEY_braille_dots_1257: u32 = 16787539;
pub const IBUS_KEY_braille_dots_357: u32 = 16787540;
pub const IBUS_KEY_braille_dots_1357: u32 = 16787541;
pub const IBUS_KEY_braille_dots_2357: u32 = 16787542;
pub const IBUS_KEY_braille_dots_12357: u32 = 16787543;
pub const IBUS_KEY_braille_dots_457: u32 = 16787544;
pub const IBUS_KEY_braille_dots_1457: u32 = 16787545;
pub const IBUS_KEY_braille_dots_2457: u32 = 16787546;
pub const IBUS_KEY_braille_dots_12457: u32 = 16787547;
pub const IBUS_KEY_braille_dots_3457: u32 = 16787548;
pub const IBUS_KEY_braille_dots_13457: u32 = 16787549;
pub const IBUS_KEY_braille_dots_23457: u32 = 16787550;
pub const IBUS_KEY_braille_dots_123457: u32 = 16787551;
pub const IBUS_KEY_braille_dots_67: u32 = 16787552;
pub const IBUS_KEY_braille_dots_167: u32 = 16787553;
pub const IBUS_KEY_braille_dots_267: u32 = 16787554;
pub const IBUS_KEY_braille_dots_1267: u32 = 16787555;
pub const IBUS_KEY_braille_dots_367: u32 = 16787556;
pub const IBUS_KEY_braille_dots_1367: u32 = 16787557;
pub const IBUS_KEY_braille_dots_2367: u32 = 16787558;
pub const IBUS_KEY_braille_dots_12367: u32 = 16787559;
pub const IBUS_KEY_braille_dots_467: u32 = 16787560;
pub const IBUS_KEY_braille_dots_1467: u32 = 16787561;
pub const IBUS_KEY_braille_dots_2467: u32 = 16787562;
pub const IBUS_KEY_braille_dots_12467: u32 = 16787563;
pub const IBUS_KEY_braille_dots_3467: u32 = 16787564;
pub const IBUS_KEY_braille_dots_13467: u32 = 16787565;
pub const IBUS_KEY_braille_dots_23467: u32 = 16787566;
pub const IBUS_KEY_braille_dots_123467: u32 = 16787567;
pub const IBUS_KEY_braille_dots_567: u32 = 16787568;
pub const IBUS_KEY_braille_dots_1567: u32 = 16787569;
pub const IBUS_KEY_braille_dots_2567: u32 = 16787570;
pub const IBUS_KEY_braille_dots_12567: u32 = 16787571;
pub const IBUS_KEY_braille_dots_3567: u32 = 16787572;
pub const IBUS_KEY_braille_dots_13567: u32 = 16787573;
pub const IBUS_KEY_braille_dots_23567: u32 = 16787574;
pub const IBUS_KEY_braille_dots_123567: u32 = 16787575;
pub const IBUS_KEY_braille_dots_4567: u32 = 16787576;
pub const IBUS_KEY_braille_dots_14567: u32 = 16787577;
pub const IBUS_KEY_braille_dots_24567: u32 = 16787578;
pub const IBUS_KEY_braille_dots_124567: u32 = 16787579;
pub const IBUS_KEY_braille_dots_34567: u32 = 16787580;
pub const IBUS_KEY_braille_dots_134567: u32 = 16787581;
pub const IBUS_KEY_braille_dots_234567: u32 = 16787582;
pub const IBUS_KEY_braille_dots_1234567: u32 = 16787583;
pub const IBUS_KEY_braille_dots_8: u32 = 16787584;
pub const IBUS_KEY_braille_dots_18: u32 = 16787585;
pub const IBUS_KEY_braille_dots_28: u32 = 16787586;
pub const IBUS_KEY_braille_dots_128: u32 = 16787587;
pub const IBUS_KEY_braille_dots_38: u32 = 16787588;
pub const IBUS_KEY_braille_dots_138: u32 = 16787589;
pub const IBUS_KEY_braille_dots_238: u32 = 16787590;
pub const IBUS_KEY_braille_dots_1238: u32 = 16787591;
pub const IBUS_KEY_braille_dots_48: u32 = 16787592;
pub const IBUS_KEY_braille_dots_148: u32 = 16787593;
pub const IBUS_KEY_braille_dots_248: u32 = 16787594;
pub const IBUS_KEY_braille_dots_1248: u32 = 16787595;
pub const IBUS_KEY_braille_dots_348: u32 = 16787596;
pub const IBUS_KEY_braille_dots_1348: u32 = 16787597;
pub const IBUS_KEY_braille_dots_2348: u32 = 16787598;
pub const IBUS_KEY_braille_dots_12348: u32 = 16787599;
pub const IBUS_KEY_braille_dots_58: u32 = 16787600;
pub const IBUS_KEY_braille_dots_158: u32 = 16787601;
pub const IBUS_KEY_braille_dots_258: u32 = 16787602;
pub const IBUS_KEY_braille_dots_1258: u32 = 16787603;
pub const IBUS_KEY_braille_dots_358: u32 = 16787604;
pub const IBUS_KEY_braille_dots_1358: u32 = 16787605;
pub const IBUS_KEY_braille_dots_2358: u32 = 16787606;
pub const IBUS_KEY_braille_dots_12358: u32 = 16787607;
pub const IBUS_KEY_braille_dots_458: u32 = 16787608;
pub const IBUS_KEY_braille_dots_1458: u32 = 16787609;
pub const IBUS_KEY_braille_dots_2458: u32 = 16787610;
pub const IBUS_KEY_braille_dots_12458: u32 = 16787611;
pub const IBUS_KEY_braille_dots_3458: u32 = 16787612;
pub const IBUS_KEY_braille_dots_13458: u32 = 16787613;
pub const IBUS_KEY_braille_dots_23458: u32 = 16787614;
pub const IBUS_KEY_braille_dots_123458: u32 = 16787615;
pub const IBUS_KEY_braille_dots_68: u32 = 16787616;
pub const IBUS_KEY_braille_dots_168: u32 = 16787617;
pub const IBUS_KEY_braille_dots_268: u32 = 16787618;
pub const IBUS_KEY_braille_dots_1268: u32 = 16787619;
pub const IBUS_KEY_braille_dots_368: u32 = 16787620;
pub const IBUS_KEY_braille_dots_1368: u32 = 16787621;
pub const IBUS_KEY_braille_dots_2368: u32 = 16787622;
pub const IBUS_KEY_braille_dots_12368: u32 = 16787623;
pub const IBUS_KEY_braille_dots_468: u32 = 16787624;
pub const IBUS_KEY_braille_dots_1468: u32 = 16787625;
pub const IBUS_KEY_braille_dots_2468: u32 = 16787626;
pub const IBUS_KEY_braille_dots_12468: u32 = 16787627;
pub const IBUS_KEY_braille_dots_3468: u32 = 16787628;
pub const IBUS_KEY_braille_dots_13468: u32 = 16787629;
pub const IBUS_KEY_braille_dots_23468: u32 = 16787630;
pub const IBUS_KEY_braille_dots_123468: u32 = 16787631;
pub const IBUS_KEY_braille_dots_568: u32 = 16787632;
pub const IBUS_KEY_braille_dots_1568: u32 = 16787633;
pub const IBUS_KEY_braille_dots_2568: u32 = 16787634;
pub const IBUS_KEY_braille_dots_12568: u32 = 16787635;
pub const IBUS_KEY_braille_dots_3568: u32 = 16787636;
pub const IBUS_KEY_braille_dots_13568: u32 = 16787637;
pub const IBUS_KEY_braille_dots_23568: u32 = 16787638;
pub const IBUS_KEY_braille_dots_123568: u32 = 16787639;
pub const IBUS_KEY_braille_dots_4568: u32 = 16787640;
pub const IBUS_KEY_braille_dots_14568: u32 = 16787641;
pub const IBUS_KEY_braille_dots_24568: u32 = 16787642;
pub const IBUS_KEY_braille_dots_124568: u32 = 16787643;
pub const IBUS_KEY_braille_dots_34568: u32 = 16787644;
pub const IBUS_KEY_braille_dots_134568: u32 = 16787645;
pub const IBUS_KEY_braille_dots_234568: u32 = 16787646;
pub const IBUS_KEY_braille_dots_1234568: u32 = 16787647;
pub const IBUS_KEY_braille_dots_78: u32 = 16787648;
pub const IBUS_KEY_braille_dots_178: u32 = 16787649;
pub const IBUS_KEY_braille_dots_278: u32 = 16787650;
pub const IBUS_KEY_braille_dots_1278: u32 = 16787651;
pub const IBUS_KEY_braille_dots_378: u32 = 16787652;
pub const IBUS_KEY_braille_dots_1378: u32 = 16787653;
pub const IBUS_KEY_braille_dots_2378: u32 = 16787654;
pub const IBUS_KEY_braille_dots_12378: u32 = 16787655;
pub const IBUS_KEY_braille_dots_478: u32 = 16787656;
pub const IBUS_KEY_braille_dots_1478: u32 = 16787657;
pub const IBUS_KEY_braille_dots_2478: u32 = 16787658;
pub const IBUS_KEY_braille_dots_12478: u32 = 16787659;
pub const IBUS_KEY_braille_dots_3478: u32 = 16787660;
pub const IBUS_KEY_braille_dots_13478: u32 = 16787661;
pub const IBUS_KEY_braille_dots_23478: u32 = 16787662;
pub const IBUS_KEY_braille_dots_123478: u32 = 16787663;
pub const IBUS_KEY_braille_dots_578: u32 = 16787664;
pub const IBUS_KEY_braille_dots_1578: u32 = 16787665;
pub const IBUS_KEY_braille_dots_2578: u32 = 16787666;
pub const IBUS_KEY_braille_dots_12578: u32 = 16787667;
pub const IBUS_KEY_braille_dots_3578: u32 = 16787668;
pub const IBUS_KEY_braille_dots_13578: u32 = 16787669;
pub const IBUS_KEY_braille_dots_23578: u32 = 16787670;
pub const IBUS_KEY_braille_dots_123578: u32 = 16787671;
pub const IBUS_KEY_braille_dots_4578: u32 = 16787672;
pub const IBUS_KEY_braille_dots_14578: u32 = 16787673;
pub const IBUS_KEY_braille_dots_24578: u32 = 16787674;
pub const IBUS_KEY_braille_dots_124578: u32 = 16787675;
pub const IBUS_KEY_braille_dots_34578: u32 = 16787676;
pub const IBUS_KEY_braille_dots_134578: u32 = 16787677;
pub const IBUS_KEY_braille_dots_234578: u32 = 16787678;
pub const IBUS_KEY_braille_dots_1234578: u32 = 16787679;
pub const IBUS_KEY_braille_dots_678: u32 = 16787680;
pub const IBUS_KEY_braille_dots_1678: u32 = 16787681;
pub const IBUS_KEY_braille_dots_2678: u32 = 16787682;
pub const IBUS_KEY_braille_dots_12678: u32 = 16787683;
pub const IBUS_KEY_braille_dots_3678: u32 = 16787684;
pub const IBUS_KEY_braille_dots_13678: u32 = 16787685;
pub const IBUS_KEY_braille_dots_23678: u32 = 16787686;
pub const IBUS_KEY_braille_dots_123678: u32 = 16787687;
pub const IBUS_KEY_braille_dots_4678: u32 = 16787688;
pub const IBUS_KEY_braille_dots_14678: u32 = 16787689;
pub const IBUS_KEY_braille_dots_24678: u32 = 16787690;
pub const IBUS_KEY_braille_dots_124678: u32 = 16787691;
pub const IBUS_KEY_braille_dots_34678: u32 = 16787692;
pub const IBUS_KEY_braille_dots_134678: u32 = 16787693;
pub const IBUS_KEY_braille_dots_234678: u32 = 16787694;
pub const IBUS_KEY_braille_dots_1234678: u32 = 16787695;
pub const IBUS_KEY_braille_dots_5678: u32 = 16787696;
pub const IBUS_KEY_braille_dots_15678: u32 = 16787697;
pub const IBUS_KEY_braille_dots_25678: u32 = 16787698;
pub const IBUS_KEY_braille_dots_125678: u32 = 16787699;
pub const IBUS_KEY_braille_dots_35678: u32 = 16787700;
pub const IBUS_KEY_braille_dots_135678: u32 = 16787701;
pub const IBUS_KEY_braille_dots_235678: u32 = 16787702;
pub const IBUS_KEY_braille_dots_1235678: u32 = 16787703;
pub const IBUS_KEY_braille_dots_45678: u32 = 16787704;
pub const IBUS_KEY_braille_dots_145678: u32 = 16787705;
pub const IBUS_KEY_braille_dots_245678: u32 = 16787706;
pub const IBUS_KEY_braille_dots_1245678: u32 = 16787707;
pub const IBUS_KEY_braille_dots_345678: u32 = 16787708;
pub const IBUS_KEY_braille_dots_1345678: u32 = 16787709;
pub const IBUS_KEY_braille_dots_2345678: u32 = 16787710;
pub const IBUS_KEY_braille_dots_12345678: u32 = 16787711;
pub const IBUS_KEY_Sinh_ng: u32 = 16780674;
pub const IBUS_KEY_Sinh_h2: u32 = 16780675;
pub const IBUS_KEY_Sinh_a: u32 = 16780677;
pub const IBUS_KEY_Sinh_aa: u32 = 16780678;
pub const IBUS_KEY_Sinh_ae: u32 = 16780679;
pub const IBUS_KEY_Sinh_aee: u32 = 16780680;
pub const IBUS_KEY_Sinh_i: u32 = 16780681;
pub const IBUS_KEY_Sinh_ii: u32 = 16780682;
pub const IBUS_KEY_Sinh_u: u32 = 16780683;
pub const IBUS_KEY_Sinh_uu: u32 = 16780684;
pub const IBUS_KEY_Sinh_ri: u32 = 16780685;
pub const IBUS_KEY_Sinh_rii: u32 = 16780686;
pub const IBUS_KEY_Sinh_lu: u32 = 16780687;
pub const IBUS_KEY_Sinh_luu: u32 = 16780688;
pub const IBUS_KEY_Sinh_e: u32 = 16780689;
pub const IBUS_KEY_Sinh_ee: u32 = 16780690;
pub const IBUS_KEY_Sinh_ai: u32 = 16780691;
pub const IBUS_KEY_Sinh_o: u32 = 16780692;
pub const IBUS_KEY_Sinh_oo: u32 = 16780693;
pub const IBUS_KEY_Sinh_au: u32 = 16780694;
pub const IBUS_KEY_Sinh_ka: u32 = 16780698;
pub const IBUS_KEY_Sinh_kha: u32 = 16780699;
pub const IBUS_KEY_Sinh_ga: u32 = 16780700;
pub const IBUS_KEY_Sinh_gha: u32 = 16780701;
pub const IBUS_KEY_Sinh_ng2: u32 = 16780702;
pub const IBUS_KEY_Sinh_nga: u32 = 16780703;
pub const IBUS_KEY_Sinh_ca: u32 = 16780704;
pub const IBUS_KEY_Sinh_cha: u32 = 16780705;
pub const IBUS_KEY_Sinh_ja: u32 = 16780706;
pub const IBUS_KEY_Sinh_jha: u32 = 16780707;
pub const IBUS_KEY_Sinh_nya: u32 = 16780708;
pub const IBUS_KEY_Sinh_jnya: u32 = 16780709;
pub const IBUS_KEY_Sinh_nja: u32 = 16780710;
pub const IBUS_KEY_Sinh_tta: u32 = 16780711;
pub const IBUS_KEY_Sinh_ttha: u32 = 16780712;
pub const IBUS_KEY_Sinh_dda: u32 = 16780713;
pub const IBUS_KEY_Sinh_ddha: u32 = 16780714;
pub const IBUS_KEY_Sinh_nna: u32 = 16780715;
pub const IBUS_KEY_Sinh_ndda: u32 = 16780716;
pub const IBUS_KEY_Sinh_tha: u32 = 16780717;
pub const IBUS_KEY_Sinh_thha: u32 = 16780718;
pub const IBUS_KEY_Sinh_dha: u32 = 16780719;
pub const IBUS_KEY_Sinh_dhha: u32 = 16780720;
pub const IBUS_KEY_Sinh_na: u32 = 16780721;
pub const IBUS_KEY_Sinh_ndha: u32 = 16780723;
pub const IBUS_KEY_Sinh_pa: u32 = 16780724;
pub const IBUS_KEY_Sinh_pha: u32 = 16780725;
pub const IBUS_KEY_Sinh_ba: u32 = 16780726;
pub const IBUS_KEY_Sinh_bha: u32 = 16780727;
pub const IBUS_KEY_Sinh_ma: u32 = 16780728;
pub const IBUS_KEY_Sinh_mba: u32 = 16780729;
pub const IBUS_KEY_Sinh_ya: u32 = 16780730;
pub const IBUS_KEY_Sinh_ra: u32 = 16780731;
pub const IBUS_KEY_Sinh_la: u32 = 16780733;
pub const IBUS_KEY_Sinh_va: u32 = 16780736;
pub const IBUS_KEY_Sinh_sha: u32 = 16780737;
pub const IBUS_KEY_Sinh_ssha: u32 = 16780738;
pub const IBUS_KEY_Sinh_sa: u32 = 16780739;
pub const IBUS_KEY_Sinh_ha: u32 = 16780740;
pub const IBUS_KEY_Sinh_lla: u32 = 16780741;
pub const IBUS_KEY_Sinh_fa: u32 = 16780742;
pub const IBUS_KEY_Sinh_al: u32 = 16780746;
pub const IBUS_KEY_Sinh_aa2: u32 = 16780751;
pub const IBUS_KEY_Sinh_ae2: u32 = 16780752;
pub const IBUS_KEY_Sinh_aee2: u32 = 16780753;
pub const IBUS_KEY_Sinh_i2: u32 = 16780754;
pub const IBUS_KEY_Sinh_ii2: u32 = 16780755;
pub const IBUS_KEY_Sinh_u2: u32 = 16780756;
pub const IBUS_KEY_Sinh_uu2: u32 = 16780758;
pub const IBUS_KEY_Sinh_ru2: u32 = 16780760;
pub const IBUS_KEY_Sinh_e2: u32 = 16780761;
pub const IBUS_KEY_Sinh_ee2: u32 = 16780762;
pub const IBUS_KEY_Sinh_ai2: u32 = 16780763;
pub const IBUS_KEY_Sinh_o2: u32 = 16780764;
pub const IBUS_KEY_Sinh_oo2: u32 = 16780765;
pub const IBUS_KEY_Sinh_au2: u32 = 16780766;
pub const IBUS_KEY_Sinh_lu2: u32 = 16780767;
pub const IBUS_KEY_Sinh_ruu2: u32 = 16780786;
pub const IBUS_KEY_Sinh_luu2: u32 = 16780787;
pub const IBUS_KEY_Sinh_kunddaliya: u32 = 16780788;
pub const IBUS_KEY_ModeLock: u32 = 269025025;
pub const IBUS_KEY_MonBrightnessUp: u32 = 269025026;
pub const IBUS_KEY_MonBrightnessDown: u32 = 269025027;
pub const IBUS_KEY_KbdLightOnOff: u32 = 269025028;
pub const IBUS_KEY_KbdBrightnessUp: u32 = 269025029;
pub const IBUS_KEY_KbdBrightnessDown: u32 = 269025030;
pub const IBUS_KEY_Standby: u32 = 269025040;
pub const IBUS_KEY_AudioLowerVolume: u32 = 269025041;
pub const IBUS_KEY_AudioMute: u32 = 269025042;
pub const IBUS_KEY_AudioRaiseVolume: u32 = 269025043;
pub const IBUS_KEY_AudioPlay: u32 = 269025044;
pub const IBUS_KEY_AudioStop: u32 = 269025045;
pub const IBUS_KEY_AudioPrev: u32 = 269025046;
pub const IBUS_KEY_AudioNext: u32 = 269025047;
pub const IBUS_KEY_HomePage: u32 = 269025048;
pub const IBUS_KEY_Mail: u32 = 269025049;
pub const IBUS_KEY_Start: u32 = 269025050;
pub const IBUS_KEY_Search: u32 = 269025051;
pub const IBUS_KEY_AudioRecord: u32 = 269025052;
pub const IBUS_KEY_Calculator: u32 = 269025053;
pub const IBUS_KEY_Memo: u32 = 269025054;
pub const IBUS_KEY_ToDoList: u32 = 269025055;
pub const IBUS_KEY_Calendar: u32 = 269025056;
pub const IBUS_KEY_PowerDown: u32 = 269025057;
pub const IBUS_KEY_ContrastAdjust: u32 = 269025058;
pub const IBUS_KEY_RockerUp: u32 = 269025059;
pub const IBUS_KEY_RockerDown: u32 = 269025060;
pub const IBUS_KEY_RockerEnter: u32 = 269025061;
pub const IBUS_KEY_Back: u32 = 269025062;
pub const IBUS_KEY_Forward: u32 = 269025063;
pub const IBUS_KEY_Stop: u32 = 269025064;
pub const IBUS_KEY_Refresh: u32 = 269025065;
pub const IBUS_KEY_PowerOff: u32 = 269025066;
pub const IBUS_KEY_WakeUp: u32 = 269025067;
pub const IBUS_KEY_Eject: u32 = 269025068;
pub const IBUS_KEY_ScreenSaver: u32 = 269025069;
pub const IBUS_KEY_WWW: u32 = 269025070;
pub const IBUS_KEY_Sleep: u32 = 269025071;
pub const IBUS_KEY_Favorites: u32 = 269025072;
pub const IBUS_KEY_AudioPause: u32 = 269025073;
pub const IBUS_KEY_AudioMedia: u32 = 269025074;
pub const IBUS_KEY_MyComputer: u32 = 269025075;
pub const IBUS_KEY_VendorHome: u32 = 269025076;
pub const IBUS_KEY_LightBulb: u32 = 269025077;
pub const IBUS_KEY_Shop: u32 = 269025078;
pub const IBUS_KEY_History: u32 = 269025079;
pub const IBUS_KEY_OpenURL: u32 = 269025080;
pub const IBUS_KEY_AddFavorite: u32 = 269025081;
pub const IBUS_KEY_HotLinks: u32 = 269025082;
pub const IBUS_KEY_BrightnessAdjust: u32 = 269025083;
pub const IBUS_KEY_Finance: u32 = 269025084;
pub const IBUS_KEY_Community: u32 = 269025085;
pub const IBUS_KEY_AudioRewind: u32 = 269025086;
pub const IBUS_KEY_BackForward: u32 = 269025087;
pub const IBUS_KEY_Launch0: u32 = 269025088;
pub const IBUS_KEY_Launch1: u32 = 269025089;
pub const IBUS_KEY_Launch2: u32 = 269025090;
pub const IBUS_KEY_Launch3: u32 = 269025091;
pub const IBUS_KEY_Launch4: u32 = 269025092;
pub const IBUS_KEY_Launch5: u32 = 269025093;
pub const IBUS_KEY_Launch6: u32 = 269025094;
pub const IBUS_KEY_Launch7: u32 = 269025095;
pub const IBUS_KEY_Launch8: u32 = 269025096;
pub const IBUS_KEY_Launch9: u32 = 269025097;
pub const IBUS_KEY_LaunchA: u32 = 269025098;
pub const IBUS_KEY_LaunchB: u32 = 269025099;
pub const IBUS_KEY_LaunchC: u32 = 269025100;
pub const IBUS_KEY_LaunchD: u32 = 269025101;
pub const IBUS_KEY_LaunchE: u32 = 269025102;
pub const IBUS_KEY_LaunchF: u32 = 269025103;
pub const IBUS_KEY_ApplicationLeft: u32 = 269025104;
pub const IBUS_KEY_ApplicationRight: u32 = 269025105;
pub const IBUS_KEY_Book: u32 = 269025106;
pub const IBUS_KEY_CD: u32 = 269025107;
pub const IBUS_KEY_WindowClear: u32 = 269025109;
pub const IBUS_KEY_Close: u32 = 269025110;
pub const IBUS_KEY_Copy: u32 = 269025111;
pub const IBUS_KEY_Cut: u32 = 269025112;
pub const IBUS_KEY_Display: u32 = 269025113;
pub const IBUS_KEY_DOS: u32 = 269025114;
pub const IBUS_KEY_Documents: u32 = 269025115;
pub const IBUS_KEY_Excel: u32 = 269025116;
pub const IBUS_KEY_Explorer: u32 = 269025117;
pub const IBUS_KEY_Game: u32 = 269025118;
pub const IBUS_KEY_Go: u32 = 269025119;
pub const IBUS_KEY_iTouch: u32 = 269025120;
pub const IBUS_KEY_LogOff: u32 = 269025121;
pub const IBUS_KEY_Market: u32 = 269025122;
pub const IBUS_KEY_Meeting: u32 = 269025123;
pub const IBUS_KEY_MenuKB: u32 = 269025125;
pub const IBUS_KEY_MenuPB: u32 = 269025126;
pub const IBUS_KEY_MySites: u32 = 269025127;
pub const IBUS_KEY_New: u32 = 269025128;
pub const IBUS_KEY_News: u32 = 269025129;
pub const IBUS_KEY_OfficeHome: u32 = 269025130;
pub const IBUS_KEY_Open: u32 = 269025131;
pub const IBUS_KEY_Option: u32 = 269025132;
pub const IBUS_KEY_Paste: u32 = 269025133;
pub const IBUS_KEY_Phone: u32 = 269025134;
pub const IBUS_KEY_Reply: u32 = 269025138;
pub const IBUS_KEY_Reload: u32 = 269025139;
pub const IBUS_KEY_RotateWindows: u32 = 269025140;
pub const IBUS_KEY_RotationPB: u32 = 269025141;
pub const IBUS_KEY_RotationKB: u32 = 269025142;
pub const IBUS_KEY_Save: u32 = 269025143;
pub const IBUS_KEY_ScrollUp: u32 = 269025144;
pub const IBUS_KEY_ScrollDown: u32 = 269025145;
pub const IBUS_KEY_ScrollClick: u32 = 269025146;
pub const IBUS_KEY_Send: u32 = 269025147;
pub const IBUS_KEY_Spell: u32 = 269025148;
pub const IBUS_KEY_SplitScreen: u32 = 269025149;
pub const IBUS_KEY_Support: u32 = 269025150;
pub const IBUS_KEY_TaskPane: u32 = 269025151;
pub const IBUS_KEY_Terminal: u32 = 269025152;
pub const IBUS_KEY_Tools: u32 = 269025153;
pub const IBUS_KEY_Travel: u32 = 269025154;
pub const IBUS_KEY_UserPB: u32 = 269025156;
pub const IBUS_KEY_User1KB: u32 = 269025157;
pub const IBUS_KEY_User2KB: u32 = 269025158;
pub const IBUS_KEY_Video: u32 = 269025159;
pub const IBUS_KEY_WheelButton: u32 = 269025160;
pub const IBUS_KEY_Word: u32 = 269025161;
pub const IBUS_KEY_Xfer: u32 = 269025162;
pub const IBUS_KEY_ZoomIn: u32 = 269025163;
pub const IBUS_KEY_ZoomOut: u32 = 269025164;
pub const IBUS_KEY_Away: u32 = 269025165;
pub const IBUS_KEY_Messenger: u32 = 269025166;
pub const IBUS_KEY_WebCam: u32 = 269025167;
pub const IBUS_KEY_MailForward: u32 = 269025168;
pub const IBUS_KEY_Pictures: u32 = 269025169;
pub const IBUS_KEY_Music: u32 = 269025170;
pub const IBUS_KEY_Battery: u32 = 269025171;
pub const IBUS_KEY_Bluetooth: u32 = 269025172;
pub const IBUS_KEY_WLAN: u32 = 269025173;
pub const IBUS_KEY_UWB: u32 = 269025174;
pub const IBUS_KEY_AudioForward: u32 = 269025175;
pub const IBUS_KEY_AudioRepeat: u32 = 269025176;
pub const IBUS_KEY_AudioRandomPlay: u32 = 269025177;
pub const IBUS_KEY_Subtitle: u32 = 269025178;
pub const IBUS_KEY_AudioCycleTrack: u32 = 269025179;
pub const IBUS_KEY_CycleAngle: u32 = 269025180;
pub const IBUS_KEY_FrameBack: u32 = 269025181;
pub const IBUS_KEY_FrameForward: u32 = 269025182;
pub const IBUS_KEY_Time: u32 = 269025183;
pub const IBUS_KEY_SelectButton: u32 = 269025184;
pub const IBUS_KEY_View: u32 = 269025185;
pub const IBUS_KEY_TopMenu: u32 = 269025186;
pub const IBUS_KEY_Red: u32 = 269025187;
pub const IBUS_KEY_Green: u32 = 269025188;
pub const IBUS_KEY_Yellow: u32 = 269025189;
pub const IBUS_KEY_Blue: u32 = 269025190;
pub const IBUS_KEY_Suspend: u32 = 269025191;
pub const IBUS_KEY_Hibernate: u32 = 269025192;
pub const IBUS_KEY_TouchpadToggle: u32 = 269025193;
pub const IBUS_KEY_TouchpadOn: u32 = 269025200;
pub const IBUS_KEY_TouchpadOff: u32 = 269025201;
pub const IBUS_KEY_AudioMicMute: u32 = 269025202;
pub const IBUS_KEY_Keyboard: u32 = 269025203;
pub const IBUS_KEY_WWAN: u32 = 269025204;
pub const IBUS_KEY_RFKill: u32 = 269025205;
pub const IBUS_KEY_AudioPreset: u32 = 269025206;
pub const IBUS_KEY_Switch_VT_1: u32 = 269024769;
pub const IBUS_KEY_Switch_VT_2: u32 = 269024770;
pub const IBUS_KEY_Switch_VT_3: u32 = 269024771;
pub const IBUS_KEY_Switch_VT_4: u32 = 269024772;
pub const IBUS_KEY_Switch_VT_5: u32 = 269024773;
pub const IBUS_KEY_Switch_VT_6: u32 = 269024774;
pub const IBUS_KEY_Switch_VT_7: u32 = 269024775;
pub const IBUS_KEY_Switch_VT_8: u32 = 269024776;
pub const IBUS_KEY_Switch_VT_9: u32 = 269024777;
pub const IBUS_KEY_Switch_VT_10: u32 = 269024778;
pub const IBUS_KEY_Switch_VT_11: u32 = 269024779;
pub const IBUS_KEY_Switch_VT_12: u32 = 269024780;
pub const IBUS_KEY_Ungrab: u32 = 269024800;
pub const IBUS_KEY_ClearGrab: u32 = 269024801;
pub const IBUS_KEY_Next_VMode: u32 = 269024802;
pub const IBUS_KEY_Prev_VMode: u32 = 269024803;
pub const IBUS_KEY_LogWindowTree: u32 = 269024804;
pub const IBUS_KEY_LogGrabInfo: u32 = 269024805;
pub const IBUS_MAX_COMPOSE_LEN: u32 = 255;
pub const IBUS_VoidSymbol: u32 = 16777215;
pub const IBUS_BackSpace: u32 = 65288;
pub const IBUS_Tab: u32 = 65289;
pub const IBUS_Linefeed: u32 = 65290;
pub const IBUS_Clear: u32 = 65291;
pub const IBUS_Return: u32 = 65293;
pub const IBUS_Pause: u32 = 65299;
pub const IBUS_Scroll_Lock: u32 = 65300;
pub const IBUS_Sys_Req: u32 = 65301;
pub const IBUS_Escape: u32 = 65307;
pub const IBUS_Delete: u32 = 65535;
pub const IBUS_Multi_key: u32 = 65312;
pub const IBUS_Codeinput: u32 = 65335;
pub const IBUS_SingleCandidate: u32 = 65340;
pub const IBUS_MultipleCandidate: u32 = 65341;
pub const IBUS_PreviousCandidate: u32 = 65342;
pub const IBUS_Kanji: u32 = 65313;
pub const IBUS_Muhenkan: u32 = 65314;
pub const IBUS_Henkan_Mode: u32 = 65315;
pub const IBUS_Henkan: u32 = 65315;
pub const IBUS_Romaji: u32 = 65316;
pub const IBUS_Hiragana: u32 = 65317;
pub const IBUS_Katakana: u32 = 65318;
pub const IBUS_Hiragana_Katakana: u32 = 65319;
pub const IBUS_Zenkaku: u32 = 65320;
pub const IBUS_Hankaku: u32 = 65321;
pub const IBUS_Zenkaku_Hankaku: u32 = 65322;
pub const IBUS_Touroku: u32 = 65323;
pub const IBUS_Massyo: u32 = 65324;
pub const IBUS_Kana_Lock: u32 = 65325;
pub const IBUS_Kana_Shift: u32 = 65326;
pub const IBUS_Eisu_Shift: u32 = 65327;
pub const IBUS_Eisu_toggle: u32 = 65328;
pub const IBUS_Kanji_Bangou: u32 = 65335;
pub const IBUS_Zen_Koho: u32 = 65341;
pub const IBUS_Mae_Koho: u32 = 65342;
pub const IBUS_Home: u32 = 65360;
pub const IBUS_Left: u32 = 65361;
pub const IBUS_Up: u32 = 65362;
pub const IBUS_Right: u32 = 65363;
pub const IBUS_Down: u32 = 65364;
pub const IBUS_Prior: u32 = 65365;
pub const IBUS_Page_Up: u32 = 65365;
pub const IBUS_Next: u32 = 65366;
pub const IBUS_Page_Down: u32 = 65366;
pub const IBUS_End: u32 = 65367;
pub const IBUS_Begin: u32 = 65368;
pub const IBUS_Select: u32 = 65376;
pub const IBUS_Print: u32 = 65377;
pub const IBUS_Execute: u32 = 65378;
pub const IBUS_Insert: u32 = 65379;
pub const IBUS_Undo: u32 = 65381;
pub const IBUS_Redo: u32 = 65382;
pub const IBUS_Menu: u32 = 65383;
pub const IBUS_Find: u32 = 65384;
pub const IBUS_Cancel: u32 = 65385;
pub const IBUS_Help: u32 = 65386;
pub const IBUS_Break: u32 = 65387;
pub const IBUS_Mode_switch: u32 = 65406;
pub const IBUS_script_switch: u32 = 65406;
pub const IBUS_Num_Lock: u32 = 65407;
pub const IBUS_KP_Space: u32 = 65408;
pub const IBUS_KP_Tab: u32 = 65417;
pub const IBUS_KP_Enter: u32 = 65421;
pub const IBUS_KP_F1: u32 = 65425;
pub const IBUS_KP_F2: u32 = 65426;
pub const IBUS_KP_F3: u32 = 65427;
pub const IBUS_KP_F4: u32 = 65428;
pub const IBUS_KP_Home: u32 = 65429;
pub const IBUS_KP_Left: u32 = 65430;
pub const IBUS_KP_Up: u32 = 65431;
pub const IBUS_KP_Right: u32 = 65432;
pub const IBUS_KP_Down: u32 = 65433;
pub const IBUS_KP_Prior: u32 = 65434;
pub const IBUS_KP_Page_Up: u32 = 65434;
pub const IBUS_KP_Next: u32 = 65435;
pub const IBUS_KP_Page_Down: u32 = 65435;
pub const IBUS_KP_End: u32 = 65436;
pub const IBUS_KP_Begin: u32 = 65437;
pub const IBUS_KP_Insert: u32 = 65438;
pub const IBUS_KP_Delete: u32 = 65439;
pub const IBUS_KP_Equal: u32 = 65469;
pub const IBUS_KP_Multiply: u32 = 65450;
pub const IBUS_KP_Add: u32 = 65451;
pub const IBUS_KP_Separator: u32 = 65452;
pub const IBUS_KP_Subtract: u32 = 65453;
pub const IBUS_KP_Decimal: u32 = 65454;
pub const IBUS_KP_Divide: u32 = 65455;
pub const IBUS_KP_0: u32 = 65456;
pub const IBUS_KP_1: u32 = 65457;
pub const IBUS_KP_2: u32 = 65458;
pub const IBUS_KP_3: u32 = 65459;
pub const IBUS_KP_4: u32 = 65460;
pub const IBUS_KP_5: u32 = 65461;
pub const IBUS_KP_6: u32 = 65462;
pub const IBUS_KP_7: u32 = 65463;
pub const IBUS_KP_8: u32 = 65464;
pub const IBUS_KP_9: u32 = 65465;
pub const IBUS_F1: u32 = 65470;
pub const IBUS_F2: u32 = 65471;
pub const IBUS_F3: u32 = 65472;
pub const IBUS_F4: u32 = 65473;
pub const IBUS_F5: u32 = 65474;
pub const IBUS_F6: u32 = 65475;
pub const IBUS_F7: u32 = 65476;
pub const IBUS_F8: u32 = 65477;
pub const IBUS_F9: u32 = 65478;
pub const IBUS_F10: u32 = 65479;
pub const IBUS_F11: u32 = 65480;
pub const IBUS_L1: u32 = 65480;
pub const IBUS_F12: u32 = 65481;
pub const IBUS_L2: u32 = 65481;
pub const IBUS_F13: u32 = 65482;
pub const IBUS_L3: u32 = 65482;
pub const IBUS_F14: u32 = 65483;
pub const IBUS_L4: u32 = 65483;
pub const IBUS_F15: u32 = 65484;
pub const IBUS_L5: u32 = 65484;
pub const IBUS_F16: u32 = 65485;
pub const IBUS_L6: u32 = 65485;
pub const IBUS_F17: u32 = 65486;
pub const IBUS_L7: u32 = 65486;
pub const IBUS_F18: u32 = 65487;
pub const IBUS_L8: u32 = 65487;
pub const IBUS_F19: u32 = 65488;
pub const IBUS_L9: u32 = 65488;
pub const IBUS_F20: u32 = 65489;
pub const IBUS_L10: u32 = 65489;
pub const IBUS_F21: u32 = 65490;
pub const IBUS_R1: u32 = 65490;
pub const IBUS_F22: u32 = 65491;
pub const IBUS_R2: u32 = 65491;
pub const IBUS_F23: u32 = 65492;
pub const IBUS_R3: u32 = 65492;
pub const IBUS_F24: u32 = 65493;
pub const IBUS_R4: u32 = 65493;
pub const IBUS_F25: u32 = 65494;
pub const IBUS_R5: u32 = 65494;
pub const IBUS_F26: u32 = 65495;
pub const IBUS_R6: u32 = 65495;
pub const IBUS_F27: u32 = 65496;
pub const IBUS_R7: u32 = 65496;
pub const IBUS_F28: u32 = 65497;
pub const IBUS_R8: u32 = 65497;
pub const IBUS_F29: u32 = 65498;
pub const IBUS_R9: u32 = 65498;
pub const IBUS_F30: u32 = 65499;
pub const IBUS_R10: u32 = 65499;
pub const IBUS_F31: u32 = 65500;
pub const IBUS_R11: u32 = 65500;
pub const IBUS_F32: u32 = 65501;
pub const IBUS_R12: u32 = 65501;
pub const IBUS_F33: u32 = 65502;
pub const IBUS_R13: u32 = 65502;
pub const IBUS_F34: u32 = 65503;
pub const IBUS_R14: u32 = 65503;
pub const IBUS_F35: u32 = 65504;
pub const IBUS_R15: u32 = 65504;
pub const IBUS_Shift_L: u32 = 65505;
pub const IBUS_Shift_R: u32 = 65506;
pub const IBUS_Control_L: u32 = 65507;
pub const IBUS_Control_R: u32 = 65508;
pub const IBUS_Caps_Lock: u32 = 65509;
pub const IBUS_Shift_Lock: u32 = 65510;
pub const IBUS_Meta_L: u32 = 65511;
pub const IBUS_Meta_R: u32 = 65512;
pub const IBUS_Alt_L: u32 = 65513;
pub const IBUS_Alt_R: u32 = 65514;
pub const IBUS_Super_L: u32 = 65515;
pub const IBUS_Super_R: u32 = 65516;
pub const IBUS_Hyper_L: u32 = 65517;
pub const IBUS_Hyper_R: u32 = 65518;
pub const IBUS_ISO_Lock: u32 = 65025;
pub const IBUS_ISO_Level2_Latch: u32 = 65026;
pub const IBUS_ISO_Level3_Shift: u32 = 65027;
pub const IBUS_ISO_Level3_Latch: u32 = 65028;
pub const IBUS_ISO_Level3_Lock: u32 = 65029;
pub const IBUS_ISO_Level5_Shift: u32 = 65041;
pub const IBUS_ISO_Level5_Latch: u32 = 65042;
pub const IBUS_ISO_Level5_Lock: u32 = 65043;
pub const IBUS_ISO_Group_Shift: u32 = 65406;
pub const IBUS_ISO_Group_Latch: u32 = 65030;
pub const IBUS_ISO_Group_Lock: u32 = 65031;
pub const IBUS_ISO_Next_Group: u32 = 65032;
pub const IBUS_ISO_Next_Group_Lock: u32 = 65033;
pub const IBUS_ISO_Prev_Group: u32 = 65034;
pub const IBUS_ISO_Prev_Group_Lock: u32 = 65035;
pub const IBUS_ISO_First_Group: u32 = 65036;
pub const IBUS_ISO_First_Group_Lock: u32 = 65037;
pub const IBUS_ISO_Last_Group: u32 = 65038;
pub const IBUS_ISO_Last_Group_Lock: u32 = 65039;
pub const IBUS_ISO_Left_Tab: u32 = 65056;
pub const IBUS_ISO_Move_Line_Up: u32 = 65057;
pub const IBUS_ISO_Move_Line_Down: u32 = 65058;
pub const IBUS_ISO_Partial_Line_Up: u32 = 65059;
pub const IBUS_ISO_Partial_Line_Down: u32 = 65060;
pub const IBUS_ISO_Partial_Space_Left: u32 = 65061;
pub const IBUS_ISO_Partial_Space_Right: u32 = 65062;
pub const IBUS_ISO_Set_Margin_Left: u32 = 65063;
pub const IBUS_ISO_Set_Margin_Right: u32 = 65064;
pub const IBUS_ISO_Release_Margin_Left: u32 = 65065;
pub const IBUS_ISO_Release_Margin_Right: u32 = 65066;
pub const IBUS_ISO_Release_Both_Margins: u32 = 65067;
pub const IBUS_ISO_Fast_Cursor_Left: u32 = 65068;
pub const IBUS_ISO_Fast_Cursor_Right: u32 = 65069;
pub const IBUS_ISO_Fast_Cursor_Up: u32 = 65070;
pub const IBUS_ISO_Fast_Cursor_Down: u32 = 65071;
pub const IBUS_ISO_Continuous_Underline: u32 = 65072;
pub const IBUS_ISO_Discontinuous_Underline: u32 = 65073;
pub const IBUS_ISO_Emphasize: u32 = 65074;
pub const IBUS_ISO_Center_Object: u32 = 65075;
pub const IBUS_ISO_Enter: u32 = 65076;
pub const IBUS_dead_grave: u32 = 65104;
pub const IBUS_dead_acute: u32 = 65105;
pub const IBUS_dead_circumflex: u32 = 65106;
pub const IBUS_dead_tilde: u32 = 65107;
pub const IBUS_dead_perispomeni: u32 = 65107;
pub const IBUS_dead_macron: u32 = 65108;
pub const IBUS_dead_breve: u32 = 65109;
pub const IBUS_dead_abovedot: u32 = 65110;
pub const IBUS_dead_diaeresis: u32 = 65111;
pub const IBUS_dead_abovering: u32 = 65112;
pub const IBUS_dead_doubleacute: u32 = 65113;
pub const IBUS_dead_caron: u32 = 65114;
pub const IBUS_dead_cedilla: u32 = 65115;
pub const IBUS_dead_ogonek: u32 = 65116;
pub const IBUS_dead_iota: u32 = 65117;
pub const IBUS_dead_voiced_sound: u32 = 65118;
pub const IBUS_dead_semivoiced_sound: u32 = 65119;
pub const IBUS_dead_belowdot: u32 = 65120;
pub const IBUS_dead_hook: u32 = 65121;
pub const IBUS_dead_horn: u32 = 65122;
pub const IBUS_dead_stroke: u32 = 65123;
pub const IBUS_dead_abovecomma: u32 = 65124;
pub const IBUS_dead_psili: u32 = 65124;
pub const IBUS_dead_abovereversedcomma: u32 = 65125;
pub const IBUS_dead_dasia: u32 = 65125;
pub const IBUS_dead_belowring: u32 = 65127;
pub const IBUS_dead_belowmacron: u32 = 65128;
pub const IBUS_dead_belowcircumflex: u32 = 65129;
pub const IBUS_dead_belowtilde: u32 = 65130;
pub const IBUS_dead_belowbreve: u32 = 65131;
pub const IBUS_dead_belowdiaeresis: u32 = 65132;
pub const IBUS_First_Virtual_Screen: u32 = 65232;
pub const IBUS_Prev_Virtual_Screen: u32 = 65233;
pub const IBUS_Next_Virtual_Screen: u32 = 65234;
pub const IBUS_Last_Virtual_Screen: u32 = 65236;
pub const IBUS_Terminate_Server: u32 = 65237;
pub const IBUS_AccessX_Enable: u32 = 65136;
pub const IBUS_AccessX_Feedback_Enable: u32 = 65137;
pub const IBUS_RepeatKeys_Enable: u32 = 65138;
pub const IBUS_SlowKeys_Enable: u32 = 65139;
pub const IBUS_BounceKeys_Enable: u32 = 65140;
pub const IBUS_StickyKeys_Enable: u32 = 65141;
pub const IBUS_MouseKeys_Enable: u32 = 65142;
pub const IBUS_MouseKeys_Accel_Enable: u32 = 65143;
pub const IBUS_Overlay1_Enable: u32 = 65144;
pub const IBUS_Overlay2_Enable: u32 = 65145;
pub const IBUS_AudibleBell_Enable: u32 = 65146;
pub const IBUS_Pointer_Left: u32 = 65248;
pub const IBUS_Pointer_Right: u32 = 65249;
pub const IBUS_Pointer_Up: u32 = 65250;
pub const IBUS_Pointer_Down: u32 = 65251;
pub const IBUS_Pointer_UpLeft: u32 = 65252;
pub const IBUS_Pointer_UpRight: u32 = 65253;
pub const IBUS_Pointer_DownLeft: u32 = 65254;
pub const IBUS_Pointer_DownRight: u32 = 65255;
pub const IBUS_Pointer_Button_Dflt: u32 = 65256;
pub const IBUS_Pointer_Button1: u32 = 65257;
pub const IBUS_Pointer_Button2: u32 = 65258;
pub const IBUS_Pointer_Button3: u32 = 65259;
pub const IBUS_Pointer_Button4: u32 = 65260;
pub const IBUS_Pointer_Button5: u32 = 65261;
pub const IBUS_Pointer_DblClick_Dflt: u32 = 65262;
pub const IBUS_Pointer_DblClick1: u32 = 65263;
pub const IBUS_Pointer_DblClick2: u32 = 65264;
pub const IBUS_Pointer_DblClick3: u32 = 65265;
pub const IBUS_Pointer_DblClick4: u32 = 65266;
pub const IBUS_Pointer_DblClick5: u32 = 65267;
pub const IBUS_Pointer_Drag_Dflt: u32 = 65268;
pub const IBUS_Pointer_Drag1: u32 = 65269;
pub const IBUS_Pointer_Drag2: u32 = 65270;
pub const IBUS_Pointer_Drag3: u32 = 65271;
pub const IBUS_Pointer_Drag4: u32 = 65272;
pub const IBUS_Pointer_Drag5: u32 = 65277;
pub const IBUS_Pointer_EnableKeys: u32 = 65273;
pub const IBUS_Pointer_Accelerate: u32 = 65274;
pub const IBUS_Pointer_DfltBtnNext: u32 = 65275;
pub const IBUS_Pointer_DfltBtnPrev: u32 = 65276;
pub const IBUS_3270_Duplicate: u32 = 64769;
pub const IBUS_3270_FieldMark: u32 = 64770;
pub const IBUS_3270_Right2: u32 = 64771;
pub const IBUS_3270_Left2: u32 = 64772;
pub const IBUS_3270_BackTab: u32 = 64773;
pub const IBUS_3270_EraseEOF: u32 = 64774;
pub const IBUS_3270_EraseInput: u32 = 64775;
pub const IBUS_3270_Reset: u32 = 64776;
pub const IBUS_3270_Quit: u32 = 64777;
pub const IBUS_3270_PA1: u32 = 64778;
pub const IBUS_3270_PA2: u32 = 64779;
pub const IBUS_3270_PA3: u32 = 64780;
pub const IBUS_3270_Test: u32 = 64781;
pub const IBUS_3270_Attn: u32 = 64782;
pub const IBUS_3270_CursorBlink: u32 = 64783;
pub const IBUS_3270_AltCursor: u32 = 64784;
pub const IBUS_3270_KeyClick: u32 = 64785;
pub const IBUS_3270_Jump: u32 = 64786;
pub const IBUS_3270_Ident: u32 = 64787;
pub const IBUS_3270_Rule: u32 = 64788;
pub const IBUS_3270_Copy: u32 = 64789;
pub const IBUS_3270_Play: u32 = 64790;
pub const IBUS_3270_Setup: u32 = 64791;
pub const IBUS_3270_Record: u32 = 64792;
pub const IBUS_3270_ChangeScreen: u32 = 64793;
pub const IBUS_3270_DeleteWord: u32 = 64794;
pub const IBUS_3270_ExSelect: u32 = 64795;
pub const IBUS_3270_CursorSelect: u32 = 64796;
pub const IBUS_3270_PrintScreen: u32 = 64797;
pub const IBUS_3270_Enter: u32 = 64798;
pub const IBUS_space: u32 = 32;
pub const IBUS_exclam: u32 = 33;
pub const IBUS_quotedbl: u32 = 34;
pub const IBUS_numbersign: u32 = 35;
pub const IBUS_dollar: u32 = 36;
pub const IBUS_percent: u32 = 37;
pub const IBUS_ampersand: u32 = 38;
pub const IBUS_apostrophe: u32 = 39;
pub const IBUS_quoteright: u32 = 39;
pub const IBUS_parenleft: u32 = 40;
pub const IBUS_parenright: u32 = 41;
pub const IBUS_asterisk: u32 = 42;
pub const IBUS_plus: u32 = 43;
pub const IBUS_comma: u32 = 44;
pub const IBUS_minus: u32 = 45;
pub const IBUS_period: u32 = 46;
pub const IBUS_slash: u32 = 47;
pub const IBUS_0: u32 = 48;
pub const IBUS_1: u32 = 49;
pub const IBUS_2: u32 = 50;
pub const IBUS_3: u32 = 51;
pub const IBUS_4: u32 = 52;
pub const IBUS_5: u32 = 53;
pub const IBUS_6: u32 = 54;
pub const IBUS_7: u32 = 55;
pub const IBUS_8: u32 = 56;
pub const IBUS_9: u32 = 57;
pub const IBUS_colon: u32 = 58;
pub const IBUS_semicolon: u32 = 59;
pub const IBUS_less: u32 = 60;
pub const IBUS_equal: u32 = 61;
pub const IBUS_greater: u32 = 62;
pub const IBUS_question: u32 = 63;
pub const IBUS_at: u32 = 64;
pub const IBUS_A: u32 = 65;
pub const IBUS_B: u32 = 66;
pub const IBUS_C: u32 = 67;
pub const IBUS_D: u32 = 68;
pub const IBUS_E: u32 = 69;
pub const IBUS_F: u32 = 70;
pub const IBUS_G: u32 = 71;
pub const IBUS_H: u32 = 72;
pub const IBUS_I: u32 = 73;
pub const IBUS_J: u32 = 74;
pub const IBUS_K: u32 = 75;
pub const IBUS_L: u32 = 76;
pub const IBUS_M: u32 = 77;
pub const IBUS_N: u32 = 78;
pub const IBUS_O: u32 = 79;
pub const IBUS_P: u32 = 80;
pub const IBUS_Q: u32 = 81;
pub const IBUS_R: u32 = 82;
pub const IBUS_S: u32 = 83;
pub const IBUS_T: u32 = 84;
pub const IBUS_U: u32 = 85;
pub const IBUS_V: u32 = 86;
pub const IBUS_W: u32 = 87;
pub const IBUS_X: u32 = 88;
pub const IBUS_Y: u32 = 89;
pub const IBUS_Z: u32 = 90;
pub const IBUS_bracketleft: u32 = 91;
pub const IBUS_backslash: u32 = 92;
pub const IBUS_bracketright: u32 = 93;
pub const IBUS_asciicircum: u32 = 94;
pub const IBUS_underscore: u32 = 95;
pub const IBUS_grave: u32 = 96;
pub const IBUS_quoteleft: u32 = 96;
pub const IBUS_a: u32 = 97;
pub const IBUS_b: u32 = 98;
pub const IBUS_c: u32 = 99;
pub const IBUS_d: u32 = 100;
pub const IBUS_e: u32 = 101;
pub const IBUS_f: u32 = 102;
pub const IBUS_g: u32 = 103;
pub const IBUS_h: u32 = 104;
pub const IBUS_i: u32 = 105;
pub const IBUS_j: u32 = 106;
pub const IBUS_k: u32 = 107;
pub const IBUS_l: u32 = 108;
pub const IBUS_m: u32 = 109;
pub const IBUS_n: u32 = 110;
pub const IBUS_o: u32 = 111;
pub const IBUS_p: u32 = 112;
pub const IBUS_q: u32 = 113;
pub const IBUS_r: u32 = 114;
pub const IBUS_s: u32 = 115;
pub const IBUS_t: u32 = 116;
pub const IBUS_u: u32 = 117;
pub const IBUS_v: u32 = 118;
pub const IBUS_w: u32 = 119;
pub const IBUS_x: u32 = 120;
pub const IBUS_y: u32 = 121;
pub const IBUS_z: u32 = 122;
pub const IBUS_braceleft: u32 = 123;
pub const IBUS_bar: u32 = 124;
pub const IBUS_braceright: u32 = 125;
pub const IBUS_asciitilde: u32 = 126;
pub const IBUS_nobreakspace: u32 = 160;
pub const IBUS_exclamdown: u32 = 161;
pub const IBUS_cent: u32 = 162;
pub const IBUS_sterling: u32 = 163;
pub const IBUS_currency: u32 = 164;
pub const IBUS_yen: u32 = 165;
pub const IBUS_brokenbar: u32 = 166;
pub const IBUS_section: u32 = 167;
pub const IBUS_diaeresis: u32 = 168;
pub const IBUS_copyright: u32 = 169;
pub const IBUS_ordfeminine: u32 = 170;
pub const IBUS_guillemotleft: u32 = 171;
pub const IBUS_notsign: u32 = 172;
pub const IBUS_hyphen: u32 = 173;
pub const IBUS_registered: u32 = 174;
pub const IBUS_macron: u32 = 175;
pub const IBUS_degree: u32 = 176;
pub const IBUS_plusminus: u32 = 177;
pub const IBUS_twosuperior: u32 = 178;
pub const IBUS_threesuperior: u32 = 179;
pub const IBUS_acute: u32 = 180;
pub const IBUS_mu: u32 = 181;
pub const IBUS_paragraph: u32 = 182;
pub const IBUS_periodcentered: u32 = 183;
pub const IBUS_cedilla: u32 = 184;
pub const IBUS_onesuperior: u32 = 185;
pub const IBUS_masculine: u32 = 186;
pub const IBUS_guillemotright: u32 = 187;
pub const IBUS_onequarter: u32 = 188;
pub const IBUS_onehalf: u32 = 189;
pub const IBUS_threequarters: u32 = 190;
pub const IBUS_questiondown: u32 = 191;
pub const IBUS_Agrave: u32 = 192;
pub const IBUS_Aacute: u32 = 193;
pub const IBUS_Acircumflex: u32 = 194;
pub const IBUS_Atilde: u32 = 195;
pub const IBUS_Adiaeresis: u32 = 196;
pub const IBUS_Aring: u32 = 197;
pub const IBUS_AE: u32 = 198;
pub const IBUS_Ccedilla: u32 = 199;
pub const IBUS_Egrave: u32 = 200;
pub const IBUS_Eacute: u32 = 201;
pub const IBUS_Ecircumflex: u32 = 202;
pub const IBUS_Ediaeresis: u32 = 203;
pub const IBUS_Igrave: u32 = 204;
pub const IBUS_Iacute: u32 = 205;
pub const IBUS_Icircumflex: u32 = 206;
pub const IBUS_Idiaeresis: u32 = 207;
pub const IBUS_ETH: u32 = 208;
pub const IBUS_Eth: u32 = 208;
pub const IBUS_Ntilde: u32 = 209;
pub const IBUS_Ograve: u32 = 210;
pub const IBUS_Oacute: u32 = 211;
pub const IBUS_Ocircumflex: u32 = 212;
pub const IBUS_Otilde: u32 = 213;
pub const IBUS_Odiaeresis: u32 = 214;
pub const IBUS_multiply: u32 = 215;
pub const IBUS_Oslash: u32 = 216;
pub const IBUS_Ooblique: u32 = 216;
pub const IBUS_Ugrave: u32 = 217;
pub const IBUS_Uacute: u32 = 218;
pub const IBUS_Ucircumflex: u32 = 219;
pub const IBUS_Udiaeresis: u32 = 220;
pub const IBUS_Yacute: u32 = 221;
pub const IBUS_THORN: u32 = 222;
pub const IBUS_Thorn: u32 = 222;
pub const IBUS_ssharp: u32 = 223;
pub const IBUS_agrave: u32 = 224;
pub const IBUS_aacute: u32 = 225;
pub const IBUS_acircumflex: u32 = 226;
pub const IBUS_atilde: u32 = 227;
pub const IBUS_adiaeresis: u32 = 228;
pub const IBUS_aring: u32 = 229;
pub const IBUS_ae: u32 = 230;
pub const IBUS_ccedilla: u32 = 231;
pub const IBUS_egrave: u32 = 232;
pub const IBUS_eacute: u32 = 233;
pub const IBUS_ecircumflex: u32 = 234;
pub const IBUS_ediaeresis: u32 = 235;
pub const IBUS_igrave: u32 = 236;
pub const IBUS_iacute: u32 = 237;
pub const IBUS_icircumflex: u32 = 238;
pub const IBUS_idiaeresis: u32 = 239;
pub const IBUS_eth: u32 = 240;
pub const IBUS_ntilde: u32 = 241;
pub const IBUS_ograve: u32 = 242;
pub const IBUS_oacute: u32 = 243;
pub const IBUS_ocircumflex: u32 = 244;
pub const IBUS_otilde: u32 = 245;
pub const IBUS_odiaeresis: u32 = 246;
pub const IBUS_division: u32 = 247;
pub const IBUS_oslash: u32 = 248;
pub const IBUS_ooblique: u32 = 248;
pub const IBUS_ugrave: u32 = 249;
pub const IBUS_uacute: u32 = 250;
pub const IBUS_ucircumflex: u32 = 251;
pub const IBUS_udiaeresis: u32 = 252;
pub const IBUS_yacute: u32 = 253;
pub const IBUS_thorn: u32 = 254;
pub const IBUS_ydiaeresis: u32 = 255;
pub const IBUS_Aogonek: u32 = 417;
pub const IBUS_breve: u32 = 418;
pub const IBUS_Lstroke: u32 = 419;
pub const IBUS_Lcaron: u32 = 421;
pub const IBUS_Sacute: u32 = 422;
pub const IBUS_Scaron: u32 = 425;
pub const IBUS_Scedilla: u32 = 426;
pub const IBUS_Tcaron: u32 = 427;
pub const IBUS_Zacute: u32 = 428;
pub const IBUS_Zcaron: u32 = 430;
pub const IBUS_Zabovedot: u32 = 431;
pub const IBUS_aogonek: u32 = 433;
pub const IBUS_ogonek: u32 = 434;
pub const IBUS_lstroke: u32 = 435;
pub const IBUS_lcaron: u32 = 437;
pub const IBUS_sacute: u32 = 438;
pub const IBUS_caron: u32 = 439;
pub const IBUS_scaron: u32 = 441;
pub const IBUS_scedilla: u32 = 442;
pub const IBUS_tcaron: u32 = 443;
pub const IBUS_zacute: u32 = 444;
pub const IBUS_doubleacute: u32 = 445;
pub const IBUS_zcaron: u32 = 446;
pub const IBUS_zabovedot: u32 = 447;
pub const IBUS_Racute: u32 = 448;
pub const IBUS_Abreve: u32 = 451;
pub const IBUS_Lacute: u32 = 453;
pub const IBUS_Cacute: u32 = 454;
pub const IBUS_Ccaron: u32 = 456;
pub const IBUS_Eogonek: u32 = 458;
pub const IBUS_Ecaron: u32 = 460;
pub const IBUS_Dcaron: u32 = 463;
pub const IBUS_Dstroke: u32 = 464;
pub const IBUS_Nacute: u32 = 465;
pub const IBUS_Ncaron: u32 = 466;
pub const IBUS_Odoubleacute: u32 = 469;
pub const IBUS_Rcaron: u32 = 472;
pub const IBUS_Uring: u32 = 473;
pub const IBUS_Udoubleacute: u32 = 475;
pub const IBUS_Tcedilla: u32 = 478;
pub const IBUS_racute: u32 = 480;
pub const IBUS_abreve: u32 = 483;
pub const IBUS_lacute: u32 = 485;
pub const IBUS_cacute: u32 = 486;
pub const IBUS_ccaron: u32 = 488;
pub const IBUS_eogonek: u32 = 490;
pub const IBUS_ecaron: u32 = 492;
pub const IBUS_dcaron: u32 = 495;
pub const IBUS_dstroke: u32 = 496;
pub const IBUS_nacute: u32 = 497;
pub const IBUS_ncaron: u32 = 498;
pub const IBUS_odoubleacute: u32 = 501;
pub const IBUS_udoubleacute: u32 = 507;
pub const IBUS_rcaron: u32 = 504;
pub const IBUS_uring: u32 = 505;
pub const IBUS_tcedilla: u32 = 510;
pub const IBUS_abovedot: u32 = 511;
pub const IBUS_Hstroke: u32 = 673;
pub const IBUS_Hcircumflex: u32 = 678;
pub const IBUS_Iabovedot: u32 = 681;
pub const IBUS_Gbreve: u32 = 683;
pub const IBUS_Jcircumflex: u32 = 684;
pub const IBUS_hstroke: u32 = 689;
pub const IBUS_hcircumflex: u32 = 694;
pub const IBUS_idotless: u32 = 697;
pub const IBUS_gbreve: u32 = 699;
pub const IBUS_jcircumflex: u32 = 700;
pub const IBUS_Cabovedot: u32 = 709;
pub const IBUS_Ccircumflex: u32 = 710;
pub const IBUS_Gabovedot: u32 = 725;
pub const IBUS_Gcircumflex: u32 = 728;
pub const IBUS_Ubreve: u32 = 733;
pub const IBUS_Scircumflex: u32 = 734;
pub const IBUS_cabovedot: u32 = 741;
pub const IBUS_ccircumflex: u32 = 742;
pub const IBUS_gabovedot: u32 = 757;
pub const IBUS_gcircumflex: u32 = 760;
pub const IBUS_ubreve: u32 = 765;
pub const IBUS_scircumflex: u32 = 766;
pub const IBUS_kra: u32 = 930;
pub const IBUS_kappa: u32 = 930;
pub const IBUS_Rcedilla: u32 = 931;
pub const IBUS_Itilde: u32 = 933;
pub const IBUS_Lcedilla: u32 = 934;
pub const IBUS_Emacron: u32 = 938;
pub const IBUS_Gcedilla: u32 = 939;
pub const IBUS_Tslash: u32 = 940;
pub const IBUS_rcedilla: u32 = 947;
pub const IBUS_itilde: u32 = 949;
pub const IBUS_lcedilla: u32 = 950;
pub const IBUS_emacron: u32 = 954;
pub const IBUS_gcedilla: u32 = 955;
pub const IBUS_tslash: u32 = 956;
pub const IBUS_ENG: u32 = 957;
pub const IBUS_eng: u32 = 959;
pub const IBUS_Amacron: u32 = 960;
pub const IBUS_Iogonek: u32 = 967;
pub const IBUS_Eabovedot: u32 = 972;
pub const IBUS_Imacron: u32 = 975;
pub const IBUS_Ncedilla: u32 = 977;
pub const IBUS_Omacron: u32 = 978;
pub const IBUS_Kcedilla: u32 = 979;
pub const IBUS_Uogonek: u32 = 985;
pub const IBUS_Utilde: u32 = 989;
pub const IBUS_Umacron: u32 = 990;
pub const IBUS_amacron: u32 = 992;
pub const IBUS_iogonek: u32 = 999;
pub const IBUS_eabovedot: u32 = 1004;
pub const IBUS_imacron: u32 = 1007;
pub const IBUS_ncedilla: u32 = 1009;
pub const IBUS_omacron: u32 = 1010;
pub const IBUS_kcedilla: u32 = 1011;
pub const IBUS_uogonek: u32 = 1017;
pub const IBUS_utilde: u32 = 1021;
pub const IBUS_umacron: u32 = 1022;
pub const IBUS_Babovedot: u32 = 16784898;
pub const IBUS_babovedot: u32 = 16784899;
pub const IBUS_Dabovedot: u32 = 16784906;
pub const IBUS_Wgrave: u32 = 16785024;
pub const IBUS_Wacute: u32 = 16785026;
pub const IBUS_dabovedot: u32 = 16784907;
pub const IBUS_Ygrave: u32 = 16785138;
pub const IBUS_Fabovedot: u32 = 16784926;
pub const IBUS_fabovedot: u32 = 16784927;
pub const IBUS_Mabovedot: u32 = 16784960;
pub const IBUS_mabovedot: u32 = 16784961;
pub const IBUS_Pabovedot: u32 = 16784982;
pub const IBUS_wgrave: u32 = 16785025;
pub const IBUS_pabovedot: u32 = 16784983;
pub const IBUS_wacute: u32 = 16785027;
pub const IBUS_Sabovedot: u32 = 16784992;
pub const IBUS_ygrave: u32 = 16785139;
pub const IBUS_Wdiaeresis: u32 = 16785028;
pub const IBUS_wdiaeresis: u32 = 16785029;
pub const IBUS_sabovedot: u32 = 16784993;
pub const IBUS_Wcircumflex: u32 = 16777588;
pub const IBUS_Tabovedot: u32 = 16785002;
pub const IBUS_Ycircumflex: u32 = 16777590;
pub const IBUS_wcircumflex: u32 = 16777589;
pub const IBUS_tabovedot: u32 = 16785003;
pub const IBUS_ycircumflex: u32 = 16777591;
pub const IBUS_OE: u32 = 5052;
pub const IBUS_oe: u32 = 5053;
pub const IBUS_Ydiaeresis: u32 = 5054;
pub const IBUS_overline: u32 = 1150;
pub const IBUS_kana_fullstop: u32 = 1185;
pub const IBUS_kana_openingbracket: u32 = 1186;
pub const IBUS_kana_closingbracket: u32 = 1187;
pub const IBUS_kana_comma: u32 = 1188;
pub const IBUS_kana_conjunctive: u32 = 1189;
pub const IBUS_kana_middledot: u32 = 1189;
pub const IBUS_kana_WO: u32 = 1190;
pub const IBUS_kana_a: u32 = 1191;
pub const IBUS_kana_i: u32 = 1192;
pub const IBUS_kana_u: u32 = 1193;
pub const IBUS_kana_e: u32 = 1194;
pub const IBUS_kana_o: u32 = 1195;
pub const IBUS_kana_ya: u32 = 1196;
pub const IBUS_kana_yu: u32 = 1197;
pub const IBUS_kana_yo: u32 = 1198;
pub const IBUS_kana_tsu: u32 = 1199;
pub const IBUS_kana_tu: u32 = 1199;
pub const IBUS_prolongedsound: u32 = 1200;
pub const IBUS_kana_A: u32 = 1201;
pub const IBUS_kana_I: u32 = 1202;
pub const IBUS_kana_U: u32 = 1203;
pub const IBUS_kana_E: u32 = 1204;
pub const IBUS_kana_O: u32 = 1205;
pub const IBUS_kana_KA: u32 = 1206;
pub const IBUS_kana_KI: u32 = 1207;
pub const IBUS_kana_KU: u32 = 1208;
pub const IBUS_kana_KE: u32 = 1209;
pub const IBUS_kana_KO: u32 = 1210;
pub const IBUS_kana_SA: u32 = 1211;
pub const IBUS_kana_SHI: u32 = 1212;
pub const IBUS_kana_SU: u32 = 1213;
pub const IBUS_kana_SE: u32 = 1214;
pub const IBUS_kana_SO: u32 = 1215;
pub const IBUS_kana_TA: u32 = 1216;
pub const IBUS_kana_CHI: u32 = 1217;
pub const IBUS_kana_TI: u32 = 1217;
pub const IBUS_kana_TSU: u32 = 1218;
pub const IBUS_kana_TU: u32 = 1218;
pub const IBUS_kana_TE: u32 = 1219;
pub const IBUS_kana_TO: u32 = 1220;
pub const IBUS_kana_NA: u32 = 1221;
pub const IBUS_kana_NI: u32 = 1222;
pub const IBUS_kana_NU: u32 = 1223;
pub const IBUS_kana_NE: u32 = 1224;
pub const IBUS_kana_NO: u32 = 1225;
pub const IBUS_kana_HA: u32 = 1226;
pub const IBUS_kana_HI: u32 = 1227;
pub const IBUS_kana_FU: u32 = 1228;
pub const IBUS_kana_HU: u32 = 1228;
pub const IBUS_kana_HE: u32 = 1229;
pub const IBUS_kana_HO: u32 = 1230;
pub const IBUS_kana_MA: u32 = 1231;
pub const IBUS_kana_MI: u32 = 1232;
pub const IBUS_kana_MU: u32 = 1233;
pub const IBUS_kana_ME: u32 = 1234;
pub const IBUS_kana_MO: u32 = 1235;
pub const IBUS_kana_YA: u32 = 1236;
pub const IBUS_kana_YU: u32 = 1237;
pub const IBUS_kana_YO: u32 = 1238;
pub const IBUS_kana_RA: u32 = 1239;
pub const IBUS_kana_RI: u32 = 1240;
pub const IBUS_kana_RU: u32 = 1241;
pub const IBUS_kana_RE: u32 = 1242;
pub const IBUS_kana_RO: u32 = 1243;
pub const IBUS_kana_WA: u32 = 1244;
pub const IBUS_kana_N: u32 = 1245;
pub const IBUS_voicedsound: u32 = 1246;
pub const IBUS_semivoicedsound: u32 = 1247;
pub const IBUS_kana_switch: u32 = 65406;
pub const IBUS_Farsi_0: u32 = 16778992;
pub const IBUS_Farsi_1: u32 = 16778993;
pub const IBUS_Farsi_2: u32 = 16778994;
pub const IBUS_Farsi_3: u32 = 16778995;
pub const IBUS_Farsi_4: u32 = 16778996;
pub const IBUS_Farsi_5: u32 = 16778997;
pub const IBUS_Farsi_6: u32 = 16778998;
pub const IBUS_Farsi_7: u32 = 16778999;
pub const IBUS_Farsi_8: u32 = 16779000;
pub const IBUS_Farsi_9: u32 = 16779001;
pub const IBUS_Arabic_percent: u32 = 16778858;
pub const IBUS_Arabic_superscript_alef: u32 = 16778864;
pub const IBUS_Arabic_tteh: u32 = 16778873;
pub const IBUS_Arabic_peh: u32 = 16778878;
pub const IBUS_Arabic_tcheh: u32 = 16778886;
pub const IBUS_Arabic_ddal: u32 = 16778888;
pub const IBUS_Arabic_rreh: u32 = 16778897;
pub const IBUS_Arabic_comma: u32 = 1452;
pub const IBUS_Arabic_fullstop: u32 = 16778964;
pub const IBUS_Arabic_0: u32 = 16778848;
pub const IBUS_Arabic_1: u32 = 16778849;
pub const IBUS_Arabic_2: u32 = 16778850;
pub const IBUS_Arabic_3: u32 = 16778851;
pub const IBUS_Arabic_4: u32 = 16778852;
pub const IBUS_Arabic_5: u32 = 16778853;
pub const IBUS_Arabic_6: u32 = 16778854;
pub const IBUS_Arabic_7: u32 = 16778855;
pub const IBUS_Arabic_8: u32 = 16778856;
pub const IBUS_Arabic_9: u32 = 16778857;
pub const IBUS_Arabic_semicolon: u32 = 1467;
pub const IBUS_Arabic_question_mark: u32 = 1471;
pub const IBUS_Arabic_hamza: u32 = 1473;
pub const IBUS_Arabic_maddaonalef: u32 = 1474;
pub const IBUS_Arabic_hamzaonalef: u32 = 1475;
pub const IBUS_Arabic_hamzaonwaw: u32 = 1476;
pub const IBUS_Arabic_hamzaunderalef: u32 = 1477;
pub const IBUS_Arabic_hamzaonyeh: u32 = 1478;
pub const IBUS_Arabic_alef: u32 = 1479;
pub const IBUS_Arabic_beh: u32 = 1480;
pub const IBUS_Arabic_tehmarbuta: u32 = 1481;
pub const IBUS_Arabic_teh: u32 = 1482;
pub const IBUS_Arabic_theh: u32 = 1483;
pub const IBUS_Arabic_jeem: u32 = 1484;
pub const IBUS_Arabic_hah: u32 = 1485;
pub const IBUS_Arabic_khah: u32 = 1486;
pub const IBUS_Arabic_dal: u32 = 1487;
pub const IBUS_Arabic_thal: u32 = 1488;
pub const IBUS_Arabic_ra: u32 = 1489;
pub const IBUS_Arabic_zain: u32 = 1490;
pub const IBUS_Arabic_seen: u32 = 1491;
pub const IBUS_Arabic_sheen: u32 = 1492;
pub const IBUS_Arabic_sad: u32 = 1493;
pub const IBUS_Arabic_dad: u32 = 1494;
pub const IBUS_Arabic_tah: u32 = 1495;
pub const IBUS_Arabic_zah: u32 = 1496;
pub const IBUS_Arabic_ain: u32 = 1497;
pub const IBUS_Arabic_ghain: u32 = 1498;
pub const IBUS_Arabic_tatweel: u32 = 1504;
pub const IBUS_Arabic_feh: u32 = 1505;
pub const IBUS_Arabic_qaf: u32 = 1506;
pub const IBUS_Arabic_kaf: u32 = 1507;
pub const IBUS_Arabic_lam: u32 = 1508;
pub const IBUS_Arabic_meem: u32 = 1509;
pub const IBUS_Arabic_noon: u32 = 1510;
pub const IBUS_Arabic_ha: u32 = 1511;
pub const IBUS_Arabic_heh: u32 = 1511;
pub const IBUS_Arabic_waw: u32 = 1512;
pub const IBUS_Arabic_alefmaksura: u32 = 1513;
pub const IBUS_Arabic_yeh: u32 = 1514;
pub const IBUS_Arabic_fathatan: u32 = 1515;
pub const IBUS_Arabic_dammatan: u32 = 1516;
pub const IBUS_Arabic_kasratan: u32 = 1517;
pub const IBUS_Arabic_fatha: u32 = 1518;
pub const IBUS_Arabic_damma: u32 = 1519;
pub const IBUS_Arabic_kasra: u32 = 1520;
pub const IBUS_Arabic_shadda: u32 = 1521;
pub const IBUS_Arabic_sukun: u32 = 1522;
pub const IBUS_Arabic_madda_above: u32 = 16778835;
pub const IBUS_Arabic_hamza_above: u32 = 16778836;
pub const IBUS_Arabic_hamza_below: u32 = 16778837;
pub const IBUS_Arabic_jeh: u32 = 16778904;
pub const IBUS_Arabic_veh: u32 = 16778916;
pub const IBUS_Arabic_keheh: u32 = 16778921;
pub const IBUS_Arabic_gaf: u32 = 16778927;
pub const IBUS_Arabic_noon_ghunna: u32 = 16778938;
pub const IBUS_Arabic_heh_doachashmee: u32 = 16778942;
pub const IBUS_Farsi_yeh: u32 = 16778956;
pub const IBUS_Arabic_farsi_yeh: u32 = 16778956;
pub const IBUS_Arabic_yeh_baree: u32 = 16778962;
pub const IBUS_Arabic_heh_goal: u32 = 16778945;
pub const IBUS_Arabic_switch: u32 = 65406;
pub const IBUS_Cyrillic_GHE_bar: u32 = 16778386;
pub const IBUS_Cyrillic_ghe_bar: u32 = 16778387;
pub const IBUS_Cyrillic_ZHE_descender: u32 = 16778390;
pub const IBUS_Cyrillic_zhe_descender: u32 = 16778391;
pub const IBUS_Cyrillic_KA_descender: u32 = 16778394;
pub const IBUS_Cyrillic_ka_descender: u32 = 16778395;
pub const IBUS_Cyrillic_KA_vertstroke: u32 = 16778396;
pub const IBUS_Cyrillic_ka_vertstroke: u32 = 16778397;
pub const IBUS_Cyrillic_EN_descender: u32 = 16778402;
pub const IBUS_Cyrillic_en_descender: u32 = 16778403;
pub const IBUS_Cyrillic_U_straight: u32 = 16778414;
pub const IBUS_Cyrillic_u_straight: u32 = 16778415;
pub const IBUS_Cyrillic_U_straight_bar: u32 = 16778416;
pub const IBUS_Cyrillic_u_straight_bar: u32 = 16778417;
pub const IBUS_Cyrillic_HA_descender: u32 = 16778418;
pub const IBUS_Cyrillic_ha_descender: u32 = 16778419;
pub const IBUS_Cyrillic_CHE_descender: u32 = 16778422;
pub const IBUS_Cyrillic_che_descender: u32 = 16778423;
pub const IBUS_Cyrillic_CHE_vertstroke: u32 = 16778424;
pub const IBUS_Cyrillic_che_vertstroke: u32 = 16778425;
pub const IBUS_Cyrillic_SHHA: u32 = 16778426;
pub const IBUS_Cyrillic_shha: u32 = 16778427;
pub const IBUS_Cyrillic_SCHWA: u32 = 16778456;
pub const IBUS_Cyrillic_schwa: u32 = 16778457;
pub const IBUS_Cyrillic_I_macron: u32 = 16778466;
pub const IBUS_Cyrillic_i_macron: u32 = 16778467;
pub const IBUS_Cyrillic_O_bar: u32 = 16778472;
pub const IBUS_Cyrillic_o_bar: u32 = 16778473;
pub const IBUS_Cyrillic_U_macron: u32 = 16778478;
pub const IBUS_Cyrillic_u_macron: u32 = 16778479;
pub const IBUS_Serbian_dje: u32 = 1697;
pub const IBUS_Macedonia_gje: u32 = 1698;
pub const IBUS_Cyrillic_io: u32 = 1699;
pub const IBUS_Ukrainian_ie: u32 = 1700;
pub const IBUS_Ukranian_je: u32 = 1700;
pub const IBUS_Macedonia_dse: u32 = 1701;
pub const IBUS_Ukrainian_i: u32 = 1702;
pub const IBUS_Ukranian_i: u32 = 1702;
pub const IBUS_Ukrainian_yi: u32 = 1703;
pub const IBUS_Ukranian_yi: u32 = 1703;
pub const IBUS_Cyrillic_je: u32 = 1704;
pub const IBUS_Serbian_je: u32 = 1704;
pub const IBUS_Cyrillic_lje: u32 = 1705;
pub const IBUS_Serbian_lje: u32 = 1705;
pub const IBUS_Cyrillic_nje: u32 = 1706;
pub const IBUS_Serbian_nje: u32 = 1706;
pub const IBUS_Serbian_tshe: u32 = 1707;
pub const IBUS_Macedonia_kje: u32 = 1708;
pub const IBUS_Ukrainian_ghe_with_upturn: u32 = 1709;
pub const IBUS_Byelorussian_shortu: u32 = 1710;
pub const IBUS_Cyrillic_dzhe: u32 = 1711;
pub const IBUS_Serbian_dze: u32 = 1711;
pub const IBUS_numerosign: u32 = 1712;
pub const IBUS_Serbian_DJE: u32 = 1713;
pub const IBUS_Macedonia_GJE: u32 = 1714;
pub const IBUS_Cyrillic_IO: u32 = 1715;
pub const IBUS_Ukrainian_IE: u32 = 1716;
pub const IBUS_Ukranian_JE: u32 = 1716;
pub const IBUS_Macedonia_DSE: u32 = 1717;
pub const IBUS_Ukrainian_I: u32 = 1718;
pub const IBUS_Ukranian_I: u32 = 1718;
pub const IBUS_Ukrainian_YI: u32 = 1719;
pub const IBUS_Ukranian_YI: u32 = 1719;
pub const IBUS_Cyrillic_JE: u32 = 1720;
pub const IBUS_Serbian_JE: u32 = 1720;
pub const IBUS_Cyrillic_LJE: u32 = 1721;
pub const IBUS_Serbian_LJE: u32 = 1721;
pub const IBUS_Cyrillic_NJE: u32 = 1722;
pub const IBUS_Serbian_NJE: u32 = 1722;
pub const IBUS_Serbian_TSHE: u32 = 1723;
pub const IBUS_Macedonia_KJE: u32 = 1724;
pub const IBUS_Ukrainian_GHE_WITH_UPTURN: u32 = 1725;
pub const IBUS_Byelorussian_SHORTU: u32 = 1726;
pub const IBUS_Cyrillic_DZHE: u32 = 1727;
pub const IBUS_Serbian_DZE: u32 = 1727;
pub const IBUS_Cyrillic_yu: u32 = 1728;
pub const IBUS_Cyrillic_a: u32 = 1729;
pub const IBUS_Cyrillic_be: u32 = 1730;
pub const IBUS_Cyrillic_tse: u32 = 1731;
pub const IBUS_Cyrillic_de: u32 = 1732;
pub const IBUS_Cyrillic_ie: u32 = 1733;
pub const IBUS_Cyrillic_ef: u32 = 1734;
pub const IBUS_Cyrillic_ghe: u32 = 1735;
pub const IBUS_Cyrillic_ha: u32 = 1736;
pub const IBUS_Cyrillic_i: u32 = 1737;
pub const IBUS_Cyrillic_shorti: u32 = 1738;
pub const IBUS_Cyrillic_ka: u32 = 1739;
pub const IBUS_Cyrillic_el: u32 = 1740;
pub const IBUS_Cyrillic_em: u32 = 1741;
pub const IBUS_Cyrillic_en: u32 = 1742;
pub const IBUS_Cyrillic_o: u32 = 1743;
pub const IBUS_Cyrillic_pe: u32 = 1744;
pub const IBUS_Cyrillic_ya: u32 = 1745;
pub const IBUS_Cyrillic_er: u32 = 1746;
pub const IBUS_Cyrillic_es: u32 = 1747;
pub const IBUS_Cyrillic_te: u32 = 1748;
pub const IBUS_Cyrillic_u: u32 = 1749;
pub const IBUS_Cyrillic_zhe: u32 = 1750;
pub const IBUS_Cyrillic_ve: u32 = 1751;
pub const IBUS_Cyrillic_softsign: u32 = 1752;
pub const IBUS_Cyrillic_yeru: u32 = 1753;
pub const IBUS_Cyrillic_ze: u32 = 1754;
pub const IBUS_Cyrillic_sha: u32 = 1755;
pub const IBUS_Cyrillic_e: u32 = 1756;
pub const IBUS_Cyrillic_shcha: u32 = 1757;
pub const IBUS_Cyrillic_che: u32 = 1758;
pub const IBUS_Cyrillic_hardsign: u32 = 1759;
pub const IBUS_Cyrillic_YU: u32 = 1760;
pub const IBUS_Cyrillic_A: u32 = 1761;
pub const IBUS_Cyrillic_BE: u32 = 1762;
pub const IBUS_Cyrillic_TSE: u32 = 1763;
pub const IBUS_Cyrillic_DE: u32 = 1764;
pub const IBUS_Cyrillic_IE: u32 = 1765;
pub const IBUS_Cyrillic_EF: u32 = 1766;
pub const IBUS_Cyrillic_GHE: u32 = 1767;
pub const IBUS_Cyrillic_HA: u32 = 1768;
pub const IBUS_Cyrillic_I: u32 = 1769;
pub const IBUS_Cyrillic_SHORTI: u32 = 1770;
pub const IBUS_Cyrillic_KA: u32 = 1771;
pub const IBUS_Cyrillic_EL: u32 = 1772;
pub const IBUS_Cyrillic_EM: u32 = 1773;
pub const IBUS_Cyrillic_EN: u32 = 1774;
pub const IBUS_Cyrillic_O: u32 = 1775;
pub const IBUS_Cyrillic_PE: u32 = 1776;
pub const IBUS_Cyrillic_YA: u32 = 1777;
pub const IBUS_Cyrillic_ER: u32 = 1778;
pub const IBUS_Cyrillic_ES: u32 = 1779;
pub const IBUS_Cyrillic_TE: u32 = 1780;
pub const IBUS_Cyrillic_U: u32 = 1781;
pub const IBUS_Cyrillic_ZHE: u32 = 1782;
pub const IBUS_Cyrillic_VE: u32 = 1783;
pub const IBUS_Cyrillic_SOFTSIGN: u32 = 1784;
pub const IBUS_Cyrillic_YERU: u32 = 1785;
pub const IBUS_Cyrillic_ZE: u32 = 1786;
pub const IBUS_Cyrillic_SHA: u32 = 1787;
pub const IBUS_Cyrillic_E: u32 = 1788;
pub const IBUS_Cyrillic_SHCHA: u32 = 1789;
pub const IBUS_Cyrillic_CHE: u32 = 1790;
pub const IBUS_Cyrillic_HARDSIGN: u32 = 1791;
pub const IBUS_Greek_ALPHAaccent: u32 = 1953;
pub const IBUS_Greek_EPSILONaccent: u32 = 1954;
pub const IBUS_Greek_ETAaccent: u32 = 1955;
pub const IBUS_Greek_IOTAaccent: u32 = 1956;
pub const IBUS_Greek_IOTAdieresis: u32 = 1957;
pub const IBUS_Greek_IOTAdiaeresis: u32 = 1957;
pub const IBUS_Greek_OMICRONaccent: u32 = 1959;
pub const IBUS_Greek_UPSILONaccent: u32 = 1960;
pub const IBUS_Greek_UPSILONdieresis: u32 = 1961;
pub const IBUS_Greek_OMEGAaccent: u32 = 1963;
pub const IBUS_Greek_accentdieresis: u32 = 1966;
pub const IBUS_Greek_horizbar: u32 = 1967;
pub const IBUS_Greek_alphaaccent: u32 = 1969;
pub const IBUS_Greek_epsilonaccent: u32 = 1970;
pub const IBUS_Greek_etaaccent: u32 = 1971;
pub const IBUS_Greek_iotaaccent: u32 = 1972;
pub const IBUS_Greek_iotadieresis: u32 = 1973;
pub const IBUS_Greek_iotaaccentdieresis: u32 = 1974;
pub const IBUS_Greek_omicronaccent: u32 = 1975;
pub const IBUS_Greek_upsilonaccent: u32 = 1976;
pub const IBUS_Greek_upsilondieresis: u32 = 1977;
pub const IBUS_Greek_upsilonaccentdieresis: u32 = 1978;
pub const IBUS_Greek_omegaaccent: u32 = 1979;
pub const IBUS_Greek_ALPHA: u32 = 1985;
pub const IBUS_Greek_BETA: u32 = 1986;
pub const IBUS_Greek_GAMMA: u32 = 1987;
pub const IBUS_Greek_DELTA: u32 = 1988;
pub const IBUS_Greek_EPSILON: u32 = 1989;
pub const IBUS_Greek_ZETA: u32 = 1990;
pub const IBUS_Greek_ETA: u32 = 1991;
pub const IBUS_Greek_THETA: u32 = 1992;
pub const IBUS_Greek_IOTA: u32 = 1993;
pub const IBUS_Greek_KAPPA: u32 = 1994;
pub const IBUS_Greek_LAMDA: u32 = 1995;
pub const IBUS_Greek_LAMBDA: u32 = 1995;
pub const IBUS_Greek_MU: u32 = 1996;
pub const IBUS_Greek_NU: u32 = 1997;
pub const IBUS_Greek_XI: u32 = 1998;
pub const IBUS_Greek_OMICRON: u32 = 1999;
pub const IBUS_Greek_PI: u32 = 2000;
pub const IBUS_Greek_RHO: u32 = 2001;
pub const IBUS_Greek_SIGMA: u32 = 2002;
pub const IBUS_Greek_TAU: u32 = 2004;
pub const IBUS_Greek_UPSILON: u32 = 2005;
pub const IBUS_Greek_PHI: u32 = 2006;
pub const IBUS_Greek_CHI: u32 = 2007;
pub const IBUS_Greek_PSI: u32 = 2008;
pub const IBUS_Greek_OMEGA: u32 = 2009;
pub const IBUS_Greek_alpha: u32 = 2017;
pub const IBUS_Greek_beta: u32 = 2018;
pub const IBUS_Greek_gamma: u32 = 2019;
pub const IBUS_Greek_delta: u32 = 2020;
pub const IBUS_Greek_epsilon: u32 = 2021;
pub const IBUS_Greek_zeta: u32 = 2022;
pub const IBUS_Greek_eta: u32 = 2023;
pub const IBUS_Greek_theta: u32 = 2024;
pub const IBUS_Greek_iota: u32 = 2025;
pub const IBUS_Greek_kappa: u32 = 2026;
pub const IBUS_Greek_lamda: u32 = 2027;
pub const IBUS_Greek_lambda: u32 = 2027;
pub const IBUS_Greek_mu: u32 = 2028;
pub const IBUS_Greek_nu: u32 = 2029;
pub const IBUS_Greek_xi: u32 = 2030;
pub const IBUS_Greek_omicron: u32 = 2031;
pub const IBUS_Greek_pi: u32 = 2032;
pub const IBUS_Greek_rho: u32 = 2033;
pub const IBUS_Greek_sigma: u32 = 2034;
pub const IBUS_Greek_finalsmallsigma: u32 = 2035;
pub const IBUS_Greek_tau: u32 = 2036;
pub const IBUS_Greek_upsilon: u32 = 2037;
pub const IBUS_Greek_phi: u32 = 2038;
pub const IBUS_Greek_chi: u32 = 2039;
pub const IBUS_Greek_psi: u32 = 2040;
pub const IBUS_Greek_omega: u32 = 2041;
pub const IBUS_Greek_switch: u32 = 65406;
pub const IBUS_leftradical: u32 = 2209;
pub const IBUS_topleftradical: u32 = 2210;
pub const IBUS_horizconnector: u32 = 2211;
pub const IBUS_topintegral: u32 = 2212;
pub const IBUS_botintegral: u32 = 2213;
pub const IBUS_vertconnector: u32 = 2214;
pub const IBUS_topleftsqbracket: u32 = 2215;
pub const IBUS_botleftsqbracket: u32 = 2216;
pub const IBUS_toprightsqbracket: u32 = 2217;
pub const IBUS_botrightsqbracket: u32 = 2218;
pub const IBUS_topleftparens: u32 = 2219;
pub const IBUS_botleftparens: u32 = 2220;
pub const IBUS_toprightparens: u32 = 2221;
pub const IBUS_botrightparens: u32 = 2222;
pub const IBUS_leftmiddlecurlybrace: u32 = 2223;
pub const IBUS_rightmiddlecurlybrace: u32 = 2224;
pub const IBUS_topleftsummation: u32 = 2225;
pub const IBUS_botleftsummation: u32 = 2226;
pub const IBUS_topvertsummationconnector: u32 = 2227;
pub const IBUS_botvertsummationconnector: u32 = 2228;
pub const IBUS_toprightsummation: u32 = 2229;
pub const IBUS_botrightsummation: u32 = 2230;
pub const IBUS_rightmiddlesummation: u32 = 2231;
pub const IBUS_lessthanequal: u32 = 2236;
pub const IBUS_notequal: u32 = 2237;
pub const IBUS_greaterthanequal: u32 = 2238;
pub const IBUS_integral: u32 = 2239;
pub const IBUS_therefore: u32 = 2240;
pub const IBUS_variation: u32 = 2241;
pub const IBUS_infinity: u32 = 2242;
pub const IBUS_nabla: u32 = 2245;
pub const IBUS_approximate: u32 = 2248;
pub const IBUS_similarequal: u32 = 2249;
pub const IBUS_ifonlyif: u32 = 2253;
pub const IBUS_implies: u32 = 2254;
pub const IBUS_identical: u32 = 2255;
pub const IBUS_radical: u32 = 2262;
pub const IBUS_includedin: u32 = 2266;
pub const IBUS_includes: u32 = 2267;
pub const IBUS_intersection: u32 = 2268;
pub const IBUS_union: u32 = 2269;
pub const IBUS_logicaland: u32 = 2270;
pub const IBUS_logicalor: u32 = 2271;
pub const IBUS_partialderivative: u32 = 2287;
pub const IBUS_function: u32 = 2294;
pub const IBUS_leftarrow: u32 = 2299;
pub const IBUS_uparrow: u32 = 2300;
pub const IBUS_rightarrow: u32 = 2301;
pub const IBUS_downarrow: u32 = 2302;
pub const IBUS_blank: u32 = 2527;
pub const IBUS_soliddiamond: u32 = 2528;
pub const IBUS_checkerboard: u32 = 2529;
pub const IBUS_ht: u32 = 2530;
pub const IBUS_ff: u32 = 2531;
pub const IBUS_cr: u32 = 2532;
pub const IBUS_lf: u32 = 2533;
pub const IBUS_nl: u32 = 2536;
pub const IBUS_vt: u32 = 2537;
pub const IBUS_lowrightcorner: u32 = 2538;
pub const IBUS_uprightcorner: u32 = 2539;
pub const IBUS_upleftcorner: u32 = 2540;
pub const IBUS_lowleftcorner: u32 = 2541;
pub const IBUS_crossinglines: u32 = 2542;
pub const IBUS_horizlinescan1: u32 = 2543;
pub const IBUS_horizlinescan3: u32 = 2544;
pub const IBUS_horizlinescan5: u32 = 2545;
pub const IBUS_horizlinescan7: u32 = 2546;
pub const IBUS_horizlinescan9: u32 = 2547;
pub const IBUS_leftt: u32 = 2548;
pub const IBUS_rightt: u32 = 2549;
pub const IBUS_bott: u32 = 2550;
pub const IBUS_topt: u32 = 2551;
pub const IBUS_vertbar: u32 = 2552;
pub const IBUS_emspace: u32 = 2721;
pub const IBUS_enspace: u32 = 2722;
pub const IBUS_em3space: u32 = 2723;
pub const IBUS_em4space: u32 = 2724;
pub const IBUS_digitspace: u32 = 2725;
pub const IBUS_punctspace: u32 = 2726;
pub const IBUS_thinspace: u32 = 2727;
pub const IBUS_hairspace: u32 = 2728;
pub const IBUS_emdash: u32 = 2729;
pub const IBUS_endash: u32 = 2730;
pub const IBUS_signifblank: u32 = 2732;
pub const IBUS_ellipsis: u32 = 2734;
pub const IBUS_doubbaselinedot: u32 = 2735;
pub const IBUS_onethird: u32 = 2736;
pub const IBUS_twothirds: u32 = 2737;
pub const IBUS_onefifth: u32 = 2738;
pub const IBUS_twofifths: u32 = 2739;
pub const IBUS_threefifths: u32 = 2740;
pub const IBUS_fourfifths: u32 = 2741;
pub const IBUS_onesixth: u32 = 2742;
pub const IBUS_fivesixths: u32 = 2743;
pub const IBUS_careof: u32 = 2744;
pub const IBUS_figdash: u32 = 2747;
pub const IBUS_leftanglebracket: u32 = 2748;
pub const IBUS_decimalpoint: u32 = 2749;
pub const IBUS_rightanglebracket: u32 = 2750;
pub const IBUS_marker: u32 = 2751;
pub const IBUS_oneeighth: u32 = 2755;
pub const IBUS_threeeighths: u32 = 2756;
pub const IBUS_fiveeighths: u32 = 2757;
pub const IBUS_seveneighths: u32 = 2758;
pub const IBUS_trademark: u32 = 2761;
pub const IBUS_signaturemark: u32 = 2762;
pub const IBUS_trademarkincircle: u32 = 2763;
pub const IBUS_leftopentriangle: u32 = 2764;
pub const IBUS_rightopentriangle: u32 = 2765;
pub const IBUS_emopencircle: u32 = 2766;
pub const IBUS_emopenrectangle: u32 = 2767;
pub const IBUS_leftsinglequotemark: u32 = 2768;
pub const IBUS_rightsinglequotemark: u32 = 2769;
pub const IBUS_leftdoublequotemark: u32 = 2770;
pub const IBUS_rightdoublequotemark: u32 = 2771;
pub const IBUS_prescription: u32 = 2772;
pub const IBUS_minutes: u32 = 2774;
pub const IBUS_seconds: u32 = 2775;
pub const IBUS_latincross: u32 = 2777;
pub const IBUS_hexagram: u32 = 2778;
pub const IBUS_filledrectbullet: u32 = 2779;
pub const IBUS_filledlefttribullet: u32 = 2780;
pub const IBUS_filledrighttribullet: u32 = 2781;
pub const IBUS_emfilledcircle: u32 = 2782;
pub const IBUS_emfilledrect: u32 = 2783;
pub const IBUS_enopencircbullet: u32 = 2784;
pub const IBUS_enopensquarebullet: u32 = 2785;
pub const IBUS_openrectbullet: u32 = 2786;
pub const IBUS_opentribulletup: u32 = 2787;
pub const IBUS_opentribulletdown: u32 = 2788;
pub const IBUS_openstar: u32 = 2789;
pub const IBUS_enfilledcircbullet: u32 = 2790;
pub const IBUS_enfilledsqbullet: u32 = 2791;
pub const IBUS_filledtribulletup: u32 = 2792;
pub const IBUS_filledtribulletdown: u32 = 2793;
pub const IBUS_leftpointer: u32 = 2794;
pub const IBUS_rightpointer: u32 = 2795;
pub const IBUS_club: u32 = 2796;
pub const IBUS_diamond: u32 = 2797;
pub const IBUS_heart: u32 = 2798;
pub const IBUS_maltesecross: u32 = 2800;
pub const IBUS_dagger: u32 = 2801;
pub const IBUS_doubledagger: u32 = 2802;
pub const IBUS_checkmark: u32 = 2803;
pub const IBUS_ballotcross: u32 = 2804;
pub const IBUS_musicalsharp: u32 = 2805;
pub const IBUS_musicalflat: u32 = 2806;
pub const IBUS_malesymbol: u32 = 2807;
pub const IBUS_femalesymbol: u32 = 2808;
pub const IBUS_telephone: u32 = 2809;
pub const IBUS_telephonerecorder: u32 = 2810;
pub const IBUS_phonographcopyright: u32 = 2811;
pub const IBUS_caret: u32 = 2812;
pub const IBUS_singlelowquotemark: u32 = 2813;
pub const IBUS_doublelowquotemark: u32 = 2814;
pub const IBUS_cursor: u32 = 2815;
pub const IBUS_leftcaret: u32 = 2979;
pub const IBUS_rightcaret: u32 = 2982;
pub const IBUS_downcaret: u32 = 2984;
pub const IBUS_upcaret: u32 = 2985;
pub const IBUS_overbar: u32 = 3008;
pub const IBUS_downtack: u32 = 3010;
pub const IBUS_upshoe: u32 = 3011;
pub const IBUS_downstile: u32 = 3012;
pub const IBUS_underbar: u32 = 3014;
pub const IBUS_jot: u32 = 3018;
pub const IBUS_quad: u32 = 3020;
pub const IBUS_uptack: u32 = 3022;
pub const IBUS_circle: u32 = 3023;
pub const IBUS_upstile: u32 = 3027;
pub const IBUS_downshoe: u32 = 3030;
pub const IBUS_rightshoe: u32 = 3032;
pub const IBUS_leftshoe: u32 = 3034;
pub const IBUS_lefttack: u32 = 3036;
pub const IBUS_righttack: u32 = 3068;
pub const IBUS_hebrew_doublelowline: u32 = 3295;
pub const IBUS_hebrew_aleph: u32 = 3296;
pub const IBUS_hebrew_bet: u32 = 3297;
pub const IBUS_hebrew_beth: u32 = 3297;
pub const IBUS_hebrew_gimel: u32 = 3298;
pub const IBUS_hebrew_gimmel: u32 = 3298;
pub const IBUS_hebrew_dalet: u32 = 3299;
pub const IBUS_hebrew_daleth: u32 = 3299;
pub const IBUS_hebrew_he: u32 = 3300;
pub const IBUS_hebrew_waw: u32 = 3301;
pub const IBUS_hebrew_zain: u32 = 3302;
pub const IBUS_hebrew_zayin: u32 = 3302;
pub const IBUS_hebrew_chet: u32 = 3303;
pub const IBUS_hebrew_het: u32 = 3303;
pub const IBUS_hebrew_tet: u32 = 3304;
pub const IBUS_hebrew_teth: u32 = 3304;
pub const IBUS_hebrew_yod: u32 = 3305;
pub const IBUS_hebrew_finalkaph: u32 = 3306;
pub const IBUS_hebrew_kaph: u32 = 3307;
pub const IBUS_hebrew_lamed: u32 = 3308;
pub const IBUS_hebrew_finalmem: u32 = 3309;
pub const IBUS_hebrew_mem: u32 = 3310;
pub const IBUS_hebrew_finalnun: u32 = 3311;
pub const IBUS_hebrew_nun: u32 = 3312;
pub const IBUS_hebrew_samech: u32 = 3313;
pub const IBUS_hebrew_samekh: u32 = 3313;
pub const IBUS_hebrew_ayin: u32 = 3314;
pub const IBUS_hebrew_finalpe: u32 = 3315;
pub const IBUS_hebrew_pe: u32 = 3316;
pub const IBUS_hebrew_finalzade: u32 = 3317;
pub const IBUS_hebrew_finalzadi: u32 = 3317;
pub const IBUS_hebrew_zade: u32 = 3318;
pub const IBUS_hebrew_zadi: u32 = 3318;
pub const IBUS_hebrew_qoph: u32 = 3319;
pub const IBUS_hebrew_kuf: u32 = 3319;
pub const IBUS_hebrew_resh: u32 = 3320;
pub const IBUS_hebrew_shin: u32 = 3321;
pub const IBUS_hebrew_taw: u32 = 3322;
pub const IBUS_hebrew_taf: u32 = 3322;
pub const IBUS_Hebrew_switch: u32 = 65406;
pub const IBUS_Thai_kokai: u32 = 3489;
pub const IBUS_Thai_khokhai: u32 = 3490;
pub const IBUS_Thai_khokhuat: u32 = 3491;
pub const IBUS_Thai_khokhwai: u32 = 3492;
pub const IBUS_Thai_khokhon: u32 = 3493;
pub const IBUS_Thai_khorakhang: u32 = 3494;
pub const IBUS_Thai_ngongu: u32 = 3495;
pub const IBUS_Thai_chochan: u32 = 3496;
pub const IBUS_Thai_choching: u32 = 3497;
pub const IBUS_Thai_chochang: u32 = 3498;
pub const IBUS_Thai_soso: u32 = 3499;
pub const IBUS_Thai_chochoe: u32 = 3500;
pub const IBUS_Thai_yoying: u32 = 3501;
pub const IBUS_Thai_dochada: u32 = 3502;
pub const IBUS_Thai_topatak: u32 = 3503;
pub const IBUS_Thai_thothan: u32 = 3504;
pub const IBUS_Thai_thonangmontho: u32 = 3505;
pub const IBUS_Thai_thophuthao: u32 = 3506;
pub const IBUS_Thai_nonen: u32 = 3507;
pub const IBUS_Thai_dodek: u32 = 3508;
pub const IBUS_Thai_totao: u32 = 3509;
pub const IBUS_Thai_thothung: u32 = 3510;
pub const IBUS_Thai_thothahan: u32 = 3511;
pub const IBUS_Thai_thothong: u32 = 3512;
pub const IBUS_Thai_nonu: u32 = 3513;
pub const IBUS_Thai_bobaimai: u32 = 3514;
pub const IBUS_Thai_popla: u32 = 3515;
pub const IBUS_Thai_phophung: u32 = 3516;
pub const IBUS_Thai_fofa: u32 = 3517;
pub const IBUS_Thai_phophan: u32 = 3518;
pub const IBUS_Thai_fofan: u32 = 3519;
pub const IBUS_Thai_phosamphao: u32 = 3520;
pub const IBUS_Thai_moma: u32 = 3521;
pub const IBUS_Thai_yoyak: u32 = 3522;
pub const IBUS_Thai_rorua: u32 = 3523;
pub const IBUS_Thai_ru: u32 = 3524;
pub const IBUS_Thai_loling: u32 = 3525;
pub const IBUS_Thai_lu: u32 = 3526;
pub const IBUS_Thai_wowaen: u32 = 3527;
pub const IBUS_Thai_sosala: u32 = 3528;
pub const IBUS_Thai_sorusi: u32 = 3529;
pub const IBUS_Thai_sosua: u32 = 3530;
pub const IBUS_Thai_hohip: u32 = 3531;
pub const IBUS_Thai_lochula: u32 = 3532;
pub const IBUS_Thai_oang: u32 = 3533;
pub const IBUS_Thai_honokhuk: u32 = 3534;
pub const IBUS_Thai_paiyannoi: u32 = 3535;
pub const IBUS_Thai_saraa: u32 = 3536;
pub const IBUS_Thai_maihanakat: u32 = 3537;
pub const IBUS_Thai_saraaa: u32 = 3538;
pub const IBUS_Thai_saraam: u32 = 3539;
pub const IBUS_Thai_sarai: u32 = 3540;
pub const IBUS_Thai_saraii: u32 = 3541;
pub const IBUS_Thai_saraue: u32 = 3542;
pub const IBUS_Thai_sarauee: u32 = 3543;
pub const IBUS_Thai_sarau: u32 = 3544;
pub const IBUS_Thai_sarauu: u32 = 3545;
pub const IBUS_Thai_phinthu: u32 = 3546;
pub const IBUS_Thai_maihanakat_maitho: u32 = 3550;
pub const IBUS_Thai_baht: u32 = 3551;
pub const IBUS_Thai_sarae: u32 = 3552;
pub const IBUS_Thai_saraae: u32 = 3553;
pub const IBUS_Thai_sarao: u32 = 3554;
pub const IBUS_Thai_saraaimaimuan: u32 = 3555;
pub const IBUS_Thai_saraaimaimalai: u32 = 3556;
pub const IBUS_Thai_lakkhangyao: u32 = 3557;
pub const IBUS_Thai_maiyamok: u32 = 3558;
pub const IBUS_Thai_maitaikhu: u32 = 3559;
pub const IBUS_Thai_maiek: u32 = 3560;
pub const IBUS_Thai_maitho: u32 = 3561;
pub const IBUS_Thai_maitri: u32 = 3562;
pub const IBUS_Thai_maichattawa: u32 = 3563;
pub const IBUS_Thai_thanthakhat: u32 = 3564;
pub const IBUS_Thai_nikhahit: u32 = 3565;
pub const IBUS_Thai_leksun: u32 = 3568;
pub const IBUS_Thai_leknung: u32 = 3569;
pub const IBUS_Thai_leksong: u32 = 3570;
pub const IBUS_Thai_leksam: u32 = 3571;
pub const IBUS_Thai_leksi: u32 = 3572;
pub const IBUS_Thai_lekha: u32 = 3573;
pub const IBUS_Thai_lekhok: u32 = 3574;
pub const IBUS_Thai_lekchet: u32 = 3575;
pub const IBUS_Thai_lekpaet: u32 = 3576;
pub const IBUS_Thai_lekkao: u32 = 3577;
pub const IBUS_Hangul: u32 = 65329;
pub const IBUS_Hangul_Start: u32 = 65330;
pub const IBUS_Hangul_End: u32 = 65331;
pub const IBUS_Hangul_Hanja: u32 = 65332;
pub const IBUS_Hangul_Jamo: u32 = 65333;
pub const IBUS_Hangul_Romaja: u32 = 65334;
pub const IBUS_Hangul_Codeinput: u32 = 65335;
pub const IBUS_Hangul_Jeonja: u32 = 65336;
pub const IBUS_Hangul_Banja: u32 = 65337;
pub const IBUS_Hangul_PreHanja: u32 = 65338;
pub const IBUS_Hangul_PostHanja: u32 = 65339;
pub const IBUS_Hangul_SingleCandidate: u32 = 65340;
pub const IBUS_Hangul_MultipleCandidate: u32 = 65341;
pub const IBUS_Hangul_PreviousCandidate: u32 = 65342;
pub const IBUS_Hangul_Special: u32 = 65343;
pub const IBUS_Hangul_switch: u32 = 65406;
pub const IBUS_Hangul_Kiyeog: u32 = 3745;
pub const IBUS_Hangul_SsangKiyeog: u32 = 3746;
pub const IBUS_Hangul_KiyeogSios: u32 = 3747;
pub const IBUS_Hangul_Nieun: u32 = 3748;
pub const IBUS_Hangul_NieunJieuj: u32 = 3749;
pub const IBUS_Hangul_NieunHieuh: u32 = 3750;
pub const IBUS_Hangul_Dikeud: u32 = 3751;
pub const IBUS_Hangul_SsangDikeud: u32 = 3752;
pub const IBUS_Hangul_Rieul: u32 = 3753;
pub const IBUS_Hangul_RieulKiyeog: u32 = 3754;
pub const IBUS_Hangul_RieulMieum: u32 = 3755;
pub const IBUS_Hangul_RieulPieub: u32 = 3756;
pub const IBUS_Hangul_RieulSios: u32 = 3757;
pub const IBUS_Hangul_RieulTieut: u32 = 3758;
pub const IBUS_Hangul_RieulPhieuf: u32 = 3759;
pub const IBUS_Hangul_RieulHieuh: u32 = 3760;
pub const IBUS_Hangul_Mieum: u32 = 3761;
pub const IBUS_Hangul_Pieub: u32 = 3762;
pub const IBUS_Hangul_SsangPieub: u32 = 3763;
pub const IBUS_Hangul_PieubSios: u32 = 3764;
pub const IBUS_Hangul_Sios: u32 = 3765;
pub const IBUS_Hangul_SsangSios: u32 = 3766;
pub const IBUS_Hangul_Ieung: u32 = 3767;
pub const IBUS_Hangul_Jieuj: u32 = 3768;
pub const IBUS_Hangul_SsangJieuj: u32 = 3769;
pub const IBUS_Hangul_Cieuc: u32 = 3770;
pub const IBUS_Hangul_Khieuq: u32 = 3771;
pub const IBUS_Hangul_Tieut: u32 = 3772;
pub const IBUS_Hangul_Phieuf: u32 = 3773;
pub const IBUS_Hangul_Hieuh: u32 = 3774;
pub const IBUS_Hangul_A: u32 = 3775;
pub const IBUS_Hangul_AE: u32 = 3776;
pub const IBUS_Hangul_YA: u32 = 3777;
pub const IBUS_Hangul_YAE: u32 = 3778;
pub const IBUS_Hangul_EO: u32 = 3779;
pub const IBUS_Hangul_E: u32 = 3780;
pub const IBUS_Hangul_YEO: u32 = 3781;
pub const IBUS_Hangul_YE: u32 = 3782;
pub const IBUS_Hangul_O: u32 = 3783;
pub const IBUS_Hangul_WA: u32 = 3784;
pub const IBUS_Hangul_WAE: u32 = 3785;
pub const IBUS_Hangul_OE: u32 = 3786;
pub const IBUS_Hangul_YO: u32 = 3787;
pub const IBUS_Hangul_U: u32 = 3788;
pub const IBUS_Hangul_WEO: u32 = 3789;
pub const IBUS_Hangul_WE: u32 = 3790;
pub const IBUS_Hangul_WI: u32 = 3791;
pub const IBUS_Hangul_YU: u32 = 3792;
pub const IBUS_Hangul_EU: u32 = 3793;
pub const IBUS_Hangul_YI: u32 = 3794;
pub const IBUS_Hangul_I: u32 = 3795;
pub const IBUS_Hangul_J_Kiyeog: u32 = 3796;
pub const IBUS_Hangul_J_SsangKiyeog: u32 = 3797;
pub const IBUS_Hangul_J_KiyeogSios: u32 = 3798;
pub const IBUS_Hangul_J_Nieun: u32 = 3799;
pub const IBUS_Hangul_J_NieunJieuj: u32 = 3800;
pub const IBUS_Hangul_J_NieunHieuh: u32 = 3801;
pub const IBUS_Hangul_J_Dikeud: u32 = 3802;
pub const IBUS_Hangul_J_Rieul: u32 = 3803;
pub const IBUS_Hangul_J_RieulKiyeog: u32 = 3804;
pub const IBUS_Hangul_J_RieulMieum: u32 = 3805;
pub const IBUS_Hangul_J_RieulPieub: u32 = 3806;
pub const IBUS_Hangul_J_RieulSios: u32 = 3807;
pub const IBUS_Hangul_J_RieulTieut: u32 = 3808;
pub const IBUS_Hangul_J_RieulPhieuf: u32 = 3809;
pub const IBUS_Hangul_J_RieulHieuh: u32 = 3810;
pub const IBUS_Hangul_J_Mieum: u32 = 3811;
pub const IBUS_Hangul_J_Pieub: u32 = 3812;
pub const IBUS_Hangul_J_PieubSios: u32 = 3813;
pub const IBUS_Hangul_J_Sios: u32 = 3814;
pub const IBUS_Hangul_J_SsangSios: u32 = 3815;
pub const IBUS_Hangul_J_Ieung: u32 = 3816;
pub const IBUS_Hangul_J_Jieuj: u32 = 3817;
pub const IBUS_Hangul_J_Cieuc: u32 = 3818;
pub const IBUS_Hangul_J_Khieuq: u32 = 3819;
pub const IBUS_Hangul_J_Tieut: u32 = 3820;
pub const IBUS_Hangul_J_Phieuf: u32 = 3821;
pub const IBUS_Hangul_J_Hieuh: u32 = 3822;
pub const IBUS_Hangul_RieulYeorinHieuh: u32 = 3823;
pub const IBUS_Hangul_SunkyeongeumMieum: u32 = 3824;
pub const IBUS_Hangul_SunkyeongeumPieub: u32 = 3825;
pub const IBUS_Hangul_PanSios: u32 = 3826;
pub const IBUS_Hangul_KkogjiDalrinIeung: u32 = 3827;
pub const IBUS_Hangul_SunkyeongeumPhieuf: u32 = 3828;
pub const IBUS_Hangul_YeorinHieuh: u32 = 3829;
pub const IBUS_Hangul_AraeA: u32 = 3830;
pub const IBUS_Hangul_AraeAE: u32 = 3831;
pub const IBUS_Hangul_J_PanSios: u32 = 3832;
pub const IBUS_Hangul_J_KkogjiDalrinIeung: u32 = 3833;
pub const IBUS_Hangul_J_YeorinHieuh: u32 = 3834;
pub const IBUS_Korean_Won: u32 = 3839;
pub const IBUS_Armenian_ligature_ew: u32 = 16778631;
pub const IBUS_Armenian_full_stop: u32 = 16778633;
pub const IBUS_Armenian_verjaket: u32 = 16778633;
pub const IBUS_Armenian_separation_mark: u32 = 16778589;
pub const IBUS_Armenian_but: u32 = 16778589;
pub const IBUS_Armenian_hyphen: u32 = 16778634;
pub const IBUS_Armenian_yentamna: u32 = 16778634;
pub const IBUS_Armenian_exclam: u32 = 16778588;
pub const IBUS_Armenian_amanak: u32 = 16778588;
pub const IBUS_Armenian_accent: u32 = 16778587;
pub const IBUS_Armenian_shesht: u32 = 16778587;
pub const IBUS_Armenian_question: u32 = 16778590;
pub const IBUS_Armenian_paruyk: u32 = 16778590;
pub const IBUS_Armenian_AYB: u32 = 16778545;
pub const IBUS_Armenian_ayb: u32 = 16778593;
pub const IBUS_Armenian_BEN: u32 = 16778546;
pub const IBUS_Armenian_ben: u32 = 16778594;
pub const IBUS_Armenian_GIM: u32 = 16778547;
pub const IBUS_Armenian_gim: u32 = 16778595;
pub const IBUS_Armenian_DA: u32 = 16778548;
pub const IBUS_Armenian_da: u32 = 16778596;
pub const IBUS_Armenian_YECH: u32 = 16778549;
pub const IBUS_Armenian_yech: u32 = 16778597;
pub const IBUS_Armenian_ZA: u32 = 16778550;
pub const IBUS_Armenian_za: u32 = 16778598;
pub const IBUS_Armenian_E: u32 = 16778551;
pub const IBUS_Armenian_e: u32 = 16778599;
pub const IBUS_Armenian_AT: u32 = 16778552;
pub const IBUS_Armenian_at: u32 = 16778600;
pub const IBUS_Armenian_TO: u32 = 16778553;
pub const IBUS_Armenian_to: u32 = 16778601;
pub const IBUS_Armenian_ZHE: u32 = 16778554;
pub const IBUS_Armenian_zhe: u32 = 16778602;
pub const IBUS_Armenian_INI: u32 = 16778555;
pub const IBUS_Armenian_ini: u32 = 16778603;
pub const IBUS_Armenian_LYUN: u32 = 16778556;
pub const IBUS_Armenian_lyun: u32 = 16778604;
pub const IBUS_Armenian_KHE: u32 = 16778557;
pub const IBUS_Armenian_khe: u32 = 16778605;
pub const IBUS_Armenian_TSA: u32 = 16778558;
pub const IBUS_Armenian_tsa: u32 = 16778606;
pub const IBUS_Armenian_KEN: u32 = 16778559;
pub const IBUS_Armenian_ken: u32 = 16778607;
pub const IBUS_Armenian_HO: u32 = 16778560;
pub const IBUS_Armenian_ho: u32 = 16778608;
pub const IBUS_Armenian_DZA: u32 = 16778561;
pub const IBUS_Armenian_dza: u32 = 16778609;
pub const IBUS_Armenian_GHAT: u32 = 16778562;
pub const IBUS_Armenian_ghat: u32 = 16778610;
pub const IBUS_Armenian_TCHE: u32 = 16778563;
pub const IBUS_Armenian_tche: u32 = 16778611;
pub const IBUS_Armenian_MEN: u32 = 16778564;
pub const IBUS_Armenian_men: u32 = 16778612;
pub const IBUS_Armenian_HI: u32 = 16778565;
pub const IBUS_Armenian_hi: u32 = 16778613;
pub const IBUS_Armenian_NU: u32 = 16778566;
pub const IBUS_Armenian_nu: u32 = 16778614;
pub const IBUS_Armenian_SHA: u32 = 16778567;
pub const IBUS_Armenian_sha: u32 = 16778615;
pub const IBUS_Armenian_VO: u32 = 16778568;
pub const IBUS_Armenian_vo: u32 = 16778616;
pub const IBUS_Armenian_CHA: u32 = 16778569;
pub const IBUS_Armenian_cha: u32 = 16778617;
pub const IBUS_Armenian_PE: u32 = 16778570;
pub const IBUS_Armenian_pe: u32 = 16778618;
pub const IBUS_Armenian_JE: u32 = 16778571;
pub const IBUS_Armenian_je: u32 = 16778619;
pub const IBUS_Armenian_RA: u32 = 16778572;
pub const IBUS_Armenian_ra: u32 = 16778620;
pub const IBUS_Armenian_SE: u32 = 16778573;
pub const IBUS_Armenian_se: u32 = 16778621;
pub const IBUS_Armenian_VEV: u32 = 16778574;
pub const IBUS_Armenian_vev: u32 = 16778622;
pub const IBUS_Armenian_TYUN: u32 = 16778575;
pub const IBUS_Armenian_tyun: u32 = 16778623;
pub const IBUS_Armenian_RE: u32 = 16778576;
pub const IBUS_Armenian_re: u32 = 16778624;
pub const IBUS_Armenian_TSO: u32 = 16778577;
pub const IBUS_Armenian_tso: u32 = 16778625;
pub const IBUS_Armenian_VYUN: u32 = 16778578;
pub const IBUS_Armenian_vyun: u32 = 16778626;
pub const IBUS_Armenian_PYUR: u32 = 16778579;
pub const IBUS_Armenian_pyur: u32 = 16778627;
pub const IBUS_Armenian_KE: u32 = 16778580;
pub const IBUS_Armenian_ke: u32 = 16778628;
pub const IBUS_Armenian_O: u32 = 16778581;
pub const IBUS_Armenian_o: u32 = 16778629;
pub const IBUS_Armenian_FE: u32 = 16778582;
pub const IBUS_Armenian_fe: u32 = 16778630;
pub const IBUS_Armenian_apostrophe: u32 = 16778586;
pub const IBUS_Georgian_an: u32 = 16781520;
pub const IBUS_Georgian_ban: u32 = 16781521;
pub const IBUS_Georgian_gan: u32 = 16781522;
pub const IBUS_Georgian_don: u32 = 16781523;
pub const IBUS_Georgian_en: u32 = 16781524;
pub const IBUS_Georgian_vin: u32 = 16781525;
pub const IBUS_Georgian_zen: u32 = 16781526;
pub const IBUS_Georgian_tan: u32 = 16781527;
pub const IBUS_Georgian_in: u32 = 16781528;
pub const IBUS_Georgian_kan: u32 = 16781529;
pub const IBUS_Georgian_las: u32 = 16781530;
pub const IBUS_Georgian_man: u32 = 16781531;
pub const IBUS_Georgian_nar: u32 = 16781532;
pub const IBUS_Georgian_on: u32 = 16781533;
pub const IBUS_Georgian_par: u32 = 16781534;
pub const IBUS_Georgian_zhar: u32 = 16781535;
pub const IBUS_Georgian_rae: u32 = 16781536;
pub const IBUS_Georgian_san: u32 = 16781537;
pub const IBUS_Georgian_tar: u32 = 16781538;
pub const IBUS_Georgian_un: u32 = 16781539;
pub const IBUS_Georgian_phar: u32 = 16781540;
pub const IBUS_Georgian_khar: u32 = 16781541;
pub const IBUS_Georgian_ghan: u32 = 16781542;
pub const IBUS_Georgian_qar: u32 = 16781543;
pub const IBUS_Georgian_shin: u32 = 16781544;
pub const IBUS_Georgian_chin: u32 = 16781545;
pub const IBUS_Georgian_can: u32 = 16781546;
pub const IBUS_Georgian_jil: u32 = 16781547;
pub const IBUS_Georgian_cil: u32 = 16781548;
pub const IBUS_Georgian_char: u32 = 16781549;
pub const IBUS_Georgian_xan: u32 = 16781550;
pub const IBUS_Georgian_jhan: u32 = 16781551;
pub const IBUS_Georgian_hae: u32 = 16781552;
pub const IBUS_Georgian_he: u32 = 16781553;
pub const IBUS_Georgian_hie: u32 = 16781554;
pub const IBUS_Georgian_we: u32 = 16781555;
pub const IBUS_Georgian_har: u32 = 16781556;
pub const IBUS_Georgian_hoe: u32 = 16781557;
pub const IBUS_Georgian_fi: u32 = 16781558;
pub const IBUS_Xabovedot: u32 = 16785034;
pub const IBUS_Ibreve: u32 = 16777516;
pub const IBUS_Zstroke: u32 = 16777653;
pub const IBUS_Gcaron: u32 = 16777702;
pub const IBUS_Ocaron: u32 = 16777681;
pub const IBUS_Obarred: u32 = 16777631;
pub const IBUS_xabovedot: u32 = 16785035;
pub const IBUS_ibreve: u32 = 16777517;
pub const IBUS_zstroke: u32 = 16777654;
pub const IBUS_gcaron: u32 = 16777703;
pub const IBUS_ocaron: u32 = 16777682;
pub const IBUS_obarred: u32 = 16777845;
pub const IBUS_SCHWA: u32 = 16777615;
pub const IBUS_schwa: u32 = 16777817;
pub const IBUS_Lbelowdot: u32 = 16784950;
pub const IBUS_lbelowdot: u32 = 16784951;
pub const IBUS_Abelowdot: u32 = 16785056;
pub const IBUS_abelowdot: u32 = 16785057;
pub const IBUS_Ahook: u32 = 16785058;
pub const IBUS_ahook: u32 = 16785059;
pub const IBUS_Acircumflexacute: u32 = 16785060;
pub const IBUS_acircumflexacute: u32 = 16785061;
pub const IBUS_Acircumflexgrave: u32 = 16785062;
pub const IBUS_acircumflexgrave: u32 = 16785063;
pub const IBUS_Acircumflexhook: u32 = 16785064;
pub const IBUS_acircumflexhook: u32 = 16785065;
pub const IBUS_Acircumflextilde: u32 = 16785066;
pub const IBUS_acircumflextilde: u32 = 16785067;
pub const IBUS_Acircumflexbelowdot: u32 = 16785068;
pub const IBUS_acircumflexbelowdot: u32 = 16785069;
pub const IBUS_Abreveacute: u32 = 16785070;
pub const IBUS_abreveacute: u32 = 16785071;
pub const IBUS_Abrevegrave: u32 = 16785072;
pub const IBUS_abrevegrave: u32 = 16785073;
pub const IBUS_Abrevehook: u32 = 16785074;
pub const IBUS_abrevehook: u32 = 16785075;
pub const IBUS_Abrevetilde: u32 = 16785076;
pub const IBUS_abrevetilde: u32 = 16785077;
pub const IBUS_Abrevebelowdot: u32 = 16785078;
pub const IBUS_abrevebelowdot: u32 = 16785079;
pub const IBUS_Ebelowdot: u32 = 16785080;
pub const IBUS_ebelowdot: u32 = 16785081;
pub const IBUS_Ehook: u32 = 16785082;
pub const IBUS_ehook: u32 = 16785083;
pub const IBUS_Etilde: u32 = 16785084;
pub const IBUS_etilde: u32 = 16785085;
pub const IBUS_Ecircumflexacute: u32 = 16785086;
pub const IBUS_ecircumflexacute: u32 = 16785087;
pub const IBUS_Ecircumflexgrave: u32 = 16785088;
pub const IBUS_ecircumflexgrave: u32 = 16785089;
pub const IBUS_Ecircumflexhook: u32 = 16785090;
pub const IBUS_ecircumflexhook: u32 = 16785091;
pub const IBUS_Ecircumflextilde: u32 = 16785092;
pub const IBUS_ecircumflextilde: u32 = 16785093;
pub const IBUS_Ecircumflexbelowdot: u32 = 16785094;
pub const IBUS_ecircumflexbelowdot: u32 = 16785095;
pub const IBUS_Ihook: u32 = 16785096;
pub const IBUS_ihook: u32 = 16785097;
pub const IBUS_Ibelowdot: u32 = 16785098;
pub const IBUS_ibelowdot: u32 = 16785099;
pub const IBUS_Obelowdot: u32 = 16785100;
pub const IBUS_obelowdot: u32 = 16785101;
pub const IBUS_Ohook: u32 = 16785102;
pub const IBUS_ohook: u32 = 16785103;
pub const IBUS_Ocircumflexacute: u32 = 16785104;
pub const IBUS_ocircumflexacute: u32 = 16785105;
pub const IBUS_Ocircumflexgrave: u32 = 16785106;
pub const IBUS_ocircumflexgrave: u32 = 16785107;
pub const IBUS_Ocircumflexhook: u32 = 16785108;
pub const IBUS_ocircumflexhook: u32 = 16785109;
pub const IBUS_Ocircumflextilde: u32 = 16785110;
pub const IBUS_ocircumflextilde: u32 = 16785111;
pub const IBUS_Ocircumflexbelowdot: u32 = 16785112;
pub const IBUS_ocircumflexbelowdot: u32 = 16785113;
pub const IBUS_Ohornacute: u32 = 16785114;
pub const IBUS_ohornacute: u32 = 16785115;
pub const IBUS_Ohorngrave: u32 = 16785116;
pub const IBUS_ohorngrave: u32 = 16785117;
pub const IBUS_Ohornhook: u32 = 16785118;
pub const IBUS_ohornhook: u32 = 16785119;
pub const IBUS_Ohorntilde: u32 = 16785120;
pub const IBUS_ohorntilde: u32 = 16785121;
pub const IBUS_Ohornbelowdot: u32 = 16785122;
pub const IBUS_ohornbelowdot: u32 = 16785123;
pub const IBUS_Ubelowdot: u32 = 16785124;
pub const IBUS_ubelowdot: u32 = 16785125;
pub const IBUS_Uhook: u32 = 16785126;
pub const IBUS_uhook: u32 = 16785127;
pub const IBUS_Uhornacute: u32 = 16785128;
pub const IBUS_uhornacute: u32 = 16785129;
pub const IBUS_Uhorngrave: u32 = 16785130;
pub const IBUS_uhorngrave: u32 = 16785131;
pub const IBUS_Uhornhook: u32 = 16785132;
pub const IBUS_uhornhook: u32 = 16785133;
pub const IBUS_Uhorntilde: u32 = 16785134;
pub const IBUS_uhorntilde: u32 = 16785135;
pub const IBUS_Uhornbelowdot: u32 = 16785136;
pub const IBUS_uhornbelowdot: u32 = 16785137;
pub const IBUS_Ybelowdot: u32 = 16785140;
pub const IBUS_ybelowdot: u32 = 16785141;
pub const IBUS_Yhook: u32 = 16785142;
pub const IBUS_yhook: u32 = 16785143;
pub const IBUS_Ytilde: u32 = 16785144;
pub const IBUS_ytilde: u32 = 16785145;
pub const IBUS_Ohorn: u32 = 16777632;
pub const IBUS_ohorn: u32 = 16777633;
pub const IBUS_Uhorn: u32 = 16777647;
pub const IBUS_uhorn: u32 = 16777648;
pub const IBUS_EcuSign: u32 = 16785568;
pub const IBUS_ColonSign: u32 = 16785569;
pub const IBUS_CruzeiroSign: u32 = 16785570;
pub const IBUS_FFrancSign: u32 = 16785571;
pub const IBUS_LiraSign: u32 = 16785572;
pub const IBUS_MillSign: u32 = 16785573;
pub const IBUS_NairaSign: u32 = 16785574;
pub const IBUS_PesetaSign: u32 = 16785575;
pub const IBUS_RupeeSign: u32 = 16785576;
pub const IBUS_WonSign: u32 = 16785577;
pub const IBUS_NewSheqelSign: u32 = 16785578;
pub const IBUS_DongSign: u32 = 16785579;
pub const IBUS_EuroSign: u32 = 8364;
pub const IBUS_zerosuperior: u32 = 16785520;
pub const IBUS_foursuperior: u32 = 16785524;
pub const IBUS_fivesuperior: u32 = 16785525;
pub const IBUS_sixsuperior: u32 = 16785526;
pub const IBUS_sevensuperior: u32 = 16785527;
pub const IBUS_eightsuperior: u32 = 16785528;
pub const IBUS_ninesuperior: u32 = 16785529;
pub const IBUS_zerosubscript: u32 = 16785536;
pub const IBUS_onesubscript: u32 = 16785537;
pub const IBUS_twosubscript: u32 = 16785538;
pub const IBUS_threesubscript: u32 = 16785539;
pub const IBUS_foursubscript: u32 = 16785540;
pub const IBUS_fivesubscript: u32 = 16785541;
pub const IBUS_sixsubscript: u32 = 16785542;
pub const IBUS_sevensubscript: u32 = 16785543;
pub const IBUS_eightsubscript: u32 = 16785544;
pub const IBUS_ninesubscript: u32 = 16785545;
pub const IBUS_partdifferential: u32 = 16785922;
pub const IBUS_emptyset: u32 = 16785925;
pub const IBUS_elementof: u32 = 16785928;
pub const IBUS_notelementof: u32 = 16785929;
pub const IBUS_containsas: u32 = 16785931;
pub const IBUS_squareroot: u32 = 16785946;
pub const IBUS_cuberoot: u32 = 16785947;
pub const IBUS_fourthroot: u32 = 16785948;
pub const IBUS_dintegral: u32 = 16785964;
pub const IBUS_tintegral: u32 = 16785965;
pub const IBUS_because: u32 = 16785973;
pub const IBUS_approxeq: u32 = 16785992;
pub const IBUS_notapproxeq: u32 = 16785991;
pub const IBUS_notidentical: u32 = 16786018;
pub const IBUS_stricteq: u32 = 16786019;
pub const IBUS_braille_dot_1: u32 = 65521;
pub const IBUS_braille_dot_2: u32 = 65522;
pub const IBUS_braille_dot_3: u32 = 65523;
pub const IBUS_braille_dot_4: u32 = 65524;
pub const IBUS_braille_dot_5: u32 = 65525;
pub const IBUS_braille_dot_6: u32 = 65526;
pub const IBUS_braille_dot_7: u32 = 65527;
pub const IBUS_braille_dot_8: u32 = 65528;
pub const IBUS_braille_dot_9: u32 = 65529;
pub const IBUS_braille_dot_10: u32 = 65530;
pub const IBUS_braille_blank: u32 = 16787456;
pub const IBUS_braille_dots_1: u32 = 16787457;
pub const IBUS_braille_dots_2: u32 = 16787458;
pub const IBUS_braille_dots_12: u32 = 16787459;
pub const IBUS_braille_dots_3: u32 = 16787460;
pub const IBUS_braille_dots_13: u32 = 16787461;
pub const IBUS_braille_dots_23: u32 = 16787462;
pub const IBUS_braille_dots_123: u32 = 16787463;
pub const IBUS_braille_dots_4: u32 = 16787464;
pub const IBUS_braille_dots_14: u32 = 16787465;
pub const IBUS_braille_dots_24: u32 = 16787466;
pub const IBUS_braille_dots_124: u32 = 16787467;
pub const IBUS_braille_dots_34: u32 = 16787468;
pub const IBUS_braille_dots_134: u32 = 16787469;
pub const IBUS_braille_dots_234: u32 = 16787470;
pub const IBUS_braille_dots_1234: u32 = 16787471;
pub const IBUS_braille_dots_5: u32 = 16787472;
pub const IBUS_braille_dots_15: u32 = 16787473;
pub const IBUS_braille_dots_25: u32 = 16787474;
pub const IBUS_braille_dots_125: u32 = 16787475;
pub const IBUS_braille_dots_35: u32 = 16787476;
pub const IBUS_braille_dots_135: u32 = 16787477;
pub const IBUS_braille_dots_235: u32 = 16787478;
pub const IBUS_braille_dots_1235: u32 = 16787479;
pub const IBUS_braille_dots_45: u32 = 16787480;
pub const IBUS_braille_dots_145: u32 = 16787481;
pub const IBUS_braille_dots_245: u32 = 16787482;
pub const IBUS_braille_dots_1245: u32 = 16787483;
pub const IBUS_braille_dots_345: u32 = 16787484;
pub const IBUS_braille_dots_1345: u32 = 16787485;
pub const IBUS_braille_dots_2345: u32 = 16787486;
pub const IBUS_braille_dots_12345: u32 = 16787487;
pub const IBUS_braille_dots_6: u32 = 16787488;
pub const IBUS_braille_dots_16: u32 = 16787489;
pub const IBUS_braille_dots_26: u32 = 16787490;
pub const IBUS_braille_dots_126: u32 = 16787491;
pub const IBUS_braille_dots_36: u32 = 16787492;
pub const IBUS_braille_dots_136: u32 = 16787493;
pub const IBUS_braille_dots_236: u32 = 16787494;
pub const IBUS_braille_dots_1236: u32 = 16787495;
pub const IBUS_braille_dots_46: u32 = 16787496;
pub const IBUS_braille_dots_146: u32 = 16787497;
pub const IBUS_braille_dots_246: u32 = 16787498;
pub const IBUS_braille_dots_1246: u32 = 16787499;
pub const IBUS_braille_dots_346: u32 = 16787500;
pub const IBUS_braille_dots_1346: u32 = 16787501;
pub const IBUS_braille_dots_2346: u32 = 16787502;
pub const IBUS_braille_dots_12346: u32 = 16787503;
pub const IBUS_braille_dots_56: u32 = 16787504;
pub const IBUS_braille_dots_156: u32 = 16787505;
pub const IBUS_braille_dots_256: u32 = 16787506;
pub const IBUS_braille_dots_1256: u32 = 16787507;
pub const IBUS_braille_dots_356: u32 = 16787508;
pub const IBUS_braille_dots_1356: u32 = 16787509;
pub const IBUS_braille_dots_2356: u32 = 16787510;
pub const IBUS_braille_dots_12356: u32 = 16787511;
pub const IBUS_braille_dots_456: u32 = 16787512;
pub const IBUS_braille_dots_1456: u32 = 16787513;
pub const IBUS_braille_dots_2456: u32 = 16787514;
pub const IBUS_braille_dots_12456: u32 = 16787515;
pub const IBUS_braille_dots_3456: u32 = 16787516;
pub const IBUS_braille_dots_13456: u32 = 16787517;
pub const IBUS_braille_dots_23456: u32 = 16787518;
pub const IBUS_braille_dots_123456: u32 = 16787519;
pub const IBUS_braille_dots_7: u32 = 16787520;
pub const IBUS_braille_dots_17: u32 = 16787521;
pub const IBUS_braille_dots_27: u32 = 16787522;
pub const IBUS_braille_dots_127: u32 = 16787523;
pub const IBUS_braille_dots_37: u32 = 16787524;
pub const IBUS_braille_dots_137: u32 = 16787525;
pub const IBUS_braille_dots_237: u32 = 16787526;
pub const IBUS_braille_dots_1237: u32 = 16787527;
pub const IBUS_braille_dots_47: u32 = 16787528;
pub const IBUS_braille_dots_147: u32 = 16787529;
pub const IBUS_braille_dots_247: u32 = 16787530;
pub const IBUS_braille_dots_1247: u32 = 16787531;
pub const IBUS_braille_dots_347: u32 = 16787532;
pub const IBUS_braille_dots_1347: u32 = 16787533;
pub const IBUS_braille_dots_2347: u32 = 16787534;
pub const IBUS_braille_dots_12347: u32 = 16787535;
pub const IBUS_braille_dots_57: u32 = 16787536;
pub const IBUS_braille_dots_157: u32 = 16787537;
pub const IBUS_braille_dots_257: u32 = 16787538;
pub const IBUS_braille_dots_1257: u32 = 16787539;
pub const IBUS_braille_dots_357: u32 = 16787540;
pub const IBUS_braille_dots_1357: u32 = 16787541;
pub const IBUS_braille_dots_2357: u32 = 16787542;
pub const IBUS_braille_dots_12357: u32 = 16787543;
pub const IBUS_braille_dots_457: u32 = 16787544;
pub const IBUS_braille_dots_1457: u32 = 16787545;
pub const IBUS_braille_dots_2457: u32 = 16787546;
pub const IBUS_braille_dots_12457: u32 = 16787547;
pub const IBUS_braille_dots_3457: u32 = 16787548;
pub const IBUS_braille_dots_13457: u32 = 16787549;
pub const IBUS_braille_dots_23457: u32 = 16787550;
pub const IBUS_braille_dots_123457: u32 = 16787551;
pub const IBUS_braille_dots_67: u32 = 16787552;
pub const IBUS_braille_dots_167: u32 = 16787553;
pub const IBUS_braille_dots_267: u32 = 16787554;
pub const IBUS_braille_dots_1267: u32 = 16787555;
pub const IBUS_braille_dots_367: u32 = 16787556;
pub const IBUS_braille_dots_1367: u32 = 16787557;
pub const IBUS_braille_dots_2367: u32 = 16787558;
pub const IBUS_braille_dots_12367: u32 = 16787559;
pub const IBUS_braille_dots_467: u32 = 16787560;
pub const IBUS_braille_dots_1467: u32 = 16787561;
pub const IBUS_braille_dots_2467: u32 = 16787562;
pub const IBUS_braille_dots_12467: u32 = 16787563;
pub const IBUS_braille_dots_3467: u32 = 16787564;
pub const IBUS_braille_dots_13467: u32 = 16787565;
pub const IBUS_braille_dots_23467: u32 = 16787566;
pub const IBUS_braille_dots_123467: u32 = 16787567;
pub const IBUS_braille_dots_567: u32 = 16787568;
pub const IBUS_braille_dots_1567: u32 = 16787569;
pub const IBUS_braille_dots_2567: u32 = 16787570;
pub const IBUS_braille_dots_12567: u32 = 16787571;
pub const IBUS_braille_dots_3567: u32 = 16787572;
pub const IBUS_braille_dots_13567: u32 = 16787573;
pub const IBUS_braille_dots_23567: u32 = 16787574;
pub const IBUS_braille_dots_123567: u32 = 16787575;
pub const IBUS_braille_dots_4567: u32 = 16787576;
pub const IBUS_braille_dots_14567: u32 = 16787577;
pub const IBUS_braille_dots_24567: u32 = 16787578;
pub const IBUS_braille_dots_124567: u32 = 16787579;
pub const IBUS_braille_dots_34567: u32 = 16787580;
pub const IBUS_braille_dots_134567: u32 = 16787581;
pub const IBUS_braille_dots_234567: u32 = 16787582;
pub const IBUS_braille_dots_1234567: u32 = 16787583;
pub const IBUS_braille_dots_8: u32 = 16787584;
pub const IBUS_braille_dots_18: u32 = 16787585;
pub const IBUS_braille_dots_28: u32 = 16787586;
pub const IBUS_braille_dots_128: u32 = 16787587;
pub const IBUS_braille_dots_38: u32 = 16787588;
pub const IBUS_braille_dots_138: u32 = 16787589;
pub const IBUS_braille_dots_238: u32 = 16787590;
pub const IBUS_braille_dots_1238: u32 = 16787591;
pub const IBUS_braille_dots_48: u32 = 16787592;
pub const IBUS_braille_dots_148: u32 = 16787593;
pub const IBUS_braille_dots_248: u32 = 16787594;
pub const IBUS_braille_dots_1248: u32 = 16787595;
pub const IBUS_braille_dots_348: u32 = 16787596;
pub const IBUS_braille_dots_1348: u32 = 16787597;
pub const IBUS_braille_dots_2348: u32 = 16787598;
pub const IBUS_braille_dots_12348: u32 = 16787599;
pub const IBUS_braille_dots_58: u32 = 16787600;
pub const IBUS_braille_dots_158: u32 = 16787601;
pub const IBUS_braille_dots_258: u32 = 16787602;
pub const IBUS_braille_dots_1258: u32 = 16787603;
pub const IBUS_braille_dots_358: u32 = 16787604;
pub const IBUS_braille_dots_1358: u32 = 16787605;
pub const IBUS_braille_dots_2358: u32 = 16787606;
pub const IBUS_braille_dots_12358: u32 = 16787607;
pub const IBUS_braille_dots_458: u32 = 16787608;
pub const IBUS_braille_dots_1458: u32 = 16787609;
pub const IBUS_braille_dots_2458: u32 = 16787610;
pub const IBUS_braille_dots_12458: u32 = 16787611;
pub const IBUS_braille_dots_3458: u32 = 16787612;
pub const IBUS_braille_dots_13458: u32 = 16787613;
pub const IBUS_braille_dots_23458: u32 = 16787614;
pub const IBUS_braille_dots_123458: u32 = 16787615;
pub const IBUS_braille_dots_68: u32 = 16787616;
pub const IBUS_braille_dots_168: u32 = 16787617;
pub const IBUS_braille_dots_268: u32 = 16787618;
pub const IBUS_braille_dots_1268: u32 = 16787619;
pub const IBUS_braille_dots_368: u32 = 16787620;
pub const IBUS_braille_dots_1368: u32 = 16787621;
pub const IBUS_braille_dots_2368: u32 = 16787622;
pub const IBUS_braille_dots_12368: u32 = 16787623;
pub const IBUS_braille_dots_468: u32 = 16787624;
pub const IBUS_braille_dots_1468: u32 = 16787625;
pub const IBUS_braille_dots_2468: u32 = 16787626;
pub const IBUS_braille_dots_12468: u32 = 16787627;
pub const IBUS_braille_dots_3468: u32 = 16787628;
pub const IBUS_braille_dots_13468: u32 = 16787629;
pub const IBUS_braille_dots_23468: u32 = 16787630;
pub const IBUS_braille_dots_123468: u32 = 16787631;
pub const IBUS_braille_dots_568: u32 = 16787632;
pub const IBUS_braille_dots_1568: u32 = 16787633;
pub const IBUS_braille_dots_2568: u32 = 16787634;
pub const IBUS_braille_dots_12568: u32 = 16787635;
pub const IBUS_braille_dots_3568: u32 = 16787636;
pub const IBUS_braille_dots_13568: u32 = 16787637;
pub const IBUS_braille_dots_23568: u32 = 16787638;
pub const IBUS_braille_dots_123568: u32 = 16787639;
pub const IBUS_braille_dots_4568: u32 = 16787640;
pub const IBUS_braille_dots_14568: u32 = 16787641;
pub const IBUS_braille_dots_24568: u32 = 16787642;
pub const IBUS_braille_dots_124568: u32 = 16787643;
pub const IBUS_braille_dots_34568: u32 = 16787644;
pub const IBUS_braille_dots_134568: u32 = 16787645;
pub const IBUS_braille_dots_234568: u32 = 16787646;
pub const IBUS_braille_dots_1234568: u32 = 16787647;
pub const IBUS_braille_dots_78: u32 = 16787648;
pub const IBUS_braille_dots_178: u32 = 16787649;
pub const IBUS_braille_dots_278: u32 = 16787650;
pub const IBUS_braille_dots_1278: u32 = 16787651;
pub const IBUS_braille_dots_378: u32 = 16787652;
pub const IBUS_braille_dots_1378: u32 = 16787653;
pub const IBUS_braille_dots_2378: u32 = 16787654;
pub const IBUS_braille_dots_12378: u32 = 16787655;
pub const IBUS_braille_dots_478: u32 = 16787656;
pub const IBUS_braille_dots_1478: u32 = 16787657;
pub const IBUS_braille_dots_2478: u32 = 16787658;
pub const IBUS_braille_dots_12478: u32 = 16787659;
pub const IBUS_braille_dots_3478: u32 = 16787660;
pub const IBUS_braille_dots_13478: u32 = 16787661;
pub const IBUS_braille_dots_23478: u32 = 16787662;
pub const IBUS_braille_dots_123478: u32 = 16787663;
pub const IBUS_braille_dots_578: u32 = 16787664;
pub const IBUS_braille_dots_1578: u32 = 16787665;
pub const IBUS_braille_dots_2578: u32 = 16787666;
pub const IBUS_braille_dots_12578: u32 = 16787667;
pub const IBUS_braille_dots_3578: u32 = 16787668;
pub const IBUS_braille_dots_13578: u32 = 16787669;
pub const IBUS_braille_dots_23578: u32 = 16787670;
pub const IBUS_braille_dots_123578: u32 = 16787671;
pub const IBUS_braille_dots_4578: u32 = 16787672;
pub const IBUS_braille_dots_14578: u32 = 16787673;
pub const IBUS_braille_dots_24578: u32 = 16787674;
pub const IBUS_braille_dots_124578: u32 = 16787675;
pub const IBUS_braille_dots_34578: u32 = 16787676;
pub const IBUS_braille_dots_134578: u32 = 16787677;
pub const IBUS_braille_dots_234578: u32 = 16787678;
pub const IBUS_braille_dots_1234578: u32 = 16787679;
pub const IBUS_braille_dots_678: u32 = 16787680;
pub const IBUS_braille_dots_1678: u32 = 16787681;
pub const IBUS_braille_dots_2678: u32 = 16787682;
pub const IBUS_braille_dots_12678: u32 = 16787683;
pub const IBUS_braille_dots_3678: u32 = 16787684;
pub const IBUS_braille_dots_13678: u32 = 16787685;
pub const IBUS_braille_dots_23678: u32 = 16787686;
pub const IBUS_braille_dots_123678: u32 = 16787687;
pub const IBUS_braille_dots_4678: u32 = 16787688;
pub const IBUS_braille_dots_14678: u32 = 16787689;
pub const IBUS_braille_dots_24678: u32 = 16787690;
pub const IBUS_braille_dots_124678: u32 = 16787691;
pub const IBUS_braille_dots_34678: u32 = 16787692;
pub const IBUS_braille_dots_134678: u32 = 16787693;
pub const IBUS_braille_dots_234678: u32 = 16787694;
pub const IBUS_braille_dots_1234678: u32 = 16787695;
pub const IBUS_braille_dots_5678: u32 = 16787696;
pub const IBUS_braille_dots_15678: u32 = 16787697;
pub const IBUS_braille_dots_25678: u32 = 16787698;
pub const IBUS_braille_dots_125678: u32 = 16787699;
pub const IBUS_braille_dots_35678: u32 = 16787700;
pub const IBUS_braille_dots_135678: u32 = 16787701;
pub const IBUS_braille_dots_235678: u32 = 16787702;
pub const IBUS_braille_dots_1235678: u32 = 16787703;
pub const IBUS_braille_dots_45678: u32 = 16787704;
pub const IBUS_braille_dots_145678: u32 = 16787705;
pub const IBUS_braille_dots_245678: u32 = 16787706;
pub const IBUS_braille_dots_1245678: u32 = 16787707;
pub const IBUS_braille_dots_345678: u32 = 16787708;
pub const IBUS_braille_dots_1345678: u32 = 16787709;
pub const IBUS_braille_dots_2345678: u32 = 16787710;
pub const IBUS_braille_dots_12345678: u32 = 16787711;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type gint8 = ::std::os::raw::c_schar;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type goffset = gint64;
pub type gintptr = ::std::os::raw::c_long;
pub type guintptr = ::std::os::raw::c_ulong;
pub type GPid = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guchar = ::std::os::raw::c_uchar;
pub type gushort = ::std::os::raw::c_ushort;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GEqualFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
#[doc = " GEqualFuncFull:\n @a: a value\n @b: a value to compare with\n @user_data: user data provided by the caller\n\n Specifies the type of a function used to test two values for\n equality. The function should return %TRUE if both values are equal\n and %FALSE otherwise.\n\n This is a version of #GEqualFunc which provides a @user_data closure from\n the caller.\n\n Returns: %TRUE if @a = @b; %FALSE otherwise\n Since: 2.74"]
pub type GEqualFuncFull = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gboolean,
>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::std::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer),
>;
#[doc = " GCopyFunc:\n @src: (not nullable): A pointer to the data which should be copied\n @data: Additional data\n\n A function of this signature is used to copy the node data\n when doing a deep-copy of a tree.\n\n Returns: (not nullable): A pointer to the copy\n\n Since: 2.4"]
pub type GCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
#[doc = " GFreeFunc:\n @data: a data pointer\n\n Declares a type of function which takes an arbitrary\n data pointer argument and has no return value. It is\n not currently used in GLib or GTK+."]
pub type GFreeFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
#[doc = " GTranslateFunc:\n @str: the untranslated string\n @data: user data specified when installing the function, e.g.\n  in g_option_group_set_translate_func()\n\n The type of functions which are used to translate user-visible\n strings, for <option>--help</option> output.\n\n Returns: a translation of the string for the current locale.\n  The returned string is owned by GLib and must not be freed."]
pub type GTranslateFunc =
    ::std::option::Option<unsafe extern "C" fn(str_: *const gchar, data: gpointer) -> *const gchar>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__GFloatIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
}
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::std::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GFloatIEEE754() {
    const UNINIT: ::std::mem::MaybeUninit<_GFloatIEEE754> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
}
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::std::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::std::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754() {
    const UNINIT: ::std::mem::MaybeUninit<_GDoubleIEEE754> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mpn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[test]
fn bindgen_test_layout__GTimeVal() {
    const UNINIT: ::std::mem::MaybeUninit<_GTimeVal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTimeVal>(),
        16usize,
        concat!("Size of: ", stringify!(_GTimeVal))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTimeVal>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTimeVal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type grefcount = gint;
pub type gatomicrefcount = gint;
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GByteArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GByteArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GByteArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GByteArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GByteArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GByteArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GPtrArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GPtrArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPtrArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GPtrArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPtrArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPtrArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdata) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(pdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_new_take(
        data: gpointer,
        len: gsize,
        clear: gboolean,
        element_size: gsize,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_new_take_zero_terminated(
        data: gpointer,
        clear: gboolean,
        element_size: gsize,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_steal(array: *mut GArray, len: *mut gsize) -> gpointer;
}
extern "C" {
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
        reserved_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_copy(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    pub fn g_array_unref(array: *mut GArray);
}
extern "C" {
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
}
extern "C" {
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint)
        -> *mut GArray;
}
extern "C" {
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: guint,
        data: gconstpointer,
        len: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_array_binary_search(
        array: *mut GArray,
        target: gconstpointer,
        compare_func: GCompareFunc,
        out_match_index: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_new() -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_take(
        data: *mut gpointer,
        len: gsize,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_from_array(
        data: *mut gpointer,
        len: gsize,
        copy_func: GCopyFunc,
        copy_func_user_data: gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_steal(array: *mut GPtrArray, len: *mut gsize) -> *mut gpointer;
}
extern "C" {
    pub fn g_ptr_array_copy(
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_full(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_null_terminated(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
        null_terminated: gboolean,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_take_null_terminated(
        data: *mut gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_from_null_terminated_array(
        data: *mut gpointer,
        copy_func: GCopyFunc,
        copy_func_user_data: gpointer,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
}
extern "C" {
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
}
extern "C" {
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
}
extern "C" {
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_steal_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_steal_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: guint,
        length: guint,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_extend(
        array_to_extend: *mut GPtrArray,
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_extend_and_steal(array_to_extend: *mut GPtrArray, array: *mut GPtrArray);
}
extern "C" {
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_sort_values(array: *mut GPtrArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_ptr_array_sort_values_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_find(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_find_with_equal_func(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        equal_func: GEqualFunc,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_is_null_terminated(array: *mut GPtrArray) -> gboolean;
}
extern "C" {
    pub fn g_byte_array_new() -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_steal(array: *mut GByteArray, len: *mut gsize) -> *mut guint8;
}
extern "C" {
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
}
extern "C" {
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
}
extern "C" {
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_unref(array: *mut GByteArray);
}
extern "C" {
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint)
        -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: guint,
        length: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
}
extern "C" {
    pub fn g_atomic_int_inc(atomic: *mut gint);
}
extern "C" {
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_compare_and_exchange_full(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
        preval: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_exchange(atomic: *mut gint, newval: gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_pointer_get(atomic: *const ::std::os::raw::c_void) -> gpointer;
}
extern "C" {
    pub fn g_atomic_pointer_set(atomic: *mut ::std::os::raw::c_void, newval: gpointer);
}
extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange_full(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
        preval: *mut ::std::os::raw::c_void,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_pointer_exchange(
        atomic: *mut ::std::os::raw::c_void,
        newval: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_atomic_pointer_add(atomic: *mut ::std::os::raw::c_void, val: gssize) -> gssize;
}
extern "C" {
    pub fn g_atomic_pointer_and(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_or(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_xor(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type GQuark = guint32;
extern "C" {
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
}
extern "C" {
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
}
#[doc = " GError:\n @domain: error domain, e.g. %G_FILE_ERROR\n @code: error code, e.g. %G_FILE_ERROR_NOENT\n @message: human-readable informative error message\n\n The `GError` structure contains information about\n an error that has occurred."]
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[test]
fn bindgen_test_layout__GError() {
    const UNINIT: ::std::mem::MaybeUninit<_GError> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GError>(),
        16usize,
        concat!("Size of: ", stringify!(_GError))
    );
    assert_eq!(
        ::std::mem::align_of::<_GError>(),
        8usize,
        concat!("Alignment of ", stringify!(_GError))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(message)
        )
    );
}
#[doc = " GErrorInitFunc:\n @error: extended error\n\n Specifies the type of function which is called just after an\n extended error instance is created and its fields filled. It should\n only initialize the fields in the private data, which can be\n received with the generated `*_get_private()` function.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @error.\n\n Since: 2.68"]
pub type GErrorInitFunc = ::std::option::Option<unsafe extern "C" fn(error: *mut GError)>;
#[doc = " GErrorCopyFunc:\n @src_error: source extended error\n @dest_error: destination extended error\n\n Specifies the type of function which is called when an extended\n error instance is copied. It is passed the pointer to the\n destination error and source error, and should copy only the fields\n of the private data from @src_error to @dest_error.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @src_error and\n @dest_error.\n\n Since: 2.68"]
pub type GErrorCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src_error: *const GError, dest_error: *mut GError)>;
#[doc = " GErrorClearFunc:\n @error: extended error to clear\n\n Specifies the type of function which is called when an extended\n error instance is freed. It is passed the error pointer about to be\n freed, and should free the error's private data fields.\n\n Normally, it is better to use G_DEFINE_EXTENDED_ERROR(), as it\n already takes care of getting the private data from @error.\n\n Since: 2.68"]
pub type GErrorClearFunc = ::std::option::Option<unsafe extern "C" fn(error: *mut GError)>;
extern "C" {
    pub fn g_error_domain_register_static(
        error_type_name: *const ::std::os::raw::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
}
extern "C" {
    pub fn g_error_domain_register(
        error_type_name: *const ::std::os::raw::c_char,
        error_type_private_size: gsize,
        error_type_init: GErrorInitFunc,
        error_type_copy: GErrorCopyFunc,
        error_type_clear: GErrorClearFunc,
    ) -> GQuark;
}
extern "C" {
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_valist(
        domain: GQuark,
        code: gint,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> *mut GError;
}
extern "C" {
    pub fn g_error_free(error: *mut GError);
}
extern "C" {
    pub fn g_error_copy(error: *const GError) -> *mut GError;
}
extern "C" {
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
}
extern "C" {
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
extern "C" {
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
}
extern "C" {
    pub fn g_clear_error(err: *mut *mut GError);
}
extern "C" {
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
}
extern "C" {
    pub fn g_prefix_error_literal(err: *mut *mut GError, prefix: *const gchar);
}
extern "C" {
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_get_user_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_real_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_home_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_tmp_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_host_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_prgname() -> *const gchar;
}
extern "C" {
    pub fn g_set_prgname(prgname: *const gchar);
}
extern "C" {
    pub fn g_get_application_name() -> *const gchar;
}
extern "C" {
    pub fn g_set_application_name(application_name: *const gchar);
}
extern "C" {
    pub fn g_get_os_info(key_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_reload_user_special_dirs_cache();
}
extern "C" {
    pub fn g_get_user_data_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_config_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_cache_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_state_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_system_data_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_system_config_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_user_runtime_dir() -> *const gchar;
}
pub const GUserDirectory_G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const GUserDirectory_G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const GUserDirectory_G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const GUserDirectory_G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const GUserDirectory_G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const GUserDirectory_G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const GUserDirectory_G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const GUserDirectory_G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const GUserDirectory_G_USER_N_DIRECTORIES: GUserDirectory = 8;
#[doc = " GUserDirectory:\n @G_USER_DIRECTORY_DESKTOP: the user's Desktop directory\n @G_USER_DIRECTORY_DOCUMENTS: the user's Documents directory\n @G_USER_DIRECTORY_DOWNLOAD: the user's Downloads directory\n @G_USER_DIRECTORY_MUSIC: the user's Music directory\n @G_USER_DIRECTORY_PICTURES: the user's Pictures directory\n @G_USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory\n @G_USER_DIRECTORY_TEMPLATES: the user's Templates directory\n @G_USER_DIRECTORY_VIDEOS: the user's Movies directory\n @G_USER_N_DIRECTORIES: the number of enum values\n\n These are logical ids for special directories which are defined\n depending on the platform used. You should use g_get_user_special_dir()\n to retrieve the full path associated to the logical id.\n\n The #GUserDirectory enumeration can be extended at later date. Not\n every platform has a directory for every logical id in this\n enumeration.\n\n Since: 2.14"]
pub type GUserDirectory = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
}
#[doc = " GDebugKey:\n @key: the string\n @value: the flag\n\n Associates a string with a bit flag.\n Used in g_parse_debug_string()."]
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
#[test]
fn bindgen_test_layout__GDebugKey() {
    const UNINIT: ::std::mem::MaybeUninit<_GDebugKey> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDebugKey>(),
        16usize,
        concat!("Size of: ", stringify!(_GDebugKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugKey>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn g_parse_debug_string(
        string: *const gchar,
        keys: *const GDebugKey,
        nkeys: guint,
    ) -> guint;
}
extern "C" {
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
}
extern "C" {
    pub fn g_vsnprintf(
        string: *mut gchar,
        n: gulong,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gint;
}
extern "C" {
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
}
pub const GFormatSizeFlags_G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const GFormatSizeFlags_G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const GFormatSizeFlags_G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub const GFormatSizeFlags_G_FORMAT_SIZE_BITS: GFormatSizeFlags = 4;
pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_VALUE: GFormatSizeFlags = 8;
pub const GFormatSizeFlags_G_FORMAT_SIZE_ONLY_UNIT: GFormatSizeFlags = 16;
pub type GFormatSizeFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size(size: guint64) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
}
#[doc = " GVoidFunc:\n\n Declares a type of function which takes no arguments\n and has no return value. It is used to specify the type\n function passed to g_atexit()."]
pub type GVoidFunc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn g_atexit(func: GVoidFunc);
}
extern "C" {
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_storage(number: gulong) -> guint;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_thread_error_quark() -> GQuark;
}
pub const GThreadError_G_THREAD_ERROR_AGAIN: GThreadError = 0;
pub type GThreadError = ::std::os::raw::c_uint;
pub type GThreadFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GMutex() {
    const UNINIT: ::std::mem::MaybeUninit<_GMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMutex>(),
        8usize,
        concat!("Size of: ", stringify!(_GMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRWLock() {
    const UNINIT: ::std::mem::MaybeUninit<_GRWLock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GRWLock>(),
        16usize,
        concat!("Size of: ", stringify!(_GRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRWLock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GCond() {
    const UNINIT: ::std::mem::MaybeUninit<_GCond> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCond>(),
        16usize,
        concat!("Size of: ", stringify!(_GCond))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCond>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCond))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(i))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRecMutex() {
    const UNINIT: ::std::mem::MaybeUninit<_GRecMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GRecMutex>(),
        16usize,
        concat!("Size of: ", stringify!(_GRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRecMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GPrivate() {
    const UNINIT: ::std::mem::MaybeUninit<_GPrivate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPrivate>(),
        32usize,
        concat!("Size of: ", stringify!(_GPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPrivate>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPrivate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).future) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(future)
        )
    );
}
pub const GOnceStatus_G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const GOnceStatus_G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const GOnceStatus_G_ONCE_STATUS_READY: GOnceStatus = 2;
pub type GOnceStatus = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
#[test]
fn bindgen_test_layout__GOnce() {
    const UNINIT: ::std::mem::MaybeUninit<_GOnce> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOnce>(),
        16usize,
        concat!("Size of: ", stringify!(_GOnce))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOnce>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOnce))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_unref(thread: *mut GThread);
}
extern "C" {
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_try_new(
        name: *const gchar,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_self() -> *mut GThread;
}
extern "C" {
    pub fn g_thread_exit(retval: gpointer);
}
extern "C" {
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
}
extern "C" {
    pub fn g_thread_yield();
}
extern "C" {
    pub fn g_mutex_init(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_clear(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_lock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
}
extern "C" {
    pub fn g_mutex_unlock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_cond_init(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_clear(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_signal(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_broadcast(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
}
extern "C" {
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
}
extern "C" {
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_once_init_enter(location: *mut ::std::os::raw::c_void) -> gboolean;
}
extern "C" {
    pub fn g_once_init_leave(location: *mut ::std::os::raw::c_void, result: gsize);
}
extern "C" {
    pub fn g_get_num_processors() -> guint;
}
#[doc = " GMutexLocker:\n\n Opaque type. See g_mutex_locker_new() for details.\n Since: 2.44"]
pub type GMutexLocker = ::std::os::raw::c_void;
#[doc = " GRecMutexLocker:\n\n Opaque type. See g_rec_mutex_locker_new() for details.\n Since: 2.60"]
pub type GRecMutexLocker = ::std::os::raw::c_void;
#[doc = " GRWLockWriterLocker:\n\n Opaque type. See g_rw_lock_writer_locker_new() for details.\n Since: 2.62"]
pub type GRWLockWriterLocker = ::std::os::raw::c_void;
#[doc = " GRWLockReaderLocker:\n\n Opaque type. See g_rw_lock_reader_locker_new() for details.\n Since: 2.62"]
pub type GRWLockReaderLocker = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
extern "C" {
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop_unlocked(
        queue: *mut GAsyncQueue,
        timeout: guint64,
    ) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub __pad0: ::std::os::raw::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: ::std::os::raw::c_int,
    pub si_overrun: ::std::os::raw::c_int,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_tid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_tid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_overrun) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_overrun)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_sigval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_sigval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_utime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_stime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_addr_lsb: ::std::os::raw::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut ::std::os::raw::c_void,
    pub _upper: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lower) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._upper) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._addr_bnd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pkey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr_lsb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr_lsb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bounds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_bounds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: ::std::os::raw::c_long,
    pub si_fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_fd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut ::std::os::raw::c_void,
    pub _syscall: ::std::os::raw::c_int,
    pub _arch: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1__bindgen_ty_7> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._call_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._syscall) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._arch) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._kill) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._timer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._rt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigchld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigfault) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigpoll) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigsys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<siginfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sifields) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(_sifields)
        )
    );
}
pub const SI_ASYNCNL: _bindgen_ty_1 = -60;
pub const SI_DETHREAD: _bindgen_ty_1 = -7;
pub const SI_TKILL: _bindgen_ty_1 = -6;
pub const SI_SIGIO: _bindgen_ty_1 = -5;
pub const SI_ASYNCIO: _bindgen_ty_1 = -4;
pub const SI_MESGQ: _bindgen_ty_1 = -3;
pub const SI_TIMER: _bindgen_ty_1 = -2;
pub const SI_QUEUE: _bindgen_ty_1 = -1;
pub const SI_USER: _bindgen_ty_1 = 0;
pub const SI_KERNEL: _bindgen_ty_1 = 128;
pub type _bindgen_ty_1 = ::std::os::raw::c_int;
pub const ILL_ILLOPC: _bindgen_ty_2 = 1;
pub const ILL_ILLOPN: _bindgen_ty_2 = 2;
pub const ILL_ILLADR: _bindgen_ty_2 = 3;
pub const ILL_ILLTRP: _bindgen_ty_2 = 4;
pub const ILL_PRVOPC: _bindgen_ty_2 = 5;
pub const ILL_PRVREG: _bindgen_ty_2 = 6;
pub const ILL_COPROC: _bindgen_ty_2 = 7;
pub const ILL_BADSTK: _bindgen_ty_2 = 8;
pub const ILL_BADIADDR: _bindgen_ty_2 = 9;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const FPE_INTDIV: _bindgen_ty_3 = 1;
pub const FPE_INTOVF: _bindgen_ty_3 = 2;
pub const FPE_FLTDIV: _bindgen_ty_3 = 3;
pub const FPE_FLTOVF: _bindgen_ty_3 = 4;
pub const FPE_FLTUND: _bindgen_ty_3 = 5;
pub const FPE_FLTRES: _bindgen_ty_3 = 6;
pub const FPE_FLTINV: _bindgen_ty_3 = 7;
pub const FPE_FLTSUB: _bindgen_ty_3 = 8;
pub const FPE_FLTUNK: _bindgen_ty_3 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_3 = 15;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const SEGV_MAPERR: _bindgen_ty_4 = 1;
pub const SEGV_ACCERR: _bindgen_ty_4 = 2;
pub const SEGV_BNDERR: _bindgen_ty_4 = 3;
pub const SEGV_PKUERR: _bindgen_ty_4 = 4;
pub const SEGV_ACCADI: _bindgen_ty_4 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_4 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_4 = 7;
pub const SEGV_MTEAERR: _bindgen_ty_4 = 8;
pub const SEGV_MTESERR: _bindgen_ty_4 = 9;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const BUS_ADRALN: _bindgen_ty_5 = 1;
pub const BUS_ADRERR: _bindgen_ty_5 = 2;
pub const BUS_OBJERR: _bindgen_ty_5 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_5 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_5 = 5;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const CLD_EXITED: _bindgen_ty_6 = 1;
pub const CLD_KILLED: _bindgen_ty_6 = 2;
pub const CLD_DUMPED: _bindgen_ty_6 = 3;
pub const CLD_TRAPPED: _bindgen_ty_6 = 4;
pub const CLD_STOPPED: _bindgen_ty_6 = 5;
pub const CLD_CONTINUED: _bindgen_ty_6 = 6;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const POLL_IN: _bindgen_ty_7 = 1;
pub const POLL_OUT: _bindgen_ty_7 = 2;
pub const POLL_MSG: _bindgen_ty_7 = 3;
pub const POLL_ERR: _bindgen_ty_7 = 4;
pub const POLL_PRI: _bindgen_ty_7 = 5;
pub const POLL_HUP: _bindgen_ty_7 = 6;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_notify: ::std::os::raw::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [::std::os::raw::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._function) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._attribute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pad) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._tid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigev_thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._sigev_un) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_8 = 0;
pub const SIGEV_NONE: _bindgen_ty_8 = 1;
pub const SIGEV_THREAD: _bindgen_ty_8 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_8 = 4;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t)
        -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raise(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ssignal(__sig: ::std::os::raw::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psignal(__sig: ::std::os::raw::c_int, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn sigblock(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn siggetmask() -> ::std::os::raw::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigismember(
        __set: *const sigset_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
    pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut siginfo_t,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_restorer) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
extern "C" {
    pub fn sigprocmask(
        __how: ::std::os::raw::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigaction(
        __sig: ::std::os::raw::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwait(
        __set: *const sigset_t,
        __sig: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sigqueue(
        __pid: __pid_t,
        __sig: ::std::os::raw::c_int,
        __val: sigval,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    const UNINIT: ::std::mem::MaybeUninit<_fpx_sw_bytes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extended_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xstate_bv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xstate_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    const UNINIT: ::std::mem::MaybeUninit<_fpreg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).significand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    const UNINIT: ::std::mem::MaybeUninit<_fpxreg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).significand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    const UNINIT: ::std::mem::MaybeUninit<_xmmreg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    const UNINIT: ::std::mem::MaybeUninit<_fpstate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cwd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swd) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ftw) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fop) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mxcsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mxcr_mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._st) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._xmm) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: ::std::os::raw::c_ushort,
    pub gs: ::std::os::raw::c_ushort,
    pub fs: ::std::os::raw::c_ushort,
    pub __pad0: ::std::os::raw::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<sigcontext__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpstate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpstate_word) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(__fpstate_word)
        )
    );
}
#[test]
fn bindgen_test_layout_sigcontext() {
    const UNINIT: ::std::mem::MaybeUninit<sigcontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigcontext>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::std::mem::align_of::<sigcontext>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r9) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r10) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r11) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r12) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r13) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r14) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r15) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdi) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsi) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rbp) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rbx) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdx) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rax) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcx) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rsp) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eflags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cs) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gs) as usize - ptr as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fs) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad0) as usize - ptr as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trapno) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).oldmask) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cr2) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved1) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    const UNINIT: ::std::mem::MaybeUninit<_xsave_hdr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_xsave_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        ::std::mem::align_of::<_xsave_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xstate_bv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    const UNINIT: ::std::mem::MaybeUninit<_ymmh_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::std::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymmh_space) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    const UNINIT: ::std::mem::MaybeUninit<_xstate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpstate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xstate_hdr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymmh) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_flags: ::std::os::raw::c_int,
    pub ss_size: usize,
}
#[test]
fn bindgen_test_layout_stack_t() {
    const UNINIT: ::std::mem::MaybeUninit<stack_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<stack_t>(),
        24usize,
        concat!("Size of: ", stringify!(stack_t))
    );
    assert_eq!(
        ::std::mem::align_of::<stack_t>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type greg_t = ::std::os::raw::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [::std::os::raw::c_ushort; 4usize],
    pub exponent: ::std::os::raw::c_ushort,
    pub __glibc_reserved1: [::std::os::raw::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    const UNINIT: ::std::mem::MaybeUninit<_libc_fpxreg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_libc_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).significand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exponent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    const UNINIT: ::std::mem::MaybeUninit<_libc_xmmreg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_libc_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    const UNINIT: ::std::mem::MaybeUninit<_libc_fpstate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_libc_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        ::std::mem::align_of::<_libc_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cwd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).swd) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ftw) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fop) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mxcsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mxcr_mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._st) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._xmm) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__glibc_reserved1) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [::std::os::raw::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    const UNINIT: ::std::mem::MaybeUninit<mcontext_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mcontext_t>(),
        256usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mcontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gregs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(gregs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpregs) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(fpregs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__reserved1) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: ::std::os::raw::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [::std::os::raw::c_ulonglong; 4usize],
}
#[test]
fn bindgen_test_layout_ucontext_t() {
    const UNINIT: ::std::mem::MaybeUninit<ucontext_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ucontext_t>(),
        968usize,
        concat!("Size of: ", stringify!(ucontext_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ucontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucontext_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpregs_mem) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__fpregs_mem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ssp) as usize - ptr as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__ssp)
        )
    );
}
extern "C" {
    pub fn siginterrupt(
        __sig: ::std::os::raw::c_int,
        __interrupt: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const SS_ONSTACK: _bindgen_ty_9 = 1;
pub const SS_DISABLE: _bindgen_ty_9 = 2;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: ::std::os::raw::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_kill(
        __threadid: pthread_t,
        __signo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_on_error_query(prg_name: *const gchar);
}
extern "C" {
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
}
extern "C" {
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_base64_decode_step(
        in_: *const gchar,
        len: gsize,
        out: *mut guchar,
        state: *mut gint,
        save: *mut guint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_lock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_trylock(address: *mut ::std::os::raw::c_void, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_pointer_bit_unlock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
pub const GTimeType_G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const GTimeType_G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const GTimeType_G_TIME_TYPE_UNIVERSAL: GTimeType = 2;
#[doc = " GTimeType:\n @G_TIME_TYPE_STANDARD: the time is in local standard time\n @G_TIME_TYPE_DAYLIGHT: the time is in local daylight time\n @G_TIME_TYPE_UNIVERSAL: the time is in UTC\n\n Disambiguates a given time in two ways.\n\n First, specifies if the given time is in universal or local time.\n\n Second, if the time is in local time, specifies if it is local\n standard time or local daylight time.  This is important for the case\n where the same local time occurs twice (during daylight savings time\n transitions, for example)."]
pub type GTimeType = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_identifier(identifier: *const gchar) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_offset(seconds: gint32) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
}
extern "C" {
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
}
extern "C" {
    pub fn g_time_zone_adjust_time(
        tz: *mut GTimeZone,
        type_: GTimeType,
        time_: *mut gint64,
    ) -> gint;
}
extern "C" {
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
}
extern "C" {
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
}
extern "C" {
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
}
extern "C" {
    pub fn g_time_zone_get_identifier(tz: *mut GTimeZone) -> *const gchar;
}
#[doc = " GTimeSpan:\n\n A value representing an interval of time, in microseconds.\n\n Since: 2.26"]
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
#[doc = " GDateTime:\n\n An opaque structure that represents a date and time, including a time zone.\n\n Since: 2.26"]
pub type GDateTime = _GDateTime;
extern "C" {
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
extern "C" {
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_iso8601(
        text: *const gchar,
        default_tz: *mut GTimeZone,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
}
extern "C" {
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
extern "C" {
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
extern "C" {
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_get_timezone(datetime: *mut GDateTime) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
extern "C" {
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
extern "C" {
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_date_time_format_iso8601(datetime: *mut GDateTime) -> *mut gchar;
}
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;
#[doc = " GBookmarkFileError:\n @G_BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed\n @G_BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found\n @G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did\n     not register a bookmark\n @G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found\n @G_BOOKMARK_FILE_ERROR_READ: document was ill formed\n @G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was\n     in an unknown encoding\n @G_BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing\n @G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found\n\n Error codes returned by bookmark file parsing."]
pub type GBookmarkFileError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_bookmark_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
#[doc = " GBookmarkFile:\n\n An opaque data structure representing a set of bookmarks."]
pub type GBookmarkFile = _GBookmarkFile;
extern "C" {
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
}
extern "C" {
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
}
extern "C" {
    pub fn g_bookmark_file_copy(bookmark: *mut GBookmarkFile) -> *mut GBookmarkFile;
}
extern "C" {
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        title: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        groups: *mut *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exec: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
        stamp: *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_application_info(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        exec: *mut *mut ::std::os::raw::c_char,
        count: *mut ::std::os::raw::c_uint,
        stamp: *mut *mut GDateTime,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        is_private: gboolean,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        added: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_set_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        added: *mut GDateTime,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_get_added_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        modified: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_set_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        modified: *mut GDateTime,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_get_modified_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        visited: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_set_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        visited: *mut GDateTime,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_get_visited_date_time(
        bookmark: *mut GBookmarkFile,
        uri: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
}
extern "C" {
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: gsize,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
}
extern "C" {
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
}
extern "C" {
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_unref(bytes: *mut GBytes);
}
extern "C" {
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
}
extern "C" {
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
}
extern "C" {
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_bytes_get_region(
        bytes: *mut GBytes,
        element_size: gsize,
        offset: gsize,
        n_elements: gsize,
    ) -> gconstpointer;
}
extern "C" {
    pub fn g_get_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn g_get_codeset() -> *mut gchar;
}
extern "C" {
    pub fn g_get_console_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    pub fn g_get_language_names() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_language_names_with_category(category_name: *const gchar) -> *const *const gchar;
}
extern "C" {
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
}
pub const GChecksumType_G_CHECKSUM_MD5: GChecksumType = 0;
pub const GChecksumType_G_CHECKSUM_SHA1: GChecksumType = 1;
pub const GChecksumType_G_CHECKSUM_SHA256: GChecksumType = 2;
pub const GChecksumType_G_CHECKSUM_SHA512: GChecksumType = 3;
pub const GChecksumType_G_CHECKSUM_SHA384: GChecksumType = 4;
#[doc = " GChecksumType:\n @G_CHECKSUM_MD5: Use the MD5 hashing algorithm\n @G_CHECKSUM_SHA1: Use the SHA-1 hashing algorithm\n @G_CHECKSUM_SHA256: Use the SHA-256 hashing algorithm\n @G_CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)\n @G_CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)\n\n The hashing algorithm to be used by #GChecksum when performing the\n digest of some data.\n\n Note that the #GChecksumType enumeration may be extended at a later\n date to include new hashing algorithm types.\n\n Since: 2.16"]
pub type GChecksumType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
#[doc = " GChecksum:\n\n An opaque structure representing a checksumming operation.\n\n To create a new GChecksum, use g_checksum_new(). To free\n a GChecksum, use g_checksum_free().\n\n Since: 2.16"]
pub type GChecksum = _GChecksum;
extern "C" {
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
}
extern "C" {
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_reset(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_free(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
}
extern "C" {
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut guint8,
        digest_len: *mut gsize,
    );
}
extern "C" {
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub const GConvertError_G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const GConvertError_G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const GConvertError_G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const GConvertError_G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const GConvertError_G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const GConvertError_G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const GConvertError_G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
pub const GConvertError_G_CONVERT_ERROR_EMBEDDED_NUL: GConvertError = 7;
#[doc = " GConvertError:\n @G_CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character\n     sets is not supported.\n @G_CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input;\n    or the character sequence could not be represented in the target\n    character set.\n @G_CONVERT_ERROR_FAILED: Conversion failed for some reason.\n @G_CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input.\n @G_CONVERT_ERROR_BAD_URI: URI is invalid.\n @G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path.\n @G_CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40\n @G_CONVERT_ERROR_EMBEDDED_NUL: An embedded NUL character is present in\n     conversion output where a NUL-terminated string is expected.\n     Since: 2.56\n\n Error codes returned by character set conversion routines."]
pub type GConvertError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_convert_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
#[doc = " GIConv: (skip)\n\n The GIConv struct wraps an iconv() conversion descriptor. It contains\n private data and should only be accessed using the following functions."]
pub type GIConv = *mut _GIConv;
extern "C" {
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
}
extern "C" {
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_iconv_close(converter: GIConv) -> gint;
}
extern "C" {
    pub fn g_convert(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_iconv(
        str_: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_fallback(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_uri(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_uri(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_get_filename_charsets(filename_charsets: *mut *mut *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer),
>;
extern "C" {
    pub fn g_datalist_init(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_clear(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_datalist_id_remove_multiple(
        datalist: *mut *mut GData,
        keys: *mut GQuark,
        n_keys: gsize,
    );
}
pub type GDuplicateFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
extern "C" {
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
}
extern "C" {
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
}
extern "C" {
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
}
extern "C" {
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const GDateDMY_G_DATE_DAY: GDateDMY = 0;
pub const GDateDMY_G_DATE_MONTH: GDateDMY = 1;
pub const GDateDMY_G_DATE_YEAR: GDateDMY = 2;
pub type GDateDMY = ::std::os::raw::c_uint;
pub const GDateWeekday_G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const GDateWeekday_G_DATE_MONDAY: GDateWeekday = 1;
pub const GDateWeekday_G_DATE_TUESDAY: GDateWeekday = 2;
pub const GDateWeekday_G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const GDateWeekday_G_DATE_THURSDAY: GDateWeekday = 4;
pub const GDateWeekday_G_DATE_FRIDAY: GDateWeekday = 5;
pub const GDateWeekday_G_DATE_SATURDAY: GDateWeekday = 6;
pub const GDateWeekday_G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = ::std::os::raw::c_uint;
pub const GDateMonth_G_DATE_BAD_MONTH: GDateMonth = 0;
pub const GDateMonth_G_DATE_JANUARY: GDateMonth = 1;
pub const GDateMonth_G_DATE_FEBRUARY: GDateMonth = 2;
pub const GDateMonth_G_DATE_MARCH: GDateMonth = 3;
pub const GDateMonth_G_DATE_APRIL: GDateMonth = 4;
pub const GDateMonth_G_DATE_MAY: GDateMonth = 5;
pub const GDateMonth_G_DATE_JUNE: GDateMonth = 6;
pub const GDateMonth_G_DATE_JULY: GDateMonth = 7;
pub const GDateMonth_G_DATE_AUGUST: GDateMonth = 8;
pub const GDateMonth_G_DATE_SEPTEMBER: GDateMonth = 9;
pub const GDateMonth_G_DATE_OCTOBER: GDateMonth = 10;
pub const GDateMonth_G_DATE_NOVEMBER: GDateMonth = 11;
pub const GDateMonth_G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GDate {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout__GDate() {
    assert_eq!(
        ::std::mem::size_of::<_GDate>(),
        8usize,
        concat!("Size of: ", stringify!(_GDate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDate))
    );
}
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::std::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::std::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::std::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::std::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::std::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::std::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn g_date_new() -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
extern "C" {
    pub fn g_date_free(date: *mut GDate);
}
extern "C" {
    pub fn g_date_copy(date: *const GDate) -> *mut GDate;
}
extern "C" {
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
extern "C" {
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
extern "C" {
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
extern "C" {
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
extern "C" {
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
extern "C" {
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
extern "C" {
    pub fn g_date_set_parse(date: *mut GDate, str_: *const gchar);
}
extern "C" {
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
extern "C" {
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
extern "C" {
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
extern "C" {
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
extern "C" {
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
extern "C" {
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
extern "C" {
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
extern "C" {
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
extern "C" {
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
extern "C" {
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
extern "C" {
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: ::std::os::raw::c_ushort,
    pub d_type: ::std::os::raw::c_uchar,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    const UNINIT: ::std::mem::MaybeUninit<dirent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        280usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_ino) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_off) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_off)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_reclen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_type) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d_name) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
pub const DT_UNKNOWN: _bindgen_ty_10 = 0;
pub const DT_FIFO: _bindgen_ty_10 = 1;
pub const DT_CHR: _bindgen_ty_10 = 2;
pub const DT_DIR: _bindgen_ty_10 = 4;
pub const DT_BLK: _bindgen_ty_10 = 6;
pub const DT_REG: _bindgen_ty_10 = 8;
pub const DT_LNK: _bindgen_ty_10 = 10;
pub const DT_SOCK: _bindgen_ty_10 = 12;
pub const DT_WHT: _bindgen_ty_10 = 14;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn opendir(__name: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    pub fn fdopendir(__fd: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: ::std::os::raw::c_long);
}
extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scandir(
        __dir: *const ::std::os::raw::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        __cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut *const dirent,
                arg2: *mut *const dirent,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdirentries(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
extern "C" {
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
extern "C" {
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
}
extern "C" {
    pub fn g_dir_rewind(dir: *mut GDir);
}
extern "C" {
    pub fn g_dir_close(dir: *mut GDir);
}
extern "C" {
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_unsetenv(variable: *const gchar);
}
extern "C" {
    pub fn g_listenv() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_get_environ() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_environ_setenv(
        envp: *mut *mut gchar,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
}
pub const GFileError_G_FILE_ERROR_EXIST: GFileError = 0;
pub const GFileError_G_FILE_ERROR_ISDIR: GFileError = 1;
pub const GFileError_G_FILE_ERROR_ACCES: GFileError = 2;
pub const GFileError_G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const GFileError_G_FILE_ERROR_NOENT: GFileError = 4;
pub const GFileError_G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const GFileError_G_FILE_ERROR_NXIO: GFileError = 6;
pub const GFileError_G_FILE_ERROR_NODEV: GFileError = 7;
pub const GFileError_G_FILE_ERROR_ROFS: GFileError = 8;
pub const GFileError_G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const GFileError_G_FILE_ERROR_FAULT: GFileError = 10;
pub const GFileError_G_FILE_ERROR_LOOP: GFileError = 11;
pub const GFileError_G_FILE_ERROR_NOSPC: GFileError = 12;
pub const GFileError_G_FILE_ERROR_NOMEM: GFileError = 13;
pub const GFileError_G_FILE_ERROR_MFILE: GFileError = 14;
pub const GFileError_G_FILE_ERROR_NFILE: GFileError = 15;
pub const GFileError_G_FILE_ERROR_BADF: GFileError = 16;
pub const GFileError_G_FILE_ERROR_INVAL: GFileError = 17;
pub const GFileError_G_FILE_ERROR_PIPE: GFileError = 18;
pub const GFileError_G_FILE_ERROR_AGAIN: GFileError = 19;
pub const GFileError_G_FILE_ERROR_INTR: GFileError = 20;
pub const GFileError_G_FILE_ERROR_IO: GFileError = 21;
pub const GFileError_G_FILE_ERROR_PERM: GFileError = 22;
pub const GFileError_G_FILE_ERROR_NOSYS: GFileError = 23;
pub const GFileError_G_FILE_ERROR_FAILED: GFileError = 24;
pub type GFileError = ::std::os::raw::c_uint;
pub const GFileTest_G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const GFileTest_G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const GFileTest_G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const GFileTest_G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const GFileTest_G_FILE_TEST_EXISTS: GFileTest = 16;
pub type GFileTest = ::std::os::raw::c_uint;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_NONE: GFileSetContentsFlags = 0;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_CONSISTENT: GFileSetContentsFlags = 1;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_DURABLE: GFileSetContentsFlags = 2;
pub const GFileSetContentsFlags_G_FILE_SET_CONTENTS_ONLY_EXISTING: GFileSetContentsFlags = 4;
#[doc = " GFileSetContentsFlags:\n @G_FILE_SET_CONTENTS_NONE: No guarantees about file consistency or durability.\n   The most dangerous setting, which is slightly faster than other settings.\n @G_FILE_SET_CONTENTS_CONSISTENT: Guarantee file consistency: after a crash,\n   either the old version of the file or the new version of the file will be\n   available, but not a mixture. On Unix systems this equates to an `fsync()`\n   on the file and use of an atomic `rename()` of the new version of the file\n   over the old.\n @G_FILE_SET_CONTENTS_DURABLE: Guarantee file durability: after a crash, the\n   new version of the file will be available. On Unix systems this equates to\n   an `fsync()` on the file (if %G_FILE_SET_CONTENTS_CONSISTENT is unset), or\n   the effects of %G_FILE_SET_CONTENTS_CONSISTENT plus an `fsync()` on the\n   directory containing the file after calling `rename()`.\n @G_FILE_SET_CONTENTS_ONLY_EXISTING: Only apply consistency and durability\n   guarantees if the file already exists. This may speed up file operations\n   if the file doesnt currently exist, but may result in a corrupted version\n   of the new file if the system crashes while writing it.\n\n Flags to pass to g_file_set_contents_full() to affect its safety and\n performance.\n\n Since: 2.66"]
pub type GFileSetContentsFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_file_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
}
extern "C" {
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
}
extern "C" {
    pub fn g_file_get_contents(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_contents(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_contents_full(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        flags: GFileSetContentsFlags,
        mode: ::std::os::raw::c_int,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
}
extern "C" {
    pub fn g_file_open_tmp(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filename_valist(first_element: *const gchar, args: *mut va_list) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
}
extern "C" {
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_get_current_dir() -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_canonicalize_filename(filename: *const gchar, relative_to: *const gchar)
        -> *mut gchar;
}
extern "C" {
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
}
extern "C" {
    pub fn g_dngettext(
        domain: *const gchar,
        msgid: *const gchar,
        msgid_plural: *const gchar,
        n: gulong,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext(
        domain: *const gchar,
        msgctxtid: *const gchar,
        msgidoffset: gsize,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext2(
        domain: *const gchar,
        context: *const gchar,
        msgid: *const gchar,
    ) -> *const gchar;
}
#[doc = " GMemVTable:\n @malloc: function to use for allocating memory.\n @realloc: function to use for reallocating memory.\n @free: function to use to free memory.\n @calloc: function to use for allocating zero-filled memory.\n @try_malloc: function to use for allocating memory without a default error handler.\n @try_realloc: function to use for reallocating memory without a default error handler.\n\n A set of functions used to perform memory allocation. The same #GMemVTable must\n be used for all allocations in the same program; a call to g_mem_set_vtable(),\n if it exists, should be prior to any use of GLib.\n\n This functions related to this has been deprecated in 2.46, and no longer work."]
pub type GMemVTable = _GMemVTable;
extern "C" {
    pub fn g_free(mem: gpointer);
}
extern "C" {
    pub fn g_free_sized(mem: gpointer, size: usize);
}
extern "C" {
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
}
extern "C" {
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_aligned_alloc(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
}
extern "C" {
    pub fn g_aligned_alloc0(n_blocks: gsize, n_block_bytes: gsize, alignment: gsize) -> gpointer;
}
extern "C" {
    pub fn g_aligned_free(mem: gpointer);
}
extern "C" {
    pub fn g_aligned_free_sized(mem: gpointer, alignment: usize, size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemVTable {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::std::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer,
    >,
    pub try_malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
#[test]
fn bindgen_test_layout__GMemVTable() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemVTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemVTable>(),
        48usize,
        concat!("Size of: ", stringify!(_GMemVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemVTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).malloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).realloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).calloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(calloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).try_malloc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_malloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).try_realloc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_realloc)
        )
    );
}
extern "C" {
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
}
extern "C" {
    pub fn g_mem_is_system_malloc() -> gboolean;
}
extern "C" {
    pub static mut g_mem_gc_friendly: gboolean;
}
extern "C" {
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
}
extern "C" {
    pub fn g_mem_profile();
}
pub type GNode = _GNode;
pub const GTraverseFlags_G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const GTraverseFlags_G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;
pub type GTraverseFlags = ::std::os::raw::c_uint;
pub const GTraverseType_G_IN_ORDER: GTraverseType = 0;
pub const GTraverseType_G_PRE_ORDER: GTraverseType = 1;
pub const GTraverseType_G_POST_ORDER: GTraverseType = 2;
pub const GTraverseType_G_LEVEL_ORDER: GTraverseType = 3;
pub type GTraverseType = ::std::os::raw::c_uint;
pub type GNodeTraverseFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
#[test]
fn bindgen_test_layout__GNode() {
    const UNINIT: ::std::mem::MaybeUninit<_GNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNode>(),
        40usize,
        concat!("Size of: ", stringify!(_GNode))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(children)
        )
    );
}
extern "C" {
    pub fn g_node_new(data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_destroy(root: *mut GNode);
}
extern "C" {
    pub fn g_node_unlink(node: *mut GNode);
}
extern "C" {
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
}
extern "C" {
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
}
extern "C" {
    pub fn g_node_depth(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_max_height(root: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_reverse_children(node: *mut GNode);
}
extern "C" {
    pub fn g_node_n_children(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
        -> *mut GNode;
}
extern "C" {
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
}
extern "C" {
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
}
extern "C" {
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    const UNINIT: ::std::mem::MaybeUninit<_GList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
extern "C" {
    pub fn g_list_alloc() -> *mut GList;
}
extern "C" {
    pub fn g_list_free(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_1(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
        -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_before_link(
        list: *mut GList,
        sibling: *mut GList,
        link_: *mut GList,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
extern "C" {
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_length(list: *mut GList) -> guint;
}
extern "C" {
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
extern "C" {
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_clear_list(list_ptr: *mut *mut GList, destroy: GDestroyNotify);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::std::os::raw::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
#[test]
fn bindgen_test_layout__GHashTableIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GHashTableIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GHashTableIter>(),
        40usize,
        concat!("Size of: ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHashTableIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy4) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy5) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy6) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy6)
        )
    );
}
extern "C" {
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_new_similar(other_hash_table: *mut GHashTable) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_steal_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        stolen_key: *mut gpointer,
        stolen_value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_steal_all_keys(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_hash_table_steal_all_values(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
}
extern "C" {
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut guint,
    ) -> *mut gpointer;
}
extern "C" {
    pub fn g_hash_table_get_keys_as_ptr_array(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_hash_table_get_values_as_ptr_array(hash_table: *mut GHashTable) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
}
extern "C" {
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_str_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int64_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_double_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
#[doc = " GHmac:\n\n An opaque structure representing a HMAC operation.\n To create a new GHmac, use g_hmac_new(). To free\n a GHmac, use g_hmac_unref().\n\n Since: 2.30"]
pub type GHmac = _GHmac;
extern "C" {
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize)
        -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_unref(hmac: *mut GHmac);
}
extern "C" {
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
}
extern "C" {
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
}
extern "C" {
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller = ::std::option::Option<
    unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer) -> gboolean,
>;
pub type GHookFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
pub const GHookFlagMask_G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const GHookFlagMask_G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const GHookFlagMask_G_HOOK_FLAG_MASK: GHookFlagMask = 15;
pub type GHookFlagMask = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GHookList() {
    const UNINIT: ::std::mem::MaybeUninit<_GHookList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GHookList>(),
        56usize,
        concat!("Size of: ", stringify!(_GHookList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHookList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHookList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(seq_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hooks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(hooks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize_hook) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(finalize_hook)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy)
        )
    );
}
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_size: guint,
        is_setup: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::std::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::std::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
#[test]
fn bindgen_test_layout__GHook() {
    const UNINIT: ::std::mem::MaybeUninit<_GHook> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GHook>(),
        64usize,
        concat!("Size of: ", stringify!(_GHook))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHook>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHook))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hook_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(hook_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(destroy)
        )
    );
}
extern "C" {
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
}
extern "C" {
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
}
extern "C" {
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
}
extern "C" {
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
}
extern "C" {
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
}
extern "C" {
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
}
#[doc = " GPollFD:\n @fd: the file descriptor to poll (or a HANDLE on Win32)\n @events: a bitwise combination from #GIOCondition, specifying which\n     events should be polled for. Typically for reading from a file\n     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n     for writing you would use %G_IO_OUT | %G_IO_ERR.\n @revents: a bitwise combination of flags from #GIOCondition, returned\n     from the poll() function to indicate which events occurred.\n\n Represents a file descriptor, which events to poll for, and which events\n occurred."]
pub type GPollFD = _GPollFD;
#[doc = " GPollFunc:\n @ufds: an array of #GPollFD elements\n @nfsd: the number of elements in @ufds\n @timeout_: the maximum time to wait for an event of the file descriptors.\n     A negative value indicates an infinite timeout.\n\n Specifies the type of function passed to g_main_context_set_poll_func().\n The semantics of the function should match those of the poll() system call.\n\n Returns: the number of #GPollFD elements which have events or errors\n     reported, or -1 if an error occurred."]
pub type GPollFunc = ::std::option::Option<
    unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint,
>;
#[doc = " GPollFD:\n @fd: the file descriptor to poll (or a HANDLE on Win32)\n @events: a bitwise combination from #GIOCondition, specifying which\n     events should be polled for. Typically for reading from a file\n     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and\n     for writing you would use %G_IO_OUT | %G_IO_ERR.\n @revents: a bitwise combination of flags from #GIOCondition, returned\n     from the poll() function to indicate which events occurred.\n\n Represents a file descriptor, which events to poll for, and which events\n occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
#[test]
fn bindgen_test_layout__GPollFD() {
    const UNINIT: ::std::mem::MaybeUninit<_GPollFD> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPollFD>(),
        8usize,
        concat!("Size of: ", stringify!(_GPollFD))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollFD>(),
        4usize,
        concat!("Alignment of ", stringify!(_GPollFD))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revents) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(revents)
        )
    );
}
extern "C" {
    #[doc = " G_POLLFD_FORMAT:\n\n A format specifier that can be used in printf()-style format strings\n when printing the @fd member of a #GPollFD."]
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    const UNINIT: ::std::mem::MaybeUninit<_GSList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSList>(),
        16usize,
        concat!("Size of: ", stringify!(_GSList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn g_slist_alloc() -> *mut GSList;
}
extern "C" {
    pub fn g_slist_free(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_1(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
extern "C" {
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
extern "C" {
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_clear_slist(slist_ptr: *mut *mut GSList, destroy: GDestroyNotify);
}
pub const GIOCondition_G_IO_IN: GIOCondition = 1;
pub const GIOCondition_G_IO_OUT: GIOCondition = 4;
pub const GIOCondition_G_IO_PRI: GIOCondition = 2;
pub const GIOCondition_G_IO_ERR: GIOCondition = 8;
pub const GIOCondition_G_IO_HUP: GIOCondition = 16;
pub const GIOCondition_G_IO_NVAL: GIOCondition = 32;
pub type GIOCondition = ::std::os::raw::c_uint;
pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_NONE: GMainContextFlags = 0;
pub const GMainContextFlags_G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: GMainContextFlags = 1;
#[doc = " GMainContextFlags:\n @G_MAIN_CONTEXT_FLAGS_NONE: Default behaviour.\n @G_MAIN_CONTEXT_FLAGS_OWNERLESS_POLLING: Assume that polling for events will\n free the thread to process other jobs. That's useful if you're using\n `g_main_context_{prepare,query,check,dispatch}` to integrate GMainContext in\n other event loops.\n\n Flags to pass to g_main_context_new_with_flags() which affect the behaviour\n of a #GMainContext.\n\n Since: 2.72"]
pub type GMainContextFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
#[doc = " GMainContext:\n\n The `GMainContext` struct is an opaque data\n type representing a set of sources to be handled in a main loop."]
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
#[doc = " GMainLoop:\n\n The `GMainLoop` struct is an opaque data type\n representing the main event loop of a GLib or GTK+ application."]
pub type GMainLoop = _GMainLoop;
#[doc = " GSource:\n\n The `GSource` struct is an opaque data type\n representing an event source."]
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
#[doc = " GSourceCallbackFuncs:\n @ref: Called when a reference is added to the callback object\n @unref: Called when a reference to the callback object is dropped\n @get: Called to extract the callback function and data from the\n     callback object.\n\n The `GSourceCallbackFuncs` struct contains\n functions for managing callback objects."]
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
#[doc = " GSourceFuncs:\n @prepare: Called before all the file descriptors are polled. If the\n     source can determine that it is ready here (without waiting for the\n     results of the poll() call) it should return %TRUE. It can also return\n     a @timeout_ value which should be the maximum timeout (in milliseconds)\n     which should be passed to the poll() call. The actual timeout used will\n     be -1 if all sources returned -1, or it will be the minimum of all\n     the @timeout_ values returned which were >= 0.  Since 2.36 this may\n     be %NULL, in which case the effect is as if the function always returns\n     %FALSE with a timeout of -1.  If @prepare returns a\n     timeout and the source also has a ready time set, then the\n     lower of the two will be used.\n @check: Called after all the file descriptors are polled. The source\n     should return %TRUE if it is ready to be dispatched. Note that some\n     time may have passed since the previous prepare function was called,\n     so the source should be checked again here.  Since 2.36 this may\n     be %NULL, in which case the effect is as if the function always returns\n     %FALSE.\n @dispatch: Called to dispatch the event source, after it has returned\n     %TRUE in either its @prepare or its @check function, or if a ready time\n     has been reached. The @dispatch function receives a callback function and\n     user data. The callback function may be %NULL if the source was never\n     connected to a callback using g_source_set_callback(). The @dispatch\n     function should call the callback function with @user_data and whatever\n     additional parameters are needed for this type of event source. The\n     return value of the @dispatch function should be %G_SOURCE_REMOVE if the\n     source should be removed or %G_SOURCE_CONTINUE to keep it.\n @finalize: Called when the source is finalized. At this point, the source\n     will have been destroyed, had its callback cleared, and have been removed\n     from its #GMainContext, but it will still have its final reference count,\n     so methods can be called on it from within this function.\n\n The `GSourceFuncs` struct contains a table of\n functions used to handle event sources in a generic manner.\n\n For idle sources, the prepare and check functions always return %TRUE\n to indicate that the source is always ready to be processed. The prepare\n function also returns a timeout value of 0 to ensure that the poll() call\n doesn't block (since that would be time wasted which could have been spent\n running the idle function).\n\n For timeout sources, the prepare and check functions both return %TRUE\n if the timeout interval has expired. The prepare function also returns\n a timeout value to ensure that the poll() call doesn't block too long\n and miss the next timeout.\n\n For file descriptor sources, the prepare function typically returns %FALSE,\n since it must wait until poll() has been called before it knows whether\n any events need to be processed. It sets the returned timeout to -1 to\n indicate that it doesn't mind how long the poll() call blocks. In the\n check function, it tests the results of the poll() call to see if the\n required condition has been met, and returns %TRUE if so."]
pub type GSourceFuncs = _GSourceFuncs;
#[doc = " GSourceFunc:\n @user_data: data passed to the function, set when the source was\n     created with one of the above functions\n\n Specifies the type of function passed to g_timeout_add(),\n g_timeout_add_full(), g_idle_add(), and g_idle_add_full().\n\n When calling g_source_set_callback(), you may need to cast a function of a\n different type to this type. Use G_SOURCE_FUNC() to avoid warnings about\n incompatible function types.\n\n Returns: %FALSE if the source should be removed. %G_SOURCE_CONTINUE and\n %G_SOURCE_REMOVE are more memorable names for the return value."]
pub type GSourceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
#[doc = " GSourceOnceFunc:\n @user_data: data passed to the function, set when the source was\n   created\n\n A source function that is only called once before being removed from the main\n context automatically.\n\n See: g_idle_add_once(), g_timeout_add_once()\n\n Since: 2.74"]
pub type GSourceOnceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
#[doc = " GChildWatchFunc:\n @pid: the process id of the child process\n @wait_status: Status information about the child process, encoded\n               in a platform-specific manner\n @user_data: user data passed to g_child_watch_add()\n\n Prototype of a #GChildWatchSource callback, called when a child\n process has exited.\n\n To interpret @wait_status, see the documentation\n for g_spawn_check_wait_status(). In particular,\n on Unix platforms, note that it is usually not equal\n to the integer passed to `exit()` or returned from `main()`."]
pub type GChildWatchFunc =
    ::std::option::Option<unsafe extern "C" fn(pid: GPid, wait_status: gint, user_data: gpointer)>;
#[doc = " GSourceDisposeFunc:\n @source: #GSource that is currently being disposed\n\n Dispose function for @source. See g_source_set_dispose_function() for\n details.\n\n Since: 2.64"]
pub type GSourceDisposeFunc = ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::std::os::raw::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[test]
fn bindgen_test_layout__GSource() {
    const UNINIT: ::std::mem::MaybeUninit<_GSource> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSource>(),
        96usize,
        concat!("Size of: ", stringify!(_GSource))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSource>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSource))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback_funcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_funcs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll_fds) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(poll_fds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            cb_data: gpointer,
            source: *mut GSource,
            func: *mut GSourceFunc,
            data: *mut gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GSourceCallbackFuncs() {
    const UNINIT: ::std::mem::MaybeUninit<_GSourceCallbackFuncs> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSourceCallbackFuncs>(),
        24usize,
        concat!("Size of: ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceCallbackFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unref) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(unref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(get)
        )
    );
}
#[doc = " GSourceDummyMarshal:\n\n This is just a placeholder for #GClosureMarshal,\n which cannot be used here for dependency reasons."]
pub type GSourceDummyMarshal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceFuncs {
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean,
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GSource,
            callback: GSourceFunc,
            user_data: gpointer,
        ) -> gboolean,
    >,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
#[test]
fn bindgen_test_layout__GSourceFuncs() {
    const UNINIT: ::std::mem::MaybeUninit<_GSourceFuncs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSourceFuncs>(),
        48usize,
        concat!("Size of: ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prepare) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closure_callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closure_marshal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_marshal)
        )
    );
}
extern "C" {
    pub fn g_main_context_new() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_new_with_flags(flags: GMainContextFlags) -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_unref(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: guint,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_wakeup(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_release(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
}
extern "C" {
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
}
extern "C" {
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_main_context_dispatch(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
}
extern "C" {
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
}
extern "C" {
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
}
extern "C" {
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_main_depth() -> gint;
}
extern "C" {
    pub fn g_main_current_source() -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
}
#[doc = " GMainContextPusher:\n\n Opaque type. See g_main_context_pusher_new() for details.\n\n Since: 2.64"]
pub type GMainContextPusher = ::std::os::raw::c_void;
extern "C" {
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
}
extern "C" {
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_source_set_dispose_function(source: *mut GSource, dispose: GSourceDisposeFunc);
}
extern "C" {
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
}
extern "C" {
    pub fn g_source_unref(source: *mut GSource);
}
extern "C" {
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
}
extern "C" {
    pub fn g_source_destroy(source: *mut GSource);
}
extern "C" {
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
}
extern "C" {
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
}
extern "C" {
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
}
extern "C" {
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_get_id(source: *mut GSource) -> guint;
}
extern "C" {
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
}
extern "C" {
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_set_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_set_static_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_get_name(source: *mut GSource) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_source_set_name_by_id(tag: guint, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
}
extern "C" {
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint, events: GIOCondition) -> gpointer;
}
extern "C" {
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
}
extern "C" {
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
}
extern "C" {
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
}
extern "C" {
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
}
extern "C" {
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_idle_source_new() -> *mut GSource;
}
extern "C" {
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_get_current_time(result: *mut GTimeVal);
}
extern "C" {
    pub fn g_get_monotonic_time() -> gint64;
}
extern "C" {
    pub fn g_get_real_time() -> gint64;
}
extern "C" {
    pub fn g_source_remove(tag: guint) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
}
#[doc = " GClearHandleFunc:\n @handle_id: the handle ID to clear\n\n Specifies the type of function passed to g_clear_handle_id().\n The implementation is expected to free the resource identified\n by @handle_id; for instance, if @handle_id is a #GSource ID,\n g_source_remove() can be used.\n\n Since: 2.56"]
pub type GClearHandleFunc = ::std::option::Option<unsafe extern "C" fn(handle_id: guint)>;
extern "C" {
    pub fn g_clear_handle_id(tag_ptr: *mut guint, clear_func: GClearHandleFunc);
}
extern "C" {
    pub fn g_timeout_add_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_timeout_add_once(interval: guint, function: GSourceOnceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_child_watch_add_full(
        priority: gint,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add_full(
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_idle_add_once(function: GSourceOnceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
}
extern "C" {
    pub static mut g_timeout_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_child_watch_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_idle_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_unix_signal_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
}
#[doc = " gunichar:\n\n A type which can hold any UTF-32 or UCS-4 character code,\n also known as a Unicode code point.\n\n If you want to produce the UTF-8 representation of a #gunichar,\n use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse\n process.\n\n To print/scan values of this type as integer, use\n %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT.\n\n The notation to express a Unicode code point in running text is\n as a hexadecimal number with four to six digits and uppercase\n letters, prefixed by the string \"U+\". Leading zeros are omitted,\n unless the code point would have fewer than four hexadecimal digits.\n For example, \"U+0041 LATIN CAPITAL LETTER A\". To print a code point\n in the U+-notation, use the format string \"U+\\%04\"G_GINT32_FORMAT\"X\".\n To scan, use the format string \"U+\\%06\"G_GINT32_FORMAT\"X\".\n\n |[\n gunichar c;\n sscanf (\"U+0041\", \"U+%06\"G_GINT32_FORMAT\"X\", &amp;c)\n g_print (\"Read U+%04\"G_GINT32_FORMAT\"X\", c);\n ]|"]
pub type gunichar = guint32;
#[doc = " gunichar2:\n\n A type which can hold any UTF-16 code\n point<footnote id=\"utf16_surrogate_pairs\">UTF-16 also has so called\n <firstterm>surrogate pairs</firstterm> to encode characters beyond\n the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored\n in a single gunichar2 field, but all GLib functions accepting gunichar2\n arrays will correctly interpret surrogate pairs.</footnote>.\n\n To print/scan values of this type to/from text you need to convert\n to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16().\n\n To print/scan values of this type as integer, use\n %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT."]
pub type gunichar2 = guint16;
pub const GUnicodeType_G_UNICODE_CONTROL: GUnicodeType = 0;
pub const GUnicodeType_G_UNICODE_FORMAT: GUnicodeType = 1;
pub const GUnicodeType_G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const GUnicodeType_G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const GUnicodeType_G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const GUnicodeType_G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const GUnicodeType_G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const GUnicodeType_G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const GUnicodeType_G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const GUnicodeType_G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const GUnicodeType_G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const GUnicodeType_G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const GUnicodeType_G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const GUnicodeType_G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const GUnicodeType_G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const GUnicodeType_G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const GUnicodeType_G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const GUnicodeType_G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const GUnicodeType_G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const GUnicodeType_G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const GUnicodeType_G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const GUnicodeType_G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const GUnicodeType_G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const GUnicodeType_G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const GUnicodeType_G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const GUnicodeType_G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const GUnicodeType_G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const GUnicodeType_G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const GUnicodeType_G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const GUnicodeType_G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;
#[doc = " GUnicodeType:\n @G_UNICODE_CONTROL: General category \"Other, Control\" (Cc)\n @G_UNICODE_FORMAT: General category \"Other, Format\" (Cf)\n @G_UNICODE_UNASSIGNED: General category \"Other, Not Assigned\" (Cn)\n @G_UNICODE_PRIVATE_USE: General category \"Other, Private Use\" (Co)\n @G_UNICODE_SURROGATE: General category \"Other, Surrogate\" (Cs)\n @G_UNICODE_LOWERCASE_LETTER: General category \"Letter, Lowercase\" (Ll)\n @G_UNICODE_MODIFIER_LETTER: General category \"Letter, Modifier\" (Lm)\n @G_UNICODE_OTHER_LETTER: General category \"Letter, Other\" (Lo)\n @G_UNICODE_TITLECASE_LETTER: General category \"Letter, Titlecase\" (Lt)\n @G_UNICODE_UPPERCASE_LETTER: General category \"Letter, Uppercase\" (Lu)\n @G_UNICODE_SPACING_MARK: General category \"Mark, Spacing\" (Mc)\n @G_UNICODE_ENCLOSING_MARK: General category \"Mark, Enclosing\" (Me)\n @G_UNICODE_NON_SPACING_MARK: General category \"Mark, Nonspacing\" (Mn)\n @G_UNICODE_DECIMAL_NUMBER: General category \"Number, Decimal Digit\" (Nd)\n @G_UNICODE_LETTER_NUMBER: General category \"Number, Letter\" (Nl)\n @G_UNICODE_OTHER_NUMBER: General category \"Number, Other\" (No)\n @G_UNICODE_CONNECT_PUNCTUATION: General category \"Punctuation, Connector\" (Pc)\n @G_UNICODE_DASH_PUNCTUATION: General category \"Punctuation, Dash\" (Pd)\n @G_UNICODE_CLOSE_PUNCTUATION: General category \"Punctuation, Close\" (Pe)\n @G_UNICODE_FINAL_PUNCTUATION: General category \"Punctuation, Final quote\" (Pf)\n @G_UNICODE_INITIAL_PUNCTUATION: General category \"Punctuation, Initial quote\" (Pi)\n @G_UNICODE_OTHER_PUNCTUATION: General category \"Punctuation, Other\" (Po)\n @G_UNICODE_OPEN_PUNCTUATION: General category \"Punctuation, Open\" (Ps)\n @G_UNICODE_CURRENCY_SYMBOL: General category \"Symbol, Currency\" (Sc)\n @G_UNICODE_MODIFIER_SYMBOL: General category \"Symbol, Modifier\" (Sk)\n @G_UNICODE_MATH_SYMBOL: General category \"Symbol, Math\" (Sm)\n @G_UNICODE_OTHER_SYMBOL: General category \"Symbol, Other\" (So)\n @G_UNICODE_LINE_SEPARATOR: General category \"Separator, Line\" (Zl)\n @G_UNICODE_PARAGRAPH_SEPARATOR: General category \"Separator, Paragraph\" (Zp)\n @G_UNICODE_SPACE_SEPARATOR: General category \"Separator, Space\" (Zs)\n\n These are the possible character classifications from the\n Unicode specification.\n See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values)."]
pub type GUnicodeType = ::std::os::raw::c_uint;
pub const GUnicodeBreakType_G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const GUnicodeBreakType_G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const GUnicodeBreakType_G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const GUnicodeBreakType_G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const GUnicodeBreakType_G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const GUnicodeBreakType_G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const GUnicodeBreakType_G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const GUnicodeBreakType_G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const GUnicodeBreakType_G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARENTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const GUnicodeBreakType_G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;
#[doc = " GUnicodeBreakType:\n @G_UNICODE_BREAK_MANDATORY: Mandatory Break (BK)\n @G_UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)\n @G_UNICODE_BREAK_LINE_FEED: Line Feed (LF)\n @G_UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)\n @G_UNICODE_BREAK_SURROGATE: Surrogates (SG)\n @G_UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)\n @G_UNICODE_BREAK_INSEPARABLE: Inseparable (IN)\n @G_UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking (\"Glue\") (GL)\n @G_UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)\n @G_UNICODE_BREAK_SPACE: Space (SP)\n @G_UNICODE_BREAK_AFTER: Break Opportunity After (BA)\n @G_UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)\n @G_UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)\n @G_UNICODE_BREAK_HYPHEN: Hyphen (HY)\n @G_UNICODE_BREAK_NON_STARTER: Nonstarter (NS)\n @G_UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)\n @G_UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)\n @G_UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)\n @G_UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)\n @G_UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)\n @G_UNICODE_BREAK_NUMERIC: Numeric (NU)\n @G_UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)\n @G_UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)\n @G_UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)\n @G_UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)\n @G_UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)\n @G_UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)\n @G_UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)\n @G_UNICODE_BREAK_UNKNOWN: Unknown (XX)\n @G_UNICODE_BREAK_NEXT_LINE: Next Line (NL)\n @G_UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)\n @G_UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)\n @G_UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)\n @G_UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)\n @G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)\n @G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)\n @G_UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28. Deprecated: 2.70: Use %G_UNICODE_BREAK_CLOSE_PARENTHESIS instead.\n @G_UNICODE_BREAK_CLOSE_PARENTHESIS: Closing Parenthesis (CP). Since 2.70\n @G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32\n @G_UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32\n @G_UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36\n @G_UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50\n @G_UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50\n @G_UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50\n\n These are the possible line break classifications.\n\n Since new unicode versions may add new types here, applications should be ready\n to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.\n\n See [Unicode Line Breaking Algorithm](https://www.unicode.org/reports/tr14/)."]
pub type GUnicodeBreakType = ::std::os::raw::c_uint;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DOGRA: GUnicodeScript = 142;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUNJALA_GONDI: GUnicodeScript = 143;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANIFI_ROHINGYA: GUnicodeScript = 144;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAKASAR: GUnicodeScript = 145;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEDEFAIDRIN: GUnicodeScript = 146;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOGDIAN: GUnicodeScript = 147;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOGDIAN: GUnicodeScript = 148;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELYMAIC: GUnicodeScript = 149;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NANDINAGARI: GUnicodeScript = 150;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: GUnicodeScript = 151;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WANCHO: GUnicodeScript = 152;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHORASMIAN: GUnicodeScript = 153;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DIVES_AKURU: GUnicodeScript = 154;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT: GUnicodeScript = 155;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YEZIDI: GUnicodeScript = 156;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRO_MINOAN: GUnicodeScript = 157;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_UYGHUR: GUnicodeScript = 158;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGSA: GUnicodeScript = 159;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TOTO: GUnicodeScript = 160;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VITHKUQI: GUnicodeScript = 161;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MATH: GUnicodeScript = 162;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAWI: GUnicodeScript = 163;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NAG_MUNDARI: GUnicodeScript = 164;
#[doc = " GUnicodeScript:\n @G_UNICODE_SCRIPT_INVALID_CODE:\n                               a value never returned from g_unichar_get_script()\n @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts\n @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the\n                               base glyph to which it is attached\n @G_UNICODE_SCRIPT_ARABIC:     Arabic\n @G_UNICODE_SCRIPT_ARMENIAN:   Armenian\n @G_UNICODE_SCRIPT_BENGALI:    Bengali\n @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo\n @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee\n @G_UNICODE_SCRIPT_COPTIC:     Coptic\n @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic\n @G_UNICODE_SCRIPT_DESERET:    Deseret\n @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari\n @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic\n @G_UNICODE_SCRIPT_GEORGIAN:   Georgian\n @G_UNICODE_SCRIPT_GOTHIC:     Gothic\n @G_UNICODE_SCRIPT_GREEK:      Greek\n @G_UNICODE_SCRIPT_GUJARATI:   Gujarati\n @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi\n @G_UNICODE_SCRIPT_HAN:        Han\n @G_UNICODE_SCRIPT_HANGUL:     Hangul\n @G_UNICODE_SCRIPT_HEBREW:     Hebrew\n @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana\n @G_UNICODE_SCRIPT_KANNADA:    Kannada\n @G_UNICODE_SCRIPT_KATAKANA:   Katakana\n @G_UNICODE_SCRIPT_KHMER:      Khmer\n @G_UNICODE_SCRIPT_LAO:        Lao\n @G_UNICODE_SCRIPT_LATIN:      Latin\n @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam\n @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian\n @G_UNICODE_SCRIPT_MYANMAR:    Myanmar\n @G_UNICODE_SCRIPT_OGHAM:      Ogham\n @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic\n @G_UNICODE_SCRIPT_ORIYA:      Oriya\n @G_UNICODE_SCRIPT_RUNIC:      Runic\n @G_UNICODE_SCRIPT_SINHALA:    Sinhala\n @G_UNICODE_SCRIPT_SYRIAC:     Syriac\n @G_UNICODE_SCRIPT_TAMIL:      Tamil\n @G_UNICODE_SCRIPT_TELUGU:     Telugu\n @G_UNICODE_SCRIPT_THAANA:     Thaana\n @G_UNICODE_SCRIPT_THAI:       Thai\n @G_UNICODE_SCRIPT_TIBETAN:    Tibetan\n @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:\n                               Canadian Aboriginal\n @G_UNICODE_SCRIPT_YI:         Yi\n @G_UNICODE_SCRIPT_TAGALOG:    Tagalog\n @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo\n @G_UNICODE_SCRIPT_BUHID:      Buhid\n @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa\n @G_UNICODE_SCRIPT_BRAILLE:    Braille\n @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot\n @G_UNICODE_SCRIPT_LIMBU:      Limbu\n @G_UNICODE_SCRIPT_OSMANYA:    Osmanya\n @G_UNICODE_SCRIPT_SHAVIAN:    Shavian\n @G_UNICODE_SCRIPT_LINEAR_B:   Linear B\n @G_UNICODE_SCRIPT_TAI_LE:     Tai Le\n @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic\n @G_UNICODE_SCRIPT_NEW_TAI_LUE:\n                               New Tai Lue\n @G_UNICODE_SCRIPT_BUGINESE:   Buginese\n @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic\n @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh\n @G_UNICODE_SCRIPT_SYLOTI_NAGRI:\n                               Syloti Nagri\n @G_UNICODE_SCRIPT_OLD_PERSIAN:\n                               Old Persian\n @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi\n @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point\n @G_UNICODE_SCRIPT_BALINESE:   Balinese\n @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform\n @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician\n @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa\n @G_UNICODE_SCRIPT_NKO:        N'Ko\n @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3\n @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3\n @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3\n @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3\n @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3\n @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3\n @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3\n @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3\n @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3\n @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3\n @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26\n @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26\n @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:\n                               Egyptian Hieroglpyhs. Since 2.26\n @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:\n                               Imperial Aramaic. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:\n                               Inscriptional Pahlavi. Since 2.26\n @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:\n                               Inscriptional Parthian. Since 2.26\n @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26\n @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26\n @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26\n @G_UNICODE_SCRIPT_MEETEI_MAYEK:\n                               Meetei Mayek. Since 2.26\n @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:\n                               Old South Arabian. Since 2.26\n @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28\n @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26\n @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26\n @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26\n @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28\n @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28\n @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28\n @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32\n @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32\n @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32\n @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32\n @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32\n @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32\n @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42\n @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42\n @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42\n @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42\n @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42\n @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42\n @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42\n @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42\n @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42\n @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42\n @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42\n @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42\n @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42\n @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42\n @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42\n @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42\n @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42\n @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42\n @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42\n @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42\n @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42\n @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42\n @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48\n @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48\n @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48\n @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48\n @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48\n @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48\n @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50\n @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50\n @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50\n @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50\n @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50\n @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50\n @G_UNICODE_SCRIPT_MASARAM_GONDI:        Masaram Gondi. Since: 2.54\n @G_UNICODE_SCRIPT_NUSHU:                Nushu. Since: 2.54\n @G_UNICODE_SCRIPT_SOYOMBO:              Soyombo. Since: 2.54\n @G_UNICODE_SCRIPT_ZANABAZAR_SQUARE:     Zanabazar Square. Since: 2.54\n @G_UNICODE_SCRIPT_DOGRA:                Dogra. Since: 2.58\n @G_UNICODE_SCRIPT_GUNJALA_GONDI:        Gunjala Gondi. Since: 2.58\n @G_UNICODE_SCRIPT_HANIFI_ROHINGYA:      Hanifi Rohingya. Since: 2.58\n @G_UNICODE_SCRIPT_MAKASAR:              Makasar. Since: 2.58\n @G_UNICODE_SCRIPT_MEDEFAIDRIN:          Medefaidrin. Since: 2.58\n @G_UNICODE_SCRIPT_OLD_SOGDIAN:          Old Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_SOGDIAN:              Sogdian. Since: 2.58\n @G_UNICODE_SCRIPT_ELYMAIC:              Elym. Since: 2.62\n @G_UNICODE_SCRIPT_NANDINAGARI:          Nand. Since: 2.62\n @G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: Rohg. Since: 2.62\n @G_UNICODE_SCRIPT_WANCHO:               Wcho. Since: 2.62\n @G_UNICODE_SCRIPT_CHORASMIAN:           Chorasmian. Since: 2.66\n @G_UNICODE_SCRIPT_DIVES_AKURU:          Dives Akuru. Since: 2.66\n @G_UNICODE_SCRIPT_KHITAN_SMALL_SCRIPT:  Khitan small script. Since: 2.66\n @G_UNICODE_SCRIPT_YEZIDI:               Yezidi. Since: 2.66\n @G_UNICODE_SCRIPT_CYPRO_MINOAN:         Cypro-Minoan. Since: 2.72\n @G_UNICODE_SCRIPT_OLD_UYGHUR:           Old Uyghur. Since: 2.72\n @G_UNICODE_SCRIPT_TANGSA:               Tangsa. Since: 2.72\n @G_UNICODE_SCRIPT_TOTO:                 Toto. Since: 2.72\n @G_UNICODE_SCRIPT_VITHKUQI:             Vithkuqi. Since: 2.72\n @G_UNICODE_SCRIPT_MATH:                 Mathematical notation. Since: 2.72\n @G_UNICODE_SCRIPT_KAWI:                 Kawi. Since 2.74\n @G_UNICODE_SCRIPT_NAG_MUNDARI:          Nag Mundari. Since 2.74\n\n The #GUnicodeScript enumeration identifies different writing\n systems. The values correspond to the names as defined in the\n Unicode standard. The enumeration has been added in GLib 2.14,\n and is interchangeable with #PangoScript.\n\n Note that new types may be added in the future. Applications\n should be ready to handle unknown values.\n See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/)."]
pub type GUnicodeScript = ::std::os::raw::c_int;
extern "C" {
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
}
extern "C" {
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
}
extern "C" {
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
}
extern "C" {
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_fully_decompose(
        ch: gunichar,
        compat: gboolean,
        result: *mut gunichar,
        result_len: gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
}
extern "C" {
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize)
        -> *mut gunichar;
}
extern "C" {
    pub static g_utf8_skip: *const gchar;
}
extern "C" {
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
}
extern "C" {
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
}
extern "C" {
    pub fn g_utf8_offset_to_pointer(str_: *const gchar, offset: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_pointer_to_offset(str_: *const gchar, pos: *const gchar) -> glong;
}
extern "C" {
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_prev_char(str_: *const gchar, p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
}
extern "C" {
    pub fn g_utf8_substring(str_: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strreverse(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_to_utf16(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_utf8_to_ucs4(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf8_to_ucs4_fast(
        str_: *const gchar,
        len: glong,
        items_written: *mut glong,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_ucs4(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_utf8(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_ucs4_to_utf16(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_ucs4_to_utf8(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_validate(str_: *const gchar, max_len: gssize, end: *mut *const gchar)
        -> gboolean;
}
extern "C" {
    pub fn g_utf8_validate_len(
        str_: *const gchar,
        max_len: gsize,
        end: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_utf8_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_casefold(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const GNormalizeMode_G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const GNormalizeMode_G_NORMALIZE_NFKC: GNormalizeMode = 3;
#[doc = " GNormalizeMode:\n @G_NORMALIZE_DEFAULT: standardize differences that do not affect the\n     text content, such as the above-mentioned accent representation\n @G_NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT\n @G_NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with\n     composed forms rather than a maximally decomposed form\n @G_NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE\n @G_NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the\n     \"compatibility\" characters in Unicode, such as SUPERSCRIPT THREE\n     to the standard forms (in this case DIGIT THREE). Formatting\n     information may be lost but for most text operations such\n     characters should be considered the same\n @G_NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL\n @G_NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed\n     forms rather than a maximally decomposed form\n @G_NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE\n\n Defines how a Unicode string is transformed in a canonical\n form, standardizing such issues as whether a character with\n an accent is represented as a base character and combining\n accent or as a single precomposed character. Unicode strings\n should generally be normalized before comparing them."]
pub type GNormalizeMode = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_utf8_normalize(str_: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_collate_key(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate_key_for_filename(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_make_valid(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const GAsciiType_G_ASCII_ALNUM: GAsciiType = 1;
pub const GAsciiType_G_ASCII_ALPHA: GAsciiType = 2;
pub const GAsciiType_G_ASCII_CNTRL: GAsciiType = 4;
pub const GAsciiType_G_ASCII_DIGIT: GAsciiType = 8;
pub const GAsciiType_G_ASCII_GRAPH: GAsciiType = 16;
pub const GAsciiType_G_ASCII_LOWER: GAsciiType = 32;
pub const GAsciiType_G_ASCII_PRINT: GAsciiType = 64;
pub const GAsciiType_G_ASCII_PUNCT: GAsciiType = 128;
pub const GAsciiType_G_ASCII_SPACE: GAsciiType = 256;
pub const GAsciiType_G_ASCII_UPPER: GAsciiType = 512;
pub const GAsciiType_G_ASCII_XDIGIT: GAsciiType = 1024;
pub type GAsciiType = ::std::os::raw::c_uint;
extern "C" {
    pub static g_ascii_table: *const guint16;
}
extern "C" {
    pub fn g_ascii_tolower(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_toupper(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_digit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_strdelimit(
        string: *mut gchar,
        delimiters: *const gchar,
        new_delimiter: gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strcanon(
        string: *mut gchar,
        valid_chars: *const gchar,
        substitutor: gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strerror(errnum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strsignal(signum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_str_has_suffix(str_: *const gchar, suffix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_str_has_prefix(str_: *const gchar, prefix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
}
extern "C" {
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
}
extern "C" {
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_formatd(
        buffer: *mut gchar,
        buf_len: gint,
        format: *const gchar,
        d: gdouble,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
}
extern "C" {
    pub fn g_ascii_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_str_is_ascii(str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
}
extern "C" {
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup(str_: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_vprintf(format: *const gchar, args: *mut __va_list_tag) -> *mut gchar;
}
extern "C" {
    pub fn g_strndup(str_: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
}
extern "C" {
    pub fn g_memdup2(mem: gconstpointer, byte_size: gsize) -> gpointer;
}
pub type GStrv = *mut *mut gchar;
extern "C" {
    pub fn g_strsplit(
        string: *const gchar,
        delimiter: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strsplit_set(
        string: *const gchar,
        delimiters: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strfreev(str_array: *mut *mut gchar);
}
extern "C" {
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
}
extern "C" {
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::std::os::raw::c_char) -> *mut gchar;
}
extern "C" {
    pub fn g_str_to_ascii(str_: *const gchar, from_locale: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_str_match_string(
        search_term: *const gchar,
        potential_hit: *const gchar,
        accept_alternates: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_strv_contains(strv: *const *const gchar, str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strv_equal(strv1: *const *const gchar, strv2: *const *const gchar) -> gboolean;
}
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_INVALID: GNumberParserError = 0;
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: GNumberParserError = 1;
#[doc = " GNumberParserError:\n @G_NUMBER_PARSER_ERROR_INVALID: String was not a valid number.\n @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: String was a number, but out of bounds.\n\n Error codes returned by functions converting a string to a number.\n\n Since: 2.54"]
pub type GNumberParserError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_number_parser_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_ascii_string_to_signed(
        str_: *const gchar,
        base: guint,
        min: gint64,
        max: gint64,
        out_num: *mut gint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ascii_string_to_unsigned(
        str_: *const gchar,
        base: guint,
        min: guint64,
        max: guint64,
        out_num: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GString {
    pub str_: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
#[test]
fn bindgen_test_layout__GString() {
    const UNINIT: ::std::mem::MaybeUninit<_GString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GString>(),
        24usize,
        concat!("Size of: ", stringify!(_GString))
    );
    assert_eq!(
        ::std::mem::align_of::<_GString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocated_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(allocated_len)
        )
    );
}
extern "C" {
    pub fn g_string_new(init: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_string_free_and_steal(string: *mut GString) -> *mut gchar;
}
extern "C" {
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
}
extern "C" {
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
}
extern "C" {
    pub fn g_string_hash(str_: *const GString) -> guint;
}
extern "C" {
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: gssize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar)
        -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: gsize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_replace(
        string: *mut GString,
        find: *const gchar,
        replace: *const gchar,
        limit: guint,
    ) -> guint;
}
extern "C" {
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: *mut __va_list_tag);
}
extern "C" {
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_vprintf(
        string: *mut GString,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_up(string: *mut GString) -> *mut GString;
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
pub const GIOError_G_IO_ERROR_NONE: GIOError = 0;
pub const GIOError_G_IO_ERROR_AGAIN: GIOError = 1;
pub const GIOError_G_IO_ERROR_INVAL: GIOError = 2;
pub const GIOError_G_IO_ERROR_UNKNOWN: GIOError = 3;
pub type GIOError = ::std::os::raw::c_uint;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;
pub type GIOChannelError = ::std::os::raw::c_uint;
pub const GIOStatus_G_IO_STATUS_ERROR: GIOStatus = 0;
pub const GIOStatus_G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const GIOStatus_G_IO_STATUS_EOF: GIOStatus = 2;
pub const GIOStatus_G_IO_STATUS_AGAIN: GIOStatus = 3;
pub type GIOStatus = ::std::os::raw::c_uint;
pub const GSeekType_G_SEEK_CUR: GSeekType = 0;
pub const GSeekType_G_SEEK_SET: GSeekType = 1;
pub const GSeekType_G_SEEK_END: GSeekType = 2;
pub type GSeekType = ::std::os::raw::c_uint;
pub const GIOFlags_G_IO_FLAG_NONE: GIOFlags = 0;
pub const GIOFlags_G_IO_FLAG_APPEND: GIOFlags = 1;
pub const GIOFlags_G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const GIOFlags_G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const GIOFlags_G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const GIOFlags_G_IO_FLAG_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_SET_MASK: GIOFlags = 3;
pub type GIOFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
#[test]
fn bindgen_test_layout__GIOChannel() {
    const UNINIT: ::std::mem::MaybeUninit<_GIOChannel> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GIOChannel>(),
        112usize,
        concat!("Size of: ", stringify!(_GIOChannel))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOChannel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).funcs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_cd) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_cd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_cd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_cd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_term) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_term_len) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_buf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoded_read_buf) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoded_read_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_buf) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partial_write_buf) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(partial_write_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::std::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::std::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::std::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::std::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::std::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::std::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc = ::std::option::Option<
    unsafe extern "C" fn(
        source: *mut GIOChannel,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOFuncs {
    pub io_read: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *mut gchar,
            count: gsize,
            bytes_read: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *const gchar,
            count: gsize,
            bytes_written: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            offset: gint64,
            type_: GSeekType,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_close: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_create_watch: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource,
    >,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            flags: GIOFlags,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_get_flags:
        ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
#[test]
fn bindgen_test_layout__GIOFuncs() {
    const UNINIT: ::std::mem::MaybeUninit<_GIOFuncs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GIOFuncs>(),
        64usize,
        concat!("Size of: ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_write) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_seek) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_close) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_create_watch) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_create_watch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_set_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_set_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io_get_flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_get_flags)
        )
    );
}
extern "C" {
    pub fn g_io_channel_init(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gsize,
        bytes_written: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_seek(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_close(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        err: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
}
extern "C" {
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
}
extern "C" {
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
}
extern "C" {
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
}
extern "C" {
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
}
extern "C" {
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const gchar,
        length: gint,
    );
}
extern "C" {
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const gchar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_new_file(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
}
extern "C" {
    pub fn g_io_channel_unix_new(fd: ::std::os::raw::c_int) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
}
extern "C" {
    pub static mut g_io_watch_funcs: GSourceFuncs;
}
pub const GKeyFileError_G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const GKeyFileError_G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const GKeyFileError_G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const GKeyFileError_G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const GKeyFileError_G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const GKeyFileError_G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;
pub type GKeyFileError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_key_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
pub const GKeyFileFlags_G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;
pub type GKeyFileFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_key_file_new() -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_free(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
}
extern "C" {
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_locale_for_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gboolean,
    );
}
extern "C" {
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint,
    );
}
extern "C" {
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint64;
}
extern "C" {
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint64,
    );
}
extern "C" {
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> guint64;
}
extern "C" {
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: guint64,
    );
}
extern "C" {
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gdouble;
}
extern "C" {
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gdouble,
    );
}
extern "C" {
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
}
extern "C" {
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
}
extern "C" {
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
extern "C" {
    pub fn g_mapped_file_new(
        filename: *const gchar,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_new_from_fd(
        fd: gint,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
}
extern "C" {
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
}
extern "C" {
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
}
extern "C" {
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
}
extern "C" {
    pub fn g_mapped_file_free(file: *mut GMappedFile);
}
pub const GMarkupError_G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const GMarkupError_G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const GMarkupError_G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const GMarkupError_G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const GMarkupError_G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;
#[doc = " GMarkupError:\n @G_MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8\n @G_MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace\n @G_MARKUP_ERROR_PARSE: document was ill-formed\n @G_MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser\n     functions; element wasn't known\n @G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser\n     functions; attribute wasn't known\n @G_MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser\n     functions; content was invalid\n @G_MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser\n     functions; a required attribute was missing\n\n Error codes returned by markup parsing."]
pub type GMarkupError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_markup_error_quark() -> GQuark;
}
pub const GMarkupParseFlags_G_MARKUP_DEFAULT_FLAGS: GMarkupParseFlags = 0;
pub const GMarkupParseFlags_G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const GMarkupParseFlags_G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const GMarkupParseFlags_G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const GMarkupParseFlags_G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;
#[doc = " GMarkupParseFlags:\n @G_MARKUP_DEFAULT_FLAGS: No special behaviour. Since: 2.74\n @G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use\n @G_MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked\n     sections are not passed literally to the @passthrough function of\n     the parser. Instead, the content of the section (without the\n     `<![CDATA[` and `]]>`) is\n     passed to the @text function. This flag was added in GLib 2.12\n @G_MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup\n     itself have line/column information prefixed to them to let the\n     caller know the location of the error. When this flag is set the\n     location information is also prefixed to errors generated by the\n     #GMarkupParser implementation functions\n @G_MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified\n     attributes and tags, along with their contents.  A qualified\n     attribute or tag is one that contains ':' in its name (ie: is in\n     another namespace).  Since: 2.40.\n\n Flags that affect the behaviour of the parser."]
pub type GMarkupParseFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
#[doc = " GMarkupParseContext:\n\n A parse context is used to parse a stream of bytes that\n you expect to contain marked-up text.\n\n See g_markup_parse_context_new(), #GMarkupParser, and so\n on for more details."]
pub type GMarkupParseContext = _GMarkupParseContext;
#[doc = " GMarkupParser:\n @start_element: Callback to invoke when the opening tag of an element\n     is seen. The callback's @attribute_names and @attribute_values parameters\n     are %NULL-terminated.\n @end_element: Callback to invoke when the closing tag of an element\n     is seen. Note that this is also called for empty tags like\n     `<empty/>`.\n @text: Callback to invoke when some text is seen (text is always\n     inside an element). Note that the text of an element may be spread\n     over multiple calls of this function. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also\n     called for the content of CDATA marked sections.\n @passthrough: Callback to invoke for comments, processing instructions\n     and doctype declarations; if you're re-writing the parsed document,\n     write the passthrough text back out in the same position. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also\n     called for CDATA marked sections.\n @error: Callback to invoke when an error occurs.\n\n Any of the fields in #GMarkupParser can be %NULL, in which case they\n will be ignored. Except for the @error function, any of these callbacks\n can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,\n %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT\n errors are intended to be set from these callbacks. If you set an error\n from a callback, g_markup_parse_context_parse() will report that error\n back to its caller."]
pub type GMarkupParser = _GMarkupParser;
#[doc = " GMarkupParser:\n @start_element: Callback to invoke when the opening tag of an element\n     is seen. The callback's @attribute_names and @attribute_values parameters\n     are %NULL-terminated.\n @end_element: Callback to invoke when the closing tag of an element\n     is seen. Note that this is also called for empty tags like\n     `<empty/>`.\n @text: Callback to invoke when some text is seen (text is always\n     inside an element). Note that the text of an element may be spread\n     over multiple calls of this function. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also\n     called for the content of CDATA marked sections.\n @passthrough: Callback to invoke for comments, processing instructions\n     and doctype declarations; if you're re-writing the parsed document,\n     write the passthrough text back out in the same position. If the\n     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also\n     called for CDATA marked sections.\n @error: Callback to invoke when an error occurs.\n\n Any of the fields in #GMarkupParser can be %NULL, in which case they\n will be ignored. Except for the @error function, any of these callbacks\n can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,\n %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT\n errors are intended to be set from these callbacks. If you set an error\n from a callback, g_markup_parse_context_parse() will report that error\n back to its caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParser {
    pub start_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            error: *mut GError,
            user_data: gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GMarkupParser() {
    const UNINIT: ::std::mem::MaybeUninit<_GMarkupParser> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMarkupParser>(),
        40usize,
        concat!("Size of: ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMarkupParser>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_element) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(start_element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_element) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(end_element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).passthrough) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(passthrough)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(error)
        )
    );
}
extern "C" {
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
}
extern "C" {
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
}
extern "C" {
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut gint,
        char_number: *mut gint,
    );
}
extern "C" {
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_printf_escaped(format: *const ::std::os::raw::c_char, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_vprintf_escaped(
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *mut gchar;
}
pub const GMarkupCollectType_G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const GMarkupCollectType_G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const GMarkupCollectType_G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const GMarkupCollectType_G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;
pub type GMarkupCollectType = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
#[doc = " GVariantType:\n\n A type in the GVariant type system.\n\n Two types may not be compared by value; use g_variant_type_equal() or\n g_variant_type_is_subtype_of().  May be copied using\n g_variant_type_copy() and freed using g_variant_type_free()."]
pub type GVariantType = _GVariantType;
extern "C" {
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_string_scan(
        string: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_free(type_: *mut GVariantType);
}
extern "C" {
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
}
extern "C" {
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: gint,
    ) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_string_get_depth_(type_string: *const gchar) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
pub const GVariantClass_G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const GVariantClass_G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const GVariantClass_G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const GVariantClass_G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const GVariantClass_G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const GVariantClass_G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const GVariantClass_G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const GVariantClass_G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const GVariantClass_G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const GVariantClass_G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const GVariantClass_G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const GVariantClass_G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const GVariantClass_G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const GVariantClass_G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const GVariantClass_G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const GVariantClass_G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const GVariantClass_G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const GVariantClass_G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;
pub type GVariantClass = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_variant_unref(value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
}
extern "C" {
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_byte(value: guint8) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring_array(
        strv: *const *const gchar,
        length: gssize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_byte(value: *mut GVariant) -> guint8;
}
extern "C" {
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
}
extern "C" {
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
}
extern "C" {
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
}
extern "C" {
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
}
extern "C" {
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
}
extern "C" {
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
}
extern "C" {
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *mut GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_tuple(children: *const *mut GVariant, n_children: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: gsize,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut gsize,
        element_size: gsize,
    ) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
}
extern "C" {
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
}
extern "C" {
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_variant_hash(value: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
}
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantIter {
    pub x: [gsize; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantIter>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantIter),
            "::",
            stringify!(x)
        )
    );
}
extern "C" {
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
}
extern "C" {
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantBuilder {
    pub u: _GVariantBuilder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantBuilder__bindgen_ty_1 {
    pub s: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    pub partial_magic: gsize,
    pub type_: *const GVariantType,
    pub y: [gsize; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partial_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantBuilder__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantBuilder() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantBuilder> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder),
            "::",
            stringify!(u)
        )
    );
}
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT:
    GVariantParseError = 16;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_RECURSION: GVariantParseError = 18;
pub type GVariantParseError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_variant_parser_get_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_parse_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new_va(
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_va(
        value: *mut GVariant,
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    );
}
extern "C" {
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const gchar,
        copy_only: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
}
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantDict {
    pub u: _GVariantDict__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantDict__bindgen_ty_1 {
    pub s: _GVariantDict__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    pub asv: *mut GVariant,
    pub partial_magic: gsize,
    pub y: [gsize; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantDict__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).asv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(asv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partial_magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantDict__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantDict() {
    const UNINIT: ::std::mem::MaybeUninit<_GVariantDict> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
}
extern "C" {
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_printf_string_upper_bound(format: *const gchar, args: *mut __va_list_tag) -> gsize;
}
pub const GLogLevelFlags_G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const GLogLevelFlags_G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const GLogLevelFlags_G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const GLogLevelFlags_G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const GLogLevelFlags_G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const GLogLevelFlags_G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const GLogLevelFlags_G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const GLogLevelFlags_G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const GLogLevelFlags_G_LOG_LEVEL_MASK: GLogLevelFlags = -4;
pub type GLogLevelFlags = ::std::os::raw::c_int;
pub type GLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ),
>;
extern "C" {
    pub fn g_log_set_handler(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
}
extern "C" {
    pub fn g_log_default_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
}
extern "C" {
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
}
extern "C" {
    pub fn g_logv(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn g_log_set_fatal_mask(
        log_domain: *const gchar,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
}
extern "C" {
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
pub const GLogWriterOutput_G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const GLogWriterOutput_G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;
#[doc = " GLogWriterOutput:\n @G_LOG_WRITER_HANDLED: Log writer has handled the log entry.\n @G_LOG_WRITER_UNHANDLED: Log writer could not handle the log entry.\n\n Return values from #GLogWriterFuncs to indicate whether the given log entry\n was successfully handled by the writer, or whether there was an error in\n handling it (and hence a fallback writer should be used).\n\n If a #GLogWriterFunc ignores a log entry, it should return\n %G_LOG_WRITER_HANDLED.\n\n Since: 2.50"]
pub type GLogWriterOutput = ::std::os::raw::c_uint;
#[doc = " GLogField:\n @key: field name (UTF-8 string)\n @value: field value (arbitrary bytes)\n @length: length of @value, in bytes, or -1 if it is nul-terminated\n\n Structure representing a single field in a structured log entry. See\n g_log_structured() for details.\n\n Log fields may contain arbitrary values, including binary with embedded nul\n bytes. If the field contains a string, the string must be UTF-8 encoded and\n have a trailing nul byte. Otherwise, @length must be set to a non-negative\n value.\n\n Since: 2.50"]
pub type GLogField = _GLogField;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLogField {
    pub key: *const gchar,
    pub value: gconstpointer,
    pub length: gssize,
}
#[test]
fn bindgen_test_layout__GLogField() {
    const UNINIT: ::std::mem::MaybeUninit<_GLogField> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GLogField>(),
        24usize,
        concat!("Size of: ", stringify!(_GLogField))
    );
    assert_eq!(
        ::std::mem::align_of::<_GLogField>(),
        8usize,
        concat!("Alignment of ", stringify!(_GLogField))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " GLogWriterFunc:\n @log_level: log level of the message\n @fields: (array length=n_fields): fields forming the message\n @n_fields: number of @fields\n @user_data: user data passed to g_log_set_writer_func()\n\n Writer function for log entries. A log entry is a collection of one or more\n #GLogFields, using the standard [field names from journal\n specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).\n See g_log_structured() for more information.\n\n Writer functions must ignore fields which they do not recognise, unless they\n can write arbitrary binary output, as field values may be arbitrary binary.\n\n @log_level is guaranteed to be included in @fields as the `PRIORITY` field,\n but is provided separately for convenience of deciding whether or where to\n output the log entry.\n\n Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log\n message successfully or if they deliberately ignored it. If there was an\n error handling the message (for example, if the writer function is meant to\n send messages to a remote logging server and there is a network error), it\n should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be\n chained and fall back to simpler handlers in case of failure.\n\n Returns: %G_LOG_WRITER_HANDLED if the log entry was handled successfully;\n   %G_LOG_WRITER_UNHANDLED otherwise\n\n Since: 2.50"]
pub type GLogWriterFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput,
>;
extern "C" {
    pub fn g_log_structured(log_domain: *const gchar, log_level: GLogLevelFlags, ...);
}
extern "C" {
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
    );
}
extern "C" {
    pub fn g_log_variant(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
}
extern "C" {
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_log_writer_supports_color(output_fd: gint) -> gboolean;
}
extern "C" {
    pub fn g_log_writer_is_journald(output_fd: gint) -> gboolean;
}
extern "C" {
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        use_color: gboolean,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_default_set_use_stderr(use_stderr: gboolean);
}
extern "C" {
    pub fn g_log_writer_default_would_drop(
        log_level: GLogLevelFlags,
        log_domain: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_log_get_debug_enabled() -> gboolean;
}
extern "C" {
    pub fn g_log_set_debug_enabled(enabled: gboolean);
}
extern "C" {
    pub fn _g_log_fallback_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    pub fn g_return_if_fail_warning(
        log_domain: *const ::std::os::raw::c_char,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_warn_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        warnexpr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assert_warning(
        log_domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn g_log_structured_standard(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        file: *const gchar,
        line: *const gchar,
        func: *const gchar,
        message_format: *const gchar,
        ...
    );
}
#[doc = " GPrintFunc:\n @string: the message to output\n\n Specifies the type of the print handler functions.\n These are called with the complete formatted string to output."]
pub type GPrintFunc = ::std::option::Option<unsafe extern "C" fn(string: *const gchar)>;
extern "C" {
    pub fn g_print(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
}
extern "C" {
    pub fn g_printerr(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
#[doc = " GOptionContext:\n\n A `GOptionContext` struct defines which options\n are accepted by the commandline option parser. The struct has only private\n fields and should not be directly accessed."]
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
#[doc = " GOptionGroup:\n\n A `GOptionGroup` struct defines the options in a single\n group. The struct has only private fields and should not be directly accessed.\n\n All options in a group share the same translation function. Libraries which\n need to parse commandline options are expected to provide a function for\n getting a `GOptionGroup` holding their options, which\n the application can then add to its #GOptionContext."]
pub type GOptionGroup = _GOptionGroup;
#[doc = " GOptionEntry:\n @long_name: The long name of an option can be used to specify it\n     in a commandline as `--long_name`. Every option must have a\n     long name. To resolve conflicts if multiple option groups contain\n     the same long name, it is also possible to specify the option as\n     `--groupname-long_name`.\n @short_name: If an option has a short name, it can be specified\n     `-short_name` in a commandline. @short_name must be  a printable\n     ASCII character different from '-', or zero if the option has no\n     short name.\n @flags: Flags from #GOptionFlags\n @arg: The type of the option, as a #GOptionArg\n @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data\n     must point to a #GOptionArgFunc callback function, which will be\n     called to handle the extra argument. Otherwise, @arg_data is a\n     pointer to a location to store the value, the required type of\n     the location depends on the @arg type:\n     - %G_OPTION_ARG_NONE: %gboolean\n     - %G_OPTION_ARG_STRING: %gchar*\n     - %G_OPTION_ARG_INT: %gint\n     - %G_OPTION_ARG_FILENAME: %gchar*\n     - %G_OPTION_ARG_STRING_ARRAY: %gchar**\n     - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**\n     - %G_OPTION_ARG_DOUBLE: %gdouble\n     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,\n     the location will contain a newly allocated string if the option\n     was given. That string needs to be freed by the callee using g_free().\n     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or\n     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().\n @description: the description for the option in `--help`\n     output. The @description is translated using the @translate_func\n     of the group, see g_option_group_set_translation_domain().\n @arg_description: The placeholder to use for the extra argument parsed\n     by the option in `--help` output. The @arg_description is translated\n     using the @translate_func of the group, see\n     g_option_group_set_translation_domain().\n\n A GOptionEntry struct defines a single option. To have an effect, they\n must be added to a #GOptionGroup with g_option_context_add_main_entries()\n or g_option_group_add_entries()."]
pub type GOptionEntry = _GOptionEntry;
pub const GOptionFlags_G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const GOptionFlags_G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const GOptionFlags_G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const GOptionFlags_G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const GOptionFlags_G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const GOptionFlags_G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const GOptionFlags_G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const GOptionFlags_G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
#[doc = " GOptionFlags:\n @G_OPTION_FLAG_NONE: No flags. Since: 2.42.\n @G_OPTION_FLAG_HIDDEN: The option doesn't appear in `--help` output.\n @G_OPTION_FLAG_IN_MAIN: The option appears in the main section of the\n     `--help` output, even if it is defined in a group.\n @G_OPTION_FLAG_REVERSE: For options of the %G_OPTION_ARG_NONE kind, this\n     flag indicates that the sense of the option is reversed. i.e. %FALSE will\n     be stored into the argument rather than %TRUE.\n @G_OPTION_FLAG_NO_ARG: For options of the %G_OPTION_ARG_CALLBACK kind,\n     this flag indicates that the callback does not take any argument\n     (like a %G_OPTION_ARG_NONE option). Since 2.8\n @G_OPTION_FLAG_FILENAME: For options of the %G_OPTION_ARG_CALLBACK\n     kind, this flag indicates that the argument should be passed to the\n     callback in the GLib filename encoding rather than UTF-8. Since 2.8\n @G_OPTION_FLAG_OPTIONAL_ARG: For options of the %G_OPTION_ARG_CALLBACK\n     kind, this flag indicates that the argument supply is optional.\n     If no argument is given then data of %GOptionParseFunc will be\n     set to NULL. Since 2.8\n @G_OPTION_FLAG_NOALIAS: This flag turns off the automatic conflict\n     resolution which prefixes long option names with `groupname-` if\n     there is a conflict. This option should only be used in situations\n     where aliasing is necessary to model some legacy commandline interface.\n     It is not safe to use this option, unless all option groups are under\n     your direct control. Since 2.8.\n\n Flags which modify individual options."]
pub type GOptionFlags = ::std::os::raw::c_uint;
pub const GOptionArg_G_OPTION_ARG_NONE: GOptionArg = 0;
pub const GOptionArg_G_OPTION_ARG_STRING: GOptionArg = 1;
pub const GOptionArg_G_OPTION_ARG_INT: GOptionArg = 2;
pub const GOptionArg_G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const GOptionArg_G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const GOptionArg_G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const GOptionArg_G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const GOptionArg_G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const GOptionArg_G_OPTION_ARG_INT64: GOptionArg = 8;
#[doc = " GOptionArg:\n @G_OPTION_ARG_NONE: No extra argument. This is useful for simple flags or booleans.\n @G_OPTION_ARG_STRING: The option takes a UTF-8 string argument.\n @G_OPTION_ARG_INT: The option takes an integer argument.\n @G_OPTION_ARG_CALLBACK: The option provides a callback (of type\n     #GOptionArgFunc) to parse the extra argument.\n @G_OPTION_ARG_FILENAME: The option takes a filename as argument, which will\nbe in the GLib filename encoding rather than UTF-8.\n @G_OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple\n     uses of the option are collected into an array of strings.\n @G_OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,\n     multiple uses of the option are collected into an array of strings.\n @G_OPTION_ARG_DOUBLE: The option takes a double argument. The argument\n     can be formatted either for the user's locale or for the \"C\" locale.\n     Since 2.12\n @G_OPTION_ARG_INT64: The option takes a 64-bit integer. Like\n     %G_OPTION_ARG_INT but for larger numbers. The number can be in\n     decimal base, or in hexadecimal (when prefixed with `0x`, for\n     example, `0xffffffff`). Since 2.12\n\n The #GOptionArg enum values determine which type of extra argument the\n options expect to find. If an option expects an extra argument, it can\n be specified in several ways; with a short option: `-x arg`, with a long\n option: `--name arg` or combined in a single argument: `--name=arg`."]
pub type GOptionArg = ::std::os::raw::c_uint;
#[doc = " GOptionArgFunc:\n @option_name: The name of the option being parsed. This will be either a\n  single dash followed by a single letter (for a short name) or two dashes\n  followed by a long option name.\n @value: The value to be parsed.\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: A return location for errors. The error code %G_OPTION_ERROR_FAILED\n  is intended to be used for errors in #GOptionArgFunc callbacks.\n\n The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK\n options.\n\n Returns: %TRUE if the option was successfully parsed, %FALSE if an error\n  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionArgFunc = ::std::option::Option<
    unsafe extern "C" fn(
        option_name: *const gchar,
        value: *const gchar,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionParseFunc:\n @context: The active #GOptionContext\n @group: The group to which the function belongs\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: A return location for error details\n\n The type of function that can be called before and after parsing.\n\n Returns: %TRUE if the function completed successfully, %FALSE if an error\n  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionParseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionErrorFunc:\n @context: The active #GOptionContext\n @group: The group to which the function belongs\n @data: User data added to the #GOptionGroup containing the option when it\n  was created with g_option_group_new()\n @error: The #GError containing details about the parse error\n\n The type of function to be used as callback when a parse error occurs."]
pub type GOptionErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ),
>;
pub const GOptionError_G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const GOptionError_G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const GOptionError_G_OPTION_ERROR_FAILED: GOptionError = 2;
#[doc = " GOptionError:\n @G_OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser.\n  This error will only be reported, if the parser hasn't been instructed\n  to ignore unknown options, see g_option_context_set_ignore_unknown_options().\n @G_OPTION_ERROR_BAD_VALUE: A value couldn't be parsed.\n @G_OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed.\n\n Error codes returned by option parsing."]
pub type GOptionError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_option_error_quark() -> GQuark;
}
#[doc = " GOptionEntry:\n @long_name: The long name of an option can be used to specify it\n     in a commandline as `--long_name`. Every option must have a\n     long name. To resolve conflicts if multiple option groups contain\n     the same long name, it is also possible to specify the option as\n     `--groupname-long_name`.\n @short_name: If an option has a short name, it can be specified\n     `-short_name` in a commandline. @short_name must be  a printable\n     ASCII character different from '-', or zero if the option has no\n     short name.\n @flags: Flags from #GOptionFlags\n @arg: The type of the option, as a #GOptionArg\n @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data\n     must point to a #GOptionArgFunc callback function, which will be\n     called to handle the extra argument. Otherwise, @arg_data is a\n     pointer to a location to store the value, the required type of\n     the location depends on the @arg type:\n     - %G_OPTION_ARG_NONE: %gboolean\n     - %G_OPTION_ARG_STRING: %gchar*\n     - %G_OPTION_ARG_INT: %gint\n     - %G_OPTION_ARG_FILENAME: %gchar*\n     - %G_OPTION_ARG_STRING_ARRAY: %gchar**\n     - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**\n     - %G_OPTION_ARG_DOUBLE: %gdouble\n     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,\n     the location will contain a newly allocated string if the option\n     was given. That string needs to be freed by the callee using g_free().\n     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or\n     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().\n @description: the description for the option in `--help`\n     output. The @description is translated using the @translate_func\n     of the group, see g_option_group_set_translation_domain().\n @arg_description: The placeholder to use for the extra argument parsed\n     by the option in `--help` output. The @arg_description is translated\n     using the @translate_func of the group, see\n     g_option_group_set_translation_domain().\n\n A GOptionEntry struct defines a single option. To have an effect, they\n must be added to a #GOptionGroup with g_option_context_add_main_entries()\n or g_option_group_add_entries()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
#[test]
fn bindgen_test_layout__GOptionEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_GOptionEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOptionEntry>(),
        48usize,
        concat!("Size of: ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOptionEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).long_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).short_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(short_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg_description) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_description)
        )
    );
}
extern "C" {
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
}
extern "C" {
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
}
extern "C" {
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_free(context: *mut GOptionContext);
}
extern "C" {
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
}
extern "C" {
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
}
extern "C" {
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
}
extern "C" {
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
}
extern "C" {
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
}
extern "C" {
    pub fn g_option_group_free(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_unref(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
}
extern "C" {
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
}
#[doc = " GPathBuf: (copy-func g_path_buf_copy) (free-func g_path_buf_free)\n\n A mutable path builder.\n\n Since: 2.76"]
pub type GPathBuf = _GPathBuf;
#[doc = " GPathBuf: (copy-func g_path_buf_copy) (free-func g_path_buf_free)\n\n A mutable path builder.\n\n Since: 2.76"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPathBuf {
    pub dummy: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GPathBuf() {
    const UNINIT: ::std::mem::MaybeUninit<_GPathBuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPathBuf>(),
        64usize,
        concat!("Size of: ", stringify!(_GPathBuf))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPathBuf>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPathBuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPathBuf),
            "::",
            stringify!(dummy)
        )
    );
}
extern "C" {
    pub fn g_path_buf_new() -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_new_from_path(path: *const ::std::os::raw::c_char) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_init(buf: *mut GPathBuf) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_init_from_path(
        buf: *mut GPathBuf,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_clear(buf: *mut GPathBuf);
}
extern "C" {
    pub fn g_path_buf_clear_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_path_buf_free(buf: *mut GPathBuf);
}
extern "C" {
    pub fn g_path_buf_free_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_path_buf_copy(buf: *mut GPathBuf) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_push(
        buf: *mut GPathBuf,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GPathBuf;
}
extern "C" {
    pub fn g_path_buf_pop(buf: *mut GPathBuf) -> gboolean;
}
extern "C" {
    pub fn g_path_buf_set_filename(
        buf: *mut GPathBuf,
        file_name: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_path_buf_set_extension(
        buf: *mut GPathBuf,
        extension: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_path_buf_to_path(buf: *mut GPathBuf) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_path_buf_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
extern "C" {
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
}
extern "C" {
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
}
extern "C" {
    pub fn g_pattern_spec_copy(pspec: *mut GPatternSpec) -> *mut GPatternSpec;
}
extern "C" {
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
}
extern "C" {
    pub fn g_pattern_spec_match(
        pspec: *mut GPatternSpec,
        string_length: gsize,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_pattern_spec_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: guint,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_spaced_primes_closest(num: guint) -> guint;
}
extern "C" {
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: gint,
        size: gsize,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
#[doc = " GQueue:\n @head: a pointer to the first element of the queue\n @tail: a pointer to the last element of the queue\n @length: the number of elements in the queue\n\n Contains the public fields of a\n [Queue][glib-Double-ended-Queues]."]
pub type GQueue = _GQueue;
#[doc = " GQueue:\n @head: a pointer to the first element of the queue\n @tail: a pointer to the last element of the queue\n @length: the number of elements in the queue\n\n Contains the public fields of a\n [Queue][glib-Double-ended-Queues]."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
#[test]
fn bindgen_test_layout__GQueue() {
    const UNINIT: ::std::mem::MaybeUninit<_GQueue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GQueue>(),
        24usize,
        concat!("Size of: ", stringify!(_GQueue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GQueue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GQueue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn g_queue_new() -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_free(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_queue_init(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_clear(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
}
extern "C" {
    pub fn g_queue_clear_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
}
extern "C" {
    pub fn g_queue_reverse(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
}
extern "C" {
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_before_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_after_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
}
extern "C" {
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
extern "C" {
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new() -> *mut GRand;
}
extern "C" {
    pub fn g_rand_free(rand_: *mut GRand);
}
extern "C" {
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
}
extern "C" {
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
}
extern "C" {
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
}
extern "C" {
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
}
extern "C" {
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    pub fn g_random_set_seed(seed: guint32);
}
extern "C" {
    pub fn g_random_int() -> guint32;
}
extern "C" {
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_random_double() -> gdouble;
}
extern "C" {
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    pub fn g_rc_box_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_release(mem_block: gpointer);
}
extern "C" {
    pub fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_rc_box_get_size(mem_block: gpointer) -> gsize;
}
extern "C" {
    pub fn g_atomic_rc_box_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_release(mem_block: gpointer);
}
extern "C" {
    pub fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_atomic_rc_box_get_size(mem_block: gpointer) -> gsize;
}
extern "C" {
    pub fn g_ref_count_init(rc: *mut grefcount);
}
extern "C" {
    pub fn g_ref_count_inc(rc: *mut grefcount);
}
extern "C" {
    pub fn g_ref_count_dec(rc: *mut grefcount) -> gboolean;
}
extern "C" {
    pub fn g_ref_count_compare(rc: *mut grefcount, val: gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_ref_count_init(arc: *mut gatomicrefcount);
}
extern "C" {
    pub fn g_atomic_ref_count_inc(arc: *mut gatomicrefcount);
}
extern "C" {
    pub fn g_atomic_ref_count_dec(arc: *mut gatomicrefcount) -> gboolean;
}
extern "C" {
    pub fn g_atomic_ref_count_compare(arc: *mut gatomicrefcount, val: gint) -> gboolean;
}
extern "C" {
    pub fn g_ref_string_new(str_: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_new_len(
        str_: *const ::std::os::raw::c_char,
        len: gssize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_new_intern(
        str_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_acquire(str_: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_ref_string_release(str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_ref_string_length(str_: *mut ::std::os::raw::c_char) -> gsize;
}
#[doc = " GRefString:\n\n A typedef for a reference-counted string. A pointer to a #GRefString can be\n treated like a standard `char*` array by all code, but can additionally have\n `g_ref_string_*()` methods called on it. `g_ref_string_*()` methods cannot be\n called on `char*` arrays not allocated using g_ref_string_new().\n\n If using #GRefString with autocleanups, g_autoptr() must be used rather than\n g_autofree(), so that the reference counting metadata is also freed.\n\n Since: 2.58"]
pub type GRefString = ::std::os::raw::c_char;
pub const GRegexError_G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const GRegexError_G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const GRegexError_G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const GRegexError_G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const GRegexError_G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const GRegexError_G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const GRegexError_G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const GRegexError_G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const GRegexError_G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const GRegexError_G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const GRegexError_G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const GRegexError_G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const GRegexError_G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const GRegexError_G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const GRegexError_G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const GRegexError_G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const GRegexError_G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const GRegexError_G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const GRegexError_G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const GRegexError_G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const GRegexError_G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const GRegexError_G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const GRegexError_G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const GRegexError_G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const GRegexError_G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const GRegexError_G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const GRegexError_G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const GRegexError_G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const GRegexError_G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const GRegexError_G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const GRegexError_G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const GRegexError_G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const GRegexError_G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const GRegexError_G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const GRegexError_G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const GRegexError_G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;
#[doc = " GRegexError:\n @G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed.\n @G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed.\n @G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement\n     string.\n @G_REGEX_ERROR_MATCH: The match process failed.\n @G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine.\n     Since 2.16\n @G_REGEX_ERROR_STRAY_BACKSLASH: \"\\\\\" at end of pattern. Since 2.16\n @G_REGEX_ERROR_MISSING_CONTROL_CHAR: \"\\\\c\" at end of pattern. Since 2.16\n @G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows \"\\\\\".\n     Since 2.16\n @G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in \"{}\"\n     quantifier. Since 2.16\n @G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in \"{}\" quantifier.\n     Since 2.16\n @G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating \"]\" for\n     character class. Since 2.16\n @G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence\n     in character class. Since 2.16\n @G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class.\n     Since 2.16\n @G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16\n @G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after \"(?\",\n     \"(?<\" or \"(?P\". Since 2.16\n @G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are\n     supported only within a class. Since 2.16\n @G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating \")\" or \")\"\n     without opening \"(\". Since 2.16\n @G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent\n     subpattern. Since 2.16\n @G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating \")\" after comment.\n     Since 2.16\n @G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large.\n     Since 2.16\n @G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16\n @G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not\n     fixed length. Since 2.16\n @G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after \"(?(\".\n     Since 2.16\n @G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains\n     more than two branches. Since 2.16\n @G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after \"(?(\".\n     Since 2.16\n @G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name.\n     Since 2.16\n @G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating\n     elements are not supported. Since 2.16\n @G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in \"\\\\x{...}\" sequence\n     is too large. Since 2.16\n @G_REGEX_ERROR_INVALID_CONDITION: Invalid condition \"(?(0)\". Since 2.16\n @G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: \\\\C not allowed in\n     lookbehind assertion. Since 2.16\n @G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely.\n     Since 2.16\n @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator\n     in subpattern name. Since 2.16\n @G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have\n     the same name. Since 2.16\n @G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed \"\\\\P\" or \"\\\\p\" sequence.\n     Since 2.16\n @G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after \"\\\\P\" or\n     \"\\\\p\". Since 2.16\n @G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long\n     (maximum 32 characters). Since 2.16\n @G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum\n     10,000). Since 2.16\n @G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than \"\\\\377\".\n     Since 2.16\n @G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: \"DEFINE\" group contains more\n     than one branch. Since 2.16\n @G_REGEX_ERROR_DEFINE_REPETION: Repeating a \"DEFINE\" group is not allowed.\n     This error is never raised. Since: 2.16 Deprecated: 2.34\n @G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options.\n     Since 2.16\n @G_REGEX_ERROR_MISSING_BACK_REFERENCE: \"\\\\g\" is not followed by a braced,\n      angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16\n @G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34\n @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing\n     control verb used does not allow an argument. Since: 2.34\n @G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing\n     control verb. Since: 2.34\n @G_REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34\n @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34\n @G_REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34\n @G_REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,\n     \"[\" is an invalid data character. Since: 2.34\n @G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the\n     same number are not allowed. Since: 2.34\n @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control\n     verb requires an argument. Since: 2.34\n @G_REGEX_ERROR_INVALID_CONTROL_CHAR: \"\\\\c\" must be followed by an ASCII\n     character. Since: 2.34\n @G_REGEX_ERROR_MISSING_NAME: \"\\\\k\" is not followed by a braced, angle-bracketed, or\n     quoted name. Since: 2.34\n @G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: \"\\\\N\" is not supported in a class. Since: 2.34\n @G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34\n @G_REGEX_ERROR_NAME_TOO_LONG: the name is too long in \"(*MARK)\", \"(*PRUNE)\",\n     \"(*SKIP)\", or \"(*THEN)\". Since: 2.34\n @G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the \\\\u sequence is\n     too large. Since: 2.34\n\n Error codes returned by regular expressions functions.\n\n Since: 2.14"]
pub type GRegexError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_regex_error_quark() -> GQuark;
}
pub const GRegexCompileFlags_G_REGEX_DEFAULT: GRegexCompileFlags = 0;
pub const GRegexCompileFlags_G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const GRegexCompileFlags_G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const GRegexCompileFlags_G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const GRegexCompileFlags_G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const GRegexCompileFlags_G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const GRegexCompileFlags_G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const GRegexCompileFlags_G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const GRegexCompileFlags_G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const GRegexCompileFlags_G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const GRegexCompileFlags_G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const GRegexCompileFlags_G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const GRegexCompileFlags_G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const GRegexCompileFlags_G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const GRegexCompileFlags_G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;
#[doc = " GRegexCompileFlags:\n @G_REGEX_DEFAULT: No special options set. Since: 2.74\n @G_REGEX_CASELESS: Letters in the pattern match both upper- and\n     lowercase letters. This option can be changed within a pattern\n     by a \"(?i)\" option setting.\n @G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting\n     of a single line of characters (even if it actually contains\n     newlines). The \"start of line\" metacharacter (\"^\") matches only\n     at the start of the string, while the \"end of line\" metacharacter\n     (\"$\") matches only at the end of the string, or before a terminating\n     newline (unless %G_REGEX_DOLLAR_ENDONLY is set). When\n     %G_REGEX_MULTILINE is set, the \"start of line\" and \"end of line\"\n     constructs match immediately following or immediately before any\n     newline in the string, respectively, as well as at the very start\n     and end. This can be changed within a pattern by a \"(?m)\" option\n     setting.\n @G_REGEX_DOTALL: A dot metacharacter (\".\") in the pattern matches all\n     characters, including newlines. Without it, newlines are excluded.\n     This option can be changed within a pattern by a (\"?s\") option setting.\n @G_REGEX_EXTENDED: Whitespace data characters in the pattern are\n     totally ignored except when escaped or inside a character class.\n     Whitespace does not include the VT character (code 11). In addition,\n     characters between an unescaped \"#\" outside a character class and\n     the next newline character, inclusive, are also ignored. This can\n     be changed within a pattern by a \"(?x)\" option setting.\n @G_REGEX_ANCHORED: The pattern is forced to be \"anchored\", that is,\n     it is constrained to match only at the first matching point in the\n     string that is being searched. This effect can also be achieved by\n     appropriate constructs in the pattern itself such as the \"^\"\n     metacharacter.\n @G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter (\"$\") in the pattern\n     matches only at the end of the string. Without this option, a\n     dollar also matches immediately before the final character if\n     it is a newline (but not before any other newlines). This option\n     is ignored if %G_REGEX_MULTILINE is set.\n @G_REGEX_UNGREEDY: Inverts the \"greediness\" of the quantifiers so that\n     they are not greedy by default, but become greedy if followed by \"?\".\n     It can also be set by a \"(?U)\" option setting within the pattern.\n @G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this\n     flag they are considered as a raw sequence of bytes.\n @G_REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing\n     parentheses in the pattern. Any opening parenthesis that is not\n     followed by \"?\" behaves as if it were followed by \"?:\" but named\n     parentheses can still be used for capturing (and they acquire numbers\n     in the usual way).\n @G_REGEX_OPTIMIZE: Since 2.74 and the port to pcre2, requests JIT\n     compilation, which, if the just-in-time compiler is available, further\n     processes a compiled pattern into machine code that executes much\n     faster. However, it comes at the cost of extra processing before the\n     match is performed, so it is most beneficial to use this when the same\n     compiled pattern is used for matching many times. Before 2.74 this\n     option used the built-in non-JIT optimizations in pcre1.\n @G_REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the\n     first newline. Since: 2.34\n @G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not\n     be unique. This can be helpful for certain types of pattern when it\n     is known that only one instance of the named subpattern can ever be\n     matched.\n @G_REGEX_NEWLINE_CR: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     is '\\r'.\n @G_REGEX_NEWLINE_LF: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     is '\\n'.\n @G_REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is\n     recognized. If this option is set, the only recognized newline character\n     sequence is '\\r\\n'.\n @G_REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence\n     is recognized. If this option is set, the only recognized newline character\n     sequences are '\\r', '\\n', and '\\r\\n'. Since: 2.34\n @G_REGEX_BSR_ANYCRLF: Usually any newline character or character sequence\n     is recognised. If this option is set, then \"\\R\" only recognizes the newline\n    characters '\\r', '\\n' and '\\r\\n'. Since: 2.34\n @G_REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with\n     JavaScript rather than PCRE. Since GLib 2.74 this is no longer supported,\n     as libpcre2 does not support it. Since: 2.34 Deprecated: 2.74\n\n Flags specifying compile-time options.\n\n Since: 2.14"]
pub type GRegexCompileFlags = ::std::os::raw::c_uint;
pub const GRegexMatchFlags_G_REGEX_MATCH_DEFAULT: GRegexMatchFlags = 0;
pub const GRegexMatchFlags_G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;
#[doc = " GRegexMatchFlags:\n @G_REGEX_MATCH_DEFAULT: No special options set. Since: 2.74\n @G_REGEX_MATCH_ANCHORED: The pattern is forced to be \"anchored\", that is,\n     it is constrained to match only at the first matching point in the\n     string that is being searched. This effect can also be achieved by\n     appropriate constructs in the pattern itself such as the \"^\"\n     metacharacter.\n @G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is\n     not the beginning of a line, so the circumflex metacharacter should\n     not match before it. Setting this without %G_REGEX_MULTILINE (at\n     compile time) causes circumflex never to match. This option affects\n     only the behaviour of the circumflex metacharacter, it does not\n     affect \"\\A\".\n @G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is\n     not the end of a line, so the dollar metacharacter should not match\n     it nor (except in multiline mode) a newline immediately before it.\n     Setting this without %G_REGEX_MULTILINE (at compile time) causes\n     dollar never to match. This option affects only the behaviour of\n     the dollar metacharacter, it does not affect \"\\Z\" or \"\\z\".\n @G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid\n     match if this option is set. If there are alternatives in the pattern,\n     they are tried. If all the alternatives match the empty string, the\n     entire match fails. For example, if the pattern \"a?b?\" is applied to\n     a string not beginning with \"a\" or \"b\", it matches the empty string\n     at the start of the string. With this flag set, this match is not\n     valid, so GRegex searches further into the string for occurrences\n     of \"a\" or \"b\".\n @G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more\n     documentation on partial matching see g_match_info_is_partial_match().\n @G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\r' character as line terminator.\n @G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\n' character as line terminator.\n @G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when\n     creating a new #GRegex, setting the '\\r\\n' characters sequence as line terminator.\n @G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when\n     creating a new #GRegex, any Unicode newline sequence\n     is recognised as a newline. These are '\\r', '\\n' and '\\rn', and the\n     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),\n     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and\n     U+2029 PARAGRAPH SEPARATOR.\n @G_REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when\n     creating a new #GRegex; any '\\r', '\\n', or '\\r\\n' character sequence\n     is recognized as a newline. Since: 2.34\n @G_REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for \"\\R\" set when\n     creating a new #GRegex; only '\\r', '\\n', or '\\r\\n' character sequences\n     are recognized as a newline by \"\\R\". Since: 2.34\n @G_REGEX_MATCH_BSR_ANY: Overrides the newline definition for \"\\R\" set when\n     creating a new #GRegex; any Unicode newline character or character sequence\n     are recognized as a newline by \"\\R\". These are '\\r', '\\n' and '\\rn', and the\n     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),\n     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and\n     U+2029 PARAGRAPH SEPARATOR. Since: 2.34\n @G_REGEX_MATCH_PARTIAL_SOFT: An alias for %G_REGEX_MATCH_PARTIAL. Since: 2.34\n @G_REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to\n     to %G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match\n     is found, without continuing to search for a possible complete match. See\n     g_match_info_is_partial_match() for more information. Since: 2.34\n @G_REGEX_MATCH_NOTEMPTY_ATSTART: Like %G_REGEX_MATCH_NOTEMPTY, but only applied to\n     the start of the matched string. For anchored\n     patterns this can only happen for pattern containing \"\\K\". Since: 2.34\n\n Flags specifying match-time options.\n\n Since: 2.14"]
pub type GRegexMatchFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
#[doc = " GRegex:\n\n A GRegex is the \"compiled\" form of a regular expression pattern.\n This structure is opaque and its fields cannot be accessed directly.\n\n Since: 2.14"]
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
#[doc = " GMatchInfo:\n\n A GMatchInfo is an opaque struct used to return information about\n matches."]
pub type GMatchInfo = _GMatchInfo;
#[doc = " GRegexEvalCallback:\n @match_info: the #GMatchInfo generated by the match.\n     Use g_match_info_get_regex() and g_match_info_get_string() if you\n     need the #GRegex or the matched string.\n @result: a #GString containing the new string\n @user_data: user data passed to g_regex_replace_eval()\n\n Specifies the type of the function passed to g_regex_replace_eval().\n It is called for each occurrence of the pattern in the string passed\n to g_regex_replace_eval(), and it should append the replacement to\n @result.\n\n Returns: %FALSE to continue the replacement process, %TRUE to stop it\n\n Since: 2.14"]
pub type GRegexEvalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        match_info: *const GMatchInfo,
        result: *mut GString,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_unref(regex: *mut GRegex);
}
extern "C" {
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
}
extern "C" {
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
}
extern "C" {
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
}
extern "C" {
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
}
extern "C" {
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
}
extern "C" {
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_check_replacement(
        replacement: *const gchar,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
}
extern "C" {
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
}
extern "C" {
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
}
extern "C" {
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
}
extern "C" {
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: gint,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
}
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::std::option::Option<
    unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean),
>;
pub const GErrorType_G_ERR_UNKNOWN: GErrorType = 0;
pub const GErrorType_G_ERR_UNEXP_EOF: GErrorType = 1;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const GErrorType_G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const GErrorType_G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const GErrorType_G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const GErrorType_G_ERR_FLOAT_MALFORMED: GErrorType = 7;
pub type GErrorType = ::std::os::raw::c_uint;
pub const GTokenType_G_TOKEN_EOF: GTokenType = 0;
pub const GTokenType_G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const GTokenType_G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const GTokenType_G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const GTokenType_G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const GTokenType_G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const GTokenType_G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const GTokenType_G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const GTokenType_G_TOKEN_COMMA: GTokenType = 44;
pub const GTokenType_G_TOKEN_NONE: GTokenType = 256;
pub const GTokenType_G_TOKEN_ERROR: GTokenType = 257;
pub const GTokenType_G_TOKEN_CHAR: GTokenType = 258;
pub const GTokenType_G_TOKEN_BINARY: GTokenType = 259;
pub const GTokenType_G_TOKEN_OCTAL: GTokenType = 260;
pub const GTokenType_G_TOKEN_INT: GTokenType = 261;
pub const GTokenType_G_TOKEN_HEX: GTokenType = 262;
pub const GTokenType_G_TOKEN_FLOAT: GTokenType = 263;
pub const GTokenType_G_TOKEN_STRING: GTokenType = 264;
pub const GTokenType_G_TOKEN_SYMBOL: GTokenType = 265;
pub const GTokenType_G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const GTokenType_G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const GTokenType_G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const GTokenType_G_TOKEN_COMMENT_MULTI: GTokenType = 269;
pub const GTokenType_G_TOKEN_LAST: GTokenType = 270;
pub type GTokenType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
}
#[test]
fn bindgen_test_layout__GTokenValue() {
    const UNINIT: ::std::mem::MaybeUninit<_GTokenValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTokenValue>(),
        8usize,
        concat!("Size of: ", stringify!(_GTokenValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTokenValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTokenValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_symbol) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_binary) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_binary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_octal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_octal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_hex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_hex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_comment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_comment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_char) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_char)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub padding_dummy: guint,
}
#[test]
fn bindgen_test_layout__GScannerConfig() {
    const UNINIT: ::std::mem::MaybeUninit<_GScannerConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GScannerConfig>(),
        40usize,
        concat!("Size of: ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScannerConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_skip_characters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_skip_characters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_identifier_first) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_identifier_nth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_nth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpair_comment_single) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cpair_comment_single)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_dummy) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(padding_dummy)
        )
    );
}
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::std::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::std::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::std::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::std::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::std::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 =
                unsafe { ::std::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::std::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::std::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::std::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::std::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::std::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::std::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::std::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::std::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::std::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::std::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::std::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::std::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::std::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::std::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::std::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::std::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
#[test]
fn bindgen_test_layout__GScanner() {
    const UNINIT: ::std::mem::MaybeUninit<_GScanner> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GScanner>(),
        144usize,
        concat!("Size of: ", stringify!(_GScanner))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScanner>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScanner))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_parse_errors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(max_parse_errors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parse_errors) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(parse_errors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qdata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).token) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).position) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_token) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_token)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_line) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_position) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_position)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).symbol_table) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(symbol_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input_fd) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_fd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text_end) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scope_id) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(scope_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msg_handler) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(msg_handler)
        )
    );
}
extern "C" {
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
}
extern "C" {
    pub fn g_scanner_destroy(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
}
extern "C" {
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
}
extern "C" {
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
}
extern "C" {
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
}
extern "C" {
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
}
extern "C" {
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
        value: gpointer,
    );
}
extern "C" {
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    );
}
extern "C" {
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    ) -> gpointer;
}
extern "C" {
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        func: GHFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
}
extern "C" {
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
}
extern "C" {
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, data: gpointer) -> gint,
>;
extern "C" {
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_free(seq: *mut GSequence);
}
extern "C" {
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
}
extern "C" {
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
extern "C" {
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
}
extern "C" {
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
        -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
}
extern "C" {
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
}
extern "C" {
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
}
extern "C" {
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
}
pub const GShellError_G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const GShellError_G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const GShellError_G_SHELL_ERROR_FAILED: GShellError = 2;
pub type GShellError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_shell_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
}
extern "C" {
    pub fn g_slice_free_chain_with_offset(
        block_size: gsize,
        mem_chain: gpointer,
        next_offset: gsize,
    );
}
pub const GSliceConfig_G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const GSliceConfig_G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const GSliceConfig_G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const GSliceConfig_G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const GSliceConfig_G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const GSliceConfig_G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;
pub type GSliceConfig = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
}
extern "C" {
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
}
extern "C" {
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: gint64,
        n_values: *mut guint,
    ) -> *mut gint64;
}
pub const GSpawnError_G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const GSpawnError_G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const GSpawnError_G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const GSpawnError_G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const GSpawnError_G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const GSpawnError_G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const GSpawnError_G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const GSpawnError_G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const GSpawnError_G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const GSpawnError_G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const GSpawnError_G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const GSpawnError_G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const GSpawnError_G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const GSpawnError_G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const GSpawnError_G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const GSpawnError_G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const GSpawnError_G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const GSpawnError_G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const GSpawnError_G_SPAWN_ERROR_FAILED: GSpawnError = 19;
#[doc = " GSpawnError:\n @G_SPAWN_ERROR_FORK: Fork failed due to lack of memory.\n @G_SPAWN_ERROR_READ: Read or select on pipes failed.\n @G_SPAWN_ERROR_CHDIR: Changing to working directory failed.\n @G_SPAWN_ERROR_ACCES: execv() returned `EACCES`\n @G_SPAWN_ERROR_PERM: execv() returned `EPERM`\n @G_SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`\n @G_SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)\n @G_SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`\n @G_SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`\n @G_SPAWN_ERROR_NOENT: execv() returned `ENOENT`\n @G_SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`\n @G_SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`\n @G_SPAWN_ERROR_LOOP: execv() returned `ELOOP`\n @G_SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`\n @G_SPAWN_ERROR_IO: execv() returned `EIO`\n @G_SPAWN_ERROR_NFILE: execv() returned `ENFILE`\n @G_SPAWN_ERROR_MFILE: execv() returned `EMFILE`\n @G_SPAWN_ERROR_INVAL: execv() returned `EINVAL`\n @G_SPAWN_ERROR_ISDIR: execv() returned `EISDIR`\n @G_SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`\n @G_SPAWN_ERROR_FAILED: Some other fatal failure,\n   `error->message` should explain.\n\n Error codes returned by spawning processes."]
pub type GSpawnError = ::std::os::raw::c_uint;
#[doc = " GSpawnChildSetupFunc:\n @data: user data passed to the function.\n\n Specifies the type of the setup function passed to g_spawn_async(),\n g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very\n limited ways, be used to affect the child's execution.\n\n On POSIX platforms, the function is called in the child after GLib\n has performed all the setup it plans to perform, but before calling\n exec(). Actions taken in this function will only affect the child,\n not the parent.\n\n On Windows, the function is called in the parent. Its usefulness on\n Windows is thus questionable. In many cases executing the child setup\n function in the parent can have ill effects, and you should be very\n careful when porting software to Windows that uses child setup\n functions.\n\n However, even on POSIX, you are extremely limited in what you can\n safely do from a #GSpawnChildSetupFunc, because any mutexes that were\n held by other threads in the parent process at the time of the fork()\n will still be locked in the child process, and they will never be\n unlocked (since the threads that held them don't exist in the child).\n POSIX allows only async-signal-safe functions (see signal(7)) to be\n called in the child between fork() and exec(), which drastically limits\n the usefulness of child setup functions.\n\n In particular, it is not safe to call any function which may\n call malloc(), which includes POSIX functions such as setenv().\n If you need to set up the child environment differently from\n the parent, you should use g_get_environ(), g_environ_setenv(),\n and g_environ_unsetenv(), and then pass the complete environment\n list to the `g_spawn...` function."]
pub type GSpawnChildSetupFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub const GSpawnFlags_G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const GSpawnFlags_G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const GSpawnFlags_G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const GSpawnFlags_G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const GSpawnFlags_G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const GSpawnFlags_G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const GSpawnFlags_G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
#[doc = " G_SPAWN_CHILD_INHERITS_STDOUT:\n\n The child will inherit the parent's standard output.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDOUT: GSpawnFlags = 512;
#[doc = " G_SPAWN_CHILD_INHERITS_STDERR:\n\n The child will inherit the parent's standard error.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDERR: GSpawnFlags = 1024;
#[doc = " G_SPAWN_STDIN_FROM_DEV_NULL:\n\n The child's standard input is attached to `/dev/null`.\n\n Since: 2.74"]
pub const GSpawnFlags_G_SPAWN_STDIN_FROM_DEV_NULL: GSpawnFlags = 2048;
#[doc = " GSpawnFlags:\n @G_SPAWN_DEFAULT: no flags, default behaviour\n @G_SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will\n     be inherited by the child; otherwise all descriptors except stdin,\n     stdout and stderr will be closed before calling exec() in the child.\n @G_SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;\n     you must use g_child_watch_add() yourself (or call waitpid() or handle\n     `SIGCHLD` yourself), or the child will become a zombie.\n @G_SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be\n     looked for in the user's `PATH`.\n @G_SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,\n     instead of going to the same location as the parent's standard output.\n @G_SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded.\n @G_SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard\n     input (by default, the child's standard input is attached to `/dev/null`).\n @G_SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to\n     execute, while the remaining elements are the actual argument vector\n     to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`\n     as the file to execute, and passes all of `argv` to the child.\n @G_SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an absolute path,\n     it will be looked for in the `PATH` from the passed child environment.\n     Since: 2.34\n @G_SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set.\n     Since: 2.40\n @G_SPAWN_CHILD_INHERITS_STDOUT: the child will inherit the parent's standard output.\n     Since: 2.74\n @G_SPAWN_CHILD_INHERITS_STDERR: the child will inherit the parent's standard error.\n     Since: 2.74\n @G_SPAWN_STDIN_FROM_DEV_NULL: the child's standard input is attached to `/dev/null`.\n     Since: 2.74\n\n Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes()."]
pub type GSpawnFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_spawn_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_exit_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_pipes_and_fds(
        working_directory: *const gchar,
        argv: *const *const gchar,
        envp: *const *const gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        source_fds: *const gint,
        target_fds: *const gint,
        n_fds: gsize,
        child_pid_out: *mut GPid,
        stdin_pipe_out: *mut gint,
        stdout_pipe_out: *mut gint,
        stderr_pipe_out: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_fds(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        wait_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_async(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_check_wait_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_spawn_check_exit_status(wait_status: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_spawn_close_pid(pid: GPid);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
extern "C" {
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
}
extern "C" {
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const gchar,
        len: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const gchar,
    ) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStrvBuilder {
    _unused: [u8; 0],
}
#[doc = " GStrvBuilder:\n\n A helper object to build a %NULL-terminated string array\n by appending. See g_strv_builder_new().\n\n Since: 2.68"]
pub type GStrvBuilder = _GStrvBuilder;
extern "C" {
    pub fn g_strv_builder_new() -> *mut GStrvBuilder;
}
extern "C" {
    pub fn g_strv_builder_unref(builder: *mut GStrvBuilder);
}
extern "C" {
    pub fn g_strv_builder_ref(builder: *mut GStrvBuilder) -> *mut GStrvBuilder;
}
extern "C" {
    pub fn g_strv_builder_add(builder: *mut GStrvBuilder, value: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_strv_builder_addv(
        builder: *mut GStrvBuilder,
        value: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_strv_builder_add_many(builder: *mut GStrvBuilder, ...);
}
extern "C" {
    pub fn g_strv_builder_end(builder: *mut GStrvBuilder) -> GStrv;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::std::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
extern "C" {
    pub fn g_strcmp0(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_minimized_result(
        minimized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_maximized_result(
        maximized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_init(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_test_subprocess() -> gboolean;
}
extern "C" {
    pub fn g_test_run() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_add_func(testpath: *const ::std::os::raw::c_char, test_func: GTestFunc);
}
extern "C" {
    pub fn g_test_add_data_func(
        testpath: *const ::std::os::raw::c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
}
extern "C" {
    pub fn g_test_add_data_func_full(
        testpath: *const ::std::os::raw::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_test_get_path() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_test_fail();
}
extern "C" {
    pub fn g_test_fail_printf(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_incomplete(msg: *const gchar);
}
extern "C" {
    pub fn g_test_incomplete_printf(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_skip(msg: *const gchar);
}
extern "C" {
    pub fn g_test_skip_printf(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_failed() -> gboolean;
}
extern "C" {
    pub fn g_test_set_nonfatal_assertions();
}
extern "C" {
    pub fn g_test_message(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn g_test_bug_base(uri_pattern: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_bug(bug_uri_snippet: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_summary(summary: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_test_timer_start();
}
extern "C" {
    pub fn g_test_timer_elapsed() -> f64;
}
extern "C" {
    pub fn g_test_timer_last() -> f64;
}
extern "C" {
    pub fn g_test_queue_free(gfree_pointer: gpointer);
}
extern "C" {
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
}
pub const GTestTrapFlags_G_TEST_TRAP_DEFAULT: GTestTrapFlags = 0;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const GTestTrapFlags_G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;
#[doc = " GTestTrapFlags:\n @G_TEST_TRAP_DEFAULT: Default behaviour. Since: 2.74\n @G_TEST_TRAP_SILENCE_STDOUT: Redirect stdout of the test child to\n     `/dev/null` so it cannot be observed on the console during test\n     runs. The actual output is still captured though to allow later\n     tests with g_test_trap_assert_stdout().\n @G_TEST_TRAP_SILENCE_STDERR: Redirect stderr of the test child to\n     `/dev/null` so it cannot be observed on the console during test\n     runs. The actual output is still captured though to allow later\n     tests with g_test_trap_assert_stderr().\n @G_TEST_TRAP_INHERIT_STDIN: If this flag is given, stdin of the\n     child process is shared with stdin of its parent process.\n     It is redirected to `/dev/null` otherwise.\n\n Test traps are guards around forked tests.\n These flags determine what traps to set.\n\n Deprecated: 2.38: #GTestTrapFlags is used only with g_test_trap_fork(),\n which is deprecated. g_test_trap_subprocess() uses\n #GTestSubprocessFlags."]
pub type GTestTrapFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
}
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_DEFAULT: GTestSubprocessFlags = 0;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;
pub type GTestSubprocessFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_test_trap_subprocess(
        test_path: *const ::std::os::raw::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
}
extern "C" {
    pub fn g_test_trap_has_passed() -> gboolean;
}
extern "C" {
    pub fn g_test_trap_reached_timeout() -> gboolean;
}
extern "C" {
    pub fn g_test_rand_int() -> gint32;
}
extern "C" {
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_test_rand_double() -> f64;
}
extern "C" {
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
}
extern "C" {
    pub fn g_test_create_case(
        test_name: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
}
extern "C" {
    pub fn g_test_create_suite(suite_name: *const ::std::os::raw::c_char) -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_get_root() -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
}
extern "C" {
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
}
extern "C" {
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_test_case_free(test_case: *mut GTestCase);
}
extern "C" {
    pub fn g_test_suite_free(suite: *mut GTestSuite);
}
extern "C" {
    pub fn g_test_trap_assertions(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        assertion_flags: guint64,
        pattern: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_expr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    ) -> !;
}
extern "C" {
    pub fn g_assertion_message_cmpstr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        cmp: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpstrv(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const *const ::std::os::raw::c_char,
        arg2: *const *const ::std::os::raw::c_char,
        first_wrong_idx: gsize,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpnum(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: u128,
        cmp: *const ::std::os::raw::c_char,
        arg2: u128,
        numtype: ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_error(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn g_test_add_vtable(
        testpath: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
#[test]
fn bindgen_test_layout_GTestConfig() {
    const UNINIT: ::std::mem::MaybeUninit<GTestConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GTestConfig>(),
        24usize,
        concat!("Size of: ", stringify!(GTestConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(GTestConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_initialized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_quick) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_perf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_perf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_verbose) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_verbose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_quiet) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quiet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).test_undefined) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_undefined)
        )
    );
}
extern "C" {
    pub static g_test_config_vars: *const GTestConfig;
}
pub const GTestResult_G_TEST_RUN_SUCCESS: GTestResult = 0;
pub const GTestResult_G_TEST_RUN_SKIPPED: GTestResult = 1;
pub const GTestResult_G_TEST_RUN_FAILURE: GTestResult = 2;
pub const GTestResult_G_TEST_RUN_INCOMPLETE: GTestResult = 3;
pub type GTestResult = ::std::os::raw::c_uint;
pub const GTestLogType_G_TEST_LOG_NONE: GTestLogType = 0;
pub const GTestLogType_G_TEST_LOG_ERROR: GTestLogType = 1;
pub const GTestLogType_G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const GTestLogType_G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const GTestLogType_G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const GTestLogType_G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const GTestLogType_G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const GTestLogType_G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const GTestLogType_G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const GTestLogType_G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const GTestLogType_G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const GTestLogType_G_TEST_LOG_STOP_SUITE: GTestLogType = 11;
pub type GTestLogType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut u128,
}
#[test]
fn bindgen_test_layout_GTestLogMsg() {
    const UNINIT: ::std::mem::MaybeUninit<GTestLogMsg> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GTestLogMsg>(),
        32usize,
        concat!("Size of: ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogMsg>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(log_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_strings) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_nums) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_nums)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nums) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(nums)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
#[test]
fn bindgen_test_layout_GTestLogBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<GTestLogBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GTestLogBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msgs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(msgs)
        )
    );
}
extern "C" {
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
}
extern "C" {
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
}
extern "C" {
    pub fn g_test_log_buffer_push(
        tbuffer: *mut GTestLogBuffer,
        n_bytes: guint,
        bytes: *const guint8,
    );
}
extern "C" {
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
}
extern "C" {
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
}
#[doc = " GTestLogFatalFunc:\n @log_domain: the log domain of the message\n @log_level: the log level of the message (including the fatal and recursion flags)\n @message: the message to process\n @user_data: user data, set in g_test_log_set_fatal_handler()\n\n Specifies the prototype of fatal log handler functions.\n\n Returns: %TRUE if the program should abort, %FALSE otherwise\n\n Since: 2.22"]
pub type GTestLogFatalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_test_expect_message(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        pattern: *const gchar,
    );
}
extern "C" {
    pub fn g_test_assert_expected_messages_internal(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
pub const GTestFileType_G_TEST_DIST: GTestFileType = 0;
pub const GTestFileType_G_TEST_BUILT: GTestFileType = 1;
pub type GTestFileType = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
}
extern "C" {
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *const gchar;
}
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
#[test]
fn bindgen_test_layout__GThreadPool() {
    const UNINIT: ::std::mem::MaybeUninit<_GThreadPool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThreadPool>(),
        24usize,
        concat!("Size of: ", stringify!(_GThreadPool))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadPool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exclusive) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(exclusive)
        )
    );
}
extern "C" {
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
extern "C" {
    pub fn g_thread_pool_new_full(
        func: GFunc,
        user_data: gpointer,
        item_free_func: GDestroyNotify,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
extern "C" {
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
}
extern "C" {
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
}
extern "C" {
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
}
extern "C" {
    pub fn g_thread_pool_stop_unused_threads();
}
extern "C" {
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
}
extern "C" {
    pub fn g_thread_pool_get_max_idle_time() -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
extern "C" {
    pub fn g_timer_new() -> *mut GTimer;
}
extern "C" {
    pub fn g_timer_destroy(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_start(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_stop(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_reset(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_continue(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
}
extern "C" {
    pub fn g_timer_is_active(timer: *mut GTimer) -> gboolean;
}
extern "C" {
    pub fn g_usleep(microseconds: gulong);
}
extern "C" {
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
}
extern "C" {
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
}
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
#[test]
fn bindgen_test_layout__GTrashStack() {
    const UNINIT: ::std::mem::MaybeUninit<_GTrashStack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTrashStack>(),
        8usize,
        concat!("Size of: ", stringify!(_GTrashStack))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTrashStack>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTrashStack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTrashStack),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
}
extern "C" {
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTreeNode {
    _unused: [u8; 0],
}
#[doc = " GTreeNode:\n\n An opaque type which identifies a specific node in a #GTree.\n\n Since: 2.68"]
pub type GTreeNode = _GTreeNode;
pub type GTraverseFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, data: gpointer) -> gboolean,
>;
#[doc = " GTraverseNodeFunc:\n @node: a #GTreeNode\n @data: user data passed to g_tree_foreach_node()\n\n Specifies the type of function passed to g_tree_foreach_node(). It is\n passed each node, together with the @user_data parameter passed to\n g_tree_foreach_node(). If the function returns %TRUE, the traversal is\n stopped.\n\n Returns: %TRUE to stop the traversal\n Since: 2.68"]
pub type GTraverseNodeFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GTreeNode, data: gpointer) -> gboolean>;
extern "C" {
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_node_first(tree: *mut GTree) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_node_last(tree: *mut GTree) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_node_previous(node: *mut GTreeNode) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_node_next(node: *mut GTreeNode) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_unref(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_destroy(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_insert_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_replace_node(tree: *mut GTree, key: gpointer, value: gpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_remove_all(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_node_key(node: *mut GTreeNode) -> gpointer;
}
extern "C" {
    pub fn g_tree_node_value(node: *mut GTreeNode) -> gpointer;
}
extern "C" {
    pub fn g_tree_lookup_node(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_tree_foreach_node(tree: *mut GTree, func: GTraverseNodeFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tree_search_node(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_tree_lower_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_upper_bound(tree: *mut GTree, key: gconstpointer) -> *mut GTreeNode;
}
extern "C" {
    pub fn g_tree_height(tree: *mut GTree) -> gint;
}
extern "C" {
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUri {
    _unused: [u8; 0],
}
pub type GUri = _GUri;
extern "C" {
    pub fn g_uri_ref(uri: *mut GUri) -> *mut GUri;
}
extern "C" {
    pub fn g_uri_unref(uri: *mut GUri);
}
pub const GUriFlags_G_URI_FLAGS_NONE: GUriFlags = 0;
pub const GUriFlags_G_URI_FLAGS_PARSE_RELAXED: GUriFlags = 1;
pub const GUriFlags_G_URI_FLAGS_HAS_PASSWORD: GUriFlags = 2;
pub const GUriFlags_G_URI_FLAGS_HAS_AUTH_PARAMS: GUriFlags = 4;
pub const GUriFlags_G_URI_FLAGS_ENCODED: GUriFlags = 8;
pub const GUriFlags_G_URI_FLAGS_NON_DNS: GUriFlags = 16;
pub const GUriFlags_G_URI_FLAGS_ENCODED_QUERY: GUriFlags = 32;
pub const GUriFlags_G_URI_FLAGS_ENCODED_PATH: GUriFlags = 64;
pub const GUriFlags_G_URI_FLAGS_ENCODED_FRAGMENT: GUriFlags = 128;
pub const GUriFlags_G_URI_FLAGS_SCHEME_NORMALIZE: GUriFlags = 256;
#[doc = " GUriFlags:\n @G_URI_FLAGS_NONE: No flags set.\n @G_URI_FLAGS_PARSE_RELAXED: Parse the URI more relaxedly than the\n     [RFC 3986](https://tools.ietf.org/html/rfc3986) grammar specifies,\n     fixing up or ignoring common mistakes in URIs coming from external\n     sources. This is also needed for some obscure URI schemes where `;`\n     separates the host from the path. Dont use this flag unless you need to.\n @G_URI_FLAGS_HAS_PASSWORD: The userinfo field may contain a password,\n     which will be separated from the username by `:`.\n @G_URI_FLAGS_HAS_AUTH_PARAMS: The userinfo may contain additional\n     authentication-related parameters, which will be separated from\n     the username and/or password by `;`.\n @G_URI_FLAGS_NON_DNS: The host component should not be assumed to be a\n     DNS hostname or IP address (for example, for `smb` URIs with NetBIOS\n     hostnames).\n @G_URI_FLAGS_ENCODED: When parsing a URI, this indicates that `%`-encoded\n     characters in the userinfo, path, query, and fragment fields\n     should not be decoded. (And likewise the host field if\n     %G_URI_FLAGS_NON_DNS is also set.) When building a URI, it indicates\n     that you have already `%`-encoded the components, and so #GUri\n     should not do any encoding itself.\n @G_URI_FLAGS_ENCODED_QUERY: Same as %G_URI_FLAGS_ENCODED, for the query\n     field only.\n @G_URI_FLAGS_ENCODED_PATH: Same as %G_URI_FLAGS_ENCODED, for the path only.\n @G_URI_FLAGS_ENCODED_FRAGMENT: Same as %G_URI_FLAGS_ENCODED, for the\n     fragment only.\n @G_URI_FLAGS_SCHEME_NORMALIZE: A scheme-based normalization will be applied.\n     For example, when parsing an HTTP URI changing omitted path to `/` and\n     omitted port to `80`; and when building a URI, changing empty path to `/`\n     and default port `80`). This only supports a subset of known schemes. (Since: 2.68)\n\n Flags that describe a URI.\n\n When parsing a URI, if you need to choose different flags based on\n the type of URI, you can use g_uri_peek_scheme() on the URI string\n to check the scheme first, and use that to decide what flags to\n parse it with.\n\n Since: 2.66"]
pub type GUriFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_uri_split(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        userinfo: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_split_with_user(
        uri_ref: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        user: *mut *mut gchar,
        password: *mut *mut gchar,
        auth_params: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        path: *mut *mut gchar,
        query: *mut *mut gchar,
        fragment: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_split_network(
        uri_string: *const gchar,
        flags: GUriFlags,
        scheme: *mut *mut gchar,
        host: *mut *mut gchar,
        port: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_is_valid(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_join(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_join_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_parse(
        uri_string: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
}
extern "C" {
    pub fn g_uri_parse_relative(
        base_uri: *mut GUri,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut GUri;
}
extern "C" {
    pub fn g_uri_resolve_relative(
        base_uri_string: *const gchar,
        uri_ref: *const gchar,
        flags: GUriFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_build(
        flags: GUriFlags,
        scheme: *const gchar,
        userinfo: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
}
extern "C" {
    pub fn g_uri_build_with_user(
        flags: GUriFlags,
        scheme: *const gchar,
        user: *const gchar,
        password: *const gchar,
        auth_params: *const gchar,
        host: *const gchar,
        port: gint,
        path: *const gchar,
        query: *const gchar,
        fragment: *const gchar,
    ) -> *mut GUri;
}
pub const GUriHideFlags_G_URI_HIDE_NONE: GUriHideFlags = 0;
pub const GUriHideFlags_G_URI_HIDE_USERINFO: GUriHideFlags = 1;
pub const GUriHideFlags_G_URI_HIDE_PASSWORD: GUriHideFlags = 2;
pub const GUriHideFlags_G_URI_HIDE_AUTH_PARAMS: GUriHideFlags = 4;
pub const GUriHideFlags_G_URI_HIDE_QUERY: GUriHideFlags = 8;
pub const GUriHideFlags_G_URI_HIDE_FRAGMENT: GUriHideFlags = 16;
#[doc = " GUriHideFlags:\n @G_URI_HIDE_NONE: No flags set.\n @G_URI_HIDE_USERINFO: Hide the userinfo.\n @G_URI_HIDE_PASSWORD: Hide the password.\n @G_URI_HIDE_AUTH_PARAMS: Hide the auth_params.\n @G_URI_HIDE_QUERY: Hide the query.\n @G_URI_HIDE_FRAGMENT: Hide the fragment.\n\n Flags describing what parts of the URI to hide in\n g_uri_to_string_partial(). Note that %G_URI_HIDE_PASSWORD and\n %G_URI_HIDE_AUTH_PARAMS will only work if the #GUri was parsed with\n the corresponding flags.\n\n Since: 2.66"]
pub type GUriHideFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_uri_to_string(uri: *mut GUri) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_to_string_partial(
        uri: *mut GUri,
        flags: GUriHideFlags,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_get_scheme(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_userinfo(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_user(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_password(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_auth_params(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_host(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_port(uri: *mut GUri) -> gint;
}
extern "C" {
    pub fn g_uri_get_path(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_query(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_fragment(uri: *mut GUri) -> *const gchar;
}
extern "C" {
    pub fn g_uri_get_flags(uri: *mut GUri) -> GUriFlags;
}
pub const GUriParamsFlags_G_URI_PARAMS_NONE: GUriParamsFlags = 0;
pub const GUriParamsFlags_G_URI_PARAMS_CASE_INSENSITIVE: GUriParamsFlags = 1;
pub const GUriParamsFlags_G_URI_PARAMS_WWW_FORM: GUriParamsFlags = 2;
pub const GUriParamsFlags_G_URI_PARAMS_PARSE_RELAXED: GUriParamsFlags = 4;
#[doc = " GUriParamsFlags:\n @G_URI_PARAMS_NONE: No flags set.\n @G_URI_PARAMS_CASE_INSENSITIVE: Parameter names are case insensitive.\n @G_URI_PARAMS_WWW_FORM: Replace `+` with space character. Only useful for\n     URLs on the web, using the `https` or `http` schemas.\n @G_URI_PARAMS_PARSE_RELAXED: See %G_URI_FLAGS_PARSE_RELAXED.\n\n Flags modifying the way parameters are handled by g_uri_parse_params() and\n #GUriParamsIter.\n\n Since: 2.66"]
pub type GUriParamsFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_uri_parse_params(
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
        error: *mut *mut GError,
    ) -> *mut GHashTable;
}
pub type GUriParamsIter = _GUriParamsIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUriParamsIter {
    pub dummy0: gint,
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: [guint8; 256usize],
}
#[test]
fn bindgen_test_layout__GUriParamsIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GUriParamsIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUriParamsIter>(),
        280usize,
        concat!("Size of: ", stringify!(_GUriParamsIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUriParamsIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUriParamsIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUriParamsIter),
            "::",
            stringify!(dummy3)
        )
    );
}
extern "C" {
    pub fn g_uri_params_iter_init(
        iter: *mut GUriParamsIter,
        params: *const gchar,
        length: gssize,
        separators: *const gchar,
        flags: GUriParamsFlags,
    );
}
extern "C" {
    pub fn g_uri_params_iter_next(
        iter: *mut GUriParamsIter,
        attribute: *mut *mut gchar,
        value: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_uri_error_quark() -> GQuark;
}
pub const GUriError_G_URI_ERROR_FAILED: GUriError = 0;
pub const GUriError_G_URI_ERROR_BAD_SCHEME: GUriError = 1;
pub const GUriError_G_URI_ERROR_BAD_USER: GUriError = 2;
pub const GUriError_G_URI_ERROR_BAD_PASSWORD: GUriError = 3;
pub const GUriError_G_URI_ERROR_BAD_AUTH_PARAMS: GUriError = 4;
pub const GUriError_G_URI_ERROR_BAD_HOST: GUriError = 5;
pub const GUriError_G_URI_ERROR_BAD_PORT: GUriError = 6;
pub const GUriError_G_URI_ERROR_BAD_PATH: GUriError = 7;
pub const GUriError_G_URI_ERROR_BAD_QUERY: GUriError = 8;
pub const GUriError_G_URI_ERROR_BAD_FRAGMENT: GUriError = 9;
#[doc = " GUriError:\n @G_URI_ERROR_FAILED: Generic error if no more specific error is available.\n     See the error message for details.\n @G_URI_ERROR_BAD_SCHEME: The scheme of a URI could not be parsed.\n @G_URI_ERROR_BAD_USER: The user/userinfo of a URI could not be parsed.\n @G_URI_ERROR_BAD_PASSWORD: The password of a URI could not be parsed.\n @G_URI_ERROR_BAD_AUTH_PARAMS: The authentication parameters of a URI could not be parsed.\n @G_URI_ERROR_BAD_HOST: The host of a URI could not be parsed.\n @G_URI_ERROR_BAD_PORT: The port of a URI could not be parsed.\n @G_URI_ERROR_BAD_PATH: The path of a URI could not be parsed.\n @G_URI_ERROR_BAD_QUERY: The query of a URI could not be parsed.\n @G_URI_ERROR_BAD_FRAGMENT: The fragment of a URI could not be parsed.\n\n Error codes returned by #GUri methods.\n\n Since: 2.66"]
pub type GUriError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_uri_unescape_string(
        escaped_string: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_unescape_segment(
        escaped_string: *const ::std::os::raw::c_char,
        escaped_string_end: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_parse_scheme(uri: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_peek_scheme(uri: *const ::std::os::raw::c_char) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_escape_string(
        unescaped: *const ::std::os::raw::c_char,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
        allow_utf8: gboolean,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uri_unescape_bytes(
        escaped_string: *const ::std::os::raw::c_char,
        length: gssize,
        illegal_characters: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_uri_escape_bytes(
        unescaped: *const guint8,
        length: gsize,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_uuid_string_is_valid(str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_uuid_string_random() -> *mut gchar;
}
extern "C" {
    pub static glib_major_version: guint;
}
extern "C" {
    pub static glib_minor_version: guint;
}
extern "C" {
    pub static glib_micro_version: guint;
}
extern "C" {
    pub static glib_interface_age: guint;
}
extern "C" {
    pub static glib_binary_age: guint;
}
extern "C" {
    pub fn glib_check_version(
        required_major: guint,
        required_minor: guint,
        required_micro: guint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
extern "C" {
    pub fn g_mem_chunk_new(
        name: *const gchar,
        atom_size: gint,
        area_size: gsize,
        type_: gint,
    ) -> *mut GMemChunk;
}
extern "C" {
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
}
extern "C" {
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_info();
}
extern "C" {
    pub fn g_blow_chunks();
}
extern "C" {
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
}
extern "C" {
    pub fn g_allocator_free(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_pop_allocator();
}
extern "C" {
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_slist_pop_allocator();
}
extern "C" {
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_node_pop_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer)>;
extern "C" {
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
}
extern "C" {
    pub fn g_cache_destroy(cache: *mut GCache);
}
extern "C" {
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
}
extern "C" {
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
pub type GCompletion = _GCompletion;
pub type GCompletionFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::std::option::Option<
    unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
#[test]
fn bindgen_test_layout__GCompletion() {
    const UNINIT: ::std::mem::MaybeUninit<_GCompletion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCompletion>(),
        40usize,
        concat!("Size of: ", stringify!(_GCompletion))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCompletion>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCompletion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).items) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cache) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strncmp_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(strncmp_func)
        )
    );
}
extern "C" {
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
}
extern "C" {
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
}
extern "C" {
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
}
extern "C" {
    pub fn g_completion_free(cmp: *mut GCompletion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTuples {
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GTuples() {
    const UNINIT: ::std::mem::MaybeUninit<_GTuples> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTuples>(),
        4usize,
        concat!("Size of: ", stringify!(_GTuples))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTuples>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTuples))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTuples),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
}
extern "C" {
    pub fn g_relation_destroy(relation: *mut GRelation);
}
extern "C" {
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: gint,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
}
extern "C" {
    pub fn g_relation_insert(relation: *mut GRelation, ...);
}
extern "C" {
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: gint,
    ) -> *mut GTuples;
}
extern "C" {
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
}
extern "C" {
    pub fn g_relation_print(relation: *mut GRelation);
}
extern "C" {
    pub fn g_tuples_destroy(tuples: *mut GTuples);
}
extern "C" {
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
}
pub const GThreadPriority_G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const GThreadPriority_G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const GThreadPriority_G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const GThreadPriority_G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;
pub type GThreadPriority = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
#[test]
fn bindgen_test_layout__GThread() {
    const UNINIT: ::std::mem::MaybeUninit<_GThread> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThread>(),
        24usize,
        concat!("Size of: ", stringify!(_GThread))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThread>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThread))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).joinable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(joinable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(priority)
        )
    );
}
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadFunctions {
    pub mutex_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait: ::std::option::Option<
        unsafe extern "C" fn(
            cond: *mut GCond,
            mutex: *mut GMutex,
            end_time: *mut GTimeVal,
        ) -> gboolean,
    >,
    pub cond_free: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new:
        ::std::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::std::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority:
        ::std::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<
        unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GThreadFunctions() {
    const UNINIT: ::std::mem::MaybeUninit<_GThreadFunctions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThreadFunctions>(),
        168usize,
        concat!("Size of: ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadFunctions>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_new) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_lock) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_trylock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_trylock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_unlock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_unlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex_free) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_new) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_signal) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_signal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_broadcast) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_broadcast)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_wait) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_wait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_timed_wait) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_timed_wait)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cond_free) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_new) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_new)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_get) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_get)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_set) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_create) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_yield) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_yield)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_join) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_join)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_exit) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_exit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_set_priority) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_set_priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_self) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_self)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_equal) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_equal)
        )
    );
}
extern "C" {
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
}
extern "C" {
    pub static mut g_thread_use_default_impl: gboolean;
}
extern "C" {
    pub static mut g_thread_gettime: ::std::option::Option<unsafe extern "C" fn() -> guint64>;
}
extern "C" {
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
}
extern "C" {
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_11 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_12 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_12 = 0;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_13 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_13 = 1;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_14 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_14 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_14 = 2;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_15 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_15 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_15 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_15 = 0;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_16 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_16 = 1;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_17 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_17 = 1;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_18 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_18 = 1;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_19 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_20 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_20 = 1;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__cancel_jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cleanup_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_GStaticMutex() {
    const UNINIT: ::std::mem::MaybeUninit<GStaticMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GStaticMutex>(),
        48usize,
        concat!("Size of: ", stringify!(GStaticMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<GStaticMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(GStaticMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: pthread_t,
    pub dummy: gdouble,
}
#[test]
fn bindgen_test_layout__GStaticRecMutex__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticRecMutex__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
#[test]
fn bindgen_test_layout__GStaticRecMutex() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticRecMutex> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex>(),
        64usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
}
extern "C" {
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
}
extern "C" {
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
#[test]
fn bindgen_test_layout__GStaticRWLock() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticRWLock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticRWLock>(),
        80usize,
        concat!("Size of: ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_cond) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_cond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_cond) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(write_cond)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_counter) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).have_writer) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(have_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).want_to_read) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).want_to_write) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_write)
        )
    );
}
extern "C" {
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticPrivate {
    pub index: guint,
}
#[test]
fn bindgen_test_layout__GStaticPrivate() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticPrivate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticPrivate>(),
        4usize,
        concat!("Size of: ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticPrivate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticPrivate),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
}
extern "C" {
    pub fn g_static_private_set(
        private_key: *mut GStaticPrivate,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
}
extern "C" {
    pub fn g_thread_init(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_get_initialized() -> gboolean;
}
extern "C" {
    pub static mut g_threads_got_initialized: gboolean;
}
extern "C" {
    pub fn g_mutex_new() -> *mut GMutex;
}
extern "C" {
    pub fn g_mutex_free(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_new() -> *mut GCond;
}
extern "C" {
    pub fn g_cond_free(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        timeval: *mut GTimeVal,
    ) -> gboolean;
}
pub type GAsyncQueue_autoptr = *mut GAsyncQueue;
pub type GAsyncQueue_listautoptr = *mut GList;
pub type GAsyncQueue_slistautoptr = *mut GSList;
pub type GAsyncQueue_queueautoptr = *mut GQueue;
pub type GBookmarkFile_autoptr = *mut GBookmarkFile;
pub type GBookmarkFile_listautoptr = *mut GList;
pub type GBookmarkFile_slistautoptr = *mut GSList;
pub type GBookmarkFile_queueautoptr = *mut GQueue;
pub type GBytes_autoptr = *mut GBytes;
pub type GBytes_listautoptr = *mut GList;
pub type GBytes_slistautoptr = *mut GSList;
pub type GBytes_queueautoptr = *mut GQueue;
pub type GChecksum_autoptr = *mut GChecksum;
pub type GChecksum_listautoptr = *mut GList;
pub type GChecksum_slistautoptr = *mut GSList;
pub type GChecksum_queueautoptr = *mut GQueue;
pub type GDateTime_autoptr = *mut GDateTime;
pub type GDateTime_listautoptr = *mut GList;
pub type GDateTime_slistautoptr = *mut GSList;
pub type GDateTime_queueautoptr = *mut GQueue;
pub type GDate_autoptr = *mut GDate;
pub type GDate_listautoptr = *mut GList;
pub type GDate_slistautoptr = *mut GSList;
pub type GDate_queueautoptr = *mut GQueue;
pub type GDir_autoptr = *mut GDir;
pub type GDir_listautoptr = *mut GList;
pub type GDir_slistautoptr = *mut GSList;
pub type GDir_queueautoptr = *mut GQueue;
pub type GError_autoptr = *mut GError;
pub type GError_listautoptr = *mut GList;
pub type GError_slistautoptr = *mut GSList;
pub type GError_queueautoptr = *mut GQueue;
pub type GHashTable_autoptr = *mut GHashTable;
pub type GHashTable_listautoptr = *mut GList;
pub type GHashTable_slistautoptr = *mut GSList;
pub type GHashTable_queueautoptr = *mut GQueue;
pub type GHmac_autoptr = *mut GHmac;
pub type GHmac_listautoptr = *mut GList;
pub type GHmac_slistautoptr = *mut GSList;
pub type GHmac_queueautoptr = *mut GQueue;
pub type GIOChannel_autoptr = *mut GIOChannel;
pub type GIOChannel_listautoptr = *mut GList;
pub type GIOChannel_slistautoptr = *mut GSList;
pub type GIOChannel_queueautoptr = *mut GQueue;
pub type GKeyFile_autoptr = *mut GKeyFile;
pub type GKeyFile_listautoptr = *mut GList;
pub type GKeyFile_slistautoptr = *mut GSList;
pub type GKeyFile_queueautoptr = *mut GQueue;
pub type GList_autoptr = *mut GList;
pub type GList_listautoptr = *mut GList;
pub type GList_slistautoptr = *mut GSList;
pub type GList_queueautoptr = *mut GQueue;
pub type GArray_autoptr = *mut GArray;
pub type GArray_listautoptr = *mut GList;
pub type GArray_slistautoptr = *mut GSList;
pub type GArray_queueautoptr = *mut GQueue;
pub type GPtrArray_autoptr = *mut GPtrArray;
pub type GPtrArray_listautoptr = *mut GList;
pub type GPtrArray_slistautoptr = *mut GSList;
pub type GPtrArray_queueautoptr = *mut GQueue;
pub type GByteArray_autoptr = *mut GByteArray;
pub type GByteArray_listautoptr = *mut GList;
pub type GByteArray_slistautoptr = *mut GSList;
pub type GByteArray_queueautoptr = *mut GQueue;
pub type GMainContext_autoptr = *mut GMainContext;
pub type GMainContext_listautoptr = *mut GList;
pub type GMainContext_slistautoptr = *mut GSList;
pub type GMainContext_queueautoptr = *mut GQueue;
pub type GMainContextPusher_autoptr = *mut GMainContextPusher;
pub type GMainContextPusher_listautoptr = *mut GList;
pub type GMainContextPusher_slistautoptr = *mut GSList;
pub type GMainContextPusher_queueautoptr = *mut GQueue;
pub type GMainLoop_autoptr = *mut GMainLoop;
pub type GMainLoop_listautoptr = *mut GList;
pub type GMainLoop_slistautoptr = *mut GSList;
pub type GMainLoop_queueautoptr = *mut GQueue;
pub type GSource_autoptr = *mut GSource;
pub type GSource_listautoptr = *mut GList;
pub type GSource_slistautoptr = *mut GSList;
pub type GSource_queueautoptr = *mut GQueue;
pub type GMappedFile_autoptr = *mut GMappedFile;
pub type GMappedFile_listautoptr = *mut GList;
pub type GMappedFile_slistautoptr = *mut GSList;
pub type GMappedFile_queueautoptr = *mut GQueue;
pub type GMarkupParseContext_autoptr = *mut GMarkupParseContext;
pub type GMarkupParseContext_listautoptr = *mut GList;
pub type GMarkupParseContext_slistautoptr = *mut GSList;
pub type GMarkupParseContext_queueautoptr = *mut GQueue;
pub type GNode_autoptr = *mut GNode;
pub type GNode_listautoptr = *mut GList;
pub type GNode_slistautoptr = *mut GSList;
pub type GNode_queueautoptr = *mut GQueue;
pub type GOptionContext_autoptr = *mut GOptionContext;
pub type GOptionContext_listautoptr = *mut GList;
pub type GOptionContext_slistautoptr = *mut GSList;
pub type GOptionContext_queueautoptr = *mut GQueue;
pub type GOptionGroup_autoptr = *mut GOptionGroup;
pub type GOptionGroup_listautoptr = *mut GList;
pub type GOptionGroup_slistautoptr = *mut GSList;
pub type GOptionGroup_queueautoptr = *mut GQueue;
pub type GPatternSpec_autoptr = *mut GPatternSpec;
pub type GPatternSpec_listautoptr = *mut GList;
pub type GPatternSpec_slistautoptr = *mut GSList;
pub type GPatternSpec_queueautoptr = *mut GQueue;
pub type GQueue_autoptr = *mut GQueue;
pub type GQueue_listautoptr = *mut GList;
pub type GQueue_slistautoptr = *mut GSList;
pub type GQueue_queueautoptr = *mut GQueue;
pub type GRand_autoptr = *mut GRand;
pub type GRand_listautoptr = *mut GList;
pub type GRand_slistautoptr = *mut GSList;
pub type GRand_queueautoptr = *mut GQueue;
pub type GRegex_autoptr = *mut GRegex;
pub type GRegex_listautoptr = *mut GList;
pub type GRegex_slistautoptr = *mut GSList;
pub type GRegex_queueautoptr = *mut GQueue;
pub type GMatchInfo_autoptr = *mut GMatchInfo;
pub type GMatchInfo_listautoptr = *mut GList;
pub type GMatchInfo_slistautoptr = *mut GSList;
pub type GMatchInfo_queueautoptr = *mut GQueue;
pub type GScanner_autoptr = *mut GScanner;
pub type GScanner_listautoptr = *mut GList;
pub type GScanner_slistautoptr = *mut GSList;
pub type GScanner_queueautoptr = *mut GQueue;
pub type GSequence_autoptr = *mut GSequence;
pub type GSequence_listautoptr = *mut GList;
pub type GSequence_slistautoptr = *mut GSList;
pub type GSequence_queueautoptr = *mut GQueue;
pub type GSList_autoptr = *mut GSList;
pub type GSList_listautoptr = *mut GList;
pub type GSList_slistautoptr = *mut GSList;
pub type GSList_queueautoptr = *mut GQueue;
pub type GString_autoptr = *mut GString;
pub type GString_listautoptr = *mut GList;
pub type GString_slistautoptr = *mut GSList;
pub type GString_queueautoptr = *mut GQueue;
pub type GStringChunk_autoptr = *mut GStringChunk;
pub type GStringChunk_listautoptr = *mut GList;
pub type GStringChunk_slistautoptr = *mut GSList;
pub type GStringChunk_queueautoptr = *mut GQueue;
pub type GStrvBuilder_autoptr = *mut GStrvBuilder;
pub type GStrvBuilder_listautoptr = *mut GList;
pub type GStrvBuilder_slistautoptr = *mut GSList;
pub type GStrvBuilder_queueautoptr = *mut GQueue;
pub type GThread_autoptr = *mut GThread;
pub type GThread_listautoptr = *mut GList;
pub type GThread_slistautoptr = *mut GSList;
pub type GThread_queueautoptr = *mut GQueue;
pub type GMutexLocker_autoptr = *mut GMutexLocker;
pub type GMutexLocker_listautoptr = *mut GList;
pub type GMutexLocker_slistautoptr = *mut GSList;
pub type GMutexLocker_queueautoptr = *mut GQueue;
pub type GRecMutexLocker_autoptr = *mut GRecMutexLocker;
pub type GRecMutexLocker_listautoptr = *mut GList;
pub type GRecMutexLocker_slistautoptr = *mut GSList;
pub type GRecMutexLocker_queueautoptr = *mut GQueue;
pub type GRWLockWriterLocker_autoptr = *mut GRWLockWriterLocker;
pub type GRWLockWriterLocker_listautoptr = *mut GList;
pub type GRWLockWriterLocker_slistautoptr = *mut GSList;
pub type GRWLockWriterLocker_queueautoptr = *mut GQueue;
pub type GRWLockReaderLocker_autoptr = *mut GRWLockReaderLocker;
pub type GRWLockReaderLocker_listautoptr = *mut GList;
pub type GRWLockReaderLocker_slistautoptr = *mut GSList;
pub type GRWLockReaderLocker_queueautoptr = *mut GQueue;
pub type GTimer_autoptr = *mut GTimer;
pub type GTimer_listautoptr = *mut GList;
pub type GTimer_slistautoptr = *mut GSList;
pub type GTimer_queueautoptr = *mut GQueue;
pub type GTimeZone_autoptr = *mut GTimeZone;
pub type GTimeZone_listautoptr = *mut GList;
pub type GTimeZone_slistautoptr = *mut GSList;
pub type GTimeZone_queueautoptr = *mut GQueue;
pub type GTree_autoptr = *mut GTree;
pub type GTree_listautoptr = *mut GList;
pub type GTree_slistautoptr = *mut GSList;
pub type GTree_queueautoptr = *mut GQueue;
pub type GVariant_autoptr = *mut GVariant;
pub type GVariant_listautoptr = *mut GList;
pub type GVariant_slistautoptr = *mut GSList;
pub type GVariant_queueautoptr = *mut GQueue;
pub type GVariantBuilder_autoptr = *mut GVariantBuilder;
pub type GVariantBuilder_listautoptr = *mut GList;
pub type GVariantBuilder_slistautoptr = *mut GSList;
pub type GVariantBuilder_queueautoptr = *mut GQueue;
pub type GVariantIter_autoptr = *mut GVariantIter;
pub type GVariantIter_listautoptr = *mut GList;
pub type GVariantIter_slistautoptr = *mut GSList;
pub type GVariantIter_queueautoptr = *mut GQueue;
pub type GVariantDict_autoptr = *mut GVariantDict;
pub type GVariantDict_listautoptr = *mut GList;
pub type GVariantDict_slistautoptr = *mut GSList;
pub type GVariantDict_queueautoptr = *mut GQueue;
pub type GVariantType_autoptr = *mut GVariantType;
pub type GVariantType_listautoptr = *mut GList;
pub type GVariantType_slistautoptr = *mut GSList;
pub type GVariantType_queueautoptr = *mut GQueue;
pub type GRefString_autoptr = *mut GRefString;
pub type GRefString_listautoptr = *mut GList;
pub type GRefString_slistautoptr = *mut GSList;
pub type GRefString_queueautoptr = *mut GQueue;
pub type GUri_autoptr = *mut GUri;
pub type GUri_listautoptr = *mut GList;
pub type GUri_slistautoptr = *mut GSList;
pub type GUri_queueautoptr = *mut GQueue;
pub type GPathBuf_autoptr = *mut GPathBuf;
pub type GPathBuf_listautoptr = *mut GList;
pub type GPathBuf_slistautoptr = *mut GSList;
pub type GPathBuf_queueautoptr = *mut GQueue;
extern "C" {
    #[doc = " ibus_get_local_machine_id:\n\n Obtains the machine UUID of the machine this process is running on.\n\n Returns: A newly allocated string that shows the UUID of the machine."]
    pub fn ibus_get_local_machine_id() -> *const gchar;
}
extern "C" {
    #[doc = " ibus_set_display:\n @display: Display address, as in DISPLAY environment for X.\n\n Set the display address."]
    pub fn ibus_set_display(display: *const gchar);
}
extern "C" {
    #[doc = " ibus_get_address:\n\n Return the D-Bus address of IBus.\n It will find the address from following source:\n <orderedlist>\n    <listitem><para>Environment variable IBUS_ADDRESS</para></listitem>\n    <listitem><para>Socket file under ~/.config/ibus/bus/</para></listitem>\n </orderedlist>\n\n Returns: D-Bus address of IBus. %NULL for not found.\n\n See also: ibus_write_address()."]
    pub fn ibus_get_address() -> *const gchar;
}
extern "C" {
    #[doc = " ibus_write_address:\n @address: D-Bus address of IBus.\n\n Write D-Bus address to socket file.\n\n See also: ibus_get_address()."]
    pub fn ibus_write_address(address: *const gchar);
}
extern "C" {
    #[doc = " ibus_get_user_name:\n\n Get the current user name.\n It is determined by:\n <orderedlist>\n    <listitem><para>getlogin()</para></listitem>\n    <listitem><para>Environment variable SUDO_USER</para></listitem>\n    <listitem><para>Environment variable USERHELPER_UID</para></listitem>\n    <listitem><para>Environment variable USERNAME</para></listitem>\n    <listitem><para>Environment variable LOGNAME</para></listitem>\n    <listitem><para>Environment variable USER</para></listitem>\n    <listitem><para>Environment variable LNAME</para></listitem>\n </orderedlist>\n\n Returns: A newly allocated string that stores current user name."]
    pub fn ibus_get_user_name() -> *const gchar;
}
extern "C" {
    #[doc = " ibus_get_daemon_uid:\n\n Get UID of ibus-daemon.\n\n Returns: UID of ibus-daemon; or 0 if UID is not available.\n\n Deprecated: This function has been deprecated and should\n not be used in newly written code."]
    pub fn ibus_get_daemon_uid() -> glong;
}
extern "C" {
    #[doc = " ibus_get_socket_path:\n\n Get the path of socket file.\n\n Returns: A newly allocated string that stores the path of socket file."]
    pub fn ibus_get_socket_path() -> *const gchar;
}
extern "C" {
    #[doc = " ibus_get_timeout:\n\n Get the GDBus timeout in milliseconds. The timeout is for clients (e.g.\n im-ibus.so), not for ibus-daemon.\n Note that the timeout for ibus-daemon could be set by --timeout command\n line option of the daemon.\n\n Returns: A GDBus timeout in milliseconds. -1 when default timeout for\n     GDBus should be used."]
    pub fn ibus_get_timeout() -> gint;
}
extern "C" {
    #[doc = " ibus_free_strv:\n @strv: List of strings.\n\n Free a list of strings.\n Deprecated: This function has been deprecated and should\n not be used in newly written code."]
    pub fn ibus_free_strv(strv: *mut *mut gchar);
}
extern "C" {
    #[doc = " ibus_key_event_to_string:\n @keyval: Key symbol.\n @modifiers: Modifiers such as Ctrl or Shift.\n\n Return the name of a key symbol and modifiers.\n\n For example, if press ctrl, shift, and enter, then this function returns:\n Shift+Control+enter.\n\n Returns: The name of a key symbol and modifier."]
    pub fn ibus_key_event_to_string(keyval: guint, modifiers: guint) -> *mut gchar;
}
extern "C" {
    #[doc = " ibus_key_event_from_string:\n @string: Key event string.\n @keyval: (out): Variable that hold key symbol result.\n @modifiers: (out): Variable that hold modifiers result.\n\n Parse key event string and return key symbol and modifiers.\n\n Returns: %TRUE for succeed; %FALSE if failed."]
    pub fn ibus_key_event_from_string(
        string: *const gchar,
        keyval: *mut guint,
        modifiers: *mut guint,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_init:\n\n Initialize the ibus types."]
    pub fn ibus_init();
}
extern "C" {
    #[doc = " ibus_main:\n\n Runs an IBus main loop until ibus_quit() is called in the loop.\n\n See also: ibus_quit()."]
    pub fn ibus_main();
}
extern "C" {
    #[doc = " ibus_quit:\n\n Stops an IBus from running.\n\n Any calls to ibus_quit() for the loop will return.\n See also: ibus_main()."]
    pub fn ibus_quit();
}
extern "C" {
    #[doc = " ibus_set_log_handler:\n @verbose: TRUE for verbose logging.\n\n Sets GLIB's log handler to ours. Our log handler adds time info\n including hour, minute, second, and microsecond, like:\n\n (ibus-daemon:7088): IBUS-DEBUG: 18:06:45.822819: ibus-daemon started\n\n If @verbose is %TRUE, all levels of messages will be logged. Otherwise,\n DEBUG and WARNING messages will be ignored.  The function is used in\n ibus-daemon, but can be useful for IBus client programs as well for\n debugging. It's totally fine for not calling this function. If you\n don't set a custom GLIB log handler, the default GLIB log handler will\n be used."]
    pub fn ibus_set_log_handler(verbose: gboolean);
}
extern "C" {
    #[doc = " ibus_unset_log_handler:\n\n Remove the log handler which is set by ibus_set_log_handler."]
    pub fn ibus_unset_log_handler();
}
pub type GType = gsize;
#[doc = " GValue:\n\n An opaque structure used to hold different types of values.\n\n The data within the structure has protected scope: it is accessible only\n to functions within a #GTypeValueTable structure, or implementations of\n the g_value_*() API. That is, code portions which implement new fundamental\n types.\n\n #GValue users cannot make any assumptions about how data is stored\n within the 2 element @data union, and the @g_type member should\n only be accessed through the G_VALUE_TYPE() macro."]
pub type GValue = _GValue;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GTypeCValue {
    _unused: [u8; 0],
}
pub type GTypeCValue = _GTypeCValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePlugin {
    _unused: [u8; 0],
}
pub type GTypePlugin = _GTypePlugin;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
pub type GTypeClass = _GTypeClass;
#[doc = " GTypeInterface:\n\n An opaque structure used as the base of all interface types."]
pub type GTypeInterface = _GTypeInterface;
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
pub type GTypeInstance = _GTypeInstance;
#[doc = " GTypeInfo:\n @class_size: Size of the class structure (required for interface, classed and instantiatable types)\n @base_init: Location of the base initialization function (optional)\n @base_finalize: Location of the base finalization function (optional)\n @class_init: Location of the class initialization function for\n  classed and instantiatable types. Location of the default vtable\n  inititalization function for interface types. (optional) This function\n  is used both to fill in virtual functions in the class or default vtable,\n  and to do type-specific setup such as registering signals and object\n  properties.\n @class_finalize: Location of the class finalization function for\n  classed and instantiatable types. Location of the default vtable\n  finalization function for interface types. (optional)\n @class_data: User-supplied data passed to the class init/finalize functions\n @instance_size: Size of the instance (object) structure (required for instantiatable types only)\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10 this field is ignored.\n @instance_init: Location of the instance initialization function (optional, for instantiatable types only)\n @value_table: A #GTypeValueTable function table for generic handling of GValues\n  of this type (usually only useful for fundamental types)\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a type's class and\n its instances.\n\n The initialized structure is passed to the g_type_register_static() function\n (or is copied into the provided #GTypeInfo structure in the\n g_type_plugin_complete_type_info()). The type system will perform a deep\n copy of this structure, so its memory does not need to be persistent\n across invocation of g_type_register_static()."]
pub type GTypeInfo = _GTypeInfo;
#[doc = " GTypeFundamentalInfo:\n @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type\n\n A structure that provides information to the type system which is\n used specifically for managing fundamental types."]
pub type GTypeFundamentalInfo = _GTypeFundamentalInfo;
#[doc = " GInterfaceInfo:\n @interface_init: location of the interface initialization function\n @interface_finalize: location of the interface finalization function\n @interface_data: user-supplied data passed to the interface init/finalize functions\n\n A structure that provides information to the type system which is\n used specifically for managing interface types."]
pub type GInterfaceInfo = _GInterfaceInfo;
#[doc = " GTypeValueTable:\n @value_init: Default initialize @values contents by poking values\n  directly into the value->data array. The data array of\n  the #GValue passed into this function was zero-filled\n  with `memset()`, so no care has to be taken to free any\n  old contents. E.g. for the implementation of a string\n  value that may never be %NULL, the implementation might\n  look like:\n  |[<!-- language=\"C\" -->\n  value->data[0].v_pointer = g_strdup (\"\");\n  ]|\n @value_free: Free any old contents that might be left in the\n  data array of the passed in @value. No resources may\n  remain allocated through the #GValue contents after\n  this function returns. E.g. for our above string type:\n  |[<!-- language=\"C\" -->\n  // only free strings without a specific flag for static storage\n  if (!(value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS))\n    g_free (value->data[0].v_pointer);\n  ]|\n @value_copy: @dest_value is a #GValue with zero-filled data section\n  and @src_value is a properly setup #GValue of same or\n  derived type.\n  The purpose of this function is to copy the contents of\n  @src_value into @dest_value in a way, that even after\n  @src_value has been freed, the contents of @dest_value\n  remain valid. String type example:\n  |[<!-- language=\"C\" -->\n  dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);\n  ]|\n @value_peek_pointer: If the value contents fit into a pointer, such as objects\n  or strings, return this pointer, so the caller can peek at\n  the current contents. To extend on our above string example:\n  |[<!-- language=\"C\" -->\n  return value->data[0].v_pointer;\n  ]|\n @collect_format: A string format describing how to collect the contents of\n  this value bit-by-bit. Each character in the format represents\n  an argument to be collected, and the characters themselves indicate\n  the type of the argument. Currently supported arguments are:\n  - 'i' - Integers. passed as collect_values[].v_int.\n  - 'l' - Longs. passed as collect_values[].v_long.\n  - 'd' - Doubles. passed as collect_values[].v_double.\n  - 'p' - Pointers. passed as collect_values[].v_pointer.\n  It should be noted that for variable argument list construction,\n  ANSI C promotes every type smaller than an integer to an int, and\n  floats to doubles. So for collection of short int or char, 'i'\n  needs to be used, and for collection of floats 'd'.\n @collect_value: The collect_value() function is responsible for converting the\n  values collected from a variable argument list into contents\n  suitable for storage in a GValue. This function should setup\n  @value similar to value_init(); e.g. for a string value that\n  does not allow %NULL pointers, it needs to either spew an error,\n  or do an implicit conversion by storing an empty string.\n  The @value passed in to this function has a zero-filled data\n  array, so just like for value_init() it is guaranteed to not\n  contain any old contents that might need freeing.\n  @n_collect_values is exactly the string length of @collect_format,\n  and @collect_values is an array of unions #GTypeCValue with\n  length @n_collect_values, containing the collected values\n  according to @collect_format.\n  @collect_flags is an argument provided as a hint by the caller.\n  It may contain the flag %G_VALUE_NOCOPY_CONTENTS indicating,\n  that the collected value contents may be considered \"static\"\n  for the duration of the @value lifetime.\n  Thus an extra copy of the contents stored in @collect_values is\n  not required for assignment to @value.\n  For our above string example, we continue with:\n  |[<!-- language=\"C\" -->\n  if (!collect_values[0].v_pointer)\n    value->data[0].v_pointer = g_strdup (\"\");\n  else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)\n  {\n    value->data[0].v_pointer = collect_values[0].v_pointer;\n    // keep a flag for the value_free() implementation to not free this string\n    value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;\n  }\n  else\n    value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);\n  return NULL;\n  ]|\n  It should be noted, that it is generally a bad idea to follow the\n  %G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to\n  reentrancy requirements and reference count assertions performed\n  by the signal emission code, reference counts should always be\n  incremented for reference counted contents stored in the value->data\n  array.  To deviate from our string example for a moment, and taking\n  a look at an exemplary implementation for collect_value() of\n  #GObject:\n  |[<!-- language=\"C\" -->\n    GObject *object = G_OBJECT (collect_values[0].v_pointer);\n    g_return_val_if_fail (object != NULL,\n       g_strdup_printf (\"Object passed as invalid NULL pointer\"));\n    // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types\n    value->data[0].v_pointer = g_object_ref (object);\n    return NULL;\n  ]|\n  The reference count for valid objects is always incremented,\n  regardless of @collect_flags. For invalid objects, the example\n  returns a newly allocated string without altering @value.\n  Upon success, collect_value() needs to return %NULL. If, however,\n  an error condition occurred, collect_value() may spew an\n  error by returning a newly allocated non-%NULL string, giving\n  a suitable description of the error condition.\n  The calling code makes no assumptions about the @value\n  contents being valid upon error returns, @value\n  is simply thrown away without further freeing. As such, it is\n  a good idea to not allocate #GValue contents, prior to returning\n  an error, however, collect_values() is not obliged to return\n  a correctly setup @value for error returns, simply because\n  any non-%NULL return is considered a fatal condition so further\n  program behaviour is undefined.\n @lcopy_format: Format description of the arguments to collect for @lcopy_value,\n  analogous to @collect_format. Usually, @lcopy_format string consists\n  only of 'p's to provide lcopy_value() with pointers to storage locations.\n @lcopy_value: This function is responsible for storing the @value contents into\n  arguments passed through a variable argument list which got\n  collected into @collect_values according to @lcopy_format.\n  @n_collect_values equals the string length of @lcopy_format,\n  and @collect_flags may contain %G_VALUE_NOCOPY_CONTENTS.\n  In contrast to collect_value(), lcopy_value() is obliged to\n  always properly support %G_VALUE_NOCOPY_CONTENTS.\n  Similar to collect_value() the function may prematurely abort\n  by returning a newly allocated string describing an error condition.\n  To complete the string example:\n  |[<!-- language=\"C\" -->\n  gchar **string_p = collect_values[0].v_pointer;\n  g_return_val_if_fail (string_p != NULL,\n      g_strdup_printf (\"string location passed as NULL\"));\n  if (collect_flags & G_VALUE_NOCOPY_CONTENTS)\n    *string_p = value->data[0].v_pointer;\n  else\n    *string_p = g_strdup (value->data[0].v_pointer);\n  ]|\n  And an illustrative version of lcopy_value() for\n  reference-counted types:\n  |[<!-- language=\"C\" -->\n  GObject **object_p = collect_values[0].v_pointer;\n  g_return_val_if_fail (object_p != NULL,\n    g_strdup_printf (\"object location passed as NULL\"));\n  if (!value->data[0].v_pointer)\n    *object_p = NULL;\n  else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) // always honour\n    *object_p = value->data[0].v_pointer;\n  else\n    *object_p = g_object_ref (value->data[0].v_pointer);\n  return NULL;\n  ]|\n\n The #GTypeValueTable provides the functions required by the #GValue\n implementation, to serve as a container for values of a type."]
pub type GTypeValueTable = _GTypeValueTable;
#[doc = " GTypeQuery:\n @type: the #GType value of the type\n @type_name: the name of the type\n @class_size: the size of the class structure\n @instance_size: the size of the instance structure\n\n A structure holding information for a specific type.\n\n See also: g_type_query()"]
pub type GTypeQuery = _GTypeQuery;
#[doc = " GTypeClass:\n\n An opaque structure used as the base of all classes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeClass>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeClass),
            "::",
            stringify!(g_type)
        )
    );
}
#[doc = " GTypeInstance:\n\n An opaque structure used as the base of all type instances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[test]
fn bindgen_test_layout__GTypeInstance() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeInstance> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeInstance>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInstance),
            "::",
            stringify!(g_class)
        )
    );
}
#[doc = " GTypeInterface:\n\n An opaque structure used as the base of all interface types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInterface {
    pub g_type: GType,
    pub g_instance_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GTypeInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInterface),
            "::",
            stringify!(g_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_instance_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInterface),
            "::",
            stringify!(g_instance_type)
        )
    );
}
#[doc = " GTypeQuery:\n @type: the #GType value of the type\n @type_name: the name of the type\n @class_size: the size of the class structure\n @instance_size: the size of the instance structure\n\n A structure holding information for a specific type.\n\n See also: g_type_query()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeQuery {
    pub type_: GType,
    pub type_name: *const gchar,
    pub class_size: guint,
    pub instance_size: guint,
}
#[test]
fn bindgen_test_layout__GTypeQuery() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeQuery> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeQuery>(),
        24usize,
        concat!("Size of: ", stringify!(_GTypeQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeQuery))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(class_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_size) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(instance_size)
        )
    );
}
pub const GTypeDebugFlags_G_TYPE_DEBUG_NONE: GTypeDebugFlags = 0;
pub const GTypeDebugFlags_G_TYPE_DEBUG_OBJECTS: GTypeDebugFlags = 1;
pub const GTypeDebugFlags_G_TYPE_DEBUG_SIGNALS: GTypeDebugFlags = 2;
pub const GTypeDebugFlags_G_TYPE_DEBUG_INSTANCE_COUNT: GTypeDebugFlags = 4;
pub const GTypeDebugFlags_G_TYPE_DEBUG_MASK: GTypeDebugFlags = 7;
#[doc = " GTypeDebugFlags:\n @G_TYPE_DEBUG_NONE: Print no messages\n @G_TYPE_DEBUG_OBJECTS: Print messages about object bookkeeping\n @G_TYPE_DEBUG_SIGNALS: Print messages about signal emissions\n @G_TYPE_DEBUG_MASK: Mask covering all debug flags\n @G_TYPE_DEBUG_INSTANCE_COUNT: Keep a count of instances of each type\n\n These flags used to be passed to g_type_init_with_debug_flags() which\n is now deprecated.\n\n If you need to enable debugging features, use the GOBJECT_DEBUG\n environment variable.\n\n Deprecated: 2.36: g_type_init() is now done automatically"]
pub type GTypeDebugFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_type_init();
}
extern "C" {
    pub fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags);
}
extern "C" {
    pub fn g_type_name(type_: GType) -> *const gchar;
}
extern "C" {
    pub fn g_type_qname(type_: GType) -> GQuark;
}
extern "C" {
    pub fn g_type_from_name(name: *const gchar) -> GType;
}
extern "C" {
    pub fn g_type_parent(type_: GType) -> GType;
}
extern "C" {
    pub fn g_type_depth(type_: GType) -> guint;
}
extern "C" {
    pub fn g_type_next_base(leaf_type: GType, root_type: GType) -> GType;
}
extern "C" {
    pub fn g_type_is_a(type_: GType, is_a_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_class_ref(type_: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_peek(type_: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_peek_static(type_: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_unref(g_class: gpointer);
}
extern "C" {
    pub fn g_type_class_peek_parent(g_class: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_interface_peek_parent(g_iface: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_type_default_interface_ref(g_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_default_interface_peek(g_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_default_interface_unref(g_iface: gpointer);
}
extern "C" {
    pub fn g_type_children(type_: GType, n_children: *mut guint) -> *mut GType;
}
extern "C" {
    pub fn g_type_interfaces(type_: GType, n_interfaces: *mut guint) -> *mut GType;
}
extern "C" {
    pub fn g_type_set_qdata(type_: GType, quark: GQuark, data: gpointer);
}
extern "C" {
    pub fn g_type_get_qdata(type_: GType, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_type_query(type_: GType, query: *mut GTypeQuery);
}
extern "C" {
    pub fn g_type_get_instance_count(type_: GType) -> ::std::os::raw::c_int;
}
#[doc = " GBaseInitFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize\n\n A callback function used by the type system to do base initialization\n of the class structures of derived types.\n\n This function is called as part of the initialization process of all derived\n classes and should reallocate or reset all dynamic class members copied over\n from the parent class.\n\n For example, class members (such as strings) that are not sufficiently\n handled by a plain memory copy of the parent class into the derived class\n have to be altered. See GClassInitFunc() for a discussion of the class\n initialization process."]
pub type GBaseInitFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
#[doc = " GBaseFinalizeFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize\n\n A callback function used by the type system to finalize those portions\n of a derived types class structure that were setup from the corresponding\n GBaseInitFunc() function.\n\n Class finalization basically works the inverse way in which class\n initialization is performed.\n\n See GClassInitFunc() for a discussion of the class initialization process."]
pub type GBaseFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
#[doc = " GClassInitFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize.\n @class_data: The @class_data member supplied via the #GTypeInfo structure.\n\n A callback function used by the type system to initialize the class\n of a specific type.\n\n This function should initialize all static class members.\n\n The initialization process of a class involves:\n\n - Copying common members from the parent class over to the\n   derived class structure.\n - Zero initialization of the remaining members not copied\n   over from the parent class.\n - Invocation of the GBaseInitFunc() initializers of all parent\n   types and the class' type.\n - Invocation of the class' GClassInitFunc() initializer.\n\n Since derived classes are partially initialized through a memory copy\n of the parent class, the general rule is that GBaseInitFunc() and\n GBaseFinalizeFunc() should take care of necessary reinitialization\n and release of those class members that were introduced by the type\n that specified these GBaseInitFunc()/GBaseFinalizeFunc().\n GClassInitFunc() should only care about initializing static\n class members, while dynamic class members (such as allocated strings\n or reference counted resources) are better handled by a GBaseInitFunc()\n for this type, so proper initialization of the dynamic class members\n is performed for class initialization of derived types as well.\n\n An example may help to correspond the intend of the different class\n initializers:\n\n |[<!-- language=\"C\" -->\n typedef struct {\n   GObjectClass parent_class;\n   gint         static_integer;\n   gchar       *dynamic_string;\n } TypeAClass;\n static void\n type_a_base_class_init (TypeAClass *class)\n {\n   class->dynamic_string = g_strdup (\"some string\");\n }\n static void\n type_a_base_class_finalize (TypeAClass *class)\n {\n   g_free (class->dynamic_string);\n }\n static void\n type_a_class_init (TypeAClass *class)\n {\n   class->static_integer = 42;\n }\n\n typedef struct {\n   TypeAClass   parent_class;\n   gfloat       static_float;\n   GString     *dynamic_gstring;\n } TypeBClass;\n static void\n type_b_base_class_init (TypeBClass *class)\n {\n   class->dynamic_gstring = g_string_new (\"some other string\");\n }\n static void\n type_b_base_class_finalize (TypeBClass *class)\n {\n   g_string_free (class->dynamic_gstring);\n }\n static void\n type_b_class_init (TypeBClass *class)\n {\n   class->static_float = 3.14159265358979323846;\n }\n ]|\n\n Initialization of TypeBClass will first cause initialization of\n TypeAClass (derived classes reference their parent classes, see\n g_type_class_ref() on this).\n\n Initialization of TypeAClass roughly involves zero-initializing its fields,\n then calling its GBaseInitFunc() type_a_base_class_init() to allocate\n its dynamic members (dynamic_string), and finally calling its GClassInitFunc()\n type_a_class_init() to initialize its static members (static_integer).\n The first step in the initialization process of TypeBClass is then\n a plain memory copy of the contents of TypeAClass into TypeBClass and\n zero-initialization of the remaining fields in TypeBClass.\n The dynamic members of TypeAClass within TypeBClass now need\n reinitialization which is performed by calling type_a_base_class_init()\n with an argument of TypeBClass.\n\n After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()\n is called to allocate the dynamic members of TypeBClass (dynamic_gstring),\n and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),\n is called to complete the initialization process with the static members\n (static_float).\n\n Corresponding finalization counter parts to the GBaseInitFunc() functions\n have to be provided to release allocated resources at class finalization\n time."]
pub type GClassInitFunc =
    ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
#[doc = " GClassFinalizeFunc:\n @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize\n @class_data: The @class_data member supplied via the #GTypeInfo structure\n\n A callback function used by the type system to finalize a class.\n\n This function is rarely needed, as dynamically allocated class resources\n should be handled by GBaseInitFunc() and GBaseFinalizeFunc().\n\n Also, specification of a GClassFinalizeFunc() in the #GTypeInfo\n structure of a static type is invalid, because classes of static types\n will never be finalized (they are artificially kept alive when their\n reference count drops to zero)."]
pub type GClassFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
#[doc = " GInstanceInitFunc:\n @instance: The instance to initialize\n @g_class: (type GObject.TypeClass): The class of the type the instance is\n    created for\n\n A callback function used by the type system to initialize a new\n instance of a type.\n\n This function initializes all instance members and allocates any resources\n required by it.\n\n Initialization of a derived instance involves calling all its parent\n types instance initializers, so the class member of the instance\n is altered during its initialization to always point to the class that\n belongs to the type the current initializer was introduced for.\n\n The extended members of @instance are guaranteed to have been filled with\n zeros before this function is called."]
pub type GInstanceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(instance: *mut GTypeInstance, g_class: gpointer)>;
#[doc = " GInterfaceInitFunc:\n @g_iface: (type GObject.TypeInterface): The interface structure to initialize\n @iface_data: The @interface_data supplied via the #GInterfaceInfo structure\n\n A callback function used by the type system to initialize a new\n interface.\n\n This function should initialize all internal data and* allocate any\n resources required by the interface.\n\n The members of @iface_data are guaranteed to have been filled with\n zeros before this function is called."]
pub type GInterfaceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
#[doc = " GInterfaceFinalizeFunc:\n @g_iface: (type GObject.TypeInterface): The interface structure to finalize\n @iface_data: The @interface_data supplied via the #GInterfaceInfo structure\n\n A callback function used by the type system to finalize an interface.\n\n This function should destroy any internal data and release any resources\n allocated by the corresponding GInterfaceInitFunc() function."]
pub type GInterfaceFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
#[doc = " GTypeClassCacheFunc:\n @cache_data: data that was given to the g_type_add_class_cache_func() call\n @g_class: (type GObject.TypeClass): The #GTypeClass structure which is\n    unreferenced\n\n A callback function which is called when the reference count of a class\n drops to zero.\n\n It may use g_type_class_ref() to prevent the class from being freed. You\n should not call g_type_class_unref() from a #GTypeClassCacheFunc function\n to prevent infinite recursion, use g_type_class_unref_uncached() instead.\n\n The functions have to check the class id passed in to figure\n whether they actually want to cache the class of this type, since all\n classes are routed through the same #GTypeClassCacheFunc chain.\n\n Returns: %TRUE to stop further #GTypeClassCacheFuncs from being\n  called, %FALSE to continue"]
pub type GTypeClassCacheFunc = ::std::option::Option<
    unsafe extern "C" fn(cache_data: gpointer, g_class: *mut GTypeClass) -> gboolean,
>;
#[doc = " GTypeInterfaceCheckFunc:\n @check_data: data passed to g_type_add_interface_check()\n @g_iface: (type GObject.TypeInterface): the interface that has been\n    initialized\n\n A callback called after an interface vtable is initialized.\n\n See g_type_add_interface_check().\n\n Since: 2.4"]
pub type GTypeInterfaceCheckFunc =
    ::std::option::Option<unsafe extern "C" fn(check_data: gpointer, g_iface: gpointer)>;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_CLASSED: GTypeFundamentalFlags = 1;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_INSTANTIATABLE: GTypeFundamentalFlags = 2;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_DERIVABLE: GTypeFundamentalFlags = 4;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_DEEP_DERIVABLE: GTypeFundamentalFlags = 8;
#[doc = " GTypeFundamentalFlags:\n @G_TYPE_FLAG_CLASSED: Indicates a classed type\n @G_TYPE_FLAG_INSTANTIATABLE: Indicates an instantiatable type (implies classed)\n @G_TYPE_FLAG_DERIVABLE: Indicates a flat derivable type\n @G_TYPE_FLAG_DEEP_DERIVABLE: Indicates a deep derivable type (implies derivable)\n\n Bit masks used to check or determine specific characteristics of a\n fundamental type."]
pub type GTypeFundamentalFlags = ::std::os::raw::c_uint;
pub const GTypeFlags_G_TYPE_FLAG_NONE: GTypeFlags = 0;
pub const GTypeFlags_G_TYPE_FLAG_ABSTRACT: GTypeFlags = 16;
pub const GTypeFlags_G_TYPE_FLAG_VALUE_ABSTRACT: GTypeFlags = 32;
pub const GTypeFlags_G_TYPE_FLAG_FINAL: GTypeFlags = 64;
pub const GTypeFlags_G_TYPE_FLAG_DEPRECATED: GTypeFlags = 128;
#[doc = " GTypeFlags:\n @G_TYPE_FLAG_NONE: No special flags. Since: 2.74\n @G_TYPE_FLAG_ABSTRACT: Indicates an abstract type. No instances can be\n  created for an abstract type\n @G_TYPE_FLAG_VALUE_ABSTRACT: Indicates an abstract value type, i.e. a type\n  that introduces a value table, but can't be used for\n  g_value_init()\n @G_TYPE_FLAG_FINAL: Indicates a final type. A final type is a non-derivable\n  leaf node in a deep derivable type hierarchy tree. Since: 2.70\n @G_TYPE_FLAG_DEPRECATED: The type is deprecated and may be removed in a\n  future version. A warning will be emitted if it is instantiated while\n  running with `G_ENABLE_DIAGNOSTIC=1`. Since 2.76\n\n Bit masks used to check or determine characteristics of a type."]
pub type GTypeFlags = ::std::os::raw::c_uint;
#[doc = " GTypeInfo:\n @class_size: Size of the class structure (required for interface, classed and instantiatable types)\n @base_init: Location of the base initialization function (optional)\n @base_finalize: Location of the base finalization function (optional)\n @class_init: Location of the class initialization function for\n  classed and instantiatable types. Location of the default vtable\n  inititalization function for interface types. (optional) This function\n  is used both to fill in virtual functions in the class or default vtable,\n  and to do type-specific setup such as registering signals and object\n  properties.\n @class_finalize: Location of the class finalization function for\n  classed and instantiatable types. Location of the default vtable\n  finalization function for interface types. (optional)\n @class_data: User-supplied data passed to the class init/finalize functions\n @instance_size: Size of the instance (object) structure (required for instantiatable types only)\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10 this field is ignored.\n @instance_init: Location of the instance initialization function (optional, for instantiatable types only)\n @value_table: A #GTypeValueTable function table for generic handling of GValues\n  of this type (usually only useful for fundamental types)\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a type's class and\n its instances.\n\n The initialized structure is passed to the g_type_register_static() function\n (or is copied into the provided #GTypeInfo structure in the\n g_type_plugin_complete_type_info()). The type system will perform a deep\n copy of this structure, so its memory does not need to be persistent\n across invocation of g_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInfo {
    pub class_size: guint16,
    pub base_init: GBaseInitFunc,
    pub base_finalize: GBaseFinalizeFunc,
    pub class_init: GClassInitFunc,
    pub class_finalize: GClassFinalizeFunc,
    pub class_data: gconstpointer,
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: GInstanceInitFunc,
    pub value_table: *const GTypeValueTable,
}
#[test]
fn bindgen_test_layout__GTypeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeInfo>(),
        72usize,
        concat!("Size of: ", stringify!(_GTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_init) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(base_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_finalize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(base_finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_init) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_finalize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).class_data) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(instance_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_preallocs) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(n_preallocs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_init) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(instance_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_table) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(value_table)
        )
    );
}
#[doc = " GTypeFundamentalInfo:\n @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type\n\n A structure that provides information to the type system which is\n used specifically for managing fundamental types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeFundamentalInfo {
    pub type_flags: GTypeFundamentalFlags,
}
#[test]
fn bindgen_test_layout__GTypeFundamentalInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeFundamentalInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeFundamentalInfo>(),
        4usize,
        concat!("Size of: ", stringify!(_GTypeFundamentalInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeFundamentalInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTypeFundamentalInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeFundamentalInfo),
            "::",
            stringify!(type_flags)
        )
    );
}
#[doc = " GInterfaceInfo:\n @interface_init: location of the interface initialization function\n @interface_finalize: location of the interface finalization function\n @interface_data: user-supplied data passed to the interface init/finalize functions\n\n A structure that provides information to the type system which is\n used specifically for managing interface types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInterfaceInfo {
    pub interface_init: GInterfaceInitFunc,
    pub interface_finalize: GInterfaceFinalizeFunc,
    pub interface_data: gpointer,
}
#[test]
fn bindgen_test_layout__GInterfaceInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GInterfaceInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInterfaceInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_GInterfaceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInterfaceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInterfaceInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_finalize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_data)
        )
    );
}
#[doc = " GTypeValueTable:\n @value_init: Default initialize @values contents by poking values\n  directly into the value->data array. The data array of\n  the #GValue passed into this function was zero-filled\n  with `memset()`, so no care has to be taken to free any\n  old contents. E.g. for the implementation of a string\n  value that may never be %NULL, the implementation might\n  look like:\n  |[<!-- language=\"C\" -->\n  value->data[0].v_pointer = g_strdup (\"\");\n  ]|\n @value_free: Free any old contents that might be left in the\n  data array of the passed in @value. No resources may\n  remain allocated through the #GValue contents after\n  this function returns. E.g. for our above string type:\n  |[<!-- language=\"C\" -->\n  // only free strings without a specific flag for static storage\n  if (!(value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS))\n    g_free (value->data[0].v_pointer);\n  ]|\n @value_copy: @dest_value is a #GValue with zero-filled data section\n  and @src_value is a properly setup #GValue of same or\n  derived type.\n  The purpose of this function is to copy the contents of\n  @src_value into @dest_value in a way, that even after\n  @src_value has been freed, the contents of @dest_value\n  remain valid. String type example:\n  |[<!-- language=\"C\" -->\n  dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);\n  ]|\n @value_peek_pointer: If the value contents fit into a pointer, such as objects\n  or strings, return this pointer, so the caller can peek at\n  the current contents. To extend on our above string example:\n  |[<!-- language=\"C\" -->\n  return value->data[0].v_pointer;\n  ]|\n @collect_format: A string format describing how to collect the contents of\n  this value bit-by-bit. Each character in the format represents\n  an argument to be collected, and the characters themselves indicate\n  the type of the argument. Currently supported arguments are:\n  - 'i' - Integers. passed as collect_values[].v_int.\n  - 'l' - Longs. passed as collect_values[].v_long.\n  - 'd' - Doubles. passed as collect_values[].v_double.\n  - 'p' - Pointers. passed as collect_values[].v_pointer.\n  It should be noted that for variable argument list construction,\n  ANSI C promotes every type smaller than an integer to an int, and\n  floats to doubles. So for collection of short int or char, 'i'\n  needs to be used, and for collection of floats 'd'.\n @collect_value: The collect_value() function is responsible for converting the\n  values collected from a variable argument list into contents\n  suitable for storage in a GValue. This function should setup\n  @value similar to value_init(); e.g. for a string value that\n  does not allow %NULL pointers, it needs to either spew an error,\n  or do an implicit conversion by storing an empty string.\n  The @value passed in to this function has a zero-filled data\n  array, so just like for value_init() it is guaranteed to not\n  contain any old contents that might need freeing.\n  @n_collect_values is exactly the string length of @collect_format,\n  and @collect_values is an array of unions #GTypeCValue with\n  length @n_collect_values, containing the collected values\n  according to @collect_format.\n  @collect_flags is an argument provided as a hint by the caller.\n  It may contain the flag %G_VALUE_NOCOPY_CONTENTS indicating,\n  that the collected value contents may be considered \"static\"\n  for the duration of the @value lifetime.\n  Thus an extra copy of the contents stored in @collect_values is\n  not required for assignment to @value.\n  For our above string example, we continue with:\n  |[<!-- language=\"C\" -->\n  if (!collect_values[0].v_pointer)\n    value->data[0].v_pointer = g_strdup (\"\");\n  else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)\n  {\n    value->data[0].v_pointer = collect_values[0].v_pointer;\n    // keep a flag for the value_free() implementation to not free this string\n    value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;\n  }\n  else\n    value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);\n  return NULL;\n  ]|\n  It should be noted, that it is generally a bad idea to follow the\n  %G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to\n  reentrancy requirements and reference count assertions performed\n  by the signal emission code, reference counts should always be\n  incremented for reference counted contents stored in the value->data\n  array.  To deviate from our string example for a moment, and taking\n  a look at an exemplary implementation for collect_value() of\n  #GObject:\n  |[<!-- language=\"C\" -->\n    GObject *object = G_OBJECT (collect_values[0].v_pointer);\n    g_return_val_if_fail (object != NULL,\n       g_strdup_printf (\"Object passed as invalid NULL pointer\"));\n    // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types\n    value->data[0].v_pointer = g_object_ref (object);\n    return NULL;\n  ]|\n  The reference count for valid objects is always incremented,\n  regardless of @collect_flags. For invalid objects, the example\n  returns a newly allocated string without altering @value.\n  Upon success, collect_value() needs to return %NULL. If, however,\n  an error condition occurred, collect_value() may spew an\n  error by returning a newly allocated non-%NULL string, giving\n  a suitable description of the error condition.\n  The calling code makes no assumptions about the @value\n  contents being valid upon error returns, @value\n  is simply thrown away without further freeing. As such, it is\n  a good idea to not allocate #GValue contents, prior to returning\n  an error, however, collect_values() is not obliged to return\n  a correctly setup @value for error returns, simply because\n  any non-%NULL return is considered a fatal condition so further\n  program behaviour is undefined.\n @lcopy_format: Format description of the arguments to collect for @lcopy_value,\n  analogous to @collect_format. Usually, @lcopy_format string consists\n  only of 'p's to provide lcopy_value() with pointers to storage locations.\n @lcopy_value: This function is responsible for storing the @value contents into\n  arguments passed through a variable argument list which got\n  collected into @collect_values according to @lcopy_format.\n  @n_collect_values equals the string length of @lcopy_format,\n  and @collect_flags may contain %G_VALUE_NOCOPY_CONTENTS.\n  In contrast to collect_value(), lcopy_value() is obliged to\n  always properly support %G_VALUE_NOCOPY_CONTENTS.\n  Similar to collect_value() the function may prematurely abort\n  by returning a newly allocated string describing an error condition.\n  To complete the string example:\n  |[<!-- language=\"C\" -->\n  gchar **string_p = collect_values[0].v_pointer;\n  g_return_val_if_fail (string_p != NULL,\n      g_strdup_printf (\"string location passed as NULL\"));\n  if (collect_flags & G_VALUE_NOCOPY_CONTENTS)\n    *string_p = value->data[0].v_pointer;\n  else\n    *string_p = g_strdup (value->data[0].v_pointer);\n  ]|\n  And an illustrative version of lcopy_value() for\n  reference-counted types:\n  |[<!-- language=\"C\" -->\n  GObject **object_p = collect_values[0].v_pointer;\n  g_return_val_if_fail (object_p != NULL,\n    g_strdup_printf (\"object location passed as NULL\"));\n  if (!value->data[0].v_pointer)\n    *object_p = NULL;\n  else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) // always honour\n    *object_p = value->data[0].v_pointer;\n  else\n    *object_p = g_object_ref (value->data[0].v_pointer);\n  return NULL;\n  ]|\n\n The #GTypeValueTable provides the functions required by the #GValue\n implementation, to serve as a container for values of a type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeValueTable {
    pub value_init: ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>,
    pub value_free: ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>,
    pub value_copy: ::std::option::Option<
        unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue),
    >,
    pub value_peek_pointer:
        ::std::option::Option<unsafe extern "C" fn(value: *const GValue) -> gpointer>,
    pub collect_format: *const gchar,
    pub collect_value: ::std::option::Option<
        unsafe extern "C" fn(
            value: *mut GValue,
            n_collect_values: guint,
            collect_values: *mut GTypeCValue,
            collect_flags: guint,
        ) -> *mut gchar,
    >,
    pub lcopy_format: *const gchar,
    pub lcopy_value: ::std::option::Option<
        unsafe extern "C" fn(
            value: *const GValue,
            n_collect_values: guint,
            collect_values: *mut GTypeCValue,
            collect_flags: guint,
        ) -> *mut gchar,
    >,
}
#[test]
fn bindgen_test_layout__GTypeValueTable() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeValueTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeValueTable>(),
        64usize,
        concat!("Size of: ", stringify!(_GTypeValueTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeValueTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeValueTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_free) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_copy) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_copy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_peek_pointer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_peek_pointer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).collect_format) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(collect_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).collect_value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(collect_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lcopy_format) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(lcopy_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lcopy_value) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(lcopy_value)
        )
    );
}
extern "C" {
    pub fn g_type_register_static(
        parent_type: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_register_static_simple(
        parent_type: GType,
        type_name: *const gchar,
        class_size: guint,
        class_init: GClassInitFunc,
        instance_size: guint,
        instance_init: GInstanceInitFunc,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_register_dynamic(
        parent_type: GType,
        type_name: *const gchar,
        plugin: *mut GTypePlugin,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_register_fundamental(
        type_id: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        finfo: *const GTypeFundamentalInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_add_interface_static(
        instance_type: GType,
        interface_type: GType,
        info: *const GInterfaceInfo,
    );
}
extern "C" {
    pub fn g_type_add_interface_dynamic(
        instance_type: GType,
        interface_type: GType,
        plugin: *mut GTypePlugin,
    );
}
extern "C" {
    pub fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType);
}
extern "C" {
    pub fn g_type_interface_prerequisites(
        interface_type: GType,
        n_prerequisites: *mut guint,
    ) -> *mut GType;
}
extern "C" {
    pub fn g_type_interface_instantiatable_prerequisite(interface_type: GType) -> GType;
}
extern "C" {
    pub fn g_type_class_add_private(g_class: gpointer, private_size: gsize);
}
extern "C" {
    pub fn g_type_add_instance_private(class_type: GType, private_size: gsize) -> gint;
}
extern "C" {
    pub fn g_type_instance_get_private(
        instance: *mut GTypeInstance,
        private_type: GType,
    ) -> gpointer;
}
extern "C" {
    pub fn g_type_class_adjust_private_offset(g_class: gpointer, private_size_or_offset: *mut gint);
}
extern "C" {
    pub fn g_type_add_class_private(class_type: GType, private_size: gsize);
}
extern "C" {
    pub fn g_type_class_get_private(klass: *mut GTypeClass, private_type: GType) -> gpointer;
}
extern "C" {
    pub fn g_type_class_get_instance_private_offset(g_class: gpointer) -> gint;
}
extern "C" {
    pub fn g_type_ensure(type_: GType);
}
extern "C" {
    pub fn g_type_get_type_registration_serial() -> guint;
}
extern "C" {
    pub fn g_type_get_plugin(type_: GType) -> *mut GTypePlugin;
}
extern "C" {
    pub fn g_type_interface_get_plugin(
        instance_type: GType,
        interface_type: GType,
    ) -> *mut GTypePlugin;
}
extern "C" {
    pub fn g_type_fundamental_next() -> GType;
}
extern "C" {
    pub fn g_type_fundamental(type_id: GType) -> GType;
}
extern "C" {
    pub fn g_type_create_instance(type_: GType) -> *mut GTypeInstance;
}
extern "C" {
    pub fn g_type_free_instance(instance: *mut GTypeInstance);
}
extern "C" {
    pub fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
extern "C" {
    pub fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
extern "C" {
    pub fn g_type_class_unref_uncached(g_class: gpointer);
}
extern "C" {
    pub fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
extern "C" {
    pub fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
extern "C" {
    pub fn g_type_value_table_peek(type_: GType) -> *mut GTypeValueTable;
}
extern "C" {
    pub fn g_type_check_instance(instance: *mut GTypeInstance) -> gboolean;
}
extern "C" {
    pub fn g_type_check_instance_cast(
        instance: *mut GTypeInstance,
        iface_type: GType,
    ) -> *mut GTypeInstance;
}
extern "C" {
    pub fn g_type_check_instance_is_a(instance: *mut GTypeInstance, iface_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_check_instance_is_fundamentally_a(
        instance: *mut GTypeInstance,
        fundamental_type: GType,
    ) -> gboolean;
}
extern "C" {
    pub fn g_type_check_class_cast(g_class: *mut GTypeClass, is_a_type: GType) -> *mut GTypeClass;
}
extern "C" {
    pub fn g_type_check_class_is_a(g_class: *mut GTypeClass, is_a_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_check_is_value_type(type_: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_check_value(value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn g_type_check_value_holds(value: *const GValue, type_: GType) -> gboolean;
}
extern "C" {
    pub fn g_type_test_flags(type_: GType, flags: guint) -> gboolean;
}
extern "C" {
    pub fn g_type_name_from_instance(instance: *mut GTypeInstance) -> *const gchar;
}
extern "C" {
    pub fn g_type_name_from_class(g_class: *mut GTypeClass) -> *const gchar;
}
#[doc = " GValueTransform:\n @src_value: Source value.\n @dest_value: Target value.\n\n The type of value transformation functions which can be registered with\n g_value_register_transform_func().\n\n @dest_value will be initialized to the correct destination type."]
pub type GValueTransform =
    ::std::option::Option<unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue)>;
#[doc = " GValue:\n\n An opaque structure used to hold different types of values.\n\n The data within the structure has protected scope: it is accessible only\n to functions within a #GTypeValueTable structure, or implementations of\n the g_value_*() API. That is, code portions which implement new fundamental\n types.\n\n #GValue users cannot make any assumptions about how data is stored\n within the 2 element @data union, and the @g_type member should\n only be accessed through the G_VALUE_TYPE() macro."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GValue {
    pub g_type: GType,
    pub data: [_GValue__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GValue__bindgen_ty_1 {
    pub v_int: gint,
    pub v_uint: guint,
    pub v_long: glong,
    pub v_ulong: gulong,
    pub v_int64: gint64,
    pub v_uint64: guint64,
    pub v_float: gfloat,
    pub v_double: gdouble,
    pub v_pointer: gpointer,
}
#[test]
fn bindgen_test_layout__GValue__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_GValue__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GValue__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GValue__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValue__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValue__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_uint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_uint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_long) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_long)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_ulong) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_ulong)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_uint64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_uint64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_pointer)
        )
    );
}
#[test]
fn bindgen_test_layout__GValue() {
    const UNINIT: ::std::mem::MaybeUninit<_GValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue),
            "::",
            stringify!(g_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn g_value_init(value: *mut GValue, g_type: GType) -> *mut GValue;
}
extern "C" {
    pub fn g_value_copy(src_value: *const GValue, dest_value: *mut GValue);
}
extern "C" {
    pub fn g_value_reset(value: *mut GValue) -> *mut GValue;
}
extern "C" {
    pub fn g_value_unset(value: *mut GValue);
}
extern "C" {
    pub fn g_value_set_instance(value: *mut GValue, instance: gpointer);
}
extern "C" {
    pub fn g_value_init_from_instance(value: *mut GValue, instance: gpointer);
}
extern "C" {
    pub fn g_value_fits_pointer(value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn g_value_peek_pointer(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_value_type_compatible(src_type: GType, dest_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_value_type_transformable(src_type: GType, dest_type: GType) -> gboolean;
}
extern "C" {
    pub fn g_value_transform(src_value: *const GValue, dest_value: *mut GValue) -> gboolean;
}
extern "C" {
    pub fn g_value_register_transform_func(
        src_type: GType,
        dest_type: GType,
        transform_func: GValueTransform,
    );
}
pub const GParamFlags_G_PARAM_READABLE: GParamFlags = 1;
pub const GParamFlags_G_PARAM_WRITABLE: GParamFlags = 2;
pub const GParamFlags_G_PARAM_READWRITE: GParamFlags = 3;
pub const GParamFlags_G_PARAM_CONSTRUCT: GParamFlags = 4;
pub const GParamFlags_G_PARAM_CONSTRUCT_ONLY: GParamFlags = 8;
pub const GParamFlags_G_PARAM_LAX_VALIDATION: GParamFlags = 16;
pub const GParamFlags_G_PARAM_STATIC_NAME: GParamFlags = 32;
pub const GParamFlags_G_PARAM_PRIVATE: GParamFlags = 32;
pub const GParamFlags_G_PARAM_STATIC_NICK: GParamFlags = 64;
pub const GParamFlags_G_PARAM_STATIC_BLURB: GParamFlags = 128;
pub const GParamFlags_G_PARAM_EXPLICIT_NOTIFY: GParamFlags = 1073741824;
pub const GParamFlags_G_PARAM_DEPRECATED: GParamFlags = -2147483648;
#[doc = " GParamFlags:\n @G_PARAM_READABLE: the parameter is readable\n @G_PARAM_WRITABLE: the parameter is writable\n @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE\n @G_PARAM_CONSTRUCT: the parameter will be set upon object construction\n @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction\n @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())\n  strict validation is not required\n @G_PARAM_STATIC_NAME: the string used as name when constructing the\n  parameter is guaranteed to remain valid and\n  unmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_STATIC_NICK: the string used as nick when constructing the\n  parameter is guaranteed to remain valid and\n  unmmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the\n  parameter is guaranteed to remain valid and\n  unmodified for the lifetime of the parameter.\n  Since 2.8\n @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this\n   property will not automatically result in a \"notify\" signal being\n   emitted: the implementation must call g_object_notify() themselves\n   in case the property actually changes.  Since: 2.42.\n @G_PARAM_PRIVATE: internal\n @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed\n  in a future version. A warning will be generated if it is used\n  while running with G_ENABLE_DIAGNOSTIC=1.\n  Since 2.26\n\n Through the #GParamFlags flag values, certain aspects of parameters\n can be configured.\n\n See also: %G_PARAM_STATIC_STRINGS"]
pub type GParamFlags = ::std::os::raw::c_int;
#[doc = " GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)\n @g_type_instance: private #GTypeInstance portion\n @name: name of this parameter: always an interned string\n @flags: #GParamFlags flags for this parameter\n @value_type: the #GValue type for this parameter\n @owner_type: #GType type that uses (introduces) this parameter\n\n All other fields of the GParamSpec struct are private and\n should not be used directly."]
pub type GParamSpec = _GParamSpec;
#[doc = " GParamSpecClass:\n @g_type_class: the parent class\n @value_type: the #GValue type for this parameter\n @finalize: The instance finalization function (optional), should chain\n  up to the finalize method of the parent class.\n @value_set_default: Resets a @value to the default value for this type\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by this type (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to this type\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n @value_is_valid: Checks if contents of @value comply with the specifications\n   set out by this type, without modifying the value. This vfunc is optional.\n   If it isn't set, GObject will use @value_validate. Since 2.74\n\n The class structure for the GParamSpec type.\n Normally, GParamSpec classes are filled by\n g_param_type_register_static()."]
pub type GParamSpecClass = _GParamSpecClass;
#[doc = " GParameter:\n @name: the parameter name\n @value: the parameter value\n\n The GParameter struct is an auxiliary structure used\n to hand parameter name/value pairs to g_object_newv().\n\n Deprecated: 2.54: This type is not introspectable."]
pub type GParameter = _GParameter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPool {
    _unused: [u8; 0],
}
pub type GParamSpecPool = _GParamSpecPool;
#[doc = " GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_unref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)\n @g_type_instance: private #GTypeInstance portion\n @name: name of this parameter: always an interned string\n @flags: #GParamFlags flags for this parameter\n @value_type: the #GValue type for this parameter\n @owner_type: #GType type that uses (introduces) this parameter\n\n All other fields of the GParamSpec struct are private and\n should not be used directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut gchar,
    pub _blurb: *mut gchar,
    pub qdata: *mut GData,
    pub ref_count: guint,
    pub param_id: guint,
}
#[test]
fn bindgen_test_layout__GParamSpec() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpec>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).owner_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(owner_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nick) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(_nick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blurb) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(_blurb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qdata) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param_id) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(param_id)
        )
    );
}
#[doc = " GParamSpecClass:\n @g_type_class: the parent class\n @value_type: the #GValue type for this parameter\n @finalize: The instance finalization function (optional), should chain\n  up to the finalize method of the parent class.\n @value_set_default: Resets a @value to the default value for this type\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by this type (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to this type\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n @value_is_valid: Checks if contents of @value comply with the specifications\n   set out by this type, without modifying the value. This vfunc is optional.\n   If it isn't set, GObject will use @value_validate. Since 2.74\n\n The class structure for the GParamSpec type.\n Normally, GParamSpec classes are filled by\n g_param_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecClass {
    pub g_type_class: GTypeClass,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean,
    >,
    pub values_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            pspec: *mut GParamSpec,
            value1: *const GValue,
            value2: *const GValue,
        ) -> gint,
    >,
    pub value_is_valid: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *const GValue) -> gboolean,
    >,
    pub dummy: [gpointer; 3usize],
}
#[test]
fn bindgen_test_layout__GParamSpecClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecClass>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_set_default) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_set_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_validate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_validate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values_cmp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(values_cmp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_is_valid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_is_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(dummy)
        )
    );
}
#[doc = " GParameter:\n @name: the parameter name\n @value: the parameter value\n\n The GParameter struct is an auxiliary structure used\n to hand parameter name/value pairs to g_object_newv().\n\n Deprecated: 2.54: This type is not introspectable."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GParameter {
    pub name: *const gchar,
    pub value: GValue,
}
#[test]
fn bindgen_test_layout__GParameter() {
    const UNINIT: ::std::mem::MaybeUninit<_GParameter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParameter>(),
        32usize,
        concat!("Size of: ", stringify!(_GParameter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParameter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParameter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParameter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParameter),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn g_param_spec_ref(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_unref(pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_param_spec_sink(pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_param_spec_ref_sink(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_get_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_param_spec_set_qdata(pspec: *mut GParamSpec, quark: GQuark, data: gpointer);
}
extern "C" {
    pub fn g_param_spec_set_qdata_full(
        pspec: *mut GParamSpec,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_param_spec_steal_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_param_spec_get_redirect_target(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_value_set_default(pspec: *mut GParamSpec, value: *mut GValue);
}
extern "C" {
    pub fn g_param_value_defaults(pspec: *mut GParamSpec, value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn g_param_value_validate(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
}
extern "C" {
    pub fn g_param_value_is_valid(pspec: *mut GParamSpec, value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn g_param_value_convert(
        pspec: *mut GParamSpec,
        src_value: *const GValue,
        dest_value: *mut GValue,
        strict_validation: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_param_values_cmp(
        pspec: *mut GParamSpec,
        value1: *const GValue,
        value2: *const GValue,
    ) -> gint;
}
extern "C" {
    pub fn g_param_spec_get_name(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    pub fn g_param_spec_get_nick(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    pub fn g_param_spec_get_blurb(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    pub fn g_value_set_param(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    pub fn g_value_get_param(value: *const GValue) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_value_dup_param(value: *const GValue) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_value_take_param(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    pub fn g_value_set_param_take_ownership(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    pub fn g_param_spec_get_default_value(pspec: *mut GParamSpec) -> *const GValue;
}
extern "C" {
    pub fn g_param_spec_get_name_quark(pspec: *mut GParamSpec) -> GQuark;
}
#[doc = " GParamSpecTypeInfo:\n @instance_size: Size of the instance (object) structure.\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.\n @instance_init: Location of the instance initialization function (optional).\n @value_type: The #GType of values conforming to this #GParamSpec\n @finalize: The instance finalization function (optional).\n @value_set_default: Resets a @value to the default value for @pspec\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by @pspec (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to @pspec\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a parameter's class and\n instances thereof.\n\n The initialized structure is passed to the g_param_type_register_static()\n The type system will perform a deep copy of this structure, so its memory\n does not need to be persistent across invocation of\n g_param_type_register_static()."]
pub type GParamSpecTypeInfo = _GParamSpecTypeInfo;
#[doc = " GParamSpecTypeInfo:\n @instance_size: Size of the instance (object) structure.\n @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.\n @instance_init: Location of the instance initialization function (optional).\n @value_type: The #GType of values conforming to this #GParamSpec\n @finalize: The instance finalization function (optional).\n @value_set_default: Resets a @value to the default value for @pspec\n  (recommended, the default is g_value_reset()), see\n  g_param_value_set_default().\n @value_validate: Ensures that the contents of @value comply with the\n  specifications set out by @pspec (optional), see\n  g_param_value_validate().\n @values_cmp: Compares @value1 with @value2 according to @pspec\n  (recommended, the default is memcmp()), see g_param_values_cmp().\n\n This structure is used to provide the type system with the information\n required to initialize and destruct (finalize) a parameter's class and\n instances thereof.\n\n The initialized structure is passed to the g_param_type_register_static()\n The type system will perform a deep copy of this structure, so its memory\n does not need to be persistent across invocation of\n g_param_type_register_static()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecTypeInfo {
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean,
    >,
    pub values_cmp: ::std::option::Option<
        unsafe extern "C" fn(
            pspec: *mut GParamSpec,
            value1: *const GValue,
            value2: *const GValue,
        ) -> gint,
    >,
}
#[test]
fn bindgen_test_layout__GParamSpecTypeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecTypeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecTypeInfo>(),
        56usize,
        concat!("Size of: ", stringify!(_GParamSpecTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecTypeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(instance_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_preallocs) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(n_preallocs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance_init) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(instance_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_set_default) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_set_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_validate) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_validate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values_cmp) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(values_cmp)
        )
    );
}
extern "C" {
    pub fn g_param_type_register_static(
        name: *const gchar,
        pspec_info: *const GParamSpecTypeInfo,
    ) -> GType;
}
extern "C" {
    pub fn g_param_spec_is_valid_name(name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn _g_param_type_register_static_constant(
        name: *const gchar,
        pspec_info: *const GParamSpecTypeInfo,
        opt_type: GType,
    ) -> GType;
}
extern "C" {
    pub fn g_param_spec_internal(
        param_type: GType,
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> gpointer;
}
extern "C" {
    pub fn g_param_spec_pool_new(type_prefixing: gboolean) -> *mut GParamSpecPool;
}
extern "C" {
    pub fn g_param_spec_pool_insert(
        pool: *mut GParamSpecPool,
        pspec: *mut GParamSpec,
        owner_type: GType,
    );
}
extern "C" {
    pub fn g_param_spec_pool_remove(pool: *mut GParamSpecPool, pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_param_spec_pool_lookup(
        pool: *mut GParamSpecPool,
        param_name: *const gchar,
        owner_type: GType,
        walk_ancestors: gboolean,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_pool_list_owned(pool: *mut GParamSpecPool, owner_type: GType)
        -> *mut GList;
}
extern "C" {
    pub fn g_param_spec_pool_list(
        pool: *mut GParamSpecPool,
        owner_type: GType,
        n_pspecs_p: *mut guint,
    ) -> *mut *mut GParamSpec;
}
#[doc = " GClosure:\n @in_marshal: Indicates whether the closure is currently being invoked with\n  g_closure_invoke()\n @is_invalid: Indicates whether the closure has been invalidated by\n  g_closure_invalidate()\n\n A #GClosure represents a callback supplied by the programmer."]
pub type GClosure = _GClosure;
pub type GClosureNotifyData = _GClosureNotifyData;
#[doc = " GCallback:\n\n The type used for callback functions in structure definitions and function\n signatures.\n\n This doesn't mean that all callback functions must take no  parameters and\n return void. The required signature of a callback function is determined by\n the context in which is used (e.g. the signal to which it is connected).\n\n Use G_CALLBACK() to cast the callback function to a #GCallback."]
pub type GCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " GClosureNotify:\n @data: data specified when registering the notification callback\n @closure: the #GClosure on which the notification is emitted\n\n The type used for the various notification callbacks which can be registered\n on closures."]
pub type GClosureNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, closure: *mut GClosure)>;
#[doc = " GClosureMarshal:\n @closure: the #GClosure to which the marshaller belongs\n @return_value: (nullable): a #GValue to store the return\n  value. May be %NULL if the callback of @closure doesn't return a\n  value.\n @n_param_values: the length of the @param_values array\n @param_values: (array length=n_param_values): an array of\n  #GValues holding the arguments on which to invoke the\n  callback of @closure\n @invocation_hint: (nullable): the invocation hint given as the\n  last argument to g_closure_invoke()\n @marshal_data: (nullable): additional data specified when\n  registering the marshaller, see g_closure_set_marshal() and\n  g_closure_set_meta_marshal()\n\n The type used for marshaller functions."]
pub type GClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    ),
>;
#[doc = " GVaClosureMarshal:\n @closure: the #GClosure to which the marshaller belongs\n @return_value: (nullable): a #GValue to store the return\n  value. May be %NULL if the callback of @closure doesn't return a\n  value.\n @instance: (type GObject.TypeInstance): the instance on which the closure is\n  invoked.\n @args: va_list of arguments to be passed to the closure.\n @marshal_data: (nullable): additional data specified when\n  registering the marshaller, see g_closure_set_marshal() and\n  g_closure_set_meta_marshal()\n @n_params: the length of the @param_types array\n @param_types: (array length=n_params): the #GType of each argument from\n  @args.\n\n This is the signature of va_list marshaller functions, an optional\n marshaller that can be used in some situations to avoid\n marshalling the signal argument into GValues."]
pub type GVaClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    ),
>;
#[doc = " GCClosure:\n @closure: the #GClosure\n @callback: the callback function\n\n A #GCClosure is a specialization of #GClosure for C function callbacks."]
pub type GCClosure = _GCClosure;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GClosureNotifyData {
    pub data: gpointer,
    pub notify: GClosureNotify,
}
#[test]
fn bindgen_test_layout__GClosureNotifyData() {
    const UNINIT: ::std::mem::MaybeUninit<_GClosureNotifyData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GClosureNotifyData>(),
        16usize,
        concat!("Size of: ", stringify!(_GClosureNotifyData))
    );
    assert_eq!(
        ::std::mem::align_of::<_GClosureNotifyData>(),
        8usize,
        concat!("Alignment of ", stringify!(_GClosureNotifyData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosureNotifyData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosureNotifyData),
            "::",
            stringify!(notify)
        )
    );
}
#[doc = " GClosure:\n @in_marshal: Indicates whether the closure is currently being invoked with\n  g_closure_invoke()\n @is_invalid: Indicates whether the closure has been invalidated by\n  g_closure_invalidate()\n\n A #GClosure represents a callback supplied by the programmer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GClosure {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub marshal: ::std::option::Option<
        unsafe extern "C" fn(
            closure: *mut GClosure,
            return_value: *mut GValue,
            n_param_values: guint,
            param_values: *const GValue,
            invocation_hint: gpointer,
            marshal_data: gpointer,
        ),
    >,
    pub data: gpointer,
    pub notifiers: *mut GClosureNotifyData,
}
#[test]
fn bindgen_test_layout__GClosure() {
    const UNINIT: ::std::mem::MaybeUninit<_GClosure> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GClosure>(),
        32usize,
        concat!("Size of: ", stringify!(_GClosure))
    );
    assert_eq!(
        ::std::mem::align_of::<_GClosure>(),
        8usize,
        concat!("Alignment of ", stringify!(_GClosure))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).marshal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(marshal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notifiers) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(notifiers)
        )
    );
}
impl _GClosure {
    #[inline]
    pub fn ref_count(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_ref_count(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn meta_marshal_nouse(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meta_marshal_nouse(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn n_guards(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_n_guards(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn n_fnotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_n_fnotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn n_inotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_n_inotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn in_inotify(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_inotify(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn floating(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_floating(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn derivative_flag(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_derivative_flag(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_marshal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_marshal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_invalid(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_invalid(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ref_count: guint,
        meta_marshal_nouse: guint,
        n_guards: guint,
        n_fnotifiers: guint,
        n_inotifiers: guint,
        in_inotify: guint,
        floating: guint,
        derivative_flag: guint,
        in_marshal: guint,
        is_invalid: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let ref_count: u32 = unsafe { ::std::mem::transmute(ref_count) };
            ref_count as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let meta_marshal_nouse: u32 = unsafe { ::std::mem::transmute(meta_marshal_nouse) };
            meta_marshal_nouse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let n_guards: u32 = unsafe { ::std::mem::transmute(n_guards) };
            n_guards as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let n_fnotifiers: u32 = unsafe { ::std::mem::transmute(n_fnotifiers) };
            n_fnotifiers as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let n_inotifiers: u32 = unsafe { ::std::mem::transmute(n_inotifiers) };
            n_inotifiers as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let in_inotify: u32 = unsafe { ::std::mem::transmute(in_inotify) };
            in_inotify as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let floating: u32 = unsafe { ::std::mem::transmute(floating) };
            floating as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let derivative_flag: u32 = unsafe { ::std::mem::transmute(derivative_flag) };
            derivative_flag as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let in_marshal: u32 = unsafe { ::std::mem::transmute(in_marshal) };
            in_marshal as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_invalid: u32 = unsafe { ::std::mem::transmute(is_invalid) };
            is_invalid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCClosure {
    pub closure: GClosure,
    pub callback: gpointer,
}
#[test]
fn bindgen_test_layout__GCClosure() {
    const UNINIT: ::std::mem::MaybeUninit<_GCClosure> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCClosure>(),
        40usize,
        concat!("Size of: ", stringify!(_GCClosure))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCClosure>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCClosure))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).closure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCClosure),
            "::",
            stringify!(closure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCClosure),
            "::",
            stringify!(callback)
        )
    );
}
extern "C" {
    pub fn g_cclosure_new(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
}
extern "C" {
    pub fn g_cclosure_new_swap(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
}
extern "C" {
    pub fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint) -> *mut GClosure;
}
extern "C" {
    pub fn g_closure_ref(closure: *mut GClosure) -> *mut GClosure;
}
extern "C" {
    pub fn g_closure_sink(closure: *mut GClosure);
}
extern "C" {
    pub fn g_closure_unref(closure: *mut GClosure);
}
extern "C" {
    pub fn g_closure_new_simple(sizeof_closure: guint, data: gpointer) -> *mut GClosure;
}
extern "C" {
    pub fn g_closure_add_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    pub fn g_closure_remove_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    pub fn g_closure_add_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    pub fn g_closure_remove_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    pub fn g_closure_add_marshal_guards(
        closure: *mut GClosure,
        pre_marshal_data: gpointer,
        pre_marshal_notify: GClosureNotify,
        post_marshal_data: gpointer,
        post_marshal_notify: GClosureNotify,
    );
}
extern "C" {
    pub fn g_closure_set_marshal(closure: *mut GClosure, marshal: GClosureMarshal);
}
extern "C" {
    pub fn g_closure_set_meta_marshal(
        closure: *mut GClosure,
        marshal_data: gpointer,
        meta_marshal: GClosureMarshal,
    );
}
extern "C" {
    pub fn g_closure_invalidate(closure: *mut GClosure);
}
extern "C" {
    pub fn g_closure_invoke(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_generic(
        closure: *mut GClosure,
        return_gvalue: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_generic_va(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args_list: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__VOID(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__VOIDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__BOOLEAN(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__BOOLEANv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__CHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__CHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UCHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UCHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__INT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__INTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UINTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__LONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__LONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__ULONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__ULONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__ENUM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__ENUMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__FLOAT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__FLOATv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__DOUBLE(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__DOUBLEv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__STRING(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__STRINGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__PARAM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__PARAMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__OBJECT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__OBJECTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__VARIANT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__VARIANTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_VOID__UINT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
#[doc = " GSignalQuery:\n @signal_id: The signal id of the signal being queried, or 0 if the\n  signal to be queried was unknown.\n @signal_name: The signal name.\n @itype: The interface/instance type that this signal can be emitted for.\n @signal_flags: The signal flags as passed in to g_signal_new().\n @return_type: The return type for user callbacks.\n @n_params: The number of parameters that user callbacks take.\n @param_types: (array length=n_params): The individual parameter types for\n  user callbacks, note that the effective callback signature is:\n  |[<!-- language=\"C\" -->\n  @return_type callback (#gpointer     data1,\n  [param_types param_names,]\n  gpointer     data2);\n  ]|\n\n A structure holding in-depth information for a specific signal.\n\n See also: g_signal_query()"]
pub type GSignalQuery = _GSignalQuery;
#[doc = " GSignalInvocationHint:\n @signal_id: The signal id of the signal invoking the callback\n @detail: The detail passed on for this emission\n @run_type: The stage the signal emission is currently in, this\n  field will contain one of %G_SIGNAL_RUN_FIRST,\n  %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP and %G_SIGNAL_ACCUMULATOR_FIRST_RUN.\n  %G_SIGNAL_ACCUMULATOR_FIRST_RUN is only set for the first run of the accumulator\n  function for a signal emission.\n\n The #GSignalInvocationHint structure is used to pass on additional information\n to callbacks during a signal emission."]
pub type GSignalInvocationHint = _GSignalInvocationHint;
#[doc = " GSignalCMarshaller:\n\n This is the signature of marshaller functions, required to marshall\n arrays of parameter values to signal emissions into C language callback\n invocations.\n\n It is merely an alias to #GClosureMarshal since the #GClosure mechanism\n takes over responsibility of actual function invocation for the signal\n system."]
pub type GSignalCMarshaller = GClosureMarshal;
#[doc = " GSignalCVaMarshaller:\n\n This is the signature of va_list marshaller functions, an optional\n marshaller that can be used in some situations to avoid\n marshalling the signal argument into GValues."]
pub type GSignalCVaMarshaller = GVaClosureMarshal;
#[doc = " GSignalEmissionHook:\n @ihint: Signal invocation hint, see #GSignalInvocationHint.\n @n_param_values: the number of parameters to the function, including\n  the instance on which the signal was emitted.\n @param_values: (array length=n_param_values): the instance on which\n  the signal was emitted, followed by the parameters of the emission.\n @data: user data associated with the hook.\n\n A simple function pointer to get invoked when the signal is emitted.\n\n Emission hooks allow you to tie a hook to the signal type, so that it will\n trap all emissions of that signal, from any object.\n\n You may not attach these to signals created with the %G_SIGNAL_NO_HOOKS flag.\n\n Returns: whether it wants to stay connected. If it returns %FALSE, the signal\n  hook is disconnected (and destroyed)."]
pub type GSignalEmissionHook = ::std::option::Option<
    unsafe extern "C" fn(
        ihint: *mut GSignalInvocationHint,
        n_param_values: guint,
        param_values: *const GValue,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GSignalAccumulator:\n @ihint: Signal invocation hint, see #GSignalInvocationHint.\n @return_accu: Accumulator to collect callback return values in, this\n  is the return value of the current signal emission.\n @handler_return: A #GValue holding the return value of the signal handler.\n @data: Callback data that was specified when creating the signal.\n\n The signal accumulator is a special callback function that can be used\n to collect return values of the various callbacks that are called\n during a signal emission.\n\n The signal accumulator is specified at signal creation time, if it is\n left %NULL, no accumulation of callback return values is performed.\n The return value of signal emissions is then the value returned by the\n last callback.\n\n Returns: The accumulator function returns whether the signal emission\n  should be aborted. Returning %TRUE will continue with\n  the signal emission. Returning %FALSE will abort the current emission.\n  Since 2.62, returning %FALSE will skip to the CLEANUP stage. In this case,\n  emission will occur as normal in the CLEANUP stage and the handler's\n  return value will be accumulated."]
pub type GSignalAccumulator = ::std::option::Option<
    unsafe extern "C" fn(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        data: gpointer,
    ) -> gboolean,
>;
pub const GSignalFlags_G_SIGNAL_RUN_FIRST: GSignalFlags = 1;
pub const GSignalFlags_G_SIGNAL_RUN_LAST: GSignalFlags = 2;
pub const GSignalFlags_G_SIGNAL_RUN_CLEANUP: GSignalFlags = 4;
pub const GSignalFlags_G_SIGNAL_NO_RECURSE: GSignalFlags = 8;
pub const GSignalFlags_G_SIGNAL_DETAILED: GSignalFlags = 16;
pub const GSignalFlags_G_SIGNAL_ACTION: GSignalFlags = 32;
pub const GSignalFlags_G_SIGNAL_NO_HOOKS: GSignalFlags = 64;
pub const GSignalFlags_G_SIGNAL_MUST_COLLECT: GSignalFlags = 128;
pub const GSignalFlags_G_SIGNAL_DEPRECATED: GSignalFlags = 256;
pub const GSignalFlags_G_SIGNAL_ACCUMULATOR_FIRST_RUN: GSignalFlags = 131072;
#[doc = " GSignalFlags:\n @G_SIGNAL_RUN_FIRST: Invoke the object method handler in the first emission stage.\n @G_SIGNAL_RUN_LAST: Invoke the object method handler in the third emission stage.\n @G_SIGNAL_RUN_CLEANUP: Invoke the object method handler in the last emission stage.\n @G_SIGNAL_NO_RECURSE: Signals being emitted for an object while currently being in\n  emission for this very object will not be emitted recursively,\n  but instead cause the first emission to be restarted.\n @G_SIGNAL_DETAILED: This signal supports \"::detail\" appendices to the signal name\n  upon handler connections and emissions.\n @G_SIGNAL_ACTION: Action signals are signals that may freely be emitted on alive\n  objects from user code via g_signal_emit() and friends, without\n  the need of being embedded into extra code that performs pre or\n  post emission adjustments on the object. They can also be thought\n  of as object methods which can be called generically by\n  third-party code.\n @G_SIGNAL_NO_HOOKS: No emissions hooks are supported for this signal.\n @G_SIGNAL_MUST_COLLECT: Varargs signal emission will always collect the\n   arguments, even if there are no signal handlers connected.  Since 2.30.\n @G_SIGNAL_DEPRECATED: The signal is deprecated and will be removed\n   in a future version. A warning will be generated if it is connected while\n   running with G_ENABLE_DIAGNOSTIC=1.  Since 2.32.\n @G_SIGNAL_ACCUMULATOR_FIRST_RUN: Only used in #GSignalAccumulator accumulator\n   functions for the #GSignalInvocationHint::run_type field to mark the first\n   call to the accumulator function for a signal emission.  Since 2.68.\n\n The signal flags are used to specify a signal's behaviour."]
pub type GSignalFlags = ::std::os::raw::c_uint;
pub const GConnectFlags_G_CONNECT_DEFAULT: GConnectFlags = 0;
pub const GConnectFlags_G_CONNECT_AFTER: GConnectFlags = 1;
pub const GConnectFlags_G_CONNECT_SWAPPED: GConnectFlags = 2;
#[doc = " GConnectFlags:\n @G_CONNECT_DEFAULT: Default behaviour (no special flags). Since: 2.74\n @G_CONNECT_AFTER: If set, the handler should be called after the\n  default handler of the signal. Normally, the handler is called before\n  the default handler.\n @G_CONNECT_SWAPPED: If set, the instance and data should be swapped when\n  calling the handler; see g_signal_connect_swapped() for an example.\n\n The connection flags are used to specify the behaviour of a signal's\n connection."]
pub type GConnectFlags = ::std::os::raw::c_uint;
pub const GSignalMatchType_G_SIGNAL_MATCH_ID: GSignalMatchType = 1;
pub const GSignalMatchType_G_SIGNAL_MATCH_DETAIL: GSignalMatchType = 2;
pub const GSignalMatchType_G_SIGNAL_MATCH_CLOSURE: GSignalMatchType = 4;
pub const GSignalMatchType_G_SIGNAL_MATCH_FUNC: GSignalMatchType = 8;
pub const GSignalMatchType_G_SIGNAL_MATCH_DATA: GSignalMatchType = 16;
pub const GSignalMatchType_G_SIGNAL_MATCH_UNBLOCKED: GSignalMatchType = 32;
#[doc = " GSignalMatchType:\n @G_SIGNAL_MATCH_ID: The signal id must be equal.\n @G_SIGNAL_MATCH_DETAIL: The signal detail must be equal.\n @G_SIGNAL_MATCH_CLOSURE: The closure must be the same.\n @G_SIGNAL_MATCH_FUNC: The C closure callback must be the same.\n @G_SIGNAL_MATCH_DATA: The closure data must be the same.\n @G_SIGNAL_MATCH_UNBLOCKED: Only unblocked signals may be matched.\n\n The match types specify what g_signal_handlers_block_matched(),\n g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()\n match signals by."]
pub type GSignalMatchType = ::std::os::raw::c_uint;
#[doc = " GSignalInvocationHint:\n @signal_id: The signal id of the signal invoking the callback\n @detail: The detail passed on for this emission\n @run_type: The stage the signal emission is currently in, this\n  field will contain one of %G_SIGNAL_RUN_FIRST,\n  %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP and %G_SIGNAL_ACCUMULATOR_FIRST_RUN.\n  %G_SIGNAL_ACCUMULATOR_FIRST_RUN is only set for the first run of the accumulator\n  function for a signal emission.\n\n The #GSignalInvocationHint structure is used to pass on additional information\n to callbacks during a signal emission."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalInvocationHint {
    pub signal_id: guint,
    pub detail: GQuark,
    pub run_type: GSignalFlags,
}
#[test]
fn bindgen_test_layout__GSignalInvocationHint() {
    const UNINIT: ::std::mem::MaybeUninit<_GSignalInvocationHint> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSignalInvocationHint>(),
        12usize,
        concat!("Size of: ", stringify!(_GSignalInvocationHint))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSignalInvocationHint>(),
        4usize,
        concat!("Alignment of ", stringify!(_GSignalInvocationHint))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(signal_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).detail) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(run_type)
        )
    );
}
#[doc = " GSignalQuery:\n @signal_id: The signal id of the signal being queried, or 0 if the\n  signal to be queried was unknown.\n @signal_name: The signal name.\n @itype: The interface/instance type that this signal can be emitted for.\n @signal_flags: The signal flags as passed in to g_signal_new().\n @return_type: The return type for user callbacks.\n @n_params: The number of parameters that user callbacks take.\n @param_types: (array length=n_params): The individual parameter types for\n  user callbacks, note that the effective callback signature is:\n  |[<!-- language=\"C\" -->\n  @return_type callback (#gpointer     data1,\n  [param_types param_names,]\n  gpointer     data2);\n  ]|\n\n A structure holding in-depth information for a specific signal.\n\n See also: g_signal_query()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalQuery {
    pub signal_id: guint,
    pub signal_name: *const gchar,
    pub itype: GType,
    pub signal_flags: GSignalFlags,
    pub return_type: GType,
    pub n_params: guint,
    pub param_types: *const GType,
}
#[test]
fn bindgen_test_layout__GSignalQuery() {
    const UNINIT: ::std::mem::MaybeUninit<_GSignalQuery> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSignalQuery>(),
        56usize,
        concat!("Size of: ", stringify!(_GSignalQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSignalQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSignalQuery))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(itype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).return_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(return_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_params) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(n_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).param_types) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(param_types)
        )
    );
}
extern "C" {
    pub fn g_signal_newv(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        param_types: *mut GType,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_new_valist(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        args: *mut __va_list_tag,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_new(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_offset: guint,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
extern "C" {
    pub fn g_signal_new_class_handler(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_handler: GCallback,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
extern "C" {
    pub fn g_signal_set_va_marshaller(
        signal_id: guint,
        instance_type: GType,
        va_marshaller: GSignalCVaMarshaller,
    );
}
extern "C" {
    pub fn g_signal_emitv(
        instance_and_params: *const GValue,
        signal_id: guint,
        detail: GQuark,
        return_value: *mut GValue,
    );
}
extern "C" {
    pub fn g_signal_emit_valist(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn g_signal_emit(instance: gpointer, signal_id: guint, detail: GQuark, ...);
}
extern "C" {
    pub fn g_signal_emit_by_name(instance: gpointer, detailed_signal: *const gchar, ...);
}
extern "C" {
    pub fn g_signal_lookup(name: *const gchar, itype: GType) -> guint;
}
extern "C" {
    pub fn g_signal_name(signal_id: guint) -> *const gchar;
}
extern "C" {
    pub fn g_signal_query(signal_id: guint, query: *mut GSignalQuery);
}
extern "C" {
    pub fn g_signal_list_ids(itype: GType, n_ids: *mut guint) -> *mut guint;
}
extern "C" {
    pub fn g_signal_is_valid_name(name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_signal_parse_name(
        detailed_signal: *const gchar,
        itype: GType,
        signal_id_p: *mut guint,
        detail_p: *mut GQuark,
        force_detail_quark: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_signal_get_invocation_hint(instance: gpointer) -> *mut GSignalInvocationHint;
}
extern "C" {
    pub fn g_signal_stop_emission(instance: gpointer, signal_id: guint, detail: GQuark);
}
extern "C" {
    pub fn g_signal_stop_emission_by_name(instance: gpointer, detailed_signal: *const gchar);
}
extern "C" {
    pub fn g_signal_add_emission_hook(
        signal_id: guint,
        detail: GQuark,
        hook_func: GSignalEmissionHook,
        hook_data: gpointer,
        data_destroy: GDestroyNotify,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong);
}
extern "C" {
    pub fn g_signal_has_handler_pending(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        may_be_blocked: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_signal_connect_closure_by_id(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_connect_closure(
        instance: gpointer,
        detailed_signal: *const gchar,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_connect_data(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
        destroy_data: GClosureNotify,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_handler_block(instance: gpointer, handler_id: gulong);
}
extern "C" {
    pub fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong);
}
extern "C" {
    pub fn g_signal_handler_disconnect(instance: gpointer, handler_id: gulong);
}
extern "C" {
    pub fn g_signal_handler_is_connected(instance: gpointer, handler_id: gulong) -> gboolean;
}
extern "C" {
    pub fn g_signal_handler_find(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> gulong;
}
extern "C" {
    pub fn g_signal_handlers_block_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_handlers_unblock_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_signal_handlers_disconnect_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_clear_signal_handler(handler_id_ptr: *mut gulong, instance: gpointer);
}
extern "C" {
    pub fn g_signal_override_class_closure(
        signal_id: guint,
        instance_type: GType,
        class_closure: *mut GClosure,
    );
}
extern "C" {
    pub fn g_signal_override_class_handler(
        signal_name: *const gchar,
        instance_type: GType,
        class_handler: GCallback,
    );
}
extern "C" {
    pub fn g_signal_chain_from_overridden(
        instance_and_params: *const GValue,
        return_value: *mut GValue,
    );
}
extern "C" {
    pub fn g_signal_chain_from_overridden_handler(instance: gpointer, ...);
}
extern "C" {
    pub fn g_signal_accumulator_true_handled(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_signal_accumulator_first_wins(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_signal_handlers_destroy(instance: gpointer);
}
extern "C" {
    pub fn _g_signals_destroy(itype: GType);
}
extern "C" {
    pub fn g_date_get_type() -> GType;
}
extern "C" {
    pub fn g_strv_get_type() -> GType;
}
extern "C" {
    pub fn g_gstring_get_type() -> GType;
}
extern "C" {
    pub fn g_hash_table_get_type() -> GType;
}
extern "C" {
    pub fn g_array_get_type() -> GType;
}
extern "C" {
    pub fn g_byte_array_get_type() -> GType;
}
extern "C" {
    pub fn g_ptr_array_get_type() -> GType;
}
extern "C" {
    pub fn g_bytes_get_type() -> GType;
}
extern "C" {
    pub fn g_variant_type_get_gtype() -> GType;
}
extern "C" {
    pub fn g_regex_get_type() -> GType;
}
extern "C" {
    pub fn g_match_info_get_type() -> GType;
}
extern "C" {
    pub fn g_error_get_type() -> GType;
}
extern "C" {
    pub fn g_date_time_get_type() -> GType;
}
extern "C" {
    pub fn g_time_zone_get_type() -> GType;
}
extern "C" {
    pub fn g_io_channel_get_type() -> GType;
}
extern "C" {
    pub fn g_io_condition_get_type() -> GType;
}
extern "C" {
    pub fn g_variant_builder_get_type() -> GType;
}
extern "C" {
    pub fn g_variant_dict_get_type() -> GType;
}
extern "C" {
    pub fn g_key_file_get_type() -> GType;
}
extern "C" {
    pub fn g_main_loop_get_type() -> GType;
}
extern "C" {
    pub fn g_main_context_get_type() -> GType;
}
extern "C" {
    pub fn g_source_get_type() -> GType;
}
extern "C" {
    pub fn g_pollfd_get_type() -> GType;
}
extern "C" {
    pub fn g_thread_get_type() -> GType;
}
extern "C" {
    pub fn g_checksum_get_type() -> GType;
}
extern "C" {
    pub fn g_markup_parse_context_get_type() -> GType;
}
extern "C" {
    pub fn g_mapped_file_get_type() -> GType;
}
extern "C" {
    pub fn g_option_group_get_type() -> GType;
}
extern "C" {
    pub fn g_uri_get_type() -> GType;
}
extern "C" {
    pub fn g_tree_get_type() -> GType;
}
extern "C" {
    pub fn g_pattern_spec_get_type() -> GType;
}
extern "C" {
    pub fn g_bookmark_file_get_type() -> GType;
}
extern "C" {
    pub fn g_variant_get_gtype() -> GType;
}
#[doc = " GBoxedCopyFunc:\n @boxed: (not nullable): The boxed structure to be copied.\n\n This function is provided by the user and should produce a copy\n of the passed in boxed structure.\n\n Returns: (not nullable): The newly created copy of the boxed structure."]
pub type GBoxedCopyFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer) -> gpointer>;
#[doc = " GBoxedFreeFunc:\n @boxed: (not nullable): The boxed structure to be freed.\n\n This function is provided by the user and should free the boxed\n structure passed."]
pub type GBoxedFreeFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer)>;
extern "C" {
    pub fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_boxed_free(boxed_type: GType, boxed: gpointer);
}
extern "C" {
    pub fn g_value_set_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    pub fn g_value_set_static_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    pub fn g_value_take_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    pub fn g_value_set_boxed_take_ownership(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    pub fn g_value_get_boxed(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_value_dup_boxed(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_boxed_type_register_static(
        name: *const gchar,
        boxed_copy: GBoxedCopyFunc,
        boxed_free: GBoxedFreeFunc,
    ) -> GType;
}
extern "C" {
    pub fn g_closure_get_type() -> GType;
}
extern "C" {
    pub fn g_value_get_type() -> GType;
}
#[doc = " GObject:\n\n The base object type.\n\n All the fields in the `GObject` structure are private to the implementation\n and should never be accessed directly.\n\n Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the\n alignment of the largest basic GLib type (typically this is #guint64 or\n #gdouble). If you need larger alignment for an element in a #GObject, you\n should allocate it on the heap (aligned), or arrange for your #GObject to be\n appropriately padded. This guarantee applies to the #GObject (or derived)\n struct, the #GObjectClass (or derived) struct, and any private data allocated\n by G_ADD_PRIVATE()."]
pub type GObject = _GObject;
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
pub type GObjectClass = _GObjectClass;
#[doc = " GObject:\n\n The base object type.\n\n All the fields in the `GObject` structure are private to the implementation\n and should never be accessed directly.\n\n Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the\n alignment of the largest basic GLib type (typically this is #guint64 or\n #gdouble). If you need larger alignment for an element in a #GObject, you\n should allocate it on the heap (aligned), or arrange for your #GObject to be\n appropriately padded. This guarantee applies to the #GObject (or derived)\n struct, the #GObjectClass (or derived) struct, and any private data allocated\n by G_ADD_PRIVATE()."]
pub type GInitiallyUnowned = _GObject;
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
pub type GInitiallyUnownedClass = _GObjectClass;
#[doc = " GObjectConstructParam:\n @pspec: the #GParamSpec of the construct parameter\n @value: the value to set the parameter to\n\n The GObjectConstructParam struct is an auxiliary structure used to hand\n #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass."]
pub type GObjectConstructParam = _GObjectConstructParam;
#[doc = " GObjectGetPropertyFunc:\n @object: a #GObject\n @property_id: the numeric id under which the property was registered with\n  g_object_class_install_property().\n @value: a #GValue to return the property value in\n @pspec: the #GParamSpec describing the property\n\n The type of the @get_property function of #GObjectClass."]
pub type GObjectGetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut GObject,
        property_id: guint,
        value: *mut GValue,
        pspec: *mut GParamSpec,
    ),
>;
#[doc = " GObjectSetPropertyFunc:\n @object: a #GObject\n @property_id: the numeric id under which the property was registered with\n  g_object_class_install_property().\n @value: the new value for the property\n @pspec: the #GParamSpec describing the property\n\n The type of the @set_property function of #GObjectClass."]
pub type GObjectSetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut GObject,
        property_id: guint,
        value: *const GValue,
        pspec: *mut GParamSpec,
    ),
>;
#[doc = " GObjectFinalizeFunc:\n @object: the #GObject being finalized\n\n The type of the @finalize function of #GObjectClass."]
pub type GObjectFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>;
#[doc = " GWeakNotify:\n @data: data that was provided when the weak reference was established\n @where_the_object_was: the object being disposed\n\n A #GWeakNotify function can be added to an object as a callback that gets\n triggered when the object is finalized.\n\n Since the object is already being disposed when the #GWeakNotify is called,\n there's not much you could do with the object, apart from e.g. using its\n address as hash-index or the like.\n\n In particular, this means its invalid to call g_object_ref(),\n g_weak_ref_init(), g_weak_ref_set(), g_object_add_toggle_ref(),\n g_object_weak_ref(), g_object_add_weak_pointer() or any function which calls\n them on the object from this callback."]
pub type GWeakNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, where_the_object_was: *mut GObject)>;
#[doc = " GObject:\n\n The base object type.\n\n All the fields in the `GObject` structure are private to the implementation\n and should never be accessed directly.\n\n Since GLib 2.72, all #GObjects are guaranteed to be aligned to at least the\n alignment of the largest basic GLib type (typically this is #guint64 or\n #gdouble). If you need larger alignment for an element in a #GObject, you\n should allocate it on the heap (aligned), or arrange for your #GObject to be\n appropriately padded. This guarantee applies to the #GObject (or derived)\n struct, the #GObjectClass (or derived) struct, and any private data allocated\n by G_ADD_PRIVATE()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[test]
fn bindgen_test_layout__GObject() {
    const UNINIT: ::std::mem::MaybeUninit<_GObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GObject>(),
        24usize,
        concat!("Size of: ", stringify!(_GObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qdata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(qdata)
        )
    );
}
#[doc = " GObjectClass:\n @g_type_class: the parent class\n @constructor: the @constructor function is called by g_object_new () to\n  complete the object initialization after all the construction properties are\n  set. The first thing a @constructor implementation must do is chain up to the\n  @constructor of the parent class. Overriding @constructor should be rarely\n  needed, e.g. to handle construct properties, or to implement singletons.\n @set_property: the generic setter for all properties of this type. Should be\n  overridden for every type with properties. If implementations of\n  @set_property don't emit property change notification explicitly, this will\n  be done implicitly by the type system. However, if the notify signal is\n  emitted explicitly, the type system will not emit it a second time.\n @get_property: the generic getter for all properties of this type. Should be\n  overridden for every type with properties.\n @dispose: the @dispose function is supposed to drop all references to other\n  objects, but keep the instance otherwise intact, so that client method\n  invocations still work. It may be run multiple times (due to reference\n  loops). Before returning, @dispose should chain up to the @dispose method\n  of the parent class.\n @finalize: instance finalization function, should finish the finalization of\n  the instance begun in @dispose and chain up to the @finalize method of the\n  parent class.\n @dispatch_properties_changed: emits property change notification for a bunch\n  of properties. Overriding @dispatch_properties_changed should be rarely\n  needed.\n @notify: the class closure for the notify signal\n @constructed: the @constructed function is called by g_object_new() as the\n  final step of the object creation process.  At the point of the call, all\n  construction properties have been set on the object.  The purpose of this\n  call is to allow for object initialisation steps that can only be performed\n  after construction properties have been set.  @constructed implementors\n  should chain up to the @constructed call of their parent class to allow it\n  to complete its initialisation.\n\n The class structure for the GObject type.\n\n |[<!-- language=\"C\" -->\n // Example of implementing a singleton using a constructor.\n static MySingleton *the_singleton = NULL;\n\n static GObject*\n my_singleton_constructor (GType                  type,\n                           guint                  n_construct_params,\n                           GObjectConstructParam *construct_params)\n {\n   GObject *object;\n\n   if (!the_singleton)\n     {\n       object = G_OBJECT_CLASS (parent_class)->constructor (type,\n                                                            n_construct_params,\n                                                            construct_params);\n       the_singleton = MY_SINGLETON (object);\n     }\n   else\n     object = g_object_ref (G_OBJECT (the_singleton));\n\n   return object;\n }\n ]|"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut GSList,
    pub constructor: ::std::option::Option<
        unsafe extern "C" fn(
            type_: GType,
            n_construct_properties: guint,
            construct_properties: *mut GObjectConstructParam,
        ) -> *mut GObject,
    >,
    pub set_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *const GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub get_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *mut GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub dispose: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub dispatch_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GObject, n_pspecs: guint, pspecs: *mut *mut GParamSpec),
    >,
    pub notify:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, pspec: *mut GParamSpec)>,
    pub constructed: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub flags: gsize,
    pub n_construct_properties: gsize,
    pub pspecs: gpointer,
    pub n_pspecs: gsize,
    pub pdummy: [gpointer; 3usize],
}
#[test]
fn bindgen_test_layout__GObjectClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GObjectClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GObjectClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GObjectClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObjectClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObjectClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).construct_properties) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(construct_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constructor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(constructor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_property) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(set_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_property) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(get_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispose) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(dispose)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finalize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatch_properties_changed) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(dispatch_properties_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).constructed) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(constructed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_construct_properties) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(n_construct_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pspecs) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(pspecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_pspecs) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(n_pspecs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(pdummy)
        )
    );
}
#[doc = " GObjectConstructParam:\n @pspec: the #GParamSpec of the construct parameter\n @value: the value to set the parameter to\n\n The GObjectConstructParam struct is an auxiliary structure used to hand\n #GParamSpec/#GValue pairs to the @constructor of a #GObjectClass."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}
#[test]
fn bindgen_test_layout__GObjectConstructParam() {
    const UNINIT: ::std::mem::MaybeUninit<_GObjectConstructParam> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GObjectConstructParam>(),
        16usize,
        concat!("Size of: ", stringify!(_GObjectConstructParam))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObjectConstructParam>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObjectConstructParam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pspec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectConstructParam),
            "::",
            stringify!(pspec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectConstructParam),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " GInitiallyUnowned:\n\n A type for objects that have an initially floating reference.\n\n All the fields in the `GInitiallyUnowned` structure are private to the\n implementation and should never be accessed directly.\n/\n/**\n GInitiallyUnownedClass:\n\n The class structure for the GInitiallyUnowned type."]
    pub fn g_initially_unowned_get_type() -> GType;
}
extern "C" {
    pub fn g_object_class_install_property(
        oclass: *mut GObjectClass,
        property_id: guint,
        pspec: *mut GParamSpec,
    );
}
extern "C" {
    pub fn g_object_class_find_property(
        oclass: *mut GObjectClass,
        property_name: *const gchar,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_object_class_list_properties(
        oclass: *mut GObjectClass,
        n_properties: *mut guint,
    ) -> *mut *mut GParamSpec;
}
extern "C" {
    pub fn g_object_class_override_property(
        oclass: *mut GObjectClass,
        property_id: guint,
        name: *const gchar,
    );
}
extern "C" {
    pub fn g_object_class_install_properties(
        oclass: *mut GObjectClass,
        n_pspecs: guint,
        pspecs: *mut *mut GParamSpec,
    );
}
extern "C" {
    pub fn g_object_interface_install_property(g_iface: gpointer, pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_object_interface_find_property(
        g_iface: gpointer,
        property_name: *const gchar,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_object_interface_list_properties(
        g_iface: gpointer,
        n_properties_p: *mut guint,
    ) -> *mut *mut GParamSpec;
}
extern "C" {
    pub fn g_object_get_type() -> GType;
}
extern "C" {
    pub fn g_object_new(object_type: GType, first_property_name: *const gchar, ...) -> gpointer;
}
extern "C" {
    pub fn g_object_new_with_properties(
        object_type: GType,
        n_properties: guint,
        names: *mut *const ::std::os::raw::c_char,
        values: *const GValue,
    ) -> *mut GObject;
}
extern "C" {
    pub fn g_object_newv(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
    ) -> gpointer;
}
extern "C" {
    pub fn g_object_new_valist(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    ) -> *mut GObject;
}
extern "C" {
    pub fn g_object_set(object: gpointer, first_property_name: *const gchar, ...);
}
extern "C" {
    pub fn g_object_get(object: gpointer, first_property_name: *const gchar, ...);
}
extern "C" {
    pub fn g_object_connect(object: gpointer, signal_spec: *const gchar, ...) -> gpointer;
}
extern "C" {
    pub fn g_object_disconnect(object: gpointer, signal_spec: *const gchar, ...);
}
extern "C" {
    pub fn g_object_setv(
        object: *mut GObject,
        n_properties: guint,
        names: *mut *const gchar,
        values: *const GValue,
    );
}
extern "C" {
    pub fn g_object_set_valist(
        object: *mut GObject,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn g_object_getv(
        object: *mut GObject,
        n_properties: guint,
        names: *mut *const gchar,
        values: *mut GValue,
    );
}
extern "C" {
    pub fn g_object_get_valist(
        object: *mut GObject,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn g_object_set_property(
        object: *mut GObject,
        property_name: *const gchar,
        value: *const GValue,
    );
}
extern "C" {
    pub fn g_object_get_property(
        object: *mut GObject,
        property_name: *const gchar,
        value: *mut GValue,
    );
}
extern "C" {
    pub fn g_object_freeze_notify(object: *mut GObject);
}
extern "C" {
    pub fn g_object_notify(object: *mut GObject, property_name: *const gchar);
}
extern "C" {
    pub fn g_object_notify_by_pspec(object: *mut GObject, pspec: *mut GParamSpec);
}
extern "C" {
    pub fn g_object_thaw_notify(object: *mut GObject);
}
extern "C" {
    pub fn g_object_is_floating(object: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_object_ref_sink(object: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_object_take_ref(object: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_object_ref(object: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_object_unref(object: gpointer);
}
extern "C" {
    pub fn g_object_weak_ref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
extern "C" {
    pub fn g_object_weak_unref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
extern "C" {
    pub fn g_object_add_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
extern "C" {
    pub fn g_object_remove_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
#[doc = " GToggleNotify:\n @data: Callback data passed to g_object_add_toggle_ref()\n @object: The object on which g_object_add_toggle_ref() was called.\n @is_last_ref: %TRUE if the toggle reference is now the\n  last reference to the object. %FALSE if the toggle\n  reference was the last reference and there are now other\n  references.\n\n A callback function used for notification when the state\n of a toggle reference changes.\n\n See also: g_object_add_toggle_ref()"]
pub type GToggleNotify = ::std::option::Option<
    unsafe extern "C" fn(data: gpointer, object: *mut GObject, is_last_ref: gboolean),
>;
extern "C" {
    pub fn g_object_add_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
extern "C" {
    pub fn g_object_remove_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
extern "C" {
    pub fn g_object_get_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_object_set_qdata(object: *mut GObject, quark: GQuark, data: gpointer);
}
extern "C" {
    pub fn g_object_set_qdata_full(
        object: *mut GObject,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_object_steal_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_object_dup_qdata(
        object: *mut GObject,
        quark: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_object_replace_qdata(
        object: *mut GObject,
        quark: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_object_get_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_object_set_data(object: *mut GObject, key: *const gchar, data: gpointer);
}
extern "C" {
    pub fn g_object_set_data_full(
        object: *mut GObject,
        key: *const gchar,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_object_steal_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_object_dup_data(
        object: *mut GObject,
        key: *const gchar,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_object_replace_data(
        object: *mut GObject,
        key: *const gchar,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_object_watch_closure(object: *mut GObject, closure: *mut GClosure);
}
extern "C" {
    pub fn g_cclosure_new_object(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
}
extern "C" {
    pub fn g_cclosure_new_object_swap(
        callback_func: GCallback,
        object: *mut GObject,
    ) -> *mut GClosure;
}
extern "C" {
    pub fn g_closure_new_object(sizeof_closure: guint, object: *mut GObject) -> *mut GClosure;
}
extern "C" {
    pub fn g_value_set_object(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    pub fn g_value_get_object(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_value_dup_object(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_signal_connect_object(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        gobject: gpointer,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
extern "C" {
    pub fn g_object_force_floating(object: *mut GObject);
}
extern "C" {
    pub fn g_object_run_dispose(object: *mut GObject);
}
extern "C" {
    pub fn g_value_take_object(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    pub fn g_value_set_object_take_ownership(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    pub fn g_object_compat_control(what: gsize, data: gpointer) -> gsize;
}
extern "C" {
    pub fn g_clear_object(object_ptr: *mut *mut GObject);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GWeakRef {
    pub priv_: GWeakRef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GWeakRef__bindgen_ty_1 {
    pub p: gpointer,
}
#[test]
fn bindgen_test_layout_GWeakRef__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<GWeakRef__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GWeakRef__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(GWeakRef__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<GWeakRef__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(GWeakRef__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GWeakRef__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
}
#[test]
fn bindgen_test_layout_GWeakRef() {
    const UNINIT: ::std::mem::MaybeUninit<GWeakRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GWeakRef>(),
        8usize,
        concat!("Size of: ", stringify!(GWeakRef))
    );
    assert_eq!(
        ::std::mem::align_of::<GWeakRef>(),
        8usize,
        concat!("Alignment of ", stringify!(GWeakRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GWeakRef),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_weak_ref_init(weak_ref: *mut GWeakRef, object: gpointer);
}
extern "C" {
    pub fn g_weak_ref_clear(weak_ref: *mut GWeakRef);
}
extern "C" {
    pub fn g_weak_ref_get(weak_ref: *mut GWeakRef) -> gpointer;
}
extern "C" {
    pub fn g_weak_ref_set(weak_ref: *mut GWeakRef, object: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBinding {
    _unused: [u8; 0],
}
#[doc = " GBinding:\n\n GBinding is an opaque structure whose members\n cannot be accessed directly.\n\n Since: 2.26"]
pub type GBinding = _GBinding;
#[doc = " GBindingTransformFunc:\n @binding: a #GBinding\n @from_value: the #GValue containing the value to transform\n @to_value: the #GValue in which to store the transformed value\n @user_data: data passed to the transform function\n\n A function to be called to transform @from_value to @to_value.\n\n If this is the @transform_to function of a binding, then @from_value\n is the @source_property on the @source object, and @to_value is the\n @target_property on the @target object. If this is the\n @transform_from function of a %G_BINDING_BIDIRECTIONAL binding,\n then those roles are reversed.\n\n Returns: %TRUE if the transformation was successful, and %FALSE\n   otherwise\n\n Since: 2.26"]
pub type GBindingTransformFunc = ::std::option::Option<
    unsafe extern "C" fn(
        binding: *mut GBinding,
        from_value: *const GValue,
        to_value: *mut GValue,
        user_data: gpointer,
    ) -> gboolean,
>;
pub const GBindingFlags_G_BINDING_DEFAULT: GBindingFlags = 0;
pub const GBindingFlags_G_BINDING_BIDIRECTIONAL: GBindingFlags = 1;
pub const GBindingFlags_G_BINDING_SYNC_CREATE: GBindingFlags = 2;
pub const GBindingFlags_G_BINDING_INVERT_BOOLEAN: GBindingFlags = 4;
#[doc = " GBindingFlags:\n @G_BINDING_DEFAULT: The default binding; if the source property\n   changes, the target property is updated with its value.\n @G_BINDING_BIDIRECTIONAL: Bidirectional binding; if either the\n   property of the source or the property of the target changes,\n   the other is updated.\n @G_BINDING_SYNC_CREATE: Synchronize the values of the source and\n   target properties when creating the binding; the direction of\n   the synchronization is always from the source to the target.\n @G_BINDING_INVERT_BOOLEAN: If the two properties being bound are\n   booleans, setting one to %TRUE will result in the other being\n   set to %FALSE and vice versa. This flag will only work for\n   boolean properties, and cannot be used when passing custom\n   transformation functions to g_object_bind_property_full().\n\n Flags to be passed to g_object_bind_property() or\n g_object_bind_property_full().\n\n This enumeration can be extended at later date.\n\n Since: 2.26"]
pub type GBindingFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_binding_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_binding_get_type() -> GType;
}
extern "C" {
    pub fn g_binding_get_flags(binding: *mut GBinding) -> GBindingFlags;
}
extern "C" {
    pub fn g_binding_get_source(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    pub fn g_binding_dup_source(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    pub fn g_binding_get_target(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    pub fn g_binding_dup_target(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    pub fn g_binding_get_source_property(binding: *mut GBinding) -> *const gchar;
}
extern "C" {
    pub fn g_binding_get_target_property(binding: *mut GBinding) -> *const gchar;
}
extern "C" {
    pub fn g_binding_unbind(binding: *mut GBinding);
}
extern "C" {
    pub fn g_object_bind_property(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
    ) -> *mut GBinding;
}
extern "C" {
    pub fn g_object_bind_property_full(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> *mut GBinding;
}
extern "C" {
    pub fn g_object_bind_property_with_closures(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    ) -> *mut GBinding;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBindingGroup {
    _unused: [u8; 0],
}
#[doc = " GBindingGroup:\n\n GBindingGroup is an opaque structure whose members\n cannot be accessed directly.\n\n Since: 2.72"]
pub type GBindingGroup = _GBindingGroup;
extern "C" {
    pub fn g_binding_group_get_type() -> GType;
}
extern "C" {
    pub fn g_binding_group_new() -> *mut GBindingGroup;
}
extern "C" {
    pub fn g_binding_group_dup_source(self_: *mut GBindingGroup) -> gpointer;
}
extern "C" {
    pub fn g_binding_group_set_source(self_: *mut GBindingGroup, source: gpointer);
}
extern "C" {
    pub fn g_binding_group_bind(
        self_: *mut GBindingGroup,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
    );
}
extern "C" {
    pub fn g_binding_group_bind_full(
        self_: *mut GBindingGroup,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        user_data_destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_binding_group_bind_with_closures(
        self_: *mut GBindingGroup,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    );
}
#[doc = " GEnumClass:\n @g_type_class: the parent class\n @minimum: the smallest possible value.\n @maximum: the largest possible value.\n @n_values: the number of possible values.\n @values: an array of #GEnumValue structs describing the\n  individual values.\n\n The class of an enumeration type holds information about its\n possible values."]
pub type GEnumClass = _GEnumClass;
#[doc = " GFlagsClass:\n @g_type_class: the parent class\n @mask: a mask covering all possible values.\n @n_values: the number of possible values.\n @values: an array of #GFlagsValue structs describing the\n  individual values.\n\n The class of a flags type holds information about its\n possible values."]
pub type GFlagsClass = _GFlagsClass;
#[doc = " GEnumValue:\n @value: the enum value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single enum value, its name, and its\n nickname."]
pub type GEnumValue = _GEnumValue;
#[doc = " GFlagsValue:\n @value: the flags value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single flags value, its name, and its\n nickname."]
pub type GFlagsValue = _GFlagsValue;
#[doc = " GEnumClass:\n @g_type_class: the parent class\n @minimum: the smallest possible value.\n @maximum: the largest possible value.\n @n_values: the number of possible values.\n @values: an array of #GEnumValue structs describing the\n  individual values.\n\n The class of an enumeration type holds information about its\n possible values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEnumClass {
    pub g_type_class: GTypeClass,
    pub minimum: gint,
    pub maximum: gint,
    pub n_values: guint,
    pub values: *mut GEnumValue,
}
#[test]
fn bindgen_test_layout__GEnumClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GEnumClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GEnumClass>(),
        32usize,
        concat!("Size of: ", stringify!(_GEnumClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEnumClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEnumClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_values) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(values)
        )
    );
}
#[doc = " GFlagsClass:\n @g_type_class: the parent class\n @mask: a mask covering all possible values.\n @n_values: the number of possible values.\n @values: an array of #GFlagsValue structs describing the\n  individual values.\n\n The class of a flags type holds information about its\n possible values."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFlagsClass {
    pub g_type_class: GTypeClass,
    pub mask: guint,
    pub n_values: guint,
    pub values: *mut GFlagsValue,
}
#[test]
fn bindgen_test_layout__GFlagsClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFlagsClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFlagsClass>(),
        24usize,
        concat!("Size of: ", stringify!(_GFlagsClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFlagsClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFlagsClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_type_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_values) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(values)
        )
    );
}
#[doc = " GEnumValue:\n @value: the enum value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single enum value, its name, and its\n nickname."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEnumValue {
    pub value: gint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[test]
fn bindgen_test_layout__GEnumValue() {
    const UNINIT: ::std::mem::MaybeUninit<_GEnumValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GEnumValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GEnumValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEnumValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEnumValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_nick) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value_nick)
        )
    );
}
#[doc = " GFlagsValue:\n @value: the flags value\n @value_name: the name of the value\n @value_nick: the nickname of the value\n\n A structure which contains a single flags value, its name, and its\n nickname."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFlagsValue {
    pub value: guint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[test]
fn bindgen_test_layout__GFlagsValue() {
    const UNINIT: ::std::mem::MaybeUninit<_GFlagsValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFlagsValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GFlagsValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFlagsValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFlagsValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_nick) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value_nick)
        )
    );
}
extern "C" {
    pub fn g_enum_get_value(enum_class: *mut GEnumClass, value: gint) -> *mut GEnumValue;
}
extern "C" {
    pub fn g_enum_get_value_by_name(
        enum_class: *mut GEnumClass,
        name: *const gchar,
    ) -> *mut GEnumValue;
}
extern "C" {
    pub fn g_enum_get_value_by_nick(
        enum_class: *mut GEnumClass,
        nick: *const gchar,
    ) -> *mut GEnumValue;
}
extern "C" {
    pub fn g_flags_get_first_value(flags_class: *mut GFlagsClass, value: guint)
        -> *mut GFlagsValue;
}
extern "C" {
    pub fn g_flags_get_value_by_name(
        flags_class: *mut GFlagsClass,
        name: *const gchar,
    ) -> *mut GFlagsValue;
}
extern "C" {
    pub fn g_flags_get_value_by_nick(
        flags_class: *mut GFlagsClass,
        nick: *const gchar,
    ) -> *mut GFlagsValue;
}
extern "C" {
    pub fn g_enum_to_string(g_enum_type: GType, value: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_flags_to_string(flags_type: GType, value: guint) -> *mut gchar;
}
extern "C" {
    pub fn g_value_set_enum(value: *mut GValue, v_enum: gint);
}
extern "C" {
    pub fn g_value_get_enum(value: *const GValue) -> gint;
}
extern "C" {
    pub fn g_value_set_flags(value: *mut GValue, v_flags: guint);
}
extern "C" {
    pub fn g_value_get_flags(value: *const GValue) -> guint;
}
extern "C" {
    pub fn g_enum_register_static(
        name: *const gchar,
        const_static_values: *const GEnumValue,
    ) -> GType;
}
extern "C" {
    pub fn g_flags_register_static(
        name: *const gchar,
        const_static_values: *const GFlagsValue,
    ) -> GType;
}
extern "C" {
    pub fn g_enum_complete_type_info(
        g_enum_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GEnumValue,
    );
}
extern "C" {
    pub fn g_flags_complete_type_info(
        g_flags_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GFlagsValue,
    );
}
extern "C" {
    pub fn g_unicode_type_get_type() -> GType;
}
extern "C" {
    pub fn g_unicode_break_type_get_type() -> GType;
}
extern "C" {
    pub fn g_unicode_script_get_type() -> GType;
}
extern "C" {
    pub fn g_normalize_mode_get_type() -> GType;
}
#[doc = " GParamSpecChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for character properties."]
pub type GParamSpecChar = _GParamSpecChar;
#[doc = " GParamSpecUChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned character properties."]
pub type GParamSpecUChar = _GParamSpecUChar;
#[doc = " GParamSpecBoolean:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for boolean properties."]
pub type GParamSpecBoolean = _GParamSpecBoolean;
#[doc = " GParamSpecInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for integer properties."]
pub type GParamSpecInt = _GParamSpecInt;
#[doc = " GParamSpecUInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned integer properties."]
pub type GParamSpecUInt = _GParamSpecUInt;
#[doc = " GParamSpecLong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for long integer properties."]
pub type GParamSpecLong = _GParamSpecLong;
#[doc = " GParamSpecULong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned long integer properties."]
pub type GParamSpecULong = _GParamSpecULong;
#[doc = " GParamSpecInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for 64bit integer properties."]
pub type GParamSpecInt64 = _GParamSpecInt64;
#[doc = " GParamSpecUInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties."]
pub type GParamSpecUInt64 = _GParamSpecUInt64;
#[doc = " GParamSpecUnichar:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties."]
pub type GParamSpecUnichar = _GParamSpecUnichar;
#[doc = " GParamSpecEnum:\n @parent_instance: private #GParamSpec portion\n @enum_class: the #GEnumClass for the enum\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for enum\n properties."]
pub type GParamSpecEnum = _GParamSpecEnum;
#[doc = " GParamSpecFlags:\n @parent_instance: private #GParamSpec portion\n @flags_class: the #GFlagsClass for the flags\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for flags\n properties."]
pub type GParamSpecFlags = _GParamSpecFlags;
#[doc = " GParamSpecFloat:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-30.\n\n A #GParamSpec derived structure that contains the meta data for float properties."]
pub type GParamSpecFloat = _GParamSpecFloat;
#[doc = " GParamSpecDouble:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-90.\n\n A #GParamSpec derived structure that contains the meta data for double properties."]
pub type GParamSpecDouble = _GParamSpecDouble;
#[doc = " GParamSpecString:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n @cset_first: a string containing the allowed values for the first byte\n @cset_nth: a string containing the allowed values for the subsequent bytes\n @substitutor: the replacement byte for bytes which don't match @cset_first or @cset_nth.\n @null_fold_if_empty: replace empty string by %NULL\n @ensure_non_null: replace %NULL strings by an empty string\n\n A #GParamSpec derived structure that contains the meta data for string\n properties."]
pub type GParamSpecString = _GParamSpecString;
#[doc = " GParamSpecParam:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM\n properties."]
pub type GParamSpecParam = _GParamSpecParam;
#[doc = " GParamSpecBoxed:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for boxed properties."]
pub type GParamSpecBoxed = _GParamSpecBoxed;
#[doc = " GParamSpecPointer:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for pointer properties."]
pub type GParamSpecPointer = _GParamSpecPointer;
#[doc = " GParamSpecValueArray:\n @parent_instance: private #GParamSpec portion\n @element_spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL\n @fixed_n_elements: if greater than 0, arrays of this property will always have this many elements\n\n A #GParamSpec derived structure that contains the meta data for #GValueArray properties."]
pub type GParamSpecValueArray = _GParamSpecValueArray;
#[doc = " GParamSpecObject:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for object properties."]
pub type GParamSpecObject = _GParamSpecObject;
#[doc = " GParamSpecOverride:\n\n A #GParamSpec derived structure that redirects operations to\n other types of #GParamSpec.\n\n All operations other than getting or setting the value are redirected,\n including accessing the nick and blurb, validating a value, and so\n forth.\n\n See g_param_spec_get_redirect_target() for retrieving the overridden\n property. #GParamSpecOverride is used in implementing\n g_object_class_override_property(), and will not be directly useful\n unless you are implementing a new base type similar to GObject.\n\n Since: 2.4"]
pub type GParamSpecOverride = _GParamSpecOverride;
#[doc = " GParamSpecGType:\n @parent_instance: private #GParamSpec portion\n @is_a_type: a #GType whose subtypes can occur as values\n\n A #GParamSpec derived structure that contains the meta data for #GType properties.\n\n Since: 2.10"]
pub type GParamSpecGType = _GParamSpecGType;
#[doc = " GParamSpecVariant:\n @parent_instance: private #GParamSpec portion\n @type: a #GVariantType, or %NULL\n @default_value: a #GVariant, or %NULL\n\n A #GParamSpec derived structure that contains the meta data for #GVariant properties.\n\n When comparing values with g_param_values_cmp(), scalar values with the same\n type will be compared with g_variant_compare(). Other non-%NULL variants will\n be checked for equality with g_variant_equal(), and their sort order is\n otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL\n values compare equal.\n\n Since: 2.26"]
pub type GParamSpecVariant = _GParamSpecVariant;
#[doc = " GParamSpecChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for character properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecChar {
    pub parent_instance: GParamSpec,
    pub minimum: gint8,
    pub maximum: gint8,
    pub default_value: gint8,
}
#[test]
fn bindgen_test_layout__GParamSpecChar() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecChar> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecChar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecChar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecChar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecChar))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecUChar:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned character properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUChar {
    pub parent_instance: GParamSpec,
    pub minimum: guint8,
    pub maximum: guint8,
    pub default_value: guint8,
}
#[test]
fn bindgen_test_layout__GParamSpecUChar() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecUChar> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUChar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecUChar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUChar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUChar))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecBoolean:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for boolean properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecBoolean {
    pub parent_instance: GParamSpec,
    pub default_value: gboolean,
}
#[test]
fn bindgen_test_layout__GParamSpecBoolean() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecBoolean> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecBoolean>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecBoolean))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecBoolean>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecBoolean))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoolean),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoolean),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecInt {
    pub parent_instance: GParamSpec,
    pub minimum: gint,
    pub maximum: gint,
    pub default_value: gint,
}
#[test]
fn bindgen_test_layout__GParamSpecInt() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecInt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecInt>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecInt))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecInt>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecInt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecUInt:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUInt {
    pub parent_instance: GParamSpec,
    pub minimum: guint,
    pub maximum: guint,
    pub default_value: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecUInt() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecUInt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUInt>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecUInt))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUInt>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUInt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecLong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for long integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecLong {
    pub parent_instance: GParamSpec,
    pub minimum: glong,
    pub maximum: glong,
    pub default_value: glong,
}
#[test]
fn bindgen_test_layout__GParamSpecLong() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecLong> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecLong>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecLong))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecLong>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecLong))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecULong:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned long integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecULong {
    pub parent_instance: GParamSpec,
    pub minimum: gulong,
    pub maximum: gulong,
    pub default_value: gulong,
}
#[test]
fn bindgen_test_layout__GParamSpecULong() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecULong> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecULong>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecULong))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecULong>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecULong))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for 64bit integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: gint64,
    pub maximum: gint64,
    pub default_value: gint64,
}
#[test]
fn bindgen_test_layout__GParamSpecInt64() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecInt64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecInt64>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecInt64))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecInt64>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecInt64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecUInt64:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: guint64,
    pub maximum: guint64,
    pub default_value: guint64,
}
#[test]
fn bindgen_test_layout__GParamSpecUInt64() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecUInt64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUInt64>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecUInt64))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUInt64>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUInt64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecUnichar:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUnichar {
    pub parent_instance: GParamSpec,
    pub default_value: gunichar,
}
#[test]
fn bindgen_test_layout__GParamSpecUnichar() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecUnichar> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUnichar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecUnichar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUnichar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUnichar))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUnichar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUnichar),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecEnum:\n @parent_instance: private #GParamSpec portion\n @enum_class: the #GEnumClass for the enum\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for enum\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecEnum {
    pub parent_instance: GParamSpec,
    pub enum_class: *mut GEnumClass,
    pub default_value: gint,
}
#[test]
fn bindgen_test_layout__GParamSpecEnum() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecEnum> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecEnum>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecEnum))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecEnum>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecEnum))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enum_class) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(enum_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecFlags:\n @parent_instance: private #GParamSpec portion\n @flags_class: the #GFlagsClass for the flags\n @default_value: default value for the property specified\n\n A #GParamSpec derived structure that contains the meta data for flags\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecFlags {
    pub parent_instance: GParamSpec,
    pub flags_class: *mut GFlagsClass,
    pub default_value: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecFlags() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecFlags> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecFlags>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecFlags>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecFlags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags_class) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(flags_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(default_value)
        )
    );
}
#[doc = " GParamSpecFloat:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-30.\n\n A #GParamSpec derived structure that contains the meta data for float properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecFloat {
    pub parent_instance: GParamSpec,
    pub minimum: gfloat,
    pub maximum: gfloat,
    pub default_value: gfloat,
    pub epsilon: gfloat,
}
#[test]
fn bindgen_test_layout__GParamSpecFloat() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecFloat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecFloat>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecFloat>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecFloat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epsilon) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(epsilon)
        )
    );
}
#[doc = " GParamSpecDouble:\n @parent_instance: private #GParamSpec portion\n @minimum: minimum value for the property specified\n @maximum: maximum value for the property specified\n @default_value: default value for the property specified\n @epsilon: values closer than @epsilon will be considered identical\n  by g_param_values_cmp(); the default value is 1e-90.\n\n A #GParamSpec derived structure that contains the meta data for double properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecDouble {
    pub parent_instance: GParamSpec,
    pub minimum: gdouble,
    pub maximum: gdouble,
    pub default_value: gdouble,
    pub epsilon: gdouble,
}
#[test]
fn bindgen_test_layout__GParamSpecDouble() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecDouble> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecDouble>(),
        104usize,
        concat!("Size of: ", stringify!(_GParamSpecDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecDouble))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minimum) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maximum) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).epsilon) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(epsilon)
        )
    );
}
#[doc = " GParamSpecString:\n @parent_instance: private #GParamSpec portion\n @default_value: default value for the property specified\n @cset_first: a string containing the allowed values for the first byte\n @cset_nth: a string containing the allowed values for the subsequent bytes\n @substitutor: the replacement byte for bytes which don't match @cset_first or @cset_nth.\n @null_fold_if_empty: replace empty string by %NULL\n @ensure_non_null: replace %NULL strings by an empty string\n\n A #GParamSpec derived structure that contains the meta data for string\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecString {
    pub parent_instance: GParamSpec,
    pub default_value: *mut gchar,
    pub cset_first: *mut gchar,
    pub cset_nth: *mut gchar,
    pub substitutor: gchar,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[test]
fn bindgen_test_layout__GParamSpecString() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecString>(),
        104usize,
        concat!("Size of: ", stringify!(_GParamSpecString))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_first) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(cset_first)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cset_nth) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(cset_nth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).substitutor) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(substitutor)
        )
    );
}
impl _GParamSpecString {
    #[inline]
    pub fn null_fold_if_empty(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_null_fold_if_empty(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ensure_non_null(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ensure_non_null(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        null_fold_if_empty: guint,
        ensure_non_null: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let null_fold_if_empty: u32 = unsafe { ::std::mem::transmute(null_fold_if_empty) };
            null_fold_if_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ensure_non_null: u32 = unsafe { ::std::mem::transmute(ensure_non_null) };
            ensure_non_null as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " GParamSpecParam:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM\n properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecParam {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecParam() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecParam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecParam>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecParam))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecParam>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecParam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecParam),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GParamSpecBoxed:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for boxed properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecBoxed {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecBoxed() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecBoxed> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecBoxed>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecBoxed))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecBoxed>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecBoxed))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoxed),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GParamSpecPointer:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for pointer properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPointer {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecPointer() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecPointer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecPointer>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecPointer))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecPointer>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecPointer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecPointer),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GParamSpecValueArray:\n @parent_instance: private #GParamSpec portion\n @element_spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL\n @fixed_n_elements: if greater than 0, arrays of this property will always have this many elements\n\n A #GParamSpec derived structure that contains the meta data for #GValueArray properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecValueArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
    pub fixed_n_elements: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecValueArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecValueArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecValueArray>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecValueArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecValueArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecValueArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element_spec) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(element_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fixed_n_elements) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(fixed_n_elements)
        )
    );
}
#[doc = " GParamSpecObject:\n @parent_instance: private #GParamSpec portion\n\n A #GParamSpec derived structure that contains the meta data for object properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecObject {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecObject() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecObject>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecObject),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GParamSpecOverride:\n\n A #GParamSpec derived structure that redirects operations to\n other types of #GParamSpec.\n\n All operations other than getting or setting the value are redirected,\n including accessing the nick and blurb, validating a value, and so\n forth.\n\n See g_param_spec_get_redirect_target() for retrieving the overridden\n property. #GParamSpecOverride is used in implementing\n g_object_class_override_property(), and will not be directly useful\n unless you are implementing a new base type similar to GObject.\n\n Since: 2.4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecOverride {
    pub parent_instance: GParamSpec,
    pub overridden: *mut GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecOverride() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecOverride> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecOverride>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecOverride))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecOverride>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecOverride))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecOverride),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overridden) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecOverride),
            "::",
            stringify!(overridden)
        )
    );
}
#[doc = " GParamSpecGType:\n @parent_instance: private #GParamSpec portion\n @is_a_type: a #GType whose subtypes can occur as values\n\n A #GParamSpec derived structure that contains the meta data for #GType properties.\n\n Since: 2.10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecGType {
    pub parent_instance: GParamSpec,
    pub is_a_type: GType,
}
#[test]
fn bindgen_test_layout__GParamSpecGType() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecGType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecGType>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecGType))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecGType>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecGType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecGType),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_a_type) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecGType),
            "::",
            stringify!(is_a_type)
        )
    );
}
#[doc = " GParamSpecVariant:\n @parent_instance: private #GParamSpec portion\n @type: a #GVariantType, or %NULL\n @default_value: a #GVariant, or %NULL\n\n A #GParamSpec derived structure that contains the meta data for #GVariant properties.\n\n When comparing values with g_param_values_cmp(), scalar values with the same\n type will be compared with g_variant_compare(). Other non-%NULL variants will\n be checked for equality with g_variant_equal(), and their sort order is\n otherwise undefined. %NULL is ordered before non-%NULL variants. Two %NULL\n values compare equal.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecVariant {
    pub parent_instance: GParamSpec,
    pub type_: *mut GVariantType,
    pub default_value: *mut GVariant,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GParamSpecVariant() {
    const UNINIT: ::std::mem::MaybeUninit<_GParamSpecVariant> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecVariant>(),
        120usize,
        concat!("Size of: ", stringify!(_GParamSpecVariant))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecVariant>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecVariant))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).default_value) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_param_spec_char(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint8,
        maximum: gint8,
        default_value: gint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_uchar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint8,
        maximum: guint8,
        default_value: guint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_boolean(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gboolean,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_int(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint,
        maximum: gint,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_uint(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint,
        maximum: guint,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_long(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: glong,
        maximum: glong,
        default_value: glong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_ulong(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gulong,
        maximum: gulong,
        default_value: gulong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_int64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint64,
        maximum: gint64,
        default_value: gint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_uint64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint64,
        maximum: guint64,
        default_value: guint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_unichar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gunichar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_enum(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        enum_type: GType,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_flags(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags_type: GType,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_float(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gfloat,
        maximum: gfloat,
        default_value: gfloat,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_double(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gdouble,
        maximum: gdouble,
        default_value: gdouble,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_string(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_param(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        param_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_boxed(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        boxed_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_pointer(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_value_array(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        element_spec: *mut GParamSpec,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_object(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        object_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_override(
        name: *const gchar,
        overridden: *mut GParamSpec,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_gtype(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        is_a_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub fn g_param_spec_variant(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        type_: *const GVariantType,
        default_value: *mut GVariant,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    pub static mut g_param_spec_types: *mut GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalGroup {
    _unused: [u8; 0],
}
#[doc = " GSignalGroup:\n\n #GSignalGroup is an opaque structure whose members\n cannot be accessed directly.\n\n Since: 2.72"]
pub type GSignalGroup = _GSignalGroup;
extern "C" {
    pub fn g_signal_group_get_type() -> GType;
}
extern "C" {
    pub fn g_signal_group_new(target_type: GType) -> *mut GSignalGroup;
}
extern "C" {
    pub fn g_signal_group_set_target(self_: *mut GSignalGroup, target: gpointer);
}
extern "C" {
    pub fn g_signal_group_dup_target(self_: *mut GSignalGroup) -> gpointer;
}
extern "C" {
    pub fn g_signal_group_block(self_: *mut GSignalGroup);
}
extern "C" {
    pub fn g_signal_group_unblock(self_: *mut GSignalGroup);
}
extern "C" {
    pub fn g_signal_group_connect_closure(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        closure: *mut GClosure,
        after: gboolean,
    );
}
extern "C" {
    pub fn g_signal_group_connect_object(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        object: gpointer,
        flags: GConnectFlags,
    );
}
extern "C" {
    pub fn g_signal_group_connect_data(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
        notify: GClosureNotify,
        flags: GConnectFlags,
    );
}
extern "C" {
    pub fn g_signal_group_connect(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_signal_group_connect_after(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_signal_group_connect_swapped(
        self_: *mut GSignalGroup,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_source_set_closure(source: *mut GSource, closure: *mut GClosure);
}
extern "C" {
    pub fn g_source_set_dummy_callback(source: *mut GSource);
}
#[doc = " GTypeModule:\n @name: the name of the module\n\n The members of the GTypeModule structure should not\n be accessed directly, except for the @name field."]
pub type GTypeModule = _GTypeModule;
#[doc = " GTypeModuleClass:\n @parent_class: the parent class\n @load: loads the module and registers one or more types using\n  g_type_module_register_type().\n @unload: unloads the module\n\n In order to implement dynamic loading of types based on #GTypeModule,\n the @load and @unload functions in #GTypeModuleClass must be implemented."]
pub type GTypeModuleClass = _GTypeModuleClass;
pub type GTypeModule_autoptr = *mut GTypeModule;
pub type GTypeModule_listautoptr = *mut GList;
pub type GTypeModule_slistautoptr = *mut GSList;
pub type GTypeModule_queueautoptr = *mut GQueue;
#[doc = " GTypeModule:\n @name: the name of the module\n\n The members of the GTypeModule structure should not\n be accessed directly, except for the @name field."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeModule {
    pub parent_instance: GObject,
    pub use_count: guint,
    pub type_infos: *mut GSList,
    pub interface_infos: *mut GSList,
    pub name: *mut gchar,
}
#[test]
fn bindgen_test_layout__GTypeModule() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeModule> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeModule>(),
        56usize,
        concat!("Size of: ", stringify!(_GTypeModule))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeModule>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeModule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(use_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_infos) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(type_infos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_infos) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(interface_infos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " GTypeModuleClass:\n @parent_class: the parent class\n @load: loads the module and registers one or more types using\n  g_type_module_register_type().\n @unload: unloads the module\n\n In order to implement dynamic loading of types based on #GTypeModule,\n the @load and @unload functions in #GTypeModuleClass must be implemented."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeModuleClass {
    pub parent_class: GObjectClass,
    pub load: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule) -> gboolean>,
    pub unload: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule)>,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GTypeModuleClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypeModuleClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypeModuleClass>(),
        184usize,
        concat!("Size of: ", stringify!(_GTypeModuleClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeModuleClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeModuleClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unload) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(unload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved4)
        )
    );
}
extern "C" {
    pub fn g_type_module_get_type() -> GType;
}
extern "C" {
    pub fn g_type_module_use(module: *mut GTypeModule) -> gboolean;
}
extern "C" {
    pub fn g_type_module_unuse(module: *mut GTypeModule);
}
extern "C" {
    pub fn g_type_module_set_name(module: *mut GTypeModule, name: *const gchar);
}
extern "C" {
    pub fn g_type_module_register_type(
        module: *mut GTypeModule,
        parent_type: GType,
        type_name: *const gchar,
        type_info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    pub fn g_type_module_add_interface(
        module: *mut GTypeModule,
        instance_type: GType,
        interface_type: GType,
        interface_info: *const GInterfaceInfo,
    );
}
extern "C" {
    pub fn g_type_module_register_enum(
        module: *mut GTypeModule,
        name: *const gchar,
        const_static_values: *const GEnumValue,
    ) -> GType;
}
extern "C" {
    pub fn g_type_module_register_flags(
        module: *mut GTypeModule,
        name: *const gchar,
        const_static_values: *const GFlagsValue,
    ) -> GType;
}
#[doc = " GTypePlugin:\n\n The GTypePlugin typedef is used as a placeholder\n for objects that implement the GTypePlugin interface.\n/\n/**\n GTypePluginClass:\n @use_plugin: Increases the use count of the plugin.\n @unuse_plugin: Decreases the use count of the plugin.\n @complete_type_info: Fills in the #GTypeInfo and\n  #GTypeValueTable structs for the type. The structs are initialized\n  with `memset(s, 0, sizeof (s))` before calling this function.\n @complete_interface_info: Fills in missing parts of the #GInterfaceInfo\n  for the interface. The structs is initialized with\n  `memset(s, 0, sizeof (s))` before calling this function.\n\n The #GTypePlugin interface is used by the type system in order to handle\n the lifecycle of dynamically loaded types."]
pub type GTypePluginClass = _GTypePluginClass;
#[doc = " GTypePluginUse:\n @plugin: the #GTypePlugin whose use count should be increased\n\n The type of the @use_plugin function of #GTypePluginClass, which gets called\n to increase the use count of @plugin."]
pub type GTypePluginUse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
#[doc = " GTypePluginUnuse:\n @plugin: the #GTypePlugin whose use count should be decreased\n\n The type of the @unuse_plugin function of #GTypePluginClass."]
pub type GTypePluginUnuse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
#[doc = " GTypePluginCompleteTypeInfo:\n @plugin: the #GTypePlugin\n @g_type: the #GType whose info is completed\n @info: the #GTypeInfo struct to fill in\n @value_table: the #GTypeValueTable to fill in\n\n The type of the @complete_type_info function of #GTypePluginClass."]
pub type GTypePluginCompleteTypeInfo = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    ),
>;
#[doc = " GTypePluginCompleteInterfaceInfo:\n @plugin: the #GTypePlugin\n @instance_type: the #GType of an instantiatable type to which the interface\n  is added\n @interface_type: the #GType of the interface whose info is completed\n @info: the #GInterfaceInfo to fill in\n\n The type of the @complete_interface_info function of #GTypePluginClass."]
pub type GTypePluginCompleteInterfaceInfo = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    ),
>;
#[doc = " GTypePlugin:\n\n The GTypePlugin typedef is used as a placeholder\n for objects that implement the GTypePlugin interface.\n/\n/**\n GTypePluginClass:\n @use_plugin: Increases the use count of the plugin.\n @unuse_plugin: Decreases the use count of the plugin.\n @complete_type_info: Fills in the #GTypeInfo and\n  #GTypeValueTable structs for the type. The structs are initialized\n  with `memset(s, 0, sizeof (s))` before calling this function.\n @complete_interface_info: Fills in missing parts of the #GInterfaceInfo\n  for the interface. The structs is initialized with\n  `memset(s, 0, sizeof (s))` before calling this function.\n\n The #GTypePlugin interface is used by the type system in order to handle\n the lifecycle of dynamically loaded types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePluginClass {
    pub base_iface: GTypeInterface,
    pub use_plugin: GTypePluginUse,
    pub unuse_plugin: GTypePluginUnuse,
    pub complete_type_info: GTypePluginCompleteTypeInfo,
    pub complete_interface_info: GTypePluginCompleteInterfaceInfo,
}
#[test]
fn bindgen_test_layout__GTypePluginClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTypePluginClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTypePluginClass>(),
        48usize,
        concat!("Size of: ", stringify!(_GTypePluginClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypePluginClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypePluginClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(base_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_plugin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(use_plugin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unuse_plugin) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(unuse_plugin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).complete_type_info) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(complete_type_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).complete_interface_info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(complete_interface_info)
        )
    );
}
extern "C" {
    pub fn g_type_plugin_get_type() -> GType;
}
extern "C" {
    pub fn g_type_plugin_use(plugin: *mut GTypePlugin);
}
extern "C" {
    pub fn g_type_plugin_unuse(plugin: *mut GTypePlugin);
}
extern "C" {
    pub fn g_type_plugin_complete_type_info(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    );
}
extern "C" {
    pub fn g_type_plugin_complete_interface_info(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    );
}
#[doc = " GValueArray:\n @n_values: number of values contained in the array\n @values: array of values\n\n A #GValueArray contains an array of #GValue elements."]
pub type GValueArray = _GValueArray;
#[doc = " GValueArray:\n @n_values: number of values contained in the array\n @values: array of values\n\n A #GValueArray contains an array of #GValue elements."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GValueArray {
    pub n_values: guint,
    pub values: *mut GValue,
    pub n_prealloced: guint,
}
#[test]
fn bindgen_test_layout__GValueArray() {
    const UNINIT: ::std::mem::MaybeUninit<_GValueArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GValueArray>(),
        24usize,
        concat!("Size of: ", stringify!(_GValueArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValueArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValueArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_prealloced) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(n_prealloced)
        )
    );
}
extern "C" {
    pub fn g_value_array_get_type() -> GType;
}
extern "C" {
    pub fn g_value_array_get_nth(value_array: *mut GValueArray, index_: guint) -> *mut GValue;
}
extern "C" {
    pub fn g_value_array_new(n_prealloced: guint) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_free(value_array: *mut GValueArray);
}
extern "C" {
    pub fn g_value_array_copy(value_array: *const GValueArray) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_prepend(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_append(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_insert(
        value_array: *mut GValueArray,
        index_: guint,
        value: *const GValue,
    ) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_remove(value_array: *mut GValueArray, index_: guint) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_sort(
        value_array: *mut GValueArray,
        compare_func: GCompareFunc,
    ) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_array_sort_with_data(
        value_array: *mut GValueArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GValueArray;
}
extern "C" {
    pub fn g_value_set_char(value: *mut GValue, v_char: gchar);
}
extern "C" {
    pub fn g_value_get_char(value: *const GValue) -> gchar;
}
extern "C" {
    pub fn g_value_set_schar(value: *mut GValue, v_char: gint8);
}
extern "C" {
    pub fn g_value_get_schar(value: *const GValue) -> gint8;
}
extern "C" {
    pub fn g_value_set_uchar(value: *mut GValue, v_uchar: guchar);
}
extern "C" {
    pub fn g_value_get_uchar(value: *const GValue) -> guchar;
}
extern "C" {
    pub fn g_value_set_boolean(value: *mut GValue, v_boolean: gboolean);
}
extern "C" {
    pub fn g_value_get_boolean(value: *const GValue) -> gboolean;
}
extern "C" {
    pub fn g_value_set_int(value: *mut GValue, v_int: gint);
}
extern "C" {
    pub fn g_value_get_int(value: *const GValue) -> gint;
}
extern "C" {
    pub fn g_value_set_uint(value: *mut GValue, v_uint: guint);
}
extern "C" {
    pub fn g_value_get_uint(value: *const GValue) -> guint;
}
extern "C" {
    pub fn g_value_set_long(value: *mut GValue, v_long: glong);
}
extern "C" {
    pub fn g_value_get_long(value: *const GValue) -> glong;
}
extern "C" {
    pub fn g_value_set_ulong(value: *mut GValue, v_ulong: gulong);
}
extern "C" {
    pub fn g_value_get_ulong(value: *const GValue) -> gulong;
}
extern "C" {
    pub fn g_value_set_int64(value: *mut GValue, v_int64: gint64);
}
extern "C" {
    pub fn g_value_get_int64(value: *const GValue) -> gint64;
}
extern "C" {
    pub fn g_value_set_uint64(value: *mut GValue, v_uint64: guint64);
}
extern "C" {
    pub fn g_value_get_uint64(value: *const GValue) -> guint64;
}
extern "C" {
    pub fn g_value_set_float(value: *mut GValue, v_float: gfloat);
}
extern "C" {
    pub fn g_value_get_float(value: *const GValue) -> gfloat;
}
extern "C" {
    pub fn g_value_set_double(value: *mut GValue, v_double: gdouble);
}
extern "C" {
    pub fn g_value_get_double(value: *const GValue) -> gdouble;
}
extern "C" {
    pub fn g_value_set_string(value: *mut GValue, v_string: *const gchar);
}
extern "C" {
    pub fn g_value_set_static_string(value: *mut GValue, v_string: *const gchar);
}
extern "C" {
    pub fn g_value_set_interned_string(value: *mut GValue, v_string: *const gchar);
}
extern "C" {
    pub fn g_value_get_string(value: *const GValue) -> *const gchar;
}
extern "C" {
    pub fn g_value_dup_string(value: *const GValue) -> *mut gchar;
}
extern "C" {
    pub fn g_value_set_pointer(value: *mut GValue, v_pointer: gpointer);
}
extern "C" {
    pub fn g_value_get_pointer(value: *const GValue) -> gpointer;
}
extern "C" {
    pub fn g_gtype_get_type() -> GType;
}
extern "C" {
    pub fn g_value_set_gtype(value: *mut GValue, v_gtype: GType);
}
extern "C" {
    pub fn g_value_get_gtype(value: *const GValue) -> GType;
}
extern "C" {
    pub fn g_value_set_variant(value: *mut GValue, variant: *mut GVariant);
}
extern "C" {
    pub fn g_value_take_variant(value: *mut GValue, variant: *mut GVariant);
}
extern "C" {
    pub fn g_value_get_variant(value: *const GValue) -> *mut GVariant;
}
extern "C" {
    pub fn g_value_dup_variant(value: *const GValue) -> *mut GVariant;
}
extern "C" {
    pub fn g_pointer_type_register_static(name: *const gchar) -> GType;
}
extern "C" {
    pub fn g_strdup_value_contents(value: *const GValue) -> *mut gchar;
}
extern "C" {
    pub fn g_value_take_string(value: *mut GValue, v_string: *mut gchar);
}
extern "C" {
    pub fn g_value_set_string_take_ownership(value: *mut GValue, v_string: *mut gchar);
}
#[doc = " gchararray:\n\n A C representable type name for %G_TYPE_STRING."]
pub type gchararray = *mut gchar;
pub type GClosure_autoptr = *mut GClosure;
pub type GClosure_listautoptr = *mut GList;
pub type GClosure_slistautoptr = *mut GSList;
pub type GClosure_queueautoptr = *mut GQueue;
pub type GEnumClass_autoptr = *mut GEnumClass;
pub type GEnumClass_listautoptr = *mut GList;
pub type GEnumClass_slistautoptr = *mut GSList;
pub type GEnumClass_queueautoptr = *mut GQueue;
pub type GFlagsClass_autoptr = *mut GFlagsClass;
pub type GFlagsClass_listautoptr = *mut GList;
pub type GFlagsClass_slistautoptr = *mut GSList;
pub type GFlagsClass_queueautoptr = *mut GQueue;
pub type GObject_autoptr = *mut GObject;
pub type GObject_listautoptr = *mut GList;
pub type GObject_slistautoptr = *mut GSList;
pub type GObject_queueautoptr = *mut GQueue;
pub type GInitiallyUnowned_autoptr = *mut GInitiallyUnowned;
pub type GInitiallyUnowned_listautoptr = *mut GList;
pub type GInitiallyUnowned_slistautoptr = *mut GSList;
pub type GInitiallyUnowned_queueautoptr = *mut GQueue;
pub type GParamSpec_autoptr = *mut GParamSpec;
pub type GParamSpec_listautoptr = *mut GList;
pub type GParamSpec_slistautoptr = *mut GSList;
pub type GParamSpec_queueautoptr = *mut GQueue;
pub type GTypeClass_autoptr = *mut GTypeClass;
pub type GTypeClass_listautoptr = *mut GList;
pub type GTypeClass_slistautoptr = *mut GSList;
pub type GTypeClass_queueautoptr = *mut GQueue;
pub const IBusModifierType_IBUS_SHIFT_MASK: IBusModifierType = 1;
pub const IBusModifierType_IBUS_LOCK_MASK: IBusModifierType = 2;
pub const IBusModifierType_IBUS_CONTROL_MASK: IBusModifierType = 4;
pub const IBusModifierType_IBUS_MOD1_MASK: IBusModifierType = 8;
pub const IBusModifierType_IBUS_MOD2_MASK: IBusModifierType = 16;
pub const IBusModifierType_IBUS_MOD3_MASK: IBusModifierType = 32;
pub const IBusModifierType_IBUS_MOD4_MASK: IBusModifierType = 64;
pub const IBusModifierType_IBUS_MOD5_MASK: IBusModifierType = 128;
pub const IBusModifierType_IBUS_BUTTON1_MASK: IBusModifierType = 256;
pub const IBusModifierType_IBUS_BUTTON2_MASK: IBusModifierType = 512;
pub const IBusModifierType_IBUS_BUTTON3_MASK: IBusModifierType = 1024;
pub const IBusModifierType_IBUS_BUTTON4_MASK: IBusModifierType = 2048;
pub const IBusModifierType_IBUS_BUTTON5_MASK: IBusModifierType = 4096;
pub const IBusModifierType_IBUS_HANDLED_MASK: IBusModifierType = 16777216;
pub const IBusModifierType_IBUS_FORWARD_MASK: IBusModifierType = 33554432;
pub const IBusModifierType_IBUS_IGNORED_MASK: IBusModifierType = 33554432;
pub const IBusModifierType_IBUS_SUPER_MASK: IBusModifierType = 67108864;
pub const IBusModifierType_IBUS_HYPER_MASK: IBusModifierType = 134217728;
pub const IBusModifierType_IBUS_META_MASK: IBusModifierType = 268435456;
pub const IBusModifierType_IBUS_RELEASE_MASK: IBusModifierType = 1073741824;
pub const IBusModifierType_IBUS_MODIFIER_MASK: IBusModifierType = 1593843711;
#[doc = " IBusModifierType:\n @IBUS_SHIFT_MASK: Shift  is activated.\n @IBUS_LOCK_MASK: Cap Lock is locked.\n @IBUS_CONTROL_MASK: Control key is activated.\n @IBUS_MOD1_MASK: Modifier 1 (Usually Alt_L (0x40),  Alt_R (0x6c),  Meta_L (0xcd)) activated.\n @IBUS_MOD2_MASK: Modifier 2 (Usually Num_Lock (0x4d)) activated.\n @IBUS_MOD3_MASK: Modifier 3 activated.\n @IBUS_MOD4_MASK: Modifier 4 (Usually Super_L (0xce),  Hyper_L (0xcf)) activated.\n @IBUS_MOD5_MASK: Modifier 5 (ISO_Level3_Shift (0x5c),  Mode_switch (0xcb)) activated.\n @IBUS_BUTTON1_MASK: Mouse button 1 (left) is activated.\n @IBUS_BUTTON2_MASK: Mouse button 2 (middle) is activated.\n @IBUS_BUTTON3_MASK: Mouse button 3 (right) is activated.\n @IBUS_BUTTON4_MASK: Mouse button 4 (scroll up) is activated.\n @IBUS_BUTTON5_MASK: Mouse button 5 (scroll down) is activated.\n @IBUS_HANDLED_MASK: Handled mask indicates the event has been handled by ibus.\n @IBUS_FORWARD_MASK: Forward mask indicates the event has been forward from ibus.\n @IBUS_IGNORED_MASK: It is an alias of IBUS_FORWARD_MASK.\n @IBUS_SUPER_MASK: Super (Usually Win) key is activated.\n @IBUS_HYPER_MASK: Hyper key is activated.\n @IBUS_META_MASK: Meta key is activated.\n @IBUS_RELEASE_MASK: Key is released.\n @IBUS_MODIFIER_MASK: Modifier mask for the all the masks above.\n\n Handles key modifier such as control, shift and alt and release event.\n Note that nits 15 - 25 are currently unused, while bit 29 is used internally."]
pub type IBusModifierType = ::std::os::raw::c_uint;
pub const IBusCapabilite_IBUS_CAP_PREEDIT_TEXT: IBusCapabilite = 1;
pub const IBusCapabilite_IBUS_CAP_AUXILIARY_TEXT: IBusCapabilite = 2;
pub const IBusCapabilite_IBUS_CAP_LOOKUP_TABLE: IBusCapabilite = 4;
pub const IBusCapabilite_IBUS_CAP_FOCUS: IBusCapabilite = 8;
pub const IBusCapabilite_IBUS_CAP_PROPERTY: IBusCapabilite = 16;
pub const IBusCapabilite_IBUS_CAP_SURROUNDING_TEXT: IBusCapabilite = 32;
pub const IBusCapabilite_IBUS_CAP_OSK: IBusCapabilite = 64;
pub const IBusCapabilite_IBUS_CAP_SYNC_PROCESS_KEY: IBusCapabilite = 128;
pub const IBusCapabilite_IBUS_CAP_SYNC_PROCESS_KEY_V2: IBusCapabilite = 128;
#[doc = " IBusCapabilite:\n @IBUS_CAP_PREEDIT_TEXT: UI is capable to show pre-edit text.\n @IBUS_CAP_AUXILIARY_TEXT: UI is capable to show auxiliary text.\n @IBUS_CAP_LOOKUP_TABLE: UI is capable to show the lookup table.\n @IBUS_CAP_FOCUS: UI is capable to get focus.\n @IBUS_CAP_PROPERTY: UI is capable to have property.\n @IBUS_CAP_SURROUNDING_TEXT: Client can provide surround text,\n  or IME can handle surround text.\n @IBUS_CAP_OSK: UI is owned by on-screen keyboard.\n @IBUS_CAP_SYNC_PROCESS_KEY: Asynchronous process key events are not\n  supported and the ibus_engine_forward_key_event() should not be\n  used for the return value of #IBusEngine::process_key_event().\n\n Capability flags of UI."]
pub type IBusCapabilite = ::std::os::raw::c_uint;
pub const IBusPreeditFocusMode_IBUS_ENGINE_PREEDIT_CLEAR: IBusPreeditFocusMode = 0;
pub const IBusPreeditFocusMode_IBUS_ENGINE_PREEDIT_COMMIT: IBusPreeditFocusMode = 1;
#[doc = " IBusPreeditFocusMode:\n @IBUS_ENGINE_PREEDIT_CLEAR: pre-edit text is cleared.\n @IBUS_ENGINE_PREEDIT_COMMIT: pre-edit text is committed.\n\n Pre-edit commit mode when the focus is lost."]
pub type IBusPreeditFocusMode = ::std::os::raw::c_uint;
pub const IBusOrientation_IBUS_ORIENTATION_HORIZONTAL: IBusOrientation = 0;
pub const IBusOrientation_IBUS_ORIENTATION_VERTICAL: IBusOrientation = 1;
pub const IBusOrientation_IBUS_ORIENTATION_SYSTEM: IBusOrientation = 2;
#[doc = " IBusOrientation:\n @IBUS_ORIENTATION_HORIZONTAL: Horizontal orientation.\n @IBUS_ORIENTATION_VERTICAL: Vertival orientation.\n @IBUS_ORIENTATION_SYSTEM: Use ibus global orientation setup.\n\n Orientation of UI."]
pub type IBusOrientation = ::std::os::raw::c_uint;
pub const IBusBusNameFlag_IBUS_BUS_NAME_FLAG_ALLOW_REPLACEMENT: IBusBusNameFlag = 1;
pub const IBusBusNameFlag_IBUS_BUS_NAME_FLAG_REPLACE_EXISTING: IBusBusNameFlag = 2;
pub const IBusBusNameFlag_IBUS_BUS_NAME_FLAG_DO_NOT_QUEUE: IBusBusNameFlag = 4;
#[doc = " IBusBusNameFlag:\n @IBUS_BUS_NAME_FLAG_ALLOW_REPLACEMENT:\n    same as DBUS_NAME_FLAG_ALLOW_REPLACEMENT\n @IBUS_BUS_NAME_FLAG_REPLACE_EXISTING:\n    same as DBUS_NAME_FLAG_REPLACE_EXISTING\n @IBUS_BUS_NAME_FLAG_DO_NOT_QUEUE:\n    same as DBUS_NAME_FLAG_DO_NOT_QUEUE"]
pub type IBusBusNameFlag = ::std::os::raw::c_uint;
pub const IBusBusRequestNameReply_IBUS_BUS_REQUEST_NAME_REPLY_PRIMARY_OWNER:
    IBusBusRequestNameReply = 1;
pub const IBusBusRequestNameReply_IBUS_BUS_REQUEST_NAME_REPLY_IN_QUEUE: IBusBusRequestNameReply = 2;
pub const IBusBusRequestNameReply_IBUS_BUS_REQUEST_NAME_REPLY_EXISTS: IBusBusRequestNameReply = 3;
pub const IBusBusRequestNameReply_IBUS_BUS_REQUEST_NAME_REPLY_ALREADY_OWNER:
    IBusBusRequestNameReply = 4;
#[doc = " IBusBusRequestNameReply:\n @IBUS_BUS_REQUEST_NAME_REPLY_PRIMARY_OWNER:\n    same as DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER\n @IBUS_BUS_REQUEST_NAME_REPLY_IN_QUEUE:\n    same as DBUS_REQUEST_NAME_REPLY_IN_QUEUE\n @IBUS_BUS_REQUEST_NAME_REPLY_EXISTS:\n    same as DBUS_REQUEST_NAME_REPLY_EXISTS\n @IBUS_BUS_REQUEST_NAME_REPLY_ALREADY_OWNER:\n    same as DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER"]
pub type IBusBusRequestNameReply = ::std::os::raw::c_uint;
pub const IBusBusStartServiceByNameReply_IBUS_BUS_START_REPLY_SUCCESS:
    IBusBusStartServiceByNameReply = 1;
pub const IBusBusStartServiceByNameReply_IBUS_BUS_START_REPLY_ALREADY_RUNNING:
    IBusBusStartServiceByNameReply = 2;
#[doc = " IBusBusStartServiceByNameReply:\n @IBUS_BUS_START_REPLY_SUCCESS:\n    same as DBUS_START_REPLY_SUCCESS\n @IBUS_BUS_START_REPLY_ALREADY_RUNNING:\n    same as DBUS_START_REPLY_ALREADY_RUNNING"]
pub type IBusBusStartServiceByNameReply = ::std::os::raw::c_uint;
pub const IBusError_IBUS_ERROR_NO_ENGINE: IBusError = 0;
pub const IBusError_IBUS_ERROR_NO_CONFIG: IBusError = 1;
pub const IBusError_IBUS_ERROR_FAILED: IBusError = 2;
#[doc = " IBusError:\n @IBUS_ERROR_NO_ENGINE:\n There is no engine associated with input context.\n @IBUS_ERROR_NO_CONFIG:\n There is no config module running.\n @IBUS_ERROR_FAILED:\n General failure."]
pub type IBusError = ::std::os::raw::c_uint;
#[doc = " IBusRectangle:\n @x: x coordinate.\n @y: y coordinate.\n @width: width of the rectangle.\n @height: height of the renctangl.\n\n Rectangle definition."]
pub type IBusRectangle = _IBusRectangle;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusRectangle {
    pub x: gint,
    pub y: gint,
    pub width: gint,
    pub height: gint,
}
#[test]
fn bindgen_test_layout__IBusRectangle() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusRectangle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusRectangle>(),
        16usize,
        concat!("Size of: ", stringify!(_IBusRectangle))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusRectangle>(),
        4usize,
        concat!("Alignment of ", stringify!(_IBusRectangle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusRectangle),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusRectangle),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusRectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusRectangle),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " IBusFreeFunc:\n @object: object to be freed.\n\n Free function prototype."]
pub type IBusFreeFunc = ::std::option::Option<unsafe extern "C" fn(object: gpointer)>;
pub const IBusInputPurpose_IBUS_INPUT_PURPOSE_FREE_FORM: IBusInputPurpose = 0;
pub const IBusInputPurpose_IBUS_INPUT_PURPOSE_ALPHA: IBusInputPurpose = 1;
pub const IBusInputPurpose_IBUS_INPUT_PURPOSE_DIGITS: IBusInputPurpose = 2;
pub const IBusInputPurpose_IBUS_INPUT_PURPOSE_NUMBER: IBusInputPurpose = 3;
pub const IBusInputPurpose_IBUS_INPUT_PURPOSE_PHONE: IBusInputPurpose = 4;
pub const IBusInputPurpose_IBUS_INPUT_PURPOSE_URL: IBusInputPurpose = 5;
pub const IBusInputPurpose_IBUS_INPUT_PURPOSE_EMAIL: IBusInputPurpose = 6;
pub const IBusInputPurpose_IBUS_INPUT_PURPOSE_NAME: IBusInputPurpose = 7;
pub const IBusInputPurpose_IBUS_INPUT_PURPOSE_PASSWORD: IBusInputPurpose = 8;
pub const IBusInputPurpose_IBUS_INPUT_PURPOSE_PIN: IBusInputPurpose = 9;
pub const IBusInputPurpose_IBUS_INPUT_PURPOSE_TERMINAL: IBusInputPurpose = 10;
#[doc = " IBusInputPurpose:\n @IBUS_INPUT_PURPOSE_FREE_FORM: Allow any character\n @IBUS_INPUT_PURPOSE_ALPHA: Allow only alphabetic characters\n @IBUS_INPUT_PURPOSE_DIGITS: Allow only digits\n @IBUS_INPUT_PURPOSE_NUMBER: Edited field expects numbers\n @IBUS_INPUT_PURPOSE_PHONE: Edited field expects phone number\n @IBUS_INPUT_PURPOSE_URL: Edited field expects URL\n @IBUS_INPUT_PURPOSE_EMAIL: Edited field expects email address\n @IBUS_INPUT_PURPOSE_NAME: Edited field expects the name of a person\n @IBUS_INPUT_PURPOSE_PASSWORD: Like @IBUS_INPUT_PURPOSE_FREE_FORM,\n     but characters are hidden\n @IBUS_INPUT_PURPOSE_PIN: Like @IBUS_INPUT_PURPOSE_DIGITS, but\n     characters are hidden\n @IBUS_INPUT_PURPOSE_TERMINAL: Allow any character, in addition to control\n     codes. Since 1.5.24\n\n Describes primary purpose of the input context.  This information\n is particularly useful to implement intelligent behavior in\n engines, such as automatic input-mode switch and text prediction.\n\n Note that the purpose is not meant to impose a totally strict rule\n about allowed characters, and does not replace input validation.\n It is fine for an on-screen keyboard to let the user override the\n character set restriction that is expressed by the purpose. The\n application is expected to validate the entry contents, even if\n it specified a purpose.\n\n The difference between @IBUS_INPUT_PURPOSE_DIGITS and\n @IBUS_INPUT_PURPOSE_NUMBER is that the former accepts only digits\n while the latter also some punctuation (like commas or points, plus,\n minus) and e or E as in 3.14E+000.\n\n This enumeration may be extended in the future; engines should\n interpret unknown values as 'free form'.\n\n Since: 1.5.4"]
pub type IBusInputPurpose = ::std::os::raw::c_uint;
pub const IBusInputHints_IBUS_INPUT_HINT_NONE: IBusInputHints = 0;
pub const IBusInputHints_IBUS_INPUT_HINT_SPELLCHECK: IBusInputHints = 1;
pub const IBusInputHints_IBUS_INPUT_HINT_NO_SPELLCHECK: IBusInputHints = 2;
pub const IBusInputHints_IBUS_INPUT_HINT_WORD_COMPLETION: IBusInputHints = 4;
pub const IBusInputHints_IBUS_INPUT_HINT_LOWERCASE: IBusInputHints = 8;
pub const IBusInputHints_IBUS_INPUT_HINT_UPPERCASE_CHARS: IBusInputHints = 16;
pub const IBusInputHints_IBUS_INPUT_HINT_UPPERCASE_WORDS: IBusInputHints = 32;
pub const IBusInputHints_IBUS_INPUT_HINT_UPPERCASE_SENTENCES: IBusInputHints = 64;
pub const IBusInputHints_IBUS_INPUT_HINT_INHIBIT_OSK: IBusInputHints = 128;
pub const IBusInputHints_IBUS_INPUT_HINT_VERTICAL_WRITING: IBusInputHints = 256;
pub const IBusInputHints_IBUS_INPUT_HINT_EMOJI: IBusInputHints = 512;
pub const IBusInputHints_IBUS_INPUT_HINT_NO_EMOJI: IBusInputHints = 1024;
pub const IBusInputHints_IBUS_INPUT_HINT_PRIVATE: IBusInputHints = 2048;
#[doc = " IBusInputHints:\n @IBUS_INPUT_HINT_NONE: No special behaviour suggested\n @IBUS_INPUT_HINT_SPELLCHECK: Suggest checking for typos\n @IBUS_INPUT_HINT_NO_SPELLCHECK: Suggest not checking for typos\n @IBUS_INPUT_HINT_WORD_COMPLETION: Suggest word completion\n @IBUS_INPUT_HINT_LOWERCASE: Suggest to convert all text to lowercase\n @IBUS_INPUT_HINT_UPPERCASE_CHARS: Suggest to capitalize all text\n @IBUS_INPUT_HINT_UPPERCASE_WORDS: Suggest to capitalize the first\n     character of each word\n @IBUS_INPUT_HINT_UPPERCASE_SENTENCES: Suggest to capitalize the\n     first word of each sentence\n @IBUS_INPUT_HINT_INHIBIT_OSK: Suggest to not show an onscreen keyboard\n     (e.g for a calculator that already has all the keys).\n @IBUS_INPUT_HINT_VERTICAL_WRITING: The text is vertical. Since 1.5.11\n @IBUS_INPUT_HINT_EMOJI: Suggest offering Emoji support. Since 1.5.24\n @IBUS_INPUT_HINT_NO_EMOJI: Suggest not offering Emoji support. Since 1.5.24\n @IBUS_INPUT_HINT_PRIVATE: Request that the input method should not\n     update personalized data (like typing history). Since 1.5.26\n\n Describes hints that might be taken into account by engines.  Note\n that engines may already tailor their behaviour according to the\n #IBusInputPurpose of the entry.\n\n Some common sense is expected when using these flags - mixing\n @IBUS_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.\n\n This enumeration may be extended in the future; engines should\n ignore unknown values.\n\n Since: 1.5.4"]
pub type IBusInputHints = ::std::os::raw::c_uint;
pub const IBusObjectFlags_IBUS_IN_DESTRUCTION: IBusObjectFlags = 1;
pub const IBusObjectFlags_IBUS_DESTROYED: IBusObjectFlags = 2;
pub const IBusObjectFlags_IBUS_RESERVED_1: IBusObjectFlags = 4;
pub const IBusObjectFlags_IBUS_RESERVED_2: IBusObjectFlags = 8;
#[doc = " IBusObjectFlags:\n @IBUS_IN_DESTRUCTION: Used in GObjectClass::dispose\n @IBUS_DESTROYED: Used during emitting IBusObject::destroy signal.\n @IBUS_RESERVED_1: Reserved.\n @IBUS_RESERVED_2: Reserved.\n\n The flags are used internally."]
pub type IBusObjectFlags = ::std::os::raw::c_uint;
#[doc = " IBusObject:\n\n All the fields in the <structname>IBusObject</structname> structure are\n private to the #IBusObject and should never be accessed directly."]
pub type IBusObject = _IBusObject;
pub type IBusObjectClass = _IBusObjectClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusObjectPrivate {
    _unused: [u8; 0],
}
pub type IBusObjectPrivate = _IBusObjectPrivate;
#[doc = " IBusObject:\n\n All the fields in the <structname>IBusObject</structname> structure are\n private to the #IBusObject and should never be accessed directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusObject {
    pub parent: GInitiallyUnowned,
    pub flags: guint32,
    pub priv_: *mut IBusObjectPrivate,
}
#[test]
fn bindgen_test_layout__IBusObject() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusObject> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusObject>(),
        40usize,
        concat!("Size of: ", stringify!(_IBusObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusObject))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusObject),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusObject),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusObject),
            "::",
            stringify!(priv_)
        )
    );
}
pub type IBusObjectDestroyFunc =
    ::std::option::Option<unsafe extern "C" fn(object: *mut IBusObject)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusObjectClass {
    pub parent: GInitiallyUnownedClass,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(object: *mut IBusObject)>,
    pub pdummy: [gpointer; 7usize],
}
#[test]
fn bindgen_test_layout__IBusObjectClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusObjectClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusObjectClass>(),
        200usize,
        concat!("Size of: ", stringify!(_IBusObjectClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusObjectClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusObjectClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusObjectClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusObjectClass),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusObjectClass),
            "::",
            stringify!(pdummy)
        )
    );
}
extern "C" {
    pub fn ibus_object_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_object_new:\n\n Creates  a new #IBusObject.\n\n Returns: A newly allocated #IBusObject"]
    pub fn ibus_object_new() -> *mut IBusObject;
}
extern "C" {
    #[doc = " ibus_object_destroy:\n @object: an #IBusObject to destroy.\n\n Emit the \"destroy\" signal notifying all reference holders that they should\n release the #IBusObject.\n\n The memory for the object itself won't be deleted until its reference count\n actually drops to 0; ibus_object_destroy merely asks reference holders to\n release their references. It does not free the object."]
    pub fn ibus_object_destroy(object: *mut IBusObject);
}
#[doc = " IBusSerializable:\n\n All the fields in the <structname>IBusSerializable</structname> structure are\n private to the #IBusSerializable and should never be accessed directly."]
pub type IBusSerializable = _IBusSerializable;
pub type IBusSerializableClass = _IBusSerializableClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusSerializablePrivate {
    _unused: [u8; 0],
}
pub type IBusSerializablePrivate = _IBusSerializablePrivate;
#[doc = " IBusSerializable:\n\n All the fields in the <structname>IBusSerializable</structname> structure are\n private to the #IBusSerializable and should never be accessed directly."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusSerializable {
    pub parent: IBusObject,
    pub priv_: *mut IBusSerializablePrivate,
}
#[test]
fn bindgen_test_layout__IBusSerializable() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusSerializable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusSerializable>(),
        48usize,
        concat!("Size of: ", stringify!(_IBusSerializable))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusSerializable>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusSerializable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusSerializable),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusSerializable),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " IBusSerializableSerializeFunc:\n @serializable: An #IBusSerializable.\n @builder: A #GVariantBuilder.\n\n Prototype of serialize function.\n Serialize function convert an #IBusSerializable to #GVariantBuilder.\n Returns a gboolean value which indicates whether the conversion is success.\n Return %TRUE if succeed.\n\n Returns: %TRUE if succeed; %FALSE otherwise."]
pub type IBusSerializableSerializeFunc = ::std::option::Option<
    unsafe extern "C" fn(
        serializable: *mut IBusSerializable,
        builder: *mut GVariantBuilder,
    ) -> gboolean,
>;
#[doc = " IBusSerializableDeserializeFunc:\n @serializable: An #IBusSerializable.\n @variant: A #GVariant contains a tuple.\n\n Prototype of deserialize function.\n Deserialize function convert a #GVariant to #IBusSerializable.\n Returns an integer value which indicates how many values in\n the variant(tuple) are consumed.\n\n Returns: The number of values in the variant(tuple) are consumed."]
pub type IBusSerializableDeserializeFunc = ::std::option::Option<
    unsafe extern "C" fn(serializable: *mut IBusSerializable, variant: *mut GVariant) -> gint,
>;
#[doc = " IBusSerializableCopyFunc:\n @dest: The destination #IBusSerializable.\n @src: A source #IBusSerializable.\n\n Prototype of copy function.\n Copy function copy from source #IBusSerializable to the destination one.\n Returns a gboolean value which indicates whether the copying is success.\n\n Returns: %TRUE if succeed; %FALSE otherwise."]
pub type IBusSerializableCopyFunc = ::std::option::Option<
    unsafe extern "C" fn(dest: *mut IBusSerializable, src: *const IBusSerializable) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusSerializableClass {
    pub parent: IBusObjectClass,
    pub serialize: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut IBusSerializable,
            builder: *mut GVariantBuilder,
        ) -> gboolean,
    >,
    pub deserialize: ::std::option::Option<
        unsafe extern "C" fn(object: *mut IBusSerializable, variant: *mut GVariant) -> gint,
    >,
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(dest: *mut IBusSerializable, src: *const IBusSerializable) -> gboolean,
    >,
    pub pdummy: [gpointer; 5usize],
}
#[test]
fn bindgen_test_layout__IBusSerializableClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusSerializableClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusSerializableClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusSerializableClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusSerializableClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusSerializableClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusSerializableClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialize) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusSerializableClass),
            "::",
            stringify!(serialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusSerializableClass),
            "::",
            stringify!(deserialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusSerializableClass),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusSerializableClass),
            "::",
            stringify!(pdummy)
        )
    );
}
extern "C" {
    pub fn ibus_serializable_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_serializable_new:\n\n Creates a new instance of an #IBusSerializable.\n\n Returns: a new instance of #IBusSerializable."]
    pub fn ibus_serializable_new() -> *mut IBusSerializable;
}
extern "C" {
    #[doc = " ibus_serializable_set_qattachment:\n @serializable: An #IBusSerializable.\n @key: String formatted key for indexing value.\n @value: Value to be attached or %NULL to remove any prevoius value.\n\n Attach a value to an #IBusSerializable. If the value is floating,\n the serializable will take the ownership.\n\n See also: ibus_serializable_set_attachment()."]
    pub fn ibus_serializable_set_qattachment(
        serializable: *mut IBusSerializable,
        key: GQuark,
        value: *mut GVariant,
    );
}
extern "C" {
    #[doc = " ibus_serializable_get_qattachment:\n @serializable: An #IBusSerializable.\n @key: String formatted key for indexing value.\n\n Gets a value from attachment of an #IBusSerializable.\n\n Returns: The attached value; or %NULL if fail to retrieve the value.\n\n See also: ibus_serializable_set_attachment()."]
    pub fn ibus_serializable_get_qattachment(
        serializable: *mut IBusSerializable,
        key: GQuark,
    ) -> *mut GVariant;
}
extern "C" {
    #[doc = " ibus_serializable_remove_qattachment:\n @serializable: An #IBusSerializable.\n @key: String formatted key for indexing value.\n\n Remove a value from attachment of an #IBusSerializable.\n See also: ibus_serializable_remove_attachment()."]
    pub fn ibus_serializable_remove_qattachment(serializable: *mut IBusSerializable, key: GQuark);
}
extern "C" {
    #[doc = " ibus_serializable_copy:\n @serializable: An #IBusSerializable.\n\n Clone an #IBusSerializable.\n The copy method should be implemented in extended class.\n\n Returns: (transfer none): A newly allocated clone object; or %NULL\n     if @object is not serializable.\n\n See also: IBusSerializableCopyFunc()."]
    pub fn ibus_serializable_copy(serializable: *mut IBusSerializable) -> *mut IBusSerializable;
}
extern "C" {
    #[doc = " ibus_serializable_serialize_object:\n @serializable: An #IBusSerializable.\n\n Serialize an #IBusSerializable to a #GVariant.\n The serialize method should be implemented in extended class.\n\n Returns: A #GVariant.\n\n See also: IBusSerializableCopyFunc()."]
    pub fn ibus_serializable_serialize_object(serializable: *mut IBusSerializable)
        -> *mut GVariant;
}
extern "C" {
    #[doc = " ibus_serializable_deserialize_object:\n @variant: A #GVariant.\n\n Deserialize a #GVariant to an #IBusSerializable/\n The deserialize method should be implemented in extended class.\n\n Returns: (transfer none): The deserialized #IBusSerializable.\n\n See also: IBusSerializableCopyFunc()."]
    pub fn ibus_serializable_deserialize_object(variant: *mut GVariant) -> *mut IBusSerializable;
}
pub const IBusAttrType_IBUS_ATTR_TYPE_UNDERLINE: IBusAttrType = 1;
pub const IBusAttrType_IBUS_ATTR_TYPE_FOREGROUND: IBusAttrType = 2;
pub const IBusAttrType_IBUS_ATTR_TYPE_BACKGROUND: IBusAttrType = 3;
#[doc = " IBusAttrType:\n @IBUS_ATTR_TYPE_UNDERLINE: Decorate with underline.\n @IBUS_ATTR_TYPE_FOREGROUND: Foreground color.\n @IBUS_ATTR_TYPE_BACKGROUND: Background color.\n\n Type enumeration of IBusText attribute."]
pub type IBusAttrType = ::std::os::raw::c_uint;
pub const IBusAttrUnderline_IBUS_ATTR_UNDERLINE_NONE: IBusAttrUnderline = 0;
pub const IBusAttrUnderline_IBUS_ATTR_UNDERLINE_SINGLE: IBusAttrUnderline = 1;
pub const IBusAttrUnderline_IBUS_ATTR_UNDERLINE_DOUBLE: IBusAttrUnderline = 2;
pub const IBusAttrUnderline_IBUS_ATTR_UNDERLINE_LOW: IBusAttrUnderline = 3;
pub const IBusAttrUnderline_IBUS_ATTR_UNDERLINE_ERROR: IBusAttrUnderline = 4;
#[doc = " IBusAttrUnderline:\n @IBUS_ATTR_UNDERLINE_NONE: No underline.\n @IBUS_ATTR_UNDERLINE_SINGLE: Single underline.\n @IBUS_ATTR_UNDERLINE_DOUBLE: Double underline.\n @IBUS_ATTR_UNDERLINE_LOW: Low underline ? FIXME\n @IBUS_ATTR_UNDERLINE_ERROR: Error underline\n\n Type of IBusText attribute."]
pub type IBusAttrUnderline = ::std::os::raw::c_uint;
#[doc = " IBusAttribute:\n @type: IBusAttributeType\n @value: Value for the type.\n @start_index: The starting index, inclusive.\n @end_index: The ending index, exclusive.\n\n Signify the type, value and scope of the attribute.\n The scope starts from @start_index till the @end_index-1."]
pub type IBusAttribute = _IBusAttribute;
pub type IBusAttributeClass = _IBusAttributeClass;
#[doc = " IBusAttribute:\n @type: IBusAttributeType\n @value: Value for the type.\n @start_index: The starting index, inclusive.\n @end_index: The ending index, exclusive.\n\n Signify the type, value and scope of the attribute.\n The scope starts from @start_index till the @end_index-1."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusAttribute {
    pub parent: IBusSerializable,
    pub type_: guint,
    pub value: guint,
    pub start_index: guint,
    pub end_index: guint,
}
#[test]
fn bindgen_test_layout__IBusAttribute() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusAttribute> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusAttribute>(),
        64usize,
        concat!("Size of: ", stringify!(_IBusAttribute))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusAttribute>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusAttribute))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusAttribute),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusAttribute),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusAttribute),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_index) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusAttribute),
            "::",
            stringify!(start_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_index) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusAttribute),
            "::",
            stringify!(end_index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusAttributeClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusAttributeClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusAttributeClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusAttributeClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusAttributeClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusAttributeClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusAttributeClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusAttributeClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    #[doc = " ibus_attribute_get_type:\n @returns: GType of IBusAttribute.\n\n Returns GType of IBusAttribute."]
    pub fn ibus_attribute_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_attribute_new:\n @type: Type of the attribute.\n @value: Value of the attribute.\n @start_index: Where attribute starts.\n @end_index: Where attribute ends.\n\n Creates a new IBusAttribute.\n\n Returns: (transfer none): A newly allocated IBusAttribute."]
    pub fn ibus_attribute_new(
        type_: guint,
        value: guint,
        start_index: guint,
        end_index: guint,
    ) -> *mut IBusAttribute;
}
extern "C" {
    #[doc = " ibus_attribute_get_attr_type:\n @attr: An #IBusAttribute\n\n Gets an enum of #IBusAttrType.\n\n Returns: An enum of #IBusAttrType."]
    pub fn ibus_attribute_get_attr_type(attr: *mut IBusAttribute) -> guint;
}
extern "C" {
    #[doc = " ibus_attribute_get_value:\n @attr: An #IBusAttribute\n\n Gets an unsigned int value relative with #IBusAttrType.\n If the type is %IBUS_ATTR_TYPE_UNDERLINE, the return value is\n #IBusAttrUnderline. If the type is %IBUS_ATTR_TYPE_FOREGROUND,\n the return value is the color RGB.\n\n Returns: An unsigned int value relative with #IBusAttrType."]
    pub fn ibus_attribute_get_value(attr: *mut IBusAttribute) -> guint;
}
extern "C" {
    #[doc = " ibus_attribute_get_start_index:\n @attr: An #IBusAttribute\n\n Gets a start unsigned index\n\n Returns: A start unsigned index"]
    pub fn ibus_attribute_get_start_index(attr: *mut IBusAttribute) -> guint;
}
extern "C" {
    #[doc = " ibus_attribute_get_end_index:\n @attr: An #IBusAttribute\n\n Gets an end unsigned index\n\n Returns: A end unsigned index"]
    pub fn ibus_attribute_get_end_index(attr: *mut IBusAttribute) -> guint;
}
extern "C" {
    #[doc = " ibus_attr_underline_new:\n @underline_type: Type of underline.\n @start_index: Where attribute starts.\n @end_index: Where attribute ends.\n\n Creates a new underline #IBusAttribute.\n\n Returns: (transfer none): A newly allocated #IBusAttribute."]
    pub fn ibus_attr_underline_new(
        underline_type: guint,
        start_index: guint,
        end_index: guint,
    ) -> *mut IBusAttribute;
}
extern "C" {
    #[doc = " ibus_attr_foreground_new:\n @color: Color in RGB.\n @start_index: Where attribute starts.\n @end_index: Where attribute ends.\n\n Creates a new foreground #IBusAttribute.\n\n Returns: (transfer none): A newly allocated #IBusAttribute."]
    pub fn ibus_attr_foreground_new(
        color: guint,
        start_index: guint,
        end_index: guint,
    ) -> *mut IBusAttribute;
}
extern "C" {
    #[doc = " ibus_attr_background_new:\n @color: Color in RGB.\n @start_index: Where attribute starts.\n @end_index: Where attribute ends.\n\n Creates a new background #IBusAttribute.\n\n Returns: (transfer none): A newly allocated #IBusAttribute."]
    pub fn ibus_attr_background_new(
        color: guint,
        start_index: guint,
        end_index: guint,
    ) -> *mut IBusAttribute;
}
#[doc = " IBusAttrList:\n @attributes: GArray that holds #IBusAttribute.\n\n Array of IBusAttribute."]
pub type IBusAttrList = _IBusAttrList;
pub type IBusAttrListClass = _IBusAttrListClass;
#[doc = " IBusAttrList:\n @attributes: GArray that holds #IBusAttribute.\n\n Array of IBusAttribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusAttrList {
    pub parent: IBusSerializable,
    pub attributes: *mut GArray,
}
#[test]
fn bindgen_test_layout__IBusAttrList() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusAttrList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusAttrList>(),
        56usize,
        concat!("Size of: ", stringify!(_IBusAttrList))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusAttrList>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusAttrList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusAttrList),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusAttrList),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusAttrListClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusAttrListClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusAttrListClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusAttrListClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusAttrListClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusAttrListClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusAttrListClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusAttrListClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    #[doc = " ibus_attr_list_get_type:\n\n Returns GType of #IBusAttrList.\n\n Returns: GType of #IBusAttrList."]
    pub fn ibus_attr_list_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_attr_list_new:\n\n Creates an new #IBusAttrList.\n\n Returns: A newly allocated #IBusAttrList."]
    pub fn ibus_attr_list_new() -> *mut IBusAttrList;
}
extern "C" {
    #[doc = " ibus_attr_list_append:\n @attr_list: An IBusAttrList instance.\n @attr: The IBusAttribute instance to be appended.\n\n Append an IBusAttribute to IBusAttrList, and increase reference."]
    pub fn ibus_attr_list_append(attr_list: *mut IBusAttrList, attr: *mut IBusAttribute);
}
extern "C" {
    #[doc = " ibus_attr_list_get:\n @attr_list: An IBusAttrList instance.\n @index: Index of the @attr_list.\n\n Returns #IBusAttribute at given index. Borrowed reference.\n\n Returns: (transfer none): #IBusAttribute at given index, %NULL if no such\n        #IBusAttribute."]
    pub fn ibus_attr_list_get(attr_list: *mut IBusAttrList, index: guint) -> *mut IBusAttribute;
}
#[doc = " IBusText:\n @is_static: Whether @text is static, i.e., no need and will not be freed. Only TRUE if IBusText is newed from ibus_text_new_from_static_string().\n @text: The string content of IBusText in UTF-8.\n @attrs: Associated IBusAttributes.\n\n A text object in IBus."]
pub type IBusText = _IBusText;
pub type IBusTextClass = _IBusTextClass;
#[doc = " IBusText:\n @is_static: Whether @text is static, i.e., no need and will not be freed. Only TRUE if IBusText is newed from ibus_text_new_from_static_string().\n @text: The string content of IBusText in UTF-8.\n @attrs: Associated IBusAttributes.\n\n A text object in IBus."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusText {
    pub parent: IBusSerializable,
    pub is_static: gboolean,
    pub text: *mut gchar,
    pub attrs: *mut IBusAttrList,
}
#[test]
fn bindgen_test_layout__IBusText() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusText> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusText>(),
        72usize,
        concat!("Size of: ", stringify!(_IBusText))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusText>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusText))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusText),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_static) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusText),
            "::",
            stringify!(is_static)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusText),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attrs) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusText),
            "::",
            stringify!(attrs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusTextClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusTextClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusTextClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusTextClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusTextClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusTextClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusTextClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusTextClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_text_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_text_new_from_string:\n @str: An text string to be set.\n\n Creates a new #IBusText from a string.\n @str will be duplicated in #IBusText, so feel free to free @str after this\n function.\n\n Returns: A newly allocated #IBusText."]
    pub fn ibus_text_new_from_string(str_: *const gchar) -> *mut IBusText;
}
extern "C" {
    #[doc = " ibus_text_new_from_ucs4:\n @str: An text string to be set.\n\n Creates a new #IBusText from an UCS-4 encoded string.\n @str will be duplicated in IBusText, so feel free to free @str after this\n function.\n\n Returns: A newly allocated #IBusText."]
    pub fn ibus_text_new_from_ucs4(str_: *const gunichar) -> *mut IBusText;
}
extern "C" {
    #[doc = " ibus_text_new_from_static_string: (skip)\n @str: An text string to be set.\n\n Creates a new #IBusText from a static string.\n\n Since @str is a static string which won't be freed.\n This function will NOT duplicate @str.\n\n Returns: A newly allocated #IBusText."]
    pub fn ibus_text_new_from_static_string(str_: *const gchar) -> *mut IBusText;
}
extern "C" {
    #[doc = " ibus_text_new_from_printf:\n @fmt: printf format string.\n @...: arguments for @fmt.\n\n Creates a new #IBusText from a printf expression.\n\n The result of printf expression is stored in the new IBusText instance.\n\n Returns: A newly allocated #IBusText."]
    pub fn ibus_text_new_from_printf(fmt: *const gchar, ...) -> *mut IBusText;
}
extern "C" {
    #[doc = " ibus_text_new_from_unichar:\n @c: A single UCS4-encoded character.\n\n Creates a new #IBusText from a single UCS4-encoded character.\n\n Returns: A newly allocated #IBusText."]
    pub fn ibus_text_new_from_unichar(c: gunichar) -> *mut IBusText;
}
extern "C" {
    #[doc = " ibus_text_append_attribute:\n @text: an IBusText\n @type: IBusAttributeType for @text.\n @value: Value for the type.\n @start_index: The starting index, inclusive.\n @end_index: The ending index, exclusive.\n\n Append an IBusAttribute for IBusText."]
    pub fn ibus_text_append_attribute(
        text: *mut IBusText,
        type_: guint,
        value: guint,
        start_index: guint,
        end_index: gint,
    );
}
extern "C" {
    #[doc = " ibus_text_get_length:\n @text: An #IBusText.\n\n Return number of characters in an #IBusText.\n This function is based on g_utf8_strlen(), so unlike strlen(),\n it does not count by bytes but characters instead.\n\n Returns: Number of character in @text, not counted by bytes."]
    pub fn ibus_text_get_length(text: *mut IBusText) -> guint;
}
extern "C" {
    #[doc = " ibus_text_get_is_static: (skip)\n @text: An #IBusText.\n\n Return the is_static in an #IBusText.\n\n Returns: the is_static in @text."]
    pub fn ibus_text_get_is_static(text: *mut IBusText) -> gboolean;
}
extern "C" {
    #[doc = " ibus_text_get_text:\n @text: An #IBusText.\n\n Return the text in an #IBusText. Should not be freed.\n\n Returns: the text in @text."]
    pub fn ibus_text_get_text(text: *mut IBusText) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_text_get_attributes:\n @text: An #IBusText.\n\n Return the attributes in an #IBusText. Should not be freed.\n\n Returns: (transfer none): the attrs in @text."]
    pub fn ibus_text_get_attributes(text: *mut IBusText) -> *mut IBusAttrList;
}
extern "C" {
    #[doc = " ibus_text_set_attributes:\n @text: An IBusText.\n @attrs: An IBusAttrList"]
    pub fn ibus_text_set_attributes(text: *mut IBusText, attrs: *mut IBusAttrList);
}
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_NONE: GAppInfoCreateFlags = 0;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_NEEDS_TERMINAL: GAppInfoCreateFlags = 1;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_SUPPORTS_URIS: GAppInfoCreateFlags = 2;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION: GAppInfoCreateFlags =
    4;
#[doc = " GAppInfoCreateFlags:\n @G_APP_INFO_CREATE_NONE: No flags.\n @G_APP_INFO_CREATE_NEEDS_TERMINAL: Application opens in a terminal window.\n @G_APP_INFO_CREATE_SUPPORTS_URIS: Application supports URI arguments.\n @G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION: Application supports startup notification. Since 2.26\n\n Flags used when creating a #GAppInfo."]
pub type GAppInfoCreateFlags = ::std::os::raw::c_uint;
pub const GConverterFlags_G_CONVERTER_NO_FLAGS: GConverterFlags = 0;
pub const GConverterFlags_G_CONVERTER_INPUT_AT_END: GConverterFlags = 1;
pub const GConverterFlags_G_CONVERTER_FLUSH: GConverterFlags = 2;
#[doc = " GConverterFlags:\n @G_CONVERTER_NO_FLAGS: No flags.\n @G_CONVERTER_INPUT_AT_END: At end of input data\n @G_CONVERTER_FLUSH: Flush data\n\n Flags used when calling a g_converter_convert().\n\n Since: 2.24"]
pub type GConverterFlags = ::std::os::raw::c_uint;
pub const GConverterResult_G_CONVERTER_ERROR: GConverterResult = 0;
pub const GConverterResult_G_CONVERTER_CONVERTED: GConverterResult = 1;
pub const GConverterResult_G_CONVERTER_FINISHED: GConverterResult = 2;
pub const GConverterResult_G_CONVERTER_FLUSHED: GConverterResult = 3;
#[doc = " GConverterResult:\n @G_CONVERTER_ERROR: There was an error during conversion.\n @G_CONVERTER_CONVERTED: Some data was consumed or produced\n @G_CONVERTER_FINISHED: The conversion is finished\n @G_CONVERTER_FLUSHED: Flushing is finished\n\n Results returned from g_converter_convert().\n\n Since: 2.24"]
pub type GConverterResult = ::std::os::raw::c_uint;
pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: GDataStreamByteOrder = 0;
pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: GDataStreamByteOrder = 1;
pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: GDataStreamByteOrder = 2;
#[doc = " GDataStreamByteOrder:\n @G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: Selects Big Endian byte order.\n @G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: Selects Little Endian byte order.\n @G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: Selects endianness based on host machine's architecture.\n\n #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources\n across various machine architectures.\n"]
pub type GDataStreamByteOrder = ::std::os::raw::c_uint;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_LF: GDataStreamNewlineType = 0;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_CR: GDataStreamNewlineType = 1;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_CR_LF: GDataStreamNewlineType = 2;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_ANY: GDataStreamNewlineType = 3;
#[doc = " GDataStreamNewlineType:\n @G_DATA_STREAM_NEWLINE_TYPE_LF: Selects \"LF\" line endings, common on most modern UNIX platforms.\n @G_DATA_STREAM_NEWLINE_TYPE_CR: Selects \"CR\" line endings.\n @G_DATA_STREAM_NEWLINE_TYPE_CR_LF: Selects \"CR, LF\" line ending, common on Microsoft Windows.\n @G_DATA_STREAM_NEWLINE_TYPE_ANY: Automatically try to handle any line ending type.\n\n #GDataStreamNewlineType is used when checking for or setting the line endings for a given file."]
pub type GDataStreamNewlineType = ::std::os::raw::c_uint;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INVALID: GFileAttributeType = 0;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_STRING: GFileAttributeType = 1;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_BYTE_STRING: GFileAttributeType = 2;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_BOOLEAN: GFileAttributeType = 3;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_UINT32: GFileAttributeType = 4;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INT32: GFileAttributeType = 5;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_UINT64: GFileAttributeType = 6;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INT64: GFileAttributeType = 7;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_OBJECT: GFileAttributeType = 8;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_STRINGV: GFileAttributeType = 9;
#[doc = " GFileAttributeType:\n @G_FILE_ATTRIBUTE_TYPE_INVALID: indicates an invalid or uninitialized type.\n @G_FILE_ATTRIBUTE_TYPE_STRING: a null terminated UTF8 string.\n @G_FILE_ATTRIBUTE_TYPE_BYTE_STRING: a zero terminated string of non-zero bytes.\n @G_FILE_ATTRIBUTE_TYPE_BOOLEAN: a boolean value.\n @G_FILE_ATTRIBUTE_TYPE_UINT32: an unsigned 4-byte/32-bit integer.\n @G_FILE_ATTRIBUTE_TYPE_INT32: a signed 4-byte/32-bit integer.\n @G_FILE_ATTRIBUTE_TYPE_UINT64: an unsigned 8-byte/64-bit integer.\n @G_FILE_ATTRIBUTE_TYPE_INT64: a signed 8-byte/64-bit integer.\n @G_FILE_ATTRIBUTE_TYPE_OBJECT: a #GObject.\n @G_FILE_ATTRIBUTE_TYPE_STRINGV: a %NULL terminated char **. Since 2.22\n\n The data types for file attributes."]
pub type GFileAttributeType = ::std::os::raw::c_uint;
pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_NONE: GFileAttributeInfoFlags = 0;
pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE: GFileAttributeInfoFlags = 1;
pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED: GFileAttributeInfoFlags =
    2;
#[doc = " GFileAttributeInfoFlags:\n @G_FILE_ATTRIBUTE_INFO_NONE: no flags set.\n @G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE: copy the attribute values when the file is copied.\n @G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED: copy the attribute values when the file is moved.\n\n Flags specifying the behaviour of an attribute."]
pub type GFileAttributeInfoFlags = ::std::os::raw::c_uint;
pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_UNSET: GFileAttributeStatus = 0;
pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_SET: GFileAttributeStatus = 1;
pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING: GFileAttributeStatus = 2;
#[doc = " GFileAttributeStatus:\n @G_FILE_ATTRIBUTE_STATUS_UNSET: Attribute value is unset (empty).\n @G_FILE_ATTRIBUTE_STATUS_SET: Attribute value is set.\n @G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING: Indicates an error in setting the value.\n\n Used by g_file_set_attributes_from_info() when setting file attributes."]
pub type GFileAttributeStatus = ::std::os::raw::c_uint;
pub const GFileQueryInfoFlags_G_FILE_QUERY_INFO_NONE: GFileQueryInfoFlags = 0;
pub const GFileQueryInfoFlags_G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS: GFileQueryInfoFlags = 1;
#[doc = " GFileQueryInfoFlags:\n @G_FILE_QUERY_INFO_NONE: No flags set.\n @G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS: Don't follow symlinks.\n\n Flags used when querying a #GFileInfo."]
pub type GFileQueryInfoFlags = ::std::os::raw::c_uint;
pub const GFileCreateFlags_G_FILE_CREATE_NONE: GFileCreateFlags = 0;
pub const GFileCreateFlags_G_FILE_CREATE_PRIVATE: GFileCreateFlags = 1;
pub const GFileCreateFlags_G_FILE_CREATE_REPLACE_DESTINATION: GFileCreateFlags = 2;
#[doc = " GFileCreateFlags:\n @G_FILE_CREATE_NONE: No flags set.\n @G_FILE_CREATE_PRIVATE: Create a file that can only be\n    accessed by the current user.\n @G_FILE_CREATE_REPLACE_DESTINATION: Replace the destination\n    as if it didn't exist before. Don't try to keep any old\n    permissions, replace instead of following links. This\n    is generally useful if you're doing a \"copy over\"\n    rather than a \"save new version of\" replace operation.\n    You can think of it as \"unlink destination\" before\n    writing to it, although the implementation may not\n    be exactly like that. This flag can only be used with\n    g_file_replace() and its variants, including g_file_replace_contents().\n    Since 2.20\n\n Flags used when an operation may create a file."]
pub type GFileCreateFlags = ::std::os::raw::c_uint;
pub const GFileMeasureFlags_G_FILE_MEASURE_NONE: GFileMeasureFlags = 0;
pub const GFileMeasureFlags_G_FILE_MEASURE_REPORT_ANY_ERROR: GFileMeasureFlags = 2;
pub const GFileMeasureFlags_G_FILE_MEASURE_APPARENT_SIZE: GFileMeasureFlags = 4;
pub const GFileMeasureFlags_G_FILE_MEASURE_NO_XDEV: GFileMeasureFlags = 8;
#[doc = " GFileMeasureFlags:\n @G_FILE_MEASURE_NONE: No flags set.\n @G_FILE_MEASURE_REPORT_ANY_ERROR: Report any error encountered\n   while traversing the directory tree.  Normally errors are only\n   reported for the toplevel file.\n @G_FILE_MEASURE_APPARENT_SIZE: Tally usage based on apparent file\n   sizes.  Normally, the block-size is used, if available, as this is a\n   more accurate representation of disk space used.\n   Compare with `du --apparent-size`.\n @G_FILE_MEASURE_NO_XDEV: Do not cross mount point boundaries.\n   Compare with `du -x`.\n\n Flags that can be used with g_file_measure_disk_usage().\n\n Since: 2.38"]
pub type GFileMeasureFlags = ::std::os::raw::c_uint;
pub const GMountMountFlags_G_MOUNT_MOUNT_NONE: GMountMountFlags = 0;
#[doc = " GMountMountFlags:\n @G_MOUNT_MOUNT_NONE: No flags set.\n\n Flags used when mounting a mount."]
pub type GMountMountFlags = ::std::os::raw::c_uint;
pub const GMountUnmountFlags_G_MOUNT_UNMOUNT_NONE: GMountUnmountFlags = 0;
pub const GMountUnmountFlags_G_MOUNT_UNMOUNT_FORCE: GMountUnmountFlags = 1;
#[doc = " GMountUnmountFlags:\n @G_MOUNT_UNMOUNT_NONE: No flags set.\n @G_MOUNT_UNMOUNT_FORCE: Unmount even if there are outstanding\n  file operations on the mount.\n\n Flags used when an unmounting a mount."]
pub type GMountUnmountFlags = ::std::os::raw::c_uint;
pub const GDriveStartFlags_G_DRIVE_START_NONE: GDriveStartFlags = 0;
#[doc = " GDriveStartFlags:\n @G_DRIVE_START_NONE: No flags set.\n\n Flags used when starting a drive.\n\n Since: 2.22"]
pub type GDriveStartFlags = ::std::os::raw::c_uint;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_UNKNOWN: GDriveStartStopType = 0;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_SHUTDOWN: GDriveStartStopType = 1;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_NETWORK: GDriveStartStopType = 2;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_MULTIDISK: GDriveStartStopType = 3;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_PASSWORD: GDriveStartStopType = 4;
#[doc = " GDriveStartStopType:\n @G_DRIVE_START_STOP_TYPE_UNKNOWN: Unknown or drive doesn't support\n    start/stop.\n @G_DRIVE_START_STOP_TYPE_SHUTDOWN: The stop method will physically\n    shut down the drive and e.g. power down the port the drive is\n    attached to.\n @G_DRIVE_START_STOP_TYPE_NETWORK: The start/stop methods are used\n    for connecting/disconnect to the drive over the network.\n @G_DRIVE_START_STOP_TYPE_MULTIDISK: The start/stop methods will\n    assemble/disassemble a virtual drive from several physical\n    drives.\n @G_DRIVE_START_STOP_TYPE_PASSWORD: The start/stop methods will\n    unlock/lock the disk (for example using the ATA <quote>SECURITY\n    UNLOCK DEVICE</quote> command)\n\n Enumeration describing how a drive can be started/stopped.\n\n Since: 2.22"]
pub type GDriveStartStopType = ::std::os::raw::c_uint;
pub const GFileCopyFlags_G_FILE_COPY_NONE: GFileCopyFlags = 0;
pub const GFileCopyFlags_G_FILE_COPY_OVERWRITE: GFileCopyFlags = 1;
pub const GFileCopyFlags_G_FILE_COPY_BACKUP: GFileCopyFlags = 2;
pub const GFileCopyFlags_G_FILE_COPY_NOFOLLOW_SYMLINKS: GFileCopyFlags = 4;
pub const GFileCopyFlags_G_FILE_COPY_ALL_METADATA: GFileCopyFlags = 8;
pub const GFileCopyFlags_G_FILE_COPY_NO_FALLBACK_FOR_MOVE: GFileCopyFlags = 16;
pub const GFileCopyFlags_G_FILE_COPY_TARGET_DEFAULT_PERMS: GFileCopyFlags = 32;
#[doc = " GFileCopyFlags:\n @G_FILE_COPY_NONE: No flags set.\n @G_FILE_COPY_OVERWRITE: Overwrite any existing files\n @G_FILE_COPY_BACKUP: Make a backup of any existing files.\n @G_FILE_COPY_NOFOLLOW_SYMLINKS: Don't follow symlinks.\n @G_FILE_COPY_ALL_METADATA: Copy all file metadata instead of just default set used for copy (see #GFileInfo).\n @G_FILE_COPY_NO_FALLBACK_FOR_MOVE: Don't use copy and delete fallback if native move not supported.\n @G_FILE_COPY_TARGET_DEFAULT_PERMS: Leaves target file with default perms, instead of setting the source file perms.\n\n Flags used when copying or moving files."]
pub type GFileCopyFlags = ::std::os::raw::c_uint;
pub const GFileMonitorFlags_G_FILE_MONITOR_NONE: GFileMonitorFlags = 0;
pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_MOUNTS: GFileMonitorFlags = 1;
pub const GFileMonitorFlags_G_FILE_MONITOR_SEND_MOVED: GFileMonitorFlags = 2;
pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_HARD_LINKS: GFileMonitorFlags = 4;
pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_MOVES: GFileMonitorFlags = 8;
#[doc = " GFileMonitorFlags:\n @G_FILE_MONITOR_NONE: No flags set.\n @G_FILE_MONITOR_WATCH_MOUNTS: Watch for mount events.\n @G_FILE_MONITOR_SEND_MOVED: Pair DELETED and CREATED events caused\n   by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED\n   event instead (NB: not supported on all backends; the default\n   behaviour -without specifying this flag- is to send single DELETED\n   and CREATED events).  Deprecated since 2.46: use\n   %G_FILE_MONITOR_WATCH_MOVES instead.\n @G_FILE_MONITOR_WATCH_HARD_LINKS: Watch for changes to the file made\n   via another hard link. Since 2.36.\n @G_FILE_MONITOR_WATCH_MOVES: Watch for rename operations on a\n   monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,\n   %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT\n   events to be emitted when possible.  Since: 2.46.\n\n Flags used to set what a #GFileMonitor will watch for."]
pub type GFileMonitorFlags = ::std::os::raw::c_uint;
pub const GFileType_G_FILE_TYPE_UNKNOWN: GFileType = 0;
pub const GFileType_G_FILE_TYPE_REGULAR: GFileType = 1;
pub const GFileType_G_FILE_TYPE_DIRECTORY: GFileType = 2;
pub const GFileType_G_FILE_TYPE_SYMBOLIC_LINK: GFileType = 3;
pub const GFileType_G_FILE_TYPE_SPECIAL: GFileType = 4;
pub const GFileType_G_FILE_TYPE_SHORTCUT: GFileType = 5;
pub const GFileType_G_FILE_TYPE_MOUNTABLE: GFileType = 6;
#[doc = " GFileType:\n @G_FILE_TYPE_UNKNOWN: File's type is unknown.\n @G_FILE_TYPE_REGULAR: File handle represents a regular file.\n @G_FILE_TYPE_DIRECTORY: File handle represents a directory.\n @G_FILE_TYPE_SYMBOLIC_LINK: File handle represents a symbolic link\n    (Unix systems).\n @G_FILE_TYPE_SPECIAL: File is a \"special\" file, such as a socket, fifo,\n    block device, or character device.\n @G_FILE_TYPE_SHORTCUT: File is a shortcut (Windows systems).\n @G_FILE_TYPE_MOUNTABLE: File is a mountable location.\n\n Indicates the file's on-disk type.\n\n On Windows systems a file will never have %G_FILE_TYPE_SYMBOLIC_LINK type;\n use #GFileInfo and %G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK to determine\n whether a file is a symlink or not. This is due to the fact that NTFS does\n not have a single filesystem object type for symbolic links - it has\n files that symlink to files, and directories that symlink to directories.\n #GFileType enumeration cannot precisely represent this important distinction,\n which is why all Windows symlinks will continue to be reported as\n %G_FILE_TYPE_REGULAR or %G_FILE_TYPE_DIRECTORY."]
pub type GFileType = ::std::os::raw::c_uint;
pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS: GFilesystemPreviewType = 0;
pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL: GFilesystemPreviewType = 1;
pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_NEVER: GFilesystemPreviewType = 2;
#[doc = " GFilesystemPreviewType:\n @G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS: Only preview files if user has explicitly requested it.\n @G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL: Preview files if user has requested preview of \"local\" files.\n @G_FILESYSTEM_PREVIEW_TYPE_NEVER: Never preview files.\n\n Indicates a hint from the file system whether files should be\n previewed in a file manager. Returned as the value of the key\n %G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW."]
pub type GFilesystemPreviewType = ::std::os::raw::c_uint;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CHANGED: GFileMonitorEvent = 0;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT: GFileMonitorEvent = 1;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_DELETED: GFileMonitorEvent = 2;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CREATED: GFileMonitorEvent = 3;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED: GFileMonitorEvent = 4;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_PRE_UNMOUNT: GFileMonitorEvent = 5;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_UNMOUNTED: GFileMonitorEvent = 6;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED: GFileMonitorEvent = 7;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_RENAMED: GFileMonitorEvent = 8;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED_IN: GFileMonitorEvent = 9;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED_OUT: GFileMonitorEvent = 10;
#[doc = " GFileMonitorEvent:\n @G_FILE_MONITOR_EVENT_CHANGED: a file changed.\n @G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT: a hint that this was probably the last change in a set of changes.\n @G_FILE_MONITOR_EVENT_DELETED: a file was deleted.\n @G_FILE_MONITOR_EVENT_CREATED: a file was created.\n @G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED: a file attribute was changed.\n @G_FILE_MONITOR_EVENT_PRE_UNMOUNT: the file location will soon be unmounted.\n @G_FILE_MONITOR_EVENT_UNMOUNTED: the file location was unmounted.\n @G_FILE_MONITOR_EVENT_MOVED: the file was moved -- only sent if the\n   (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set\n @G_FILE_MONITOR_EVENT_RENAMED: the file was renamed within the\n   current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES\n   flag is set.  Since: 2.46.\n @G_FILE_MONITOR_EVENT_MOVED_IN: the file was moved into the\n   monitored directory from another location -- only sent if the\n   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.\n @G_FILE_MONITOR_EVENT_MOVED_OUT: the file was moved out of the\n   monitored directory to another location -- only sent if the\n   %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46\n\n Specifies what type of event a monitor event is."]
pub type GFileMonitorEvent = ::std::os::raw::c_uint;
pub const GIOErrorEnum_G_IO_ERROR_FAILED: GIOErrorEnum = 0;
pub const GIOErrorEnum_G_IO_ERROR_NOT_FOUND: GIOErrorEnum = 1;
pub const GIOErrorEnum_G_IO_ERROR_EXISTS: GIOErrorEnum = 2;
pub const GIOErrorEnum_G_IO_ERROR_IS_DIRECTORY: GIOErrorEnum = 3;
pub const GIOErrorEnum_G_IO_ERROR_NOT_DIRECTORY: GIOErrorEnum = 4;
pub const GIOErrorEnum_G_IO_ERROR_NOT_EMPTY: GIOErrorEnum = 5;
pub const GIOErrorEnum_G_IO_ERROR_NOT_REGULAR_FILE: GIOErrorEnum = 6;
pub const GIOErrorEnum_G_IO_ERROR_NOT_SYMBOLIC_LINK: GIOErrorEnum = 7;
pub const GIOErrorEnum_G_IO_ERROR_NOT_MOUNTABLE_FILE: GIOErrorEnum = 8;
pub const GIOErrorEnum_G_IO_ERROR_FILENAME_TOO_LONG: GIOErrorEnum = 9;
pub const GIOErrorEnum_G_IO_ERROR_INVALID_FILENAME: GIOErrorEnum = 10;
pub const GIOErrorEnum_G_IO_ERROR_TOO_MANY_LINKS: GIOErrorEnum = 11;
pub const GIOErrorEnum_G_IO_ERROR_NO_SPACE: GIOErrorEnum = 12;
pub const GIOErrorEnum_G_IO_ERROR_INVALID_ARGUMENT: GIOErrorEnum = 13;
pub const GIOErrorEnum_G_IO_ERROR_PERMISSION_DENIED: GIOErrorEnum = 14;
pub const GIOErrorEnum_G_IO_ERROR_NOT_SUPPORTED: GIOErrorEnum = 15;
pub const GIOErrorEnum_G_IO_ERROR_NOT_MOUNTED: GIOErrorEnum = 16;
pub const GIOErrorEnum_G_IO_ERROR_ALREADY_MOUNTED: GIOErrorEnum = 17;
pub const GIOErrorEnum_G_IO_ERROR_CLOSED: GIOErrorEnum = 18;
pub const GIOErrorEnum_G_IO_ERROR_CANCELLED: GIOErrorEnum = 19;
pub const GIOErrorEnum_G_IO_ERROR_PENDING: GIOErrorEnum = 20;
pub const GIOErrorEnum_G_IO_ERROR_READ_ONLY: GIOErrorEnum = 21;
pub const GIOErrorEnum_G_IO_ERROR_CANT_CREATE_BACKUP: GIOErrorEnum = 22;
pub const GIOErrorEnum_G_IO_ERROR_WRONG_ETAG: GIOErrorEnum = 23;
pub const GIOErrorEnum_G_IO_ERROR_TIMED_OUT: GIOErrorEnum = 24;
pub const GIOErrorEnum_G_IO_ERROR_WOULD_RECURSE: GIOErrorEnum = 25;
pub const GIOErrorEnum_G_IO_ERROR_BUSY: GIOErrorEnum = 26;
pub const GIOErrorEnum_G_IO_ERROR_WOULD_BLOCK: GIOErrorEnum = 27;
pub const GIOErrorEnum_G_IO_ERROR_HOST_NOT_FOUND: GIOErrorEnum = 28;
pub const GIOErrorEnum_G_IO_ERROR_WOULD_MERGE: GIOErrorEnum = 29;
pub const GIOErrorEnum_G_IO_ERROR_FAILED_HANDLED: GIOErrorEnum = 30;
pub const GIOErrorEnum_G_IO_ERROR_TOO_MANY_OPEN_FILES: GIOErrorEnum = 31;
pub const GIOErrorEnum_G_IO_ERROR_NOT_INITIALIZED: GIOErrorEnum = 32;
pub const GIOErrorEnum_G_IO_ERROR_ADDRESS_IN_USE: GIOErrorEnum = 33;
pub const GIOErrorEnum_G_IO_ERROR_PARTIAL_INPUT: GIOErrorEnum = 34;
pub const GIOErrorEnum_G_IO_ERROR_INVALID_DATA: GIOErrorEnum = 35;
pub const GIOErrorEnum_G_IO_ERROR_DBUS_ERROR: GIOErrorEnum = 36;
pub const GIOErrorEnum_G_IO_ERROR_HOST_UNREACHABLE: GIOErrorEnum = 37;
pub const GIOErrorEnum_G_IO_ERROR_NETWORK_UNREACHABLE: GIOErrorEnum = 38;
pub const GIOErrorEnum_G_IO_ERROR_CONNECTION_REFUSED: GIOErrorEnum = 39;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_FAILED: GIOErrorEnum = 40;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_AUTH_FAILED: GIOErrorEnum = 41;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_NEED_AUTH: GIOErrorEnum = 42;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_NOT_ALLOWED: GIOErrorEnum = 43;
pub const GIOErrorEnum_G_IO_ERROR_BROKEN_PIPE: GIOErrorEnum = 44;
pub const GIOErrorEnum_G_IO_ERROR_CONNECTION_CLOSED: GIOErrorEnum = 44;
pub const GIOErrorEnum_G_IO_ERROR_NOT_CONNECTED: GIOErrorEnum = 45;
pub const GIOErrorEnum_G_IO_ERROR_MESSAGE_TOO_LARGE: GIOErrorEnum = 46;
pub const GIOErrorEnum_G_IO_ERROR_NO_SUCH_DEVICE: GIOErrorEnum = 47;
#[doc = " GIOErrorEnum:\n @G_IO_ERROR_FAILED: Generic error condition for when an operation fails\n     and no more specific #GIOErrorEnum value is defined.\n @G_IO_ERROR_NOT_FOUND: File not found.\n @G_IO_ERROR_EXISTS: File already exists.\n @G_IO_ERROR_IS_DIRECTORY: File is a directory.\n @G_IO_ERROR_NOT_DIRECTORY: File is not a directory.\n @G_IO_ERROR_NOT_EMPTY: File is a directory that isn't empty.\n @G_IO_ERROR_NOT_REGULAR_FILE: File is not a regular file.\n @G_IO_ERROR_NOT_SYMBOLIC_LINK: File is not a symbolic link.\n @G_IO_ERROR_NOT_MOUNTABLE_FILE: File cannot be mounted.\n @G_IO_ERROR_FILENAME_TOO_LONG: Filename is too many characters.\n @G_IO_ERROR_INVALID_FILENAME: Filename is invalid or contains invalid characters.\n @G_IO_ERROR_TOO_MANY_LINKS: File contains too many symbolic links.\n @G_IO_ERROR_NO_SPACE: No space left on drive.\n @G_IO_ERROR_INVALID_ARGUMENT: Invalid argument.\n @G_IO_ERROR_PERMISSION_DENIED: Permission denied.\n @G_IO_ERROR_NOT_SUPPORTED: Operation (or one of its parameters) not supported\n @G_IO_ERROR_NOT_MOUNTED: File isn't mounted.\n @G_IO_ERROR_ALREADY_MOUNTED: File is already mounted.\n @G_IO_ERROR_CLOSED: File was closed.\n @G_IO_ERROR_CANCELLED: Operation was cancelled. See #GCancellable.\n @G_IO_ERROR_PENDING: Operations are still pending.\n @G_IO_ERROR_READ_ONLY: File is read only.\n @G_IO_ERROR_CANT_CREATE_BACKUP: Backup couldn't be created.\n @G_IO_ERROR_WRONG_ETAG: File's Entity Tag was incorrect.\n @G_IO_ERROR_TIMED_OUT: Operation timed out.\n @G_IO_ERROR_WOULD_RECURSE: Operation would be recursive.\n @G_IO_ERROR_BUSY: File is busy.\n @G_IO_ERROR_WOULD_BLOCK: Operation would block.\n @G_IO_ERROR_HOST_NOT_FOUND: Host couldn't be found (remote operations).\n @G_IO_ERROR_WOULD_MERGE: Operation would merge files.\n @G_IO_ERROR_FAILED_HANDLED: Operation failed and a helper program has\n     already interacted with the user. Do not display any error dialog.\n @G_IO_ERROR_TOO_MANY_OPEN_FILES: The current process has too many files\n     open and can't open any more. Duplicate descriptors do count toward\n     this limit. Since 2.20\n @G_IO_ERROR_NOT_INITIALIZED: The object has not been initialized. Since 2.22\n @G_IO_ERROR_ADDRESS_IN_USE: The requested address is already in use. Since 2.22\n @G_IO_ERROR_PARTIAL_INPUT: Need more input to finish operation. Since 2.24\n @G_IO_ERROR_INVALID_DATA: The input data was invalid. Since 2.24\n @G_IO_ERROR_DBUS_ERROR: A remote object generated an error that\n     doesn't correspond to a locally registered #GError error\n     domain. Use g_dbus_error_get_remote_error() to extract the D-Bus\n     error name and g_dbus_error_strip_remote_error() to fix up the\n     message so it matches what was received on the wire. Since 2.26.\n @G_IO_ERROR_HOST_UNREACHABLE: Host unreachable. Since 2.26\n @G_IO_ERROR_NETWORK_UNREACHABLE: Network unreachable. Since 2.26\n @G_IO_ERROR_CONNECTION_REFUSED: Connection refused. Since 2.26\n @G_IO_ERROR_PROXY_FAILED: Connection to proxy server failed. Since 2.26\n @G_IO_ERROR_PROXY_AUTH_FAILED: Proxy authentication failed. Since 2.26\n @G_IO_ERROR_PROXY_NEED_AUTH: Proxy server needs authentication. Since 2.26\n @G_IO_ERROR_PROXY_NOT_ALLOWED: Proxy connection is not allowed by ruleset.\n     Since 2.26\n @G_IO_ERROR_BROKEN_PIPE: Broken pipe. Since 2.36\n @G_IO_ERROR_CONNECTION_CLOSED: Connection closed by peer. Note that this\n     is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some\n     \"connection closed\" errors returned %G_IO_ERROR_BROKEN_PIPE, but others\n     returned %G_IO_ERROR_FAILED. Now they should all return the same\n     value, which has this more logical name. Since 2.44.\n @G_IO_ERROR_NOT_CONNECTED: Transport endpoint is not connected. Since 2.44\n @G_IO_ERROR_MESSAGE_TOO_LARGE: Message too large. Since 2.48.\n @G_IO_ERROR_NO_SUCH_DEVICE: No such device found. Since 2.74\n\n Error codes returned by GIO functions.\n\n Note that this domain may be extended in future GLib releases. In\n general, new error codes either only apply to new APIs, or else\n replace %G_IO_ERROR_FAILED in cases that were not explicitly\n distinguished before. You should therefore avoid writing code like\n |[<!-- language=\"C\" -->\n if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))\n   {\n     // Assume that this is EPRINTERONFIRE\n     ...\n   }\n ]|\n but should instead treat all unrecognized error codes the same as\n %G_IO_ERROR_FAILED.\n\n See also #GPollableReturn for a cheaper way of returning\n %G_IO_ERROR_WOULD_BLOCK to callers without allocating a #GError."]
pub type GIOErrorEnum = ::std::os::raw::c_uint;
pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_PASSWORD: GAskPasswordFlags = 1;
pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_USERNAME: GAskPasswordFlags = 2;
pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_DOMAIN: GAskPasswordFlags = 4;
pub const GAskPasswordFlags_G_ASK_PASSWORD_SAVING_SUPPORTED: GAskPasswordFlags = 8;
pub const GAskPasswordFlags_G_ASK_PASSWORD_ANONYMOUS_SUPPORTED: GAskPasswordFlags = 16;
pub const GAskPasswordFlags_G_ASK_PASSWORD_TCRYPT: GAskPasswordFlags = 32;
#[doc = " GAskPasswordFlags:\n @G_ASK_PASSWORD_NEED_PASSWORD: operation requires a password.\n @G_ASK_PASSWORD_NEED_USERNAME: operation requires a username.\n @G_ASK_PASSWORD_NEED_DOMAIN: operation requires a domain.\n @G_ASK_PASSWORD_SAVING_SUPPORTED: operation supports saving settings.\n @G_ASK_PASSWORD_ANONYMOUS_SUPPORTED: operation supports anonymous users.\n @G_ASK_PASSWORD_TCRYPT: operation takes TCRYPT parameters (Since: 2.58)\n\n #GAskPasswordFlags are used to request specific information from the\n user, or to notify the user of their choices in an authentication\n situation."]
pub type GAskPasswordFlags = ::std::os::raw::c_uint;
pub const GPasswordSave_G_PASSWORD_SAVE_NEVER: GPasswordSave = 0;
pub const GPasswordSave_G_PASSWORD_SAVE_FOR_SESSION: GPasswordSave = 1;
pub const GPasswordSave_G_PASSWORD_SAVE_PERMANENTLY: GPasswordSave = 2;
#[doc = " GPasswordSave:\n @G_PASSWORD_SAVE_NEVER: never save a password.\n @G_PASSWORD_SAVE_FOR_SESSION: save a password for the session.\n @G_PASSWORD_SAVE_PERMANENTLY: save a password permanently.\n\n #GPasswordSave is used to indicate the lifespan of a saved password.\n\n #Gvfs stores passwords in the Gnome keyring when this flag allows it\n to, and later retrieves it again from there."]
pub type GPasswordSave = ::std::os::raw::c_uint;
pub const GMountOperationResult_G_MOUNT_OPERATION_HANDLED: GMountOperationResult = 0;
pub const GMountOperationResult_G_MOUNT_OPERATION_ABORTED: GMountOperationResult = 1;
pub const GMountOperationResult_G_MOUNT_OPERATION_UNHANDLED: GMountOperationResult = 2;
#[doc = " GMountOperationResult:\n @G_MOUNT_OPERATION_HANDLED: The request was fulfilled and the\n     user specified data is now available\n @G_MOUNT_OPERATION_ABORTED: The user requested the mount operation\n     to be aborted\n @G_MOUNT_OPERATION_UNHANDLED: The request was unhandled (i.e. not\n     implemented)\n\n #GMountOperationResult is returned as a result when a request for\n information is send by the mounting operation."]
pub type GMountOperationResult = ::std::os::raw::c_uint;
pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_NONE: GOutputStreamSpliceFlags = 0;
pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE: GOutputStreamSpliceFlags =
    1;
pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET: GOutputStreamSpliceFlags =
    2;
#[doc = " GOutputStreamSpliceFlags:\n @G_OUTPUT_STREAM_SPLICE_NONE: Do not close either stream.\n @G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE: Close the source stream after\n     the splice.\n @G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET: Close the target stream after\n     the splice.\n\n GOutputStreamSpliceFlags determine how streams should be spliced."]
pub type GOutputStreamSpliceFlags = ::std::os::raw::c_uint;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_NONE: GIOStreamSpliceFlags = 0;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_CLOSE_STREAM1: GIOStreamSpliceFlags = 1;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_CLOSE_STREAM2: GIOStreamSpliceFlags = 2;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_WAIT_FOR_BOTH: GIOStreamSpliceFlags = 4;
#[doc = " GIOStreamSpliceFlags:\n @G_IO_STREAM_SPLICE_NONE: Do not close either stream.\n @G_IO_STREAM_SPLICE_CLOSE_STREAM1: Close the first stream after\n     the splice.\n @G_IO_STREAM_SPLICE_CLOSE_STREAM2: Close the second stream after\n     the splice.\n @G_IO_STREAM_SPLICE_WAIT_FOR_BOTH: Wait for both splice operations to finish\n     before calling the callback.\n\n GIOStreamSpliceFlags determine how streams should be spliced.\n\n Since: 2.28"]
pub type GIOStreamSpliceFlags = ::std::os::raw::c_uint;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_UNKNOWN: GEmblemOrigin = 0;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_DEVICE: GEmblemOrigin = 1;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_LIVEMETADATA: GEmblemOrigin = 2;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_TAG: GEmblemOrigin = 3;
#[doc = " GEmblemOrigin:\n @G_EMBLEM_ORIGIN_UNKNOWN: Emblem of unknown origin\n @G_EMBLEM_ORIGIN_DEVICE: Emblem adds device-specific information\n @G_EMBLEM_ORIGIN_LIVEMETADATA: Emblem depicts live metadata, such as \"readonly\"\n @G_EMBLEM_ORIGIN_TAG: Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)\n\n GEmblemOrigin is used to add information about the origin of the emblem\n to #GEmblem.\n\n Since: 2.18"]
pub type GEmblemOrigin = ::std::os::raw::c_uint;
pub const GResolverError_G_RESOLVER_ERROR_NOT_FOUND: GResolverError = 0;
pub const GResolverError_G_RESOLVER_ERROR_TEMPORARY_FAILURE: GResolverError = 1;
pub const GResolverError_G_RESOLVER_ERROR_INTERNAL: GResolverError = 2;
#[doc = " GResolverError:\n @G_RESOLVER_ERROR_NOT_FOUND: the requested name/address/service was not\n     found\n @G_RESOLVER_ERROR_TEMPORARY_FAILURE: the requested information could not\n     be looked up due to a network error or similar problem\n @G_RESOLVER_ERROR_INTERNAL: unknown error\n\n An error code used with %G_RESOLVER_ERROR in a #GError returned\n from a #GResolver routine.\n\n Since: 2.22"]
pub type GResolverError = ::std::os::raw::c_uint;
pub const GResolverRecordType_G_RESOLVER_RECORD_SRV: GResolverRecordType = 1;
pub const GResolverRecordType_G_RESOLVER_RECORD_MX: GResolverRecordType = 2;
pub const GResolverRecordType_G_RESOLVER_RECORD_TXT: GResolverRecordType = 3;
pub const GResolverRecordType_G_RESOLVER_RECORD_SOA: GResolverRecordType = 4;
pub const GResolverRecordType_G_RESOLVER_RECORD_NS: GResolverRecordType = 5;
#[doc = " GResolverRecordType:\n @G_RESOLVER_RECORD_SRV: look up DNS SRV records for a domain\n @G_RESOLVER_RECORD_MX: look up DNS MX records for a domain\n @G_RESOLVER_RECORD_TXT: look up DNS TXT records for a name\n @G_RESOLVER_RECORD_SOA: look up DNS SOA records for a zone\n @G_RESOLVER_RECORD_NS: look up DNS NS records for a domain\n\n The type of record that g_resolver_lookup_records() or\n g_resolver_lookup_records_async() should retrieve. The records are returned\n as lists of #GVariant tuples. Each record type has different values in\n the variant tuples returned.\n\n %G_RESOLVER_RECORD_SRV records are returned as variants with the signature\n `(qqqs)`, containing a `guint16` with the priority, a `guint16` with the\n weight, a `guint16` with the port, and a string of the hostname.\n\n %G_RESOLVER_RECORD_MX records are returned as variants with the signature\n `(qs)`, representing a `guint16` with the preference, and a string containing\n the mail exchanger hostname.\n\n %G_RESOLVER_RECORD_TXT records are returned as variants with the signature\n `(as)`, representing an array of the strings in the text record. Note: Most TXT\n records only contain a single string, but\n [RFC 1035](https://tools.ietf.org/html/rfc1035#section-3.3.14) does allow a\n record to contain multiple strings. The RFC which defines the interpretation\n of a specific TXT record will likely require concatenation of multiple\n strings if they are present, as with\n [RFC 7208](https://tools.ietf.org/html/rfc7208#section-3.3).\n\n %G_RESOLVER_RECORD_SOA records are returned as variants with the signature\n `(ssuuuuu)`, representing a string containing the primary name server, a\n string containing the administrator, the serial as a `guint32`, the refresh\n interval as a `guint32`, the retry interval as a `guint32`, the expire timeout\n as a `guint32`, and the TTL as a `guint32`.\n\n %G_RESOLVER_RECORD_NS records are returned as variants with the signature\n `(s)`, representing a string of the hostname of the name server.\n\n Since: 2.34"]
pub type GResolverRecordType = ::std::os::raw::c_uint;
pub const GResourceError_G_RESOURCE_ERROR_NOT_FOUND: GResourceError = 0;
pub const GResourceError_G_RESOURCE_ERROR_INTERNAL: GResourceError = 1;
#[doc = " GResourceError:\n @G_RESOURCE_ERROR_NOT_FOUND: no file was found at the requested path\n @G_RESOURCE_ERROR_INTERNAL: unknown error\n\n An error code used with %G_RESOURCE_ERROR in a #GError returned\n from a #GResource routine.\n\n Since: 2.32"]
pub type GResourceError = ::std::os::raw::c_uint;
pub const GResourceFlags_G_RESOURCE_FLAGS_NONE: GResourceFlags = 0;
pub const GResourceFlags_G_RESOURCE_FLAGS_COMPRESSED: GResourceFlags = 1;
#[doc = " GResourceFlags:\n @G_RESOURCE_FLAGS_NONE: No flags set.\n @G_RESOURCE_FLAGS_COMPRESSED: The file is compressed.\n\n GResourceFlags give information about a particular file inside a resource\n bundle.\n\n Since: 2.32"]
pub type GResourceFlags = ::std::os::raw::c_uint;
pub const GResourceLookupFlags_G_RESOURCE_LOOKUP_FLAGS_NONE: GResourceLookupFlags = 0;
#[doc = " GResourceLookupFlags:\n @G_RESOURCE_LOOKUP_FLAGS_NONE: No flags set.\n\n GResourceLookupFlags determine how resource path lookups are handled.\n\n Since: 2.32"]
pub type GResourceLookupFlags = ::std::os::raw::c_uint;
pub const GSocketFamily_G_SOCKET_FAMILY_INVALID: GSocketFamily = 0;
pub const GSocketFamily_G_SOCKET_FAMILY_UNIX: GSocketFamily = 1;
pub const GSocketFamily_G_SOCKET_FAMILY_IPV4: GSocketFamily = 2;
pub const GSocketFamily_G_SOCKET_FAMILY_IPV6: GSocketFamily = 10;
#[doc = " GSocketFamily:\n @G_SOCKET_FAMILY_INVALID: no address family\n @G_SOCKET_FAMILY_IPV4: the IPv4 family\n @G_SOCKET_FAMILY_IPV6: the IPv6 family\n @G_SOCKET_FAMILY_UNIX: the UNIX domain family\n\n The protocol family of a #GSocketAddress. (These values are\n identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,\n if available.)\n\n Since: 2.22"]
pub type GSocketFamily = ::std::os::raw::c_uint;
pub const GSocketType_G_SOCKET_TYPE_INVALID: GSocketType = 0;
pub const GSocketType_G_SOCKET_TYPE_STREAM: GSocketType = 1;
pub const GSocketType_G_SOCKET_TYPE_DATAGRAM: GSocketType = 2;
pub const GSocketType_G_SOCKET_TYPE_SEQPACKET: GSocketType = 3;
#[doc = " GSocketType:\n @G_SOCKET_TYPE_INVALID: Type unknown or wrong\n @G_SOCKET_TYPE_STREAM: Reliable connection-based byte streams (e.g. TCP).\n @G_SOCKET_TYPE_DATAGRAM: Connectionless, unreliable datagram passing.\n     (e.g. UDP)\n @G_SOCKET_TYPE_SEQPACKET: Reliable connection-based passing of datagrams\n     of fixed maximum length (e.g. SCTP).\n\n Flags used when creating a #GSocket. Some protocols may not implement\n all the socket types.\n\n Since: 2.22"]
pub type GSocketType = ::std::os::raw::c_uint;
pub const GSocketMsgFlags_G_SOCKET_MSG_NONE: GSocketMsgFlags = 0;
pub const GSocketMsgFlags_G_SOCKET_MSG_OOB: GSocketMsgFlags = 1;
pub const GSocketMsgFlags_G_SOCKET_MSG_PEEK: GSocketMsgFlags = 2;
pub const GSocketMsgFlags_G_SOCKET_MSG_DONTROUTE: GSocketMsgFlags = 4;
#[doc = " GSocketMsgFlags:\n @G_SOCKET_MSG_NONE: No flags.\n @G_SOCKET_MSG_OOB: Request to send/receive out of band data.\n @G_SOCKET_MSG_PEEK: Read data from the socket without removing it from\n     the queue.\n @G_SOCKET_MSG_DONTROUTE: Don't use a gateway to send out the packet,\n     only send to hosts on directly connected networks.\n\n Flags used in g_socket_receive_message() and g_socket_send_message().\n The flags listed in the enum are some commonly available flags, but the\n values used for them are the same as on the platform, and any other flags\n are passed in/out as is. So to use a platform specific flag, just include\n the right system header and pass in the flag.\n\n Since: 2.22"]
pub type GSocketMsgFlags = ::std::os::raw::c_uint;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_UNKNOWN: GSocketProtocol = -1;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_DEFAULT: GSocketProtocol = 0;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_TCP: GSocketProtocol = 6;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_UDP: GSocketProtocol = 17;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_SCTP: GSocketProtocol = 132;
#[doc = " GSocketProtocol:\n @G_SOCKET_PROTOCOL_UNKNOWN: The protocol type is unknown\n @G_SOCKET_PROTOCOL_DEFAULT: The default protocol for the family/type\n @G_SOCKET_PROTOCOL_TCP: TCP over IP\n @G_SOCKET_PROTOCOL_UDP: UDP over IP\n @G_SOCKET_PROTOCOL_SCTP: SCTP over IP\n\n A protocol identifier is specified when creating a #GSocket, which is a\n family/type specific identifier, where 0 means the default protocol for\n the particular family/type.\n\n This enum contains a set of commonly available and used protocols. You\n can also pass any other identifiers handled by the platform in order to\n use protocols not listed here.\n\n Since: 2.22"]
pub type GSocketProtocol = ::std::os::raw::c_int;
pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_ZLIB: GZlibCompressorFormat = 0;
pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_GZIP: GZlibCompressorFormat = 1;
pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_RAW: GZlibCompressorFormat = 2;
#[doc = " GZlibCompressorFormat:\n @G_ZLIB_COMPRESSOR_FORMAT_ZLIB: deflate compression with zlib header\n @G_ZLIB_COMPRESSOR_FORMAT_GZIP: gzip file format\n @G_ZLIB_COMPRESSOR_FORMAT_RAW: deflate compression with no header\n\n Used to select the type of data format to use for #GZlibDecompressor\n and #GZlibCompressor.\n\n Since: 2.24"]
pub type GZlibCompressorFormat = ::std::os::raw::c_uint;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_INVALID: GUnixSocketAddressType = 0;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ANONYMOUS: GUnixSocketAddressType = 1;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_PATH: GUnixSocketAddressType = 2;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ABSTRACT: GUnixSocketAddressType = 3;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED: GUnixSocketAddressType = 4;
#[doc = " GUnixSocketAddressType:\n @G_UNIX_SOCKET_ADDRESS_INVALID: invalid\n @G_UNIX_SOCKET_ADDRESS_ANONYMOUS: anonymous\n @G_UNIX_SOCKET_ADDRESS_PATH: a filesystem path\n @G_UNIX_SOCKET_ADDRESS_ABSTRACT: an abstract name\n @G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED: an abstract name, 0-padded\n   to the full length of a unix socket name\n\n The type of name used by a #GUnixSocketAddress.\n %G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain\n socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS\n indicates a socket not bound to any name (eg, a client-side socket,\n or a socket created with socketpair()).\n\n For abstract sockets, there are two incompatible ways of naming\n them; the man pages suggest using the entire `struct sockaddr_un`\n as the name, padding the unused parts of the %sun_path field with\n zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.\n However, many programs instead just use a portion of %sun_path, and\n pass an appropriate smaller length to bind() or connect(). This is\n %G_UNIX_SOCKET_ADDRESS_ABSTRACT.\n\n Since: 2.26"]
pub type GUnixSocketAddressType = ::std::os::raw::c_uint;
pub const GBusType_G_BUS_TYPE_STARTER: GBusType = -1;
pub const GBusType_G_BUS_TYPE_NONE: GBusType = 0;
pub const GBusType_G_BUS_TYPE_SYSTEM: GBusType = 1;
pub const GBusType_G_BUS_TYPE_SESSION: GBusType = 2;
#[doc = " GBusType:\n @G_BUS_TYPE_STARTER: An alias for the message bus that activated the process, if any.\n @G_BUS_TYPE_NONE: Not a message bus.\n @G_BUS_TYPE_SYSTEM: The system-wide message bus.\n @G_BUS_TYPE_SESSION: The login session message bus.\n\n An enumeration for well-known message buses.\n\n Since: 2.26"]
pub type GBusType = ::std::os::raw::c_int;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_NONE: GBusNameOwnerFlags = 0;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT: GBusNameOwnerFlags = 1;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_REPLACE: GBusNameOwnerFlags = 2;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE: GBusNameOwnerFlags = 4;
#[doc = " GBusNameOwnerFlags:\n @G_BUS_NAME_OWNER_FLAGS_NONE: No flags set.\n @G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT: Allow another message bus connection to claim the name.\n @G_BUS_NAME_OWNER_FLAGS_REPLACE: If another message bus connection owns the name and have\n specified %G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.\n @G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE: If another message bus connection owns the name, immediately\n return an error from g_bus_own_name() rather than entering the waiting queue for that name. (Since 2.54)\n\n Flags used in g_bus_own_name().\n\n Since: 2.26"]
pub type GBusNameOwnerFlags = ::std::os::raw::c_uint;
pub const GBusNameWatcherFlags_G_BUS_NAME_WATCHER_FLAGS_NONE: GBusNameWatcherFlags = 0;
pub const GBusNameWatcherFlags_G_BUS_NAME_WATCHER_FLAGS_AUTO_START: GBusNameWatcherFlags = 1;
#[doc = " GBusNameWatcherFlags:\n @G_BUS_NAME_WATCHER_FLAGS_NONE: No flags set.\n @G_BUS_NAME_WATCHER_FLAGS_AUTO_START: If no-one owns the name when\n beginning to watch the name, ask the bus to launch an owner for the\n name.\n\n Flags used in g_bus_watch_name().\n\n Since: 2.26"]
pub type GBusNameWatcherFlags = ::std::os::raw::c_uint;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_NONE: GDBusProxyFlags = 0;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES: GDBusProxyFlags = 1;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS: GDBusProxyFlags = 2;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START: GDBusProxyFlags = 4;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES: GDBusProxyFlags = 8;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION: GDBusProxyFlags =
    16;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_NO_MATCH_RULE: GDBusProxyFlags = 32;
#[doc = " GDBusProxyFlags:\n @G_DBUS_PROXY_FLAGS_NONE: No flags set.\n @G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES: Don't load properties.\n @G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS: Don't connect to signals on the remote object.\n @G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START: If the proxy is for a well-known name,\n do not ask the bus to launch an owner during proxy initialization or a method call.\n This flag is only meaningful in proxies for well-known names.\n @G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES: If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #GDBusProxy::g-properties-changed signal. When the value is received the #GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.\n @G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION: If the proxy is for a well-known name,\n do not ask the bus to launch an owner during proxy initialization, but allow it to be\n autostarted by a method call. This flag is only meaningful in proxies for well-known names,\n and only if %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.\n @G_DBUS_PROXY_FLAGS_NO_MATCH_RULE: Don't actually send the AddMatch D-Bus\n    call for this signal subscription. This gives you more control\n    over which match rules you add (but you must add them manually). (Since: 2.72)\n\n Flags used when constructing an instance of a #GDBusProxy derived class.\n\n Since: 2.26"]
pub type GDBusProxyFlags = ::std::os::raw::c_uint;
pub const GDBusError_G_DBUS_ERROR_FAILED: GDBusError = 0;
pub const GDBusError_G_DBUS_ERROR_NO_MEMORY: GDBusError = 1;
pub const GDBusError_G_DBUS_ERROR_SERVICE_UNKNOWN: GDBusError = 2;
pub const GDBusError_G_DBUS_ERROR_NAME_HAS_NO_OWNER: GDBusError = 3;
pub const GDBusError_G_DBUS_ERROR_NO_REPLY: GDBusError = 4;
pub const GDBusError_G_DBUS_ERROR_IO_ERROR: GDBusError = 5;
pub const GDBusError_G_DBUS_ERROR_BAD_ADDRESS: GDBusError = 6;
pub const GDBusError_G_DBUS_ERROR_NOT_SUPPORTED: GDBusError = 7;
pub const GDBusError_G_DBUS_ERROR_LIMITS_EXCEEDED: GDBusError = 8;
pub const GDBusError_G_DBUS_ERROR_ACCESS_DENIED: GDBusError = 9;
pub const GDBusError_G_DBUS_ERROR_AUTH_FAILED: GDBusError = 10;
pub const GDBusError_G_DBUS_ERROR_NO_SERVER: GDBusError = 11;
pub const GDBusError_G_DBUS_ERROR_TIMEOUT: GDBusError = 12;
pub const GDBusError_G_DBUS_ERROR_NO_NETWORK: GDBusError = 13;
pub const GDBusError_G_DBUS_ERROR_ADDRESS_IN_USE: GDBusError = 14;
pub const GDBusError_G_DBUS_ERROR_DISCONNECTED: GDBusError = 15;
pub const GDBusError_G_DBUS_ERROR_INVALID_ARGS: GDBusError = 16;
pub const GDBusError_G_DBUS_ERROR_FILE_NOT_FOUND: GDBusError = 17;
pub const GDBusError_G_DBUS_ERROR_FILE_EXISTS: GDBusError = 18;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_METHOD: GDBusError = 19;
pub const GDBusError_G_DBUS_ERROR_TIMED_OUT: GDBusError = 20;
pub const GDBusError_G_DBUS_ERROR_MATCH_RULE_NOT_FOUND: GDBusError = 21;
pub const GDBusError_G_DBUS_ERROR_MATCH_RULE_INVALID: GDBusError = 22;
pub const GDBusError_G_DBUS_ERROR_SPAWN_EXEC_FAILED: GDBusError = 23;
pub const GDBusError_G_DBUS_ERROR_SPAWN_FORK_FAILED: GDBusError = 24;
pub const GDBusError_G_DBUS_ERROR_SPAWN_CHILD_EXITED: GDBusError = 25;
pub const GDBusError_G_DBUS_ERROR_SPAWN_CHILD_SIGNALED: GDBusError = 26;
pub const GDBusError_G_DBUS_ERROR_SPAWN_FAILED: GDBusError = 27;
pub const GDBusError_G_DBUS_ERROR_SPAWN_SETUP_FAILED: GDBusError = 28;
pub const GDBusError_G_DBUS_ERROR_SPAWN_CONFIG_INVALID: GDBusError = 29;
pub const GDBusError_G_DBUS_ERROR_SPAWN_SERVICE_INVALID: GDBusError = 30;
pub const GDBusError_G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND: GDBusError = 31;
pub const GDBusError_G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID: GDBusError = 32;
pub const GDBusError_G_DBUS_ERROR_SPAWN_FILE_INVALID: GDBusError = 33;
pub const GDBusError_G_DBUS_ERROR_SPAWN_NO_MEMORY: GDBusError = 34;
pub const GDBusError_G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN: GDBusError = 35;
pub const GDBusError_G_DBUS_ERROR_INVALID_SIGNATURE: GDBusError = 36;
pub const GDBusError_G_DBUS_ERROR_INVALID_FILE_CONTENT: GDBusError = 37;
pub const GDBusError_G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN: GDBusError = 38;
pub const GDBusError_G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN: GDBusError = 39;
pub const GDBusError_G_DBUS_ERROR_OBJECT_PATH_IN_USE: GDBusError = 40;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_OBJECT: GDBusError = 41;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_INTERFACE: GDBusError = 42;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_PROPERTY: GDBusError = 43;
pub const GDBusError_G_DBUS_ERROR_PROPERTY_READ_ONLY: GDBusError = 44;
#[doc = " GDBusError:\n @G_DBUS_ERROR_FAILED:\n A generic error; \"something went wrong\" - see the error message for\n more.\n @G_DBUS_ERROR_NO_MEMORY:\n There was not enough memory to complete an operation.\n @G_DBUS_ERROR_SERVICE_UNKNOWN:\n The bus doesn't know how to launch a service to supply the bus name\n you wanted.\n @G_DBUS_ERROR_NAME_HAS_NO_OWNER:\n The bus name you referenced doesn't exist (i.e. no application owns\n it).\n @G_DBUS_ERROR_NO_REPLY:\n No reply to a message expecting one, usually means a timeout occurred.\n @G_DBUS_ERROR_IO_ERROR:\n Something went wrong reading or writing to a socket, for example.\n @G_DBUS_ERROR_BAD_ADDRESS:\n A D-Bus bus address was malformed.\n @G_DBUS_ERROR_NOT_SUPPORTED:\n Requested operation isn't supported (like ENOSYS on UNIX).\n @G_DBUS_ERROR_LIMITS_EXCEEDED:\n Some limited resource is exhausted.\n @G_DBUS_ERROR_ACCESS_DENIED:\n Security restrictions don't allow doing what you're trying to do.\n @G_DBUS_ERROR_AUTH_FAILED:\n Authentication didn't work.\n @G_DBUS_ERROR_NO_SERVER:\n Unable to connect to server (probably caused by ECONNREFUSED on a\n socket).\n @G_DBUS_ERROR_TIMEOUT:\n Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that\n %G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:\n this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also\n exists. We can't fix it for compatibility reasons so just be\n careful.\n @G_DBUS_ERROR_NO_NETWORK:\n No network access (probably ENETUNREACH on a socket).\n @G_DBUS_ERROR_ADDRESS_IN_USE:\n Can't bind a socket since its address is in use (i.e. EADDRINUSE).\n @G_DBUS_ERROR_DISCONNECTED:\n The connection is disconnected and you're trying to use it.\n @G_DBUS_ERROR_INVALID_ARGS:\n Invalid arguments passed to a method call.\n @G_DBUS_ERROR_FILE_NOT_FOUND:\n Missing file.\n @G_DBUS_ERROR_FILE_EXISTS:\n Existing file and the operation you're using does not silently overwrite.\n @G_DBUS_ERROR_UNKNOWN_METHOD:\n Method name you invoked isn't known by the object you invoked it on.\n @G_DBUS_ERROR_UNKNOWN_OBJECT:\n Object you invoked a method on isn't known. Since 2.42\n @G_DBUS_ERROR_UNKNOWN_INTERFACE:\n Interface you invoked a method on isn't known by the object. Since 2.42\n @G_DBUS_ERROR_UNKNOWN_PROPERTY:\n Property you tried to access isn't known by the object. Since 2.42\n @G_DBUS_ERROR_PROPERTY_READ_ONLY:\n Property you tried to set is read-only. Since 2.42\n @G_DBUS_ERROR_TIMED_OUT:\n Certain timeout errors, e.g. while starting a service. Warning: this is\n confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We\n can't fix it for compatibility reasons so just be careful.\n @G_DBUS_ERROR_MATCH_RULE_NOT_FOUND:\n Tried to remove or modify a match rule that didn't exist.\n @G_DBUS_ERROR_MATCH_RULE_INVALID:\n The match rule isn't syntactically valid.\n @G_DBUS_ERROR_SPAWN_EXEC_FAILED:\n While starting a new process, the exec() call failed.\n @G_DBUS_ERROR_SPAWN_FORK_FAILED:\n While starting a new process, the fork() call failed.\n @G_DBUS_ERROR_SPAWN_CHILD_EXITED:\n While starting a new process, the child exited with a status code.\n @G_DBUS_ERROR_SPAWN_CHILD_SIGNALED:\n While starting a new process, the child exited on a signal.\n @G_DBUS_ERROR_SPAWN_FAILED:\n While starting a new process, something went wrong.\n @G_DBUS_ERROR_SPAWN_SETUP_FAILED:\n We failed to setup the environment correctly.\n @G_DBUS_ERROR_SPAWN_CONFIG_INVALID:\n We failed to setup the config parser correctly.\n @G_DBUS_ERROR_SPAWN_SERVICE_INVALID:\n Bus name was not valid.\n @G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND:\n Service file not found in system-services directory.\n @G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID:\n Permissions are incorrect on the setuid helper.\n @G_DBUS_ERROR_SPAWN_FILE_INVALID:\n Service file invalid (Name, User or Exec missing).\n @G_DBUS_ERROR_SPAWN_NO_MEMORY:\n Tried to get a UNIX process ID and it wasn't available.\n @G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN:\n Tried to get a UNIX process ID and it wasn't available.\n @G_DBUS_ERROR_INVALID_SIGNATURE:\n A type signature is not valid.\n @G_DBUS_ERROR_INVALID_FILE_CONTENT:\n A file contains invalid syntax or is otherwise broken.\n @G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:\n Asked for SELinux security context and it wasn't available.\n @G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN:\n Asked for ADT audit data and it wasn't available.\n @G_DBUS_ERROR_OBJECT_PATH_IN_USE:\n There's already an object with the requested object path.\n\n Error codes for the %G_DBUS_ERROR error domain.\n\n Since: 2.26"]
pub type GDBusError = ::std::os::raw::c_uint;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_NONE: GDBusConnectionFlags = 0;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT: GDBusConnectionFlags =
    1;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER: GDBusConnectionFlags =
    2;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS:
    GDBusConnectionFlags = 4;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION:
    GDBusConnectionFlags = 8;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING:
    GDBusConnectionFlags = 16;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER:
    GDBusConnectionFlags = 32;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_CROSS_NAMESPACE: GDBusConnectionFlags = 64;
#[doc = " GDBusConnectionFlags:\n @G_DBUS_CONNECTION_FLAGS_NONE: No flags set.\n @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT: Perform authentication against server.\n @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER: Perform authentication against client.\n @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: When\n authenticating as a server, allow the anonymous authentication\n method.\n @G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION: Pass this flag if connecting to a peer that is a\n message bus. This means that the Hello() method will be invoked as part of the connection setup.\n @G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING: If set, processing of D-Bus messages is\n delayed until g_dbus_connection_start_message_processing() is called.\n @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: When authenticating\n as a server, require the UID of the peer to be the same as the UID of the server. (Since: 2.68)\n @G_DBUS_CONNECTION_FLAGS_CROSS_NAMESPACE: When authenticating, try to use\n  protocols that work across a Linux user namespace boundary, even if this\n  reduces interoperability with older D-Bus implementations. This currently\n  affects client-side `EXTERNAL` authentication, for which this flag makes\n  connections to a server in another user namespace succeed, but causes\n  a deadlock when connecting to a GDBus server older than 2.73.3. Since: 2.74\n\n Flags used when creating a new #GDBusConnection.\n\n Since: 2.26"]
pub type GDBusConnectionFlags = ::std::os::raw::c_uint;
pub const GDBusCapabilityFlags_G_DBUS_CAPABILITY_FLAGS_NONE: GDBusCapabilityFlags = 0;
pub const GDBusCapabilityFlags_G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING: GDBusCapabilityFlags = 1;
#[doc = " GDBusCapabilityFlags:\n @G_DBUS_CAPABILITY_FLAGS_NONE: No flags set.\n @G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING: The connection\n supports exchanging UNIX file descriptors with the remote peer.\n\n Capabilities negotiated with the remote peer.\n\n Since: 2.26"]
pub type GDBusCapabilityFlags = ::std::os::raw::c_uint;
pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_NONE: GDBusCallFlags = 0;
pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_NO_AUTO_START: GDBusCallFlags = 1;
pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: GDBusCallFlags = 2;
#[doc = " GDBusCallFlags:\n @G_DBUS_CALL_FLAGS_NONE: No flags set.\n @G_DBUS_CALL_FLAGS_NO_AUTO_START: The bus must not launch\n an owner for the destination name in response to this method\n invocation.\n @G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: the caller is prepared to\n wait for interactive authorization. Since 2.46.\n\n Flags used in g_dbus_connection_call() and similar APIs.\n\n Since: 2.26"]
pub type GDBusCallFlags = ::std::os::raw::c_uint;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_INVALID: GDBusMessageType = 0;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_METHOD_CALL: GDBusMessageType = 1;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_METHOD_RETURN: GDBusMessageType = 2;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_ERROR: GDBusMessageType = 3;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_SIGNAL: GDBusMessageType = 4;
#[doc = " GDBusMessageType:\n @G_DBUS_MESSAGE_TYPE_INVALID: Message is of invalid type.\n @G_DBUS_MESSAGE_TYPE_METHOD_CALL: Method call.\n @G_DBUS_MESSAGE_TYPE_METHOD_RETURN: Method reply.\n @G_DBUS_MESSAGE_TYPE_ERROR: Error reply.\n @G_DBUS_MESSAGE_TYPE_SIGNAL: Signal emission.\n\n Message types used in #GDBusMessage.\n\n Since: 2.26"]
pub type GDBusMessageType = ::std::os::raw::c_uint;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NONE: GDBusMessageFlags = 0;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED: GDBusMessageFlags = 1;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NO_AUTO_START: GDBusMessageFlags = 2;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION:
    GDBusMessageFlags = 4;
#[doc = " GDBusMessageFlags:\n @G_DBUS_MESSAGE_FLAGS_NONE: No flags set.\n @G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED: A reply is not expected.\n @G_DBUS_MESSAGE_FLAGS_NO_AUTO_START: The bus must not launch an\n owner for the destination name in response to this message.\n @G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: If set on a method\n call, this flag means that the caller is prepared to wait for interactive\n authorization. Since 2.46.\n\n Message flags used in #GDBusMessage.\n\n Since: 2.26"]
pub type GDBusMessageFlags = ::std::os::raw::c_uint;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_INVALID: GDBusMessageHeaderField = 0;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_PATH: GDBusMessageHeaderField = 1;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE: GDBusMessageHeaderField =
    2;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_MEMBER: GDBusMessageHeaderField = 3;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME: GDBusMessageHeaderField =
    4;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL:
    GDBusMessageHeaderField = 5;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION: GDBusMessageHeaderField =
    6;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_SENDER: GDBusMessageHeaderField = 7;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE: GDBusMessageHeaderField =
    8;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS:
    GDBusMessageHeaderField = 9;
#[doc = " GDBusMessageHeaderField:\n @G_DBUS_MESSAGE_HEADER_FIELD_INVALID: Not a valid header field.\n @G_DBUS_MESSAGE_HEADER_FIELD_PATH: The object path.\n @G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE: The interface name.\n @G_DBUS_MESSAGE_HEADER_FIELD_MEMBER: The method or signal name.\n @G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME: The name of the error that occurred.\n @G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL: The serial number the message is a reply to.\n @G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION: The name the message is intended for.\n @G_DBUS_MESSAGE_HEADER_FIELD_SENDER: Unique name of the sender of the message (filled in by the bus).\n @G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE: The signature of the message body.\n @G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS: The number of UNIX file descriptors that accompany the message.\n\n Header fields used in #GDBusMessage.\n\n Since: 2.26"]
pub type GDBusMessageHeaderField = ::std::os::raw::c_uint;
pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_NONE: GDBusPropertyInfoFlags = 0;
pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_READABLE: GDBusPropertyInfoFlags = 1;
pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE: GDBusPropertyInfoFlags = 2;
#[doc = " GDBusPropertyInfoFlags:\n @G_DBUS_PROPERTY_INFO_FLAGS_NONE: No flags set.\n @G_DBUS_PROPERTY_INFO_FLAGS_READABLE: Property is readable.\n @G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE: Property is writable.\n\n Flags describing the access control of a D-Bus property.\n\n Since: 2.26"]
pub type GDBusPropertyInfoFlags = ::std::os::raw::c_uint;
pub const GDBusSubtreeFlags_G_DBUS_SUBTREE_FLAGS_NONE: GDBusSubtreeFlags = 0;
pub const GDBusSubtreeFlags_G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES: GDBusSubtreeFlags =
    1;
#[doc = " GDBusSubtreeFlags:\n @G_DBUS_SUBTREE_FLAGS_NONE: No flags set.\n @G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES: Method calls to objects not in the enumerated range\n                                                       will still be dispatched. This is useful if you want\n                                                       to dynamically spawn objects in the subtree.\n\n Flags passed to g_dbus_connection_register_subtree().\n\n Since: 2.26"]
pub type GDBusSubtreeFlags = ::std::os::raw::c_uint;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_NONE: GDBusServerFlags = 0;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_RUN_IN_THREAD: GDBusServerFlags = 1;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: GDBusServerFlags = 2;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: GDBusServerFlags =
    4;
#[doc = " GDBusServerFlags:\n @G_DBUS_SERVER_FLAGS_NONE: No flags set.\n @G_DBUS_SERVER_FLAGS_RUN_IN_THREAD: All #GDBusServer::new-connection\n signals will run in separated dedicated threads (see signal for\n details).\n @G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: Allow the anonymous\n authentication method.\n @G_DBUS_SERVER_FLAGS_AUTHENTICATION_REQUIRE_SAME_USER: Require the UID of the\n peer to be the same as the UID of the server when authenticating. (Since: 2.68)\n\n Flags used when creating a #GDBusServer.\n\n Since: 2.26"]
pub type GDBusServerFlags = ::std::os::raw::c_uint;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_NONE: GDBusSignalFlags = 0;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE: GDBusSignalFlags = 1;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE: GDBusSignalFlags = 2;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH: GDBusSignalFlags = 4;
#[doc = " GDBusSignalFlags:\n @G_DBUS_SIGNAL_FLAGS_NONE: No flags set.\n @G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE: Don't actually send the AddMatch\n D-Bus call for this signal subscription.  This gives you more control\n over which match rules you add (but you must add them manually).\n @G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE: Match first arguments that\n contain a bus or interface name with the given namespace.\n @G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH: Match first arguments that\n contain an object path that is either equivalent to the given path,\n or one of the paths is a subpath of the other.\n\n Flags used when subscribing to signals via g_dbus_connection_signal_subscribe().\n\n Since: 2.26"]
pub type GDBusSignalFlags = ::std::os::raw::c_uint;
pub const GDBusSendMessageFlags_G_DBUS_SEND_MESSAGE_FLAGS_NONE: GDBusSendMessageFlags = 0;
pub const GDBusSendMessageFlags_G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL: GDBusSendMessageFlags =
    1;
#[doc = " GDBusSendMessageFlags:\n @G_DBUS_SEND_MESSAGE_FLAGS_NONE: No flags set.\n @G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL: Do not automatically\n assign a serial number from the #GDBusConnection object when\n sending a message.\n\n Flags used when sending #GDBusMessages on a #GDBusConnection.\n\n Since: 2.26"]
pub type GDBusSendMessageFlags = ::std::os::raw::c_uint;
pub const GCredentialsType_G_CREDENTIALS_TYPE_INVALID: GCredentialsType = 0;
pub const GCredentialsType_G_CREDENTIALS_TYPE_LINUX_UCRED: GCredentialsType = 1;
pub const GCredentialsType_G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED: GCredentialsType = 2;
pub const GCredentialsType_G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED: GCredentialsType = 3;
pub const GCredentialsType_G_CREDENTIALS_TYPE_SOLARIS_UCRED: GCredentialsType = 4;
pub const GCredentialsType_G_CREDENTIALS_TYPE_NETBSD_UNPCBID: GCredentialsType = 5;
pub const GCredentialsType_G_CREDENTIALS_TYPE_APPLE_XUCRED: GCredentialsType = 6;
pub const GCredentialsType_G_CREDENTIALS_TYPE_WIN32_PID: GCredentialsType = 7;
#[doc = " GCredentialsType:\n @G_CREDENTIALS_TYPE_INVALID: Indicates an invalid native credential type.\n @G_CREDENTIALS_TYPE_LINUX_UCRED: The native credentials type is a `struct ucred`.\n @G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED: The native credentials type is a `struct cmsgcred`.\n @G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED: The native credentials type is a `struct sockpeercred`. Added in 2.30.\n @G_CREDENTIALS_TYPE_SOLARIS_UCRED: The native credentials type is a `ucred_t`. Added in 2.40.\n @G_CREDENTIALS_TYPE_NETBSD_UNPCBID: The native credentials type is a `struct unpcbid`. Added in 2.42.\n @G_CREDENTIALS_TYPE_APPLE_XUCRED: The native credentials type is a `struct xucred`. Added in 2.66.\n @G_CREDENTIALS_TYPE_WIN32_PID: The native credentials type is a PID `DWORD`. Added in 2.72.\n\n Enumeration describing different kinds of native credential types.\n\n Since: 2.26"]
pub type GCredentialsType = ::std::os::raw::c_uint;
pub const GDBusMessageByteOrder_G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN: GDBusMessageByteOrder = 66;
pub const GDBusMessageByteOrder_G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN: GDBusMessageByteOrder =
    108;
#[doc = " GDBusMessageByteOrder:\n @G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN: The byte order is big endian.\n @G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN: The byte order is little endian.\n\n Enumeration used to describe the byte order of a D-Bus message.\n\n Since: 2.26"]
pub type GDBusMessageByteOrder = ::std::os::raw::c_uint;
pub const GApplicationFlags_G_APPLICATION_FLAGS_NONE: GApplicationFlags = 0;
pub const GApplicationFlags_G_APPLICATION_DEFAULT_FLAGS: GApplicationFlags = 0;
pub const GApplicationFlags_G_APPLICATION_IS_SERVICE: GApplicationFlags = 1;
pub const GApplicationFlags_G_APPLICATION_IS_LAUNCHER: GApplicationFlags = 2;
pub const GApplicationFlags_G_APPLICATION_HANDLES_OPEN: GApplicationFlags = 4;
pub const GApplicationFlags_G_APPLICATION_HANDLES_COMMAND_LINE: GApplicationFlags = 8;
pub const GApplicationFlags_G_APPLICATION_SEND_ENVIRONMENT: GApplicationFlags = 16;
pub const GApplicationFlags_G_APPLICATION_NON_UNIQUE: GApplicationFlags = 32;
pub const GApplicationFlags_G_APPLICATION_CAN_OVERRIDE_APP_ID: GApplicationFlags = 64;
pub const GApplicationFlags_G_APPLICATION_ALLOW_REPLACEMENT: GApplicationFlags = 128;
pub const GApplicationFlags_G_APPLICATION_REPLACE: GApplicationFlags = 256;
#[doc = " GApplicationFlags:\n @G_APPLICATION_FLAGS_NONE: Default. Deprecated in 2.74, use\n   %G_APPLICATION_DEFAULT_FLAGS instead\n @G_APPLICATION_DEFAULT_FLAGS: Default flags. Since: 2.74\n @G_APPLICATION_IS_SERVICE: Run as a service. In this mode, registration\n      fails if the service is already running, and the application\n      will initially wait up to 10 seconds for an initial activation\n      message to arrive.\n @G_APPLICATION_IS_LAUNCHER: Don't try to become the primary instance.\n @G_APPLICATION_HANDLES_OPEN: This application handles opening files (in\n     the primary instance). Note that this flag only affects the default\n     implementation of local_command_line(), and has no effect if\n     %G_APPLICATION_HANDLES_COMMAND_LINE is given.\n     See g_application_run() for details.\n @G_APPLICATION_HANDLES_COMMAND_LINE: This application handles command line\n     arguments (in the primary instance). Note that this flag only affect\n     the default implementation of local_command_line().\n     See g_application_run() for details.\n @G_APPLICATION_SEND_ENVIRONMENT: Send the environment of the\n     launching process to the primary instance. Set this flag if your\n     application is expected to behave differently depending on certain\n     environment variables. For instance, an editor might be expected\n     to use the `GIT_COMMITTER_NAME` environment variable\n     when editing a git commit message. The environment is available\n     to the #GApplication::command-line signal handler, via\n     g_application_command_line_getenv().\n @G_APPLICATION_NON_UNIQUE: Make no attempts to do any of the typical\n     single-instance application negotiation, even if the application\n     ID is given.  The application neither attempts to become the\n     owner of the application ID nor does it check if an existing\n     owner already exists.  Everything occurs in the local process.\n     Since: 2.30.\n @G_APPLICATION_CAN_OVERRIDE_APP_ID: Allow users to override the\n     application ID from the command line with `--gapplication-app-id`.\n     Since: 2.48\n @G_APPLICATION_ALLOW_REPLACEMENT: Allow another instance to take over\n     the bus name. Since: 2.60\n @G_APPLICATION_REPLACE: Take over from another instance. This flag is\n     usually set by passing `--gapplication-replace` on the commandline.\n     Since: 2.60\n\n Flags used to define the behaviour of a #GApplication.\n\n Since: 2.28"]
pub type GApplicationFlags = ::std::os::raw::c_uint;
pub const GTlsError_G_TLS_ERROR_UNAVAILABLE: GTlsError = 0;
pub const GTlsError_G_TLS_ERROR_MISC: GTlsError = 1;
pub const GTlsError_G_TLS_ERROR_BAD_CERTIFICATE: GTlsError = 2;
pub const GTlsError_G_TLS_ERROR_NOT_TLS: GTlsError = 3;
pub const GTlsError_G_TLS_ERROR_HANDSHAKE: GTlsError = 4;
pub const GTlsError_G_TLS_ERROR_CERTIFICATE_REQUIRED: GTlsError = 5;
pub const GTlsError_G_TLS_ERROR_EOF: GTlsError = 6;
pub const GTlsError_G_TLS_ERROR_INAPPROPRIATE_FALLBACK: GTlsError = 7;
pub const GTlsError_G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD: GTlsError = 8;
#[doc = " GTlsError:\n @G_TLS_ERROR_UNAVAILABLE: No TLS provider is available\n @G_TLS_ERROR_MISC: Miscellaneous TLS error\n @G_TLS_ERROR_BAD_CERTIFICATE: The certificate presented could not\n   be parsed or failed validation.\n @G_TLS_ERROR_NOT_TLS: The TLS handshake failed because the\n   peer does not seem to be a TLS server.\n @G_TLS_ERROR_HANDSHAKE: The TLS handshake failed because the\n   peer's certificate was not acceptable.\n @G_TLS_ERROR_CERTIFICATE_REQUIRED: The TLS handshake failed because\n   the server requested a client-side certificate, but none was\n   provided. See g_tls_connection_set_certificate().\n @G_TLS_ERROR_EOF: The TLS connection was closed without proper\n   notice, which may indicate an attack. See\n   g_tls_connection_set_require_close_notify().\n @G_TLS_ERROR_INAPPROPRIATE_FALLBACK: The TLS handshake failed\n   because the client sent the fallback SCSV, indicating a protocol\n   downgrade attack. Since: 2.60\n @G_TLS_ERROR_BAD_CERTIFICATE_PASSWORD: The certificate failed\n   to load because a password was incorrect. Since: 2.72\n\n An error code used with %G_TLS_ERROR in a #GError returned from a\n TLS-related routine.\n\n Since: 2.28"]
pub type GTlsError = ::std::os::raw::c_uint;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_NO_FLAGS: GTlsCertificateFlags = 0;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_UNKNOWN_CA: GTlsCertificateFlags = 1;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_BAD_IDENTITY: GTlsCertificateFlags = 2;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_NOT_ACTIVATED: GTlsCertificateFlags = 4;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_EXPIRED: GTlsCertificateFlags = 8;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_REVOKED: GTlsCertificateFlags = 16;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_INSECURE: GTlsCertificateFlags = 32;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_GENERIC_ERROR: GTlsCertificateFlags = 64;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_VALIDATE_ALL: GTlsCertificateFlags = 127;
#[doc = " GTlsCertificateFlags:\n @G_TLS_CERTIFICATE_NO_FLAGS: No flags set. Since: 2.74\n @G_TLS_CERTIFICATE_UNKNOWN_CA: The signing certificate authority is\n   not known.\n @G_TLS_CERTIFICATE_BAD_IDENTITY: The certificate does not match the\n   expected identity of the site that it was retrieved from.\n @G_TLS_CERTIFICATE_NOT_ACTIVATED: The certificate's activation time\n   is still in the future\n @G_TLS_CERTIFICATE_EXPIRED: The certificate has expired\n @G_TLS_CERTIFICATE_REVOKED: The certificate has been revoked\n   according to the #GTlsConnection's certificate revocation list.\n @G_TLS_CERTIFICATE_INSECURE: The certificate's algorithm is\n   considered insecure.\n @G_TLS_CERTIFICATE_GENERIC_ERROR: Some other error occurred validating\n   the certificate\n @G_TLS_CERTIFICATE_VALIDATE_ALL: the combination of all of the above\n   flags\n\n A set of flags describing TLS certification validation. This can be\n used to describe why a particular certificate was rejected (for\n example, in #GTlsConnection::accept-certificate).\n\n GLib guarantees that if certificate verification fails, at least one\n flag will be set, but it does not guarantee that all possible flags\n will be set. Accordingly, you may not safely decide to ignore any\n particular type of error. For example, it would be incorrect to mask\n %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,\n because this could potentially be the only error flag set even if\n other problems exist with the certificate.\n\n Since: 2.28"]
pub type GTlsCertificateFlags = ::std::os::raw::c_uint;
pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_NONE: GTlsAuthenticationMode = 0;
pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_REQUESTED: GTlsAuthenticationMode = 1;
pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_REQUIRED: GTlsAuthenticationMode = 2;
#[doc = " GTlsAuthenticationMode:\n @G_TLS_AUTHENTICATION_NONE: client authentication not required\n @G_TLS_AUTHENTICATION_REQUESTED: client authentication is requested\n @G_TLS_AUTHENTICATION_REQUIRED: client authentication is required\n\n The client authentication mode for a #GTlsServerConnection.\n\n Since: 2.28"]
pub type GTlsAuthenticationMode = ::std::os::raw::c_uint;
pub const GTlsChannelBindingType_G_TLS_CHANNEL_BINDING_TLS_UNIQUE: GTlsChannelBindingType = 0;
pub const GTlsChannelBindingType_G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT:
    GTlsChannelBindingType = 1;
pub const GTlsChannelBindingType_G_TLS_CHANNEL_BINDING_TLS_EXPORTER: GTlsChannelBindingType = 2;
#[doc = " GTlsChannelBindingType:\n @G_TLS_CHANNEL_BINDING_TLS_UNIQUE:\n    [`tls-unique`](https://tools.ietf.org/html/rfc5929#section-3) binding\n    type\n @G_TLS_CHANNEL_BINDING_TLS_SERVER_END_POINT:\n    [`tls-server-end-point`](https://tools.ietf.org/html/rfc5929#section-4)\n    binding type\n @G_TLS_CHANNEL_BINDING_TLS_EXPORTER:\n    [`tls-exporter`](https://www.rfc-editor.org/rfc/rfc9266.html) binding\n    type. Since: 2.74\n\n The type of TLS channel binding data to retrieve from #GTlsConnection\n or #GDtlsConnection, as documented by RFC 5929 or RFC 9266. The\n [`tls-unique-for-telnet`](https://tools.ietf.org/html/rfc5929#section-5)\n binding type is not currently implemented.\n\n Since: 2.66"]
pub type GTlsChannelBindingType = ::std::os::raw::c_uint;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED:
    GTlsChannelBindingError = 0;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE:
    GTlsChannelBindingError = 1;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE:
    GTlsChannelBindingError = 2;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED:
    GTlsChannelBindingError = 3;
pub const GTlsChannelBindingError_G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR:
    GTlsChannelBindingError = 4;
#[doc = " GTlsChannelBindingError:\n @G_TLS_CHANNEL_BINDING_ERROR_NOT_IMPLEMENTED: Either entire binding\n    retrieval facility or specific binding type is not implemented in the\n    TLS backend.\n @G_TLS_CHANNEL_BINDING_ERROR_INVALID_STATE: The handshake is not yet\n    complete on the connection which is a strong requirement for any existing\n    binding type.\n @G_TLS_CHANNEL_BINDING_ERROR_NOT_AVAILABLE: Handshake is complete but\n    binding data is not available. That normally indicates the TLS\n    implementation failed to provide the binding data. For example, some\n    implementations do not provide a peer certificate for resumed connections.\n @G_TLS_CHANNEL_BINDING_ERROR_NOT_SUPPORTED: Binding type is not supported\n    on the current connection. This error could be triggered when requesting\n    `tls-server-end-point` binding data for a certificate which has no hash\n    function or uses multiple hash functions.\n @G_TLS_CHANNEL_BINDING_ERROR_GENERAL_ERROR: Any other backend error\n    preventing binding data retrieval.\n\n An error code used with %G_TLS_CHANNEL_BINDING_ERROR in a #GError to\n indicate a TLS channel binding retrieval error.\n\n Since: 2.66"]
pub type GTlsChannelBindingError = ::std::os::raw::c_uint;
pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_NEVER: GTlsRehandshakeMode = 0;
pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_SAFELY: GTlsRehandshakeMode = 1;
pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_UNSAFELY: GTlsRehandshakeMode = 2;
#[doc = " GTlsRehandshakeMode:\n @G_TLS_REHANDSHAKE_NEVER: Never allow rehandshaking\n @G_TLS_REHANDSHAKE_SAFELY: Allow safe rehandshaking only\n @G_TLS_REHANDSHAKE_UNSAFELY: Allow unsafe rehandshaking\n\n When to allow rehandshaking. See\n g_tls_connection_set_rehandshake_mode().\n\n Since: 2.28\n\n Deprecated: 2.60. Changing the rehandshake mode is no longer\n   required for compatibility. Also, rehandshaking has been removed\n   from the TLS protocol in TLS 1.3."]
pub type GTlsRehandshakeMode = ::std::os::raw::c_uint;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_NONE: _GTlsPasswordFlags = 0;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_RETRY: _GTlsPasswordFlags = 2;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_MANY_TRIES: _GTlsPasswordFlags = 4;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_FINAL_TRY: _GTlsPasswordFlags = 8;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_PKCS11_USER: _GTlsPasswordFlags = 16;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER: _GTlsPasswordFlags = 32;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC: _GTlsPasswordFlags = 64;
#[doc = " GTlsPasswordFlags:\n @G_TLS_PASSWORD_NONE: No flags\n @G_TLS_PASSWORD_RETRY: The password was wrong, and the user should retry.\n @G_TLS_PASSWORD_MANY_TRIES: Hint to the user that the password has been\n    wrong many times, and the user may not have many chances left.\n @G_TLS_PASSWORD_FINAL_TRY: Hint to the user that this is the last try to get\n    this password right.\n @G_TLS_PASSWORD_PKCS11_USER: For PKCS #11, the user PIN is required.\n    Since: 2.70.\n @G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER: For PKCS #11, the security officer\n    PIN is required. Since: 2.70.\n @G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC: For PKCS #11, the context-specific\n    PIN is required. Since: 2.70.\n\n Various flags for the password.\n\n Since: 2.30"]
pub type _GTlsPasswordFlags = ::std::os::raw::c_uint;
#[doc = " GTlsPasswordFlags:\n @G_TLS_PASSWORD_NONE: No flags\n @G_TLS_PASSWORD_RETRY: The password was wrong, and the user should retry.\n @G_TLS_PASSWORD_MANY_TRIES: Hint to the user that the password has been\n    wrong many times, and the user may not have many chances left.\n @G_TLS_PASSWORD_FINAL_TRY: Hint to the user that this is the last try to get\n    this password right.\n @G_TLS_PASSWORD_PKCS11_USER: For PKCS #11, the user PIN is required.\n    Since: 2.70.\n @G_TLS_PASSWORD_PKCS11_SECURITY_OFFICER: For PKCS #11, the security officer\n    PIN is required. Since: 2.70.\n @G_TLS_PASSWORD_PKCS11_CONTEXT_SPECIFIC: For PKCS #11, the context-specific\n    PIN is required. Since: 2.70.\n\n Various flags for the password.\n\n Since: 2.30"]
pub use self::_GTlsPasswordFlags as GTlsPasswordFlags;
pub const GTlsInteractionResult_G_TLS_INTERACTION_UNHANDLED: GTlsInteractionResult = 0;
pub const GTlsInteractionResult_G_TLS_INTERACTION_HANDLED: GTlsInteractionResult = 1;
pub const GTlsInteractionResult_G_TLS_INTERACTION_FAILED: GTlsInteractionResult = 2;
#[doc = " GTlsInteractionResult:\n @G_TLS_INTERACTION_UNHANDLED: The interaction was unhandled (i.e. not\n     implemented).\n @G_TLS_INTERACTION_HANDLED: The interaction completed, and resulting data\n     is available.\n @G_TLS_INTERACTION_FAILED: The interaction has failed, or was cancelled.\n     and the operation should be aborted.\n\n #GTlsInteractionResult is returned by various functions in #GTlsInteraction\n when finishing an interaction request.\n\n Since: 2.30"]
pub type GTlsInteractionResult = ::std::os::raw::c_uint;
pub const GDBusInterfaceSkeletonFlags_G_DBUS_INTERFACE_SKELETON_FLAGS_NONE:
    GDBusInterfaceSkeletonFlags = 0;
pub const GDBusInterfaceSkeletonFlags_G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD : GDBusInterfaceSkeletonFlags = 1 ;
#[doc = " GDBusInterfaceSkeletonFlags:\n @G_DBUS_INTERFACE_SKELETON_FLAGS_NONE: No flags set.\n @G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD: Each method invocation is handled in\n   a thread dedicated to the invocation. This means that the method implementation can use blocking IO\n   without blocking any other part of the process. It also means that the method implementation must\n   use locking to access data structures used by other threads.\n\n Flags describing the behavior of a #GDBusInterfaceSkeleton instance.\n\n Since: 2.30"]
pub type GDBusInterfaceSkeletonFlags = ::std::os::raw::c_uint;
pub const GDBusObjectManagerClientFlags_G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE:
    GDBusObjectManagerClientFlags = 0;
pub const GDBusObjectManagerClientFlags_G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START:
    GDBusObjectManagerClientFlags = 1;
#[doc = " GDBusObjectManagerClientFlags:\n @G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE: No flags set.\n @G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START: If not set and the\n   manager is for a well-known name, then request the bus to launch\n   an owner for the name if no-one owns the name. This flag can only\n   be used in managers for well-known names.\n\n Flags used when constructing a #GDBusObjectManagerClient.\n\n Since: 2.30"]
pub type GDBusObjectManagerClientFlags = ::std::os::raw::c_uint;
pub const GTlsDatabaseVerifyFlags_G_TLS_DATABASE_VERIFY_NONE: GTlsDatabaseVerifyFlags = 0;
#[doc = " GTlsDatabaseVerifyFlags:\n @G_TLS_DATABASE_VERIFY_NONE: No verification flags\n\n Flags for g_tls_database_verify_chain().\n\n Since: 2.30"]
pub type GTlsDatabaseVerifyFlags = ::std::os::raw::c_uint;
pub const GTlsDatabaseLookupFlags_G_TLS_DATABASE_LOOKUP_NONE: GTlsDatabaseLookupFlags = 0;
pub const GTlsDatabaseLookupFlags_G_TLS_DATABASE_LOOKUP_KEYPAIR: GTlsDatabaseLookupFlags = 1;
#[doc = " GTlsDatabaseLookupFlags:\n @G_TLS_DATABASE_LOOKUP_NONE: No lookup flags\n @G_TLS_DATABASE_LOOKUP_KEYPAIR: Restrict lookup to certificates that have\n     a private key.\n\n Flags for g_tls_database_lookup_certificate_for_handle(),\n g_tls_database_lookup_certificate_issuer(),\n and g_tls_database_lookup_certificates_issued_by().\n\n Since: 2.30"]
pub type GTlsDatabaseLookupFlags = ::std::os::raw::c_uint;
pub const GTlsCertificateRequestFlags_G_TLS_CERTIFICATE_REQUEST_NONE: GTlsCertificateRequestFlags =
    0;
#[doc = " GTlsCertificateRequestFlags:\n @G_TLS_CERTIFICATE_REQUEST_NONE: No flags\n\n Flags for g_tls_interaction_request_certificate(),\n g_tls_interaction_request_certificate_async(), and\n g_tls_interaction_invoke_request_certificate().\n\n Since: 2.40"]
pub type GTlsCertificateRequestFlags = ::std::os::raw::c_uint;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_UNKNOWN: GTlsProtocolVersion = 0;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_SSL_3_0: GTlsProtocolVersion = 1;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_0: GTlsProtocolVersion = 2;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_1: GTlsProtocolVersion = 3;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_2: GTlsProtocolVersion = 4;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_TLS_1_3: GTlsProtocolVersion = 5;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_DTLS_1_0: GTlsProtocolVersion = 201;
pub const GTlsProtocolVersion_G_TLS_PROTOCOL_VERSION_DTLS_1_2: GTlsProtocolVersion = 202;
#[doc = " GTlsProtocolVersion:\n @G_TLS_PROTOCOL_VERSION_UNKNOWN: No protocol version or unknown protocol version\n @G_TLS_PROTOCOL_VERSION_SSL_3_0: SSL 3.0, which is insecure and should not be used\n @G_TLS_PROTOCOL_VERSION_TLS_1_0: TLS 1.0, which is insecure and should not be used\n @G_TLS_PROTOCOL_VERSION_TLS_1_1: TLS 1.1, which is insecure and should not be used\n @G_TLS_PROTOCOL_VERSION_TLS_1_2: TLS 1.2, defined by [RFC 5246](https://datatracker.ietf.org/doc/html/rfc5246)\n @G_TLS_PROTOCOL_VERSION_TLS_1_3: TLS 1.3, defined by [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446)\n @G_TLS_PROTOCOL_VERSION_DTLS_1_0: DTLS 1.0, which is insecure and should not be used\n @G_TLS_PROTOCOL_VERSION_DTLS_1_2: DTLS 1.2, defined by [RFC 6347](https://datatracker.ietf.org/doc/html/rfc6347)\n\n The TLS or DTLS protocol version used by a #GTlsConnection or\n #GDtlsConnection. The integer values of these versions are sequential\n to ensure newer known protocol versions compare greater than older\n known versions. Any known DTLS protocol version will compare greater\n than any SSL or TLS protocol version. The protocol version may be\n %G_TLS_PROTOCOL_VERSION_UNKNOWN if the TLS backend supports a newer\n protocol version that GLib does not yet know about. This means that\n it's possible for an unknown DTLS protocol version to compare less\n than the TLS protocol versions.\n\n Since: 2.70"]
pub type GTlsProtocolVersion = ::std::os::raw::c_uint;
pub const GIOModuleScopeFlags_G_IO_MODULE_SCOPE_NONE: GIOModuleScopeFlags = 0;
pub const GIOModuleScopeFlags_G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: GIOModuleScopeFlags = 1;
#[doc = " GIOModuleScopeFlags:\n @G_IO_MODULE_SCOPE_NONE: No module scan flags\n @G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: When using this scope to load or\n     scan modules, automatically block a modules which has the same base\n     basename as previously loaded module.\n\n Flags for use with g_io_module_scope_new().\n\n Since: 2.30"]
pub type GIOModuleScopeFlags = ::std::os::raw::c_uint;
pub const GSocketClientEvent_G_SOCKET_CLIENT_RESOLVING: GSocketClientEvent = 0;
pub const GSocketClientEvent_G_SOCKET_CLIENT_RESOLVED: GSocketClientEvent = 1;
pub const GSocketClientEvent_G_SOCKET_CLIENT_CONNECTING: GSocketClientEvent = 2;
pub const GSocketClientEvent_G_SOCKET_CLIENT_CONNECTED: GSocketClientEvent = 3;
pub const GSocketClientEvent_G_SOCKET_CLIENT_PROXY_NEGOTIATING: GSocketClientEvent = 4;
pub const GSocketClientEvent_G_SOCKET_CLIENT_PROXY_NEGOTIATED: GSocketClientEvent = 5;
pub const GSocketClientEvent_G_SOCKET_CLIENT_TLS_HANDSHAKING: GSocketClientEvent = 6;
pub const GSocketClientEvent_G_SOCKET_CLIENT_TLS_HANDSHAKED: GSocketClientEvent = 7;
pub const GSocketClientEvent_G_SOCKET_CLIENT_COMPLETE: GSocketClientEvent = 8;
#[doc = " GSocketClientEvent:\n @G_SOCKET_CLIENT_RESOLVING: The client is doing a DNS lookup.\n @G_SOCKET_CLIENT_RESOLVED: The client has completed a DNS lookup.\n @G_SOCKET_CLIENT_CONNECTING: The client is connecting to a remote\n   host (either a proxy or the destination server).\n @G_SOCKET_CLIENT_CONNECTED: The client has connected to a remote\n   host.\n @G_SOCKET_CLIENT_PROXY_NEGOTIATING: The client is negotiating\n   with a proxy to connect to the destination server.\n @G_SOCKET_CLIENT_PROXY_NEGOTIATED: The client has negotiated\n   with the proxy server.\n @G_SOCKET_CLIENT_TLS_HANDSHAKING: The client is performing a\n   TLS handshake.\n @G_SOCKET_CLIENT_TLS_HANDSHAKED: The client has performed a\n   TLS handshake.\n @G_SOCKET_CLIENT_COMPLETE: The client is done with a particular\n   #GSocketConnectable.\n\n Describes an event occurring on a #GSocketClient. See the\n #GSocketClient::event signal for more details.\n\n Additional values may be added to this type in the future.\n\n Since: 2.32"]
pub type GSocketClientEvent = ::std::os::raw::c_uint;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_BINDING: GSocketListenerEvent = 0;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_BOUND: GSocketListenerEvent = 1;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_LISTENING: GSocketListenerEvent = 2;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_LISTENED: GSocketListenerEvent = 3;
#[doc = " GSocketListenerEvent:\n @G_SOCKET_LISTENER_BINDING: The listener is about to bind a socket.\n @G_SOCKET_LISTENER_BOUND: The listener has bound a socket.\n @G_SOCKET_LISTENER_LISTENING: The listener is about to start\n    listening on this socket.\n @G_SOCKET_LISTENER_LISTENED: The listener is now listening on\n   this socket.\n\n Describes an event occurring on a #GSocketListener. See the\n #GSocketListener::event signal for more details.\n\n Additional values may be added to this type in the future.\n\n Since: 2.46"]
pub type GSocketListenerEvent = ::std::os::raw::c_uint;
pub const GTestDBusFlags_G_TEST_DBUS_NONE: GTestDBusFlags = 0;
#[doc = " GTestDBusFlags:\n @G_TEST_DBUS_NONE: No flags.\n\n Flags to define future #GTestDBus behaviour.\n\n Since: 2.34"]
pub type GTestDBusFlags = ::std::os::raw::c_uint;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_NONE: GSubprocessFlags = 0;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDIN_PIPE: GSubprocessFlags = 1;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDIN_INHERIT: GSubprocessFlags = 2;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDOUT_PIPE: GSubprocessFlags = 4;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDOUT_SILENCE: GSubprocessFlags = 8;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_PIPE: GSubprocessFlags = 16;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_SILENCE: GSubprocessFlags = 32;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_MERGE: GSubprocessFlags = 64;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_INHERIT_FDS: GSubprocessFlags = 128;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP: GSubprocessFlags = 256;
#[doc = " GSubprocessFlags:\n @G_SUBPROCESS_FLAGS_NONE: No flags.\n @G_SUBPROCESS_FLAGS_STDIN_PIPE: create a pipe for the stdin of the\n   spawned process that can be accessed with\n   g_subprocess_get_stdin_pipe().\n @G_SUBPROCESS_FLAGS_STDIN_INHERIT: stdin is inherited from the\n   calling process.\n @G_SUBPROCESS_FLAGS_STDOUT_PIPE: create a pipe for the stdout of the\n   spawned process that can be accessed with\n   g_subprocess_get_stdout_pipe().\n @G_SUBPROCESS_FLAGS_STDOUT_SILENCE: silence the stdout of the spawned\n   process (ie: redirect to `/dev/null`).\n @G_SUBPROCESS_FLAGS_STDERR_PIPE: create a pipe for the stderr of the\n   spawned process that can be accessed with\n   g_subprocess_get_stderr_pipe().\n @G_SUBPROCESS_FLAGS_STDERR_SILENCE: silence the stderr of the spawned\n   process (ie: redirect to `/dev/null`).\n @G_SUBPROCESS_FLAGS_STDERR_MERGE: merge the stderr of the spawned\n   process with whatever the stdout happens to be.  This is a good way\n   of directing both streams to a common log file, for example.\n @G_SUBPROCESS_FLAGS_INHERIT_FDS: spawned processes will inherit the\n   file descriptors of their parent, unless those descriptors have\n   been explicitly marked as close-on-exec.  This flag has no effect\n   over the \"standard\" file descriptors (stdin, stdout, stderr).\n @G_SUBPROCESS_FLAGS_SEARCH_PATH_FROM_ENVP: if path searching is\n   needed when spawning the subprocess, use the `PATH` in the launcher\n   environment. (Since: 2.72)\n\n Flags to define the behaviour of a #GSubprocess.\n\n Note that the default for stdin is to redirect from `/dev/null`.  For\n stdout and stderr the default are for them to inherit the\n corresponding descriptor from the calling process.\n\n Note that it is a programmer error to mix 'incompatible' flags.  For\n example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and\n %G_SUBPROCESS_FLAGS_STDOUT_SILENCE.\n\n Since: 2.40"]
pub type GSubprocessFlags = ::std::os::raw::c_uint;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_NORMAL: GNotificationPriority = 0;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_LOW: GNotificationPriority = 1;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_HIGH: GNotificationPriority = 2;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_URGENT: GNotificationPriority = 3;
#[doc = " GNotificationPriority:\n @G_NOTIFICATION_PRIORITY_LOW: for notifications that do not require\n   immediate attention - typically used for contextual background\n   information, such as contact birthdays or local weather\n @G_NOTIFICATION_PRIORITY_NORMAL: the default priority, to be used for the\n   majority of notifications (for example email messages, software updates,\n   completed download/sync operations)\n @G_NOTIFICATION_PRIORITY_HIGH: for events that require more attention,\n   usually because responses are time-sensitive (for example chat and SMS\n   messages or alarms)\n @G_NOTIFICATION_PRIORITY_URGENT: for urgent notifications, or notifications\n   that require a response in a short space of time (for example phone calls\n   or emergency warnings)\n\n Priority levels for #GNotifications.\n\n Since: 2.42"]
pub type GNotificationPriority = ::std::os::raw::c_uint;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_LOCAL: GNetworkConnectivity = 1;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_LIMITED: GNetworkConnectivity = 2;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_PORTAL: GNetworkConnectivity = 3;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_FULL: GNetworkConnectivity = 4;
#[doc = " GNetworkConnectivity:\n @G_NETWORK_CONNECTIVITY_LOCAL: The host is not configured with a\n   route to the Internet; it may or may not be connected to a local\n   network.\n @G_NETWORK_CONNECTIVITY_LIMITED: The host is connected to a network, but\n   does not appear to be able to reach the full Internet, perhaps\n   due to upstream network problems.\n @G_NETWORK_CONNECTIVITY_PORTAL: The host is behind a captive portal and\n   cannot reach the full Internet.\n @G_NETWORK_CONNECTIVITY_FULL: The host is connected to a network, and\n   appears to be able to reach the full Internet.\n\n The host's network connectivity state, as reported by #GNetworkMonitor.\n\n Since: 2.44"]
pub type GNetworkConnectivity = ::std::os::raw::c_uint;
pub const GPollableReturn_G_POLLABLE_RETURN_FAILED: GPollableReturn = 0;
pub const GPollableReturn_G_POLLABLE_RETURN_OK: GPollableReturn = 1;
pub const GPollableReturn_G_POLLABLE_RETURN_WOULD_BLOCK: GPollableReturn = -27;
#[doc = " GPollableReturn:\n @G_POLLABLE_RETURN_FAILED: Generic error condition for when an operation fails.\n @G_POLLABLE_RETURN_OK: The operation was successfully finished.\n @G_POLLABLE_RETURN_WOULD_BLOCK: The operation would block.\n\n Return value for various IO operations that signal errors via the\n return value and not necessarily via a #GError.\n\n This enum exists to be able to return errors to callers without having to\n allocate a #GError. Allocating #GErrors can be quite expensive for\n regularly happening errors like %G_IO_ERROR_WOULD_BLOCK.\n\n In case of %G_POLLABLE_RETURN_FAILED a #GError should be set for the\n operation to give details about the error that happened.\n\n Since: 2.60"]
pub type GPollableReturn = ::std::os::raw::c_int;
pub const GMemoryMonitorWarningLevel_G_MEMORY_MONITOR_WARNING_LEVEL_LOW:
    GMemoryMonitorWarningLevel = 50;
pub const GMemoryMonitorWarningLevel_G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM:
    GMemoryMonitorWarningLevel = 100;
pub const GMemoryMonitorWarningLevel_G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL:
    GMemoryMonitorWarningLevel = 255;
#[doc = " GMemoryMonitorWarningLevel:\n @G_MEMORY_MONITOR_WARNING_LEVEL_LOW: Memory on the device is low, processes\n   should free up unneeded resources (for example, in-memory caches) so they can\n   be used elsewhere.\n @G_MEMORY_MONITOR_WARNING_LEVEL_MEDIUM: Same as @G_MEMORY_MONITOR_WARNING_LEVEL_LOW\n   but the device has even less free memory, so processes should try harder to free\n   up unneeded resources. If your process does not need to stay running, it is a\n   good time for it to quit.\n @G_MEMORY_MONITOR_WARNING_LEVEL_CRITICAL: The system will soon start terminating\n   processes to reclaim memory, including background processes.\n\n Memory availability warning levels.\n\n Note that because new values might be added, it is recommended that applications check\n #GMemoryMonitorWarningLevel as ranges, for example:\n |[<!-- language=\"C\" -->\n if (warning_level > G_MEMORY_MONITOR_WARNING_LEVEL_LOW)\n   drop_caches ();\n ]|\n\n Since: 2.64"]
pub type GMemoryMonitorWarningLevel = ::std::os::raw::c_uint;
#[doc = " GAppLaunchContext:\n\n Integrating the launch with the launching application. This is used to\n handle for instance startup notification and launching the new application\n on the same screen as the launching window."]
pub type GAppLaunchContext = _GAppLaunchContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppInfo {
    _unused: [u8; 0],
}
pub type GAppInfo = _GAppInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncResult {
    _unused: [u8; 0],
}
pub type GAsyncResult = _GAsyncResult;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncInitable {
    _unused: [u8; 0],
}
pub type GAsyncInitable = _GAsyncInitable;
pub type GBufferedInputStream = _GBufferedInputStream;
pub type GBufferedOutputStream = _GBufferedOutputStream;
pub type GCancellable = _GCancellable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCharsetConverter {
    _unused: [u8; 0],
}
pub type GCharsetConverter = _GCharsetConverter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverter {
    _unused: [u8; 0],
}
pub type GConverter = _GConverter;
pub type GConverterInputStream = _GConverterInputStream;
pub type GConverterOutputStream = _GConverterOutputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDatagramBased {
    _unused: [u8; 0],
}
pub type GDatagramBased = _GDatagramBased;
pub type GDataInputStream = _GDataInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimplePermission {
    _unused: [u8; 0],
}
pub type GSimplePermission = _GSimplePermission;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibCompressor {
    _unused: [u8; 0],
}
pub type GZlibCompressor = _GZlibCompressor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibDecompressor {
    _unused: [u8; 0],
}
pub type GZlibDecompressor = _GZlibDecompressor;
#[doc = " GSimpleActionGroup:\n\n The #GSimpleActionGroup structure contains private data and should only be accessed using the provided API.\n\n Since: 2.28"]
pub type GSimpleActionGroup = _GSimpleActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRemoteActionGroup {
    _unused: [u8; 0],
}
pub type GRemoteActionGroup = _GRemoteActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusActionGroup {
    _unused: [u8; 0],
}
pub type GDBusActionGroup = _GDBusActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionMap {
    _unused: [u8; 0],
}
pub type GActionMap = _GActionMap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionGroup {
    _unused: [u8; 0],
}
pub type GActionGroup = _GActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPropertyAction {
    _unused: [u8; 0],
}
pub type GPropertyAction = _GPropertyAction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleAction {
    _unused: [u8; 0],
}
pub type GSimpleAction = _GSimpleAction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAction {
    _unused: [u8; 0],
}
pub type GAction = _GAction;
pub type GApplication = _GApplication;
pub type GApplicationCommandLine = _GApplicationCommandLine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsBackend {
    _unused: [u8; 0],
}
pub type GSettingsBackend = _GSettingsBackend;
pub type GSettings = _GSettings;
pub type GPermission = _GPermission;
pub type GMenuModel = _GMenuModel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNotification {
    _unused: [u8; 0],
}
pub type GNotification = _GNotification;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDrive {
    _unused: [u8; 0],
}
#[doc = " GDrive:\n\n Opaque drive object."]
pub type GDrive = _GDrive;
pub type GFileEnumerator = _GFileEnumerator;
#[doc = " GFileMonitor:\n\n Watches for changes to a file."]
pub type GFileMonitor = _GFileMonitor;
pub type GFilterInputStream = _GFilterInputStream;
pub type GFilterOutputStream = _GFilterOutputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFile {
    _unused: [u8; 0],
}
#[doc = " GFile:\n\n A handle to an object implementing the #GFileIface interface.\n Generally stores a location within the file system. Handles do not\n necessarily represent files or directories that currently exist."]
pub type GFile = _GFile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInfo {
    _unused: [u8; 0],
}
pub type GFileInfo = _GFileInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileAttributeMatcher {
    _unused: [u8; 0],
}
#[doc = " GFileAttributeMatcher:\n\n Determines if a string matches a file attribute."]
pub type GFileAttributeMatcher = _GFileAttributeMatcher;
#[doc = " GFileAttributeInfo:\n @name: the name of the attribute.\n @type: the #GFileAttributeType type of the attribute.\n @flags: a set of #GFileAttributeInfoFlags.\n\n Information about a specific attribute."]
pub type GFileAttributeInfo = _GFileAttributeInfo;
#[doc = " GFileAttributeInfoList:\n @infos: an array of #GFileAttributeInfos.\n @n_infos: the number of values in the array.\n\n Acts as a lightweight registry for possible valid file attributes.\n The registry stores Key-Value pair formats as #GFileAttributeInfos."]
pub type GFileAttributeInfoList = _GFileAttributeInfoList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileDescriptorBased {
    _unused: [u8; 0],
}
pub type GFileDescriptorBased = _GFileDescriptorBased;
pub type GFileInputStream = _GFileInputStream;
pub type GFileOutputStream = _GFileOutputStream;
pub type GFileIOStream = _GFileIOStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIcon {
    _unused: [u8; 0],
}
pub type GFileIcon = _GFileIcon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilenameCompleter {
    _unused: [u8; 0],
}
pub type GFilenameCompleter = _GFilenameCompleter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIcon {
    _unused: [u8; 0],
}
pub type GIcon = _GIcon;
pub type GInetAddress = _GInetAddress;
pub type GInetAddressMask = _GInetAddressMask;
pub type GInetSocketAddress = _GInetSocketAddress;
pub type GNativeSocketAddress = _GNativeSocketAddress;
pub type GInputStream = _GInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInitable {
    _unused: [u8; 0],
}
pub type GInitable = _GInitable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOModule {
    _unused: [u8; 0],
}
pub type GIOModule = _GIOModule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOExtensionPoint {
    _unused: [u8; 0],
}
pub type GIOExtensionPoint = _GIOExtensionPoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOExtension {
    _unused: [u8; 0],
}
pub type GIOExtension = _GIOExtension;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOSchedulerJob {
    _unused: [u8; 0],
}
#[doc = " GIOSchedulerJob:\n\n Opaque class for defining and scheduling IO jobs."]
pub type GIOSchedulerJob = _GIOSchedulerJob;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStreamAdapter {
    _unused: [u8; 0],
}
pub type GIOStreamAdapter = _GIOStreamAdapter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLoadableIcon {
    _unused: [u8; 0],
}
pub type GLoadableIcon = _GLoadableIcon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytesIcon {
    _unused: [u8; 0],
}
pub type GBytesIcon = _GBytesIcon;
pub type GMemoryInputStream = _GMemoryInputStream;
pub type GMemoryOutputStream = _GMemoryOutputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMount {
    _unused: [u8; 0],
}
#[doc = " GMount:\n\n A handle to an object implementing the #GMountIface interface."]
pub type GMount = _GMount;
pub type GMountOperation = _GMountOperation;
pub type GNetworkAddress = _GNetworkAddress;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkMonitor {
    _unused: [u8; 0],
}
pub type GNetworkMonitor = _GNetworkMonitor;
pub type GNetworkService = _GNetworkService;
pub type GOutputStream = _GOutputStream;
#[doc = " GIOStream:\n\n Base class for read-write streams."]
pub type GIOStream = _GIOStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleIOStream {
    _unused: [u8; 0],
}
pub type GSimpleIOStream = _GSimpleIOStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableInputStream {
    _unused: [u8; 0],
}
pub type GPollableInputStream = _GPollableInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableOutputStream {
    _unused: [u8; 0],
}
pub type GPollableOutputStream = _GPollableOutputStream;
pub type GResolver = _GResolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResource {
    _unused: [u8; 0],
}
#[doc = " GResource:\n\n A resource bundle.\n\n Since: 2.32"]
pub type GResource = _GResource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSeekable {
    _unused: [u8; 0],
}
pub type GSeekable = _GSeekable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleAsyncResult {
    _unused: [u8; 0],
}
pub type GSimpleAsyncResult = _GSimpleAsyncResult;
#[doc = " GSocket:\n\n A lowlevel network socket object.\n\n Since: 2.22"]
pub type GSocket = _GSocket;
#[doc = " GSocketControlMessage:\n\n Base class for socket-type specific control messages that can be sent and\n received over #GSocket."]
pub type GSocketControlMessage = _GSocketControlMessage;
#[doc = " GSocketClient:\n\n A helper class for network clients to make connections.\n\n Since: 2.22"]
pub type GSocketClient = _GSocketClient;
#[doc = " GSocketConnection:\n\n A socket connection GIOStream object for connection-oriented sockets.\n\n Since: 2.22"]
pub type GSocketConnection = _GSocketConnection;
#[doc = " GSocketListener:\n\n A helper class for network servers to listen for and accept connections.\n\n Since: 2.22"]
pub type GSocketListener = _GSocketListener;
#[doc = " GSocketService:\n\n A helper class for handling accepting incoming connections in the\n glib mainloop.\n\n Since: 2.22"]
pub type GSocketService = _GSocketService;
pub type GSocketAddress = _GSocketAddress;
pub type GSocketAddressEnumerator = _GSocketAddressEnumerator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectable {
    _unused: [u8; 0],
}
pub type GSocketConnectable = _GSocketConnectable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSrvTarget {
    _unused: [u8; 0],
}
pub type GSrvTarget = _GSrvTarget;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTask {
    _unused: [u8; 0],
}
pub type GTask = _GTask;
#[doc = " GTcpConnection:\n\n A #GSocketConnection for TCP/IP connections.\n\n Since: 2.22"]
pub type GTcpConnection = _GTcpConnection;
pub type GTcpWrapperConnection = _GTcpWrapperConnection;
#[doc = " GThreadedSocketService:\n\n A helper class for handling accepting incoming connections in the\n glib mainloop and handling them in a thread.\n\n Since: 2.22"]
pub type GThreadedSocketService = _GThreadedSocketService;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsConnection {
    _unused: [u8; 0],
}
pub type GDtlsConnection = _GDtlsConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsClientConnection {
    _unused: [u8; 0],
}
pub type GDtlsClientConnection = _GDtlsClientConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsServerConnection {
    _unused: [u8; 0],
}
pub type GDtlsServerConnection = _GDtlsServerConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThemedIcon {
    _unused: [u8; 0],
}
pub type GThemedIcon = _GThemedIcon;
pub type GTlsCertificate = _GTlsCertificate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsClientConnection {
    _unused: [u8; 0],
}
pub type GTlsClientConnection = _GTlsClientConnection;
pub type GTlsConnection = _GTlsConnection;
pub type GTlsDatabase = _GTlsDatabase;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsFileDatabase {
    _unused: [u8; 0],
}
pub type GTlsFileDatabase = _GTlsFileDatabase;
pub type GTlsInteraction = _GTlsInteraction;
pub type GTlsPassword = _GTlsPassword;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsServerConnection {
    _unused: [u8; 0],
}
pub type GTlsServerConnection = _GTlsServerConnection;
pub type GVfs = _GVfs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyResolver {
    _unused: [u8; 0],
}
#[doc = " GProxyResolver:\n\n A helper class to enumerate proxies base on URI.\n\n Since: 2.26"]
pub type GProxyResolver = _GProxyResolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxy {
    _unused: [u8; 0],
}
pub type GProxy = _GProxy;
pub type GProxyAddress = _GProxyAddress;
pub type GProxyAddressEnumerator = _GProxyAddressEnumerator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolume {
    _unused: [u8; 0],
}
#[doc = " GVolume:\n\n Opaque mountable volume object."]
pub type GVolume = _GVolume;
pub type GVolumeMonitor = _GVolumeMonitor;
#[doc = " GAsyncReadyCallback:\n @source_object: (nullable): the object the asynchronous operation was started with.\n @res: a #GAsyncResult.\n @data: user data passed to the callback.\n\n Type definition for a function that will be called back when an asynchronous\n operation within GIO has been completed. #GAsyncReadyCallback\n callbacks from #GTask are guaranteed to be invoked in a later\n iteration of the\n [thread-default main context][g-main-context-push-thread-default]\n where the #GTask was created. All other users of\n #GAsyncReadyCallback must likewise call it asynchronously in a\n later iteration of the main context.\n\n The asynchronous operation is guaranteed to have held a reference to\n @source_object from the time when the `*_async()` function was called, until\n after this callback returns."]
pub type GAsyncReadyCallback = ::std::option::Option<
    unsafe extern "C" fn(source_object: *mut GObject, res: *mut GAsyncResult, data: gpointer),
>;
#[doc = " GFileProgressCallback:\n @current_num_bytes: the current number of bytes in the operation.\n @total_num_bytes: the total number of bytes in the operation.\n @data: user data passed to the callback.\n\n When doing file operations that may take a while, such as moving\n a file or copying a file, a progress callback is used to pass how\n far along that operation is to the application."]
pub type GFileProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(current_num_bytes: goffset, total_num_bytes: goffset, data: gpointer),
>;
#[doc = " GFileReadMoreCallback:\n @file_contents: the data as currently read.\n @file_size: the size of the data currently read.\n @callback_data: data passed to the callback.\n\n When loading the partial contents of a file with g_file_load_partial_contents_async(),\n it may become necessary to determine if any more data from the file should be loaded.\n A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data\n should be read, or %FALSE otherwise.\n\n Returns: %TRUE if more data should be read back. %FALSE otherwise."]
pub type GFileReadMoreCallback = ::std::option::Option<
    unsafe extern "C" fn(
        file_contents: *const ::std::os::raw::c_char,
        file_size: goffset,
        callback_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GFileMeasureProgressCallback:\n @reporting: %TRUE if more reports will come\n @current_size: the current cumulative size measurement\n @num_dirs: the number of directories visited so far\n @num_files: the number of non-directory files encountered\n @data: the data passed to the original request for this callback\n\n This callback type is used by g_file_measure_disk_usage() to make\n periodic progress reports when measuring the amount of disk spaced\n used by a directory.\n\n These calls are made on a best-effort basis and not all types of\n #GFile will support them.  At the minimum, however, one call will\n always be made immediately.\n\n In the case that there is no support, @reporting will be set to\n %FALSE (and the other values undefined) and no further calls will be\n made.  Otherwise, the @reporting will be %TRUE and the other values\n all-zeros during the first (immediate) call.  In this way, you can\n know which type of progress UI to show without a delay.\n\n For g_file_measure_disk_usage() the callback is made directly.  For\n g_file_measure_disk_usage_async() the callback is made via the\n default main context of the calling thread (ie: the same way that the\n final async result would be reported).\n\n @current_size is in the same units as requested by the operation (see\n %G_FILE_MEASURE_APPARENT_SIZE).\n\n The frequency of the updates is implementation defined, but is\n ideally about once every 200ms.\n\n The last progress callback may or may not be equal to the final\n result.  Always check the async result to get the final value.\n\n Since: 2.38"]
pub type GFileMeasureProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        reporting: gboolean,
        current_size: guint64,
        num_dirs: guint64,
        num_files: guint64,
        data: gpointer,
    ),
>;
#[doc = " GIOSchedulerJobFunc:\n @job: a #GIOSchedulerJob.\n @cancellable: optional #GCancellable object, %NULL to ignore.\n @data: data passed to the callback function\n\n I/O Job function.\n\n Long-running jobs should periodically check the @cancellable\n to see if they have been cancelled.\n\n Returns: %TRUE if this function should be called again to\n    complete the job, %FALSE if the job is complete (or cancelled)"]
pub type GIOSchedulerJobFunc = ::std::option::Option<
    unsafe extern "C" fn(
        job: *mut GIOSchedulerJob,
        cancellable: *mut GCancellable,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GSimpleAsyncThreadFunc:\n @res: a #GSimpleAsyncResult.\n @object: a #GObject.\n @cancellable: optional #GCancellable object, %NULL to ignore.\n\n Simple thread function that runs an asynchronous operation and\n checks for cancellation."]
pub type GSimpleAsyncThreadFunc = ::std::option::Option<
    unsafe extern "C" fn(
        res: *mut GSimpleAsyncResult,
        object: *mut GObject,
        cancellable: *mut GCancellable,
    ),
>;
#[doc = " GSocketSourceFunc:\n @socket: the #GSocket\n @condition: the current condition at the source fired.\n @data: data passed in by the user.\n\n This is the function type of the callback used for the #GSource\n returned by g_socket_create_source().\n\n Returns: it should return %FALSE if the source should be removed.\n\n Since: 2.22"]
pub type GSocketSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(socket: *mut GSocket, condition: GIOCondition, data: gpointer) -> gboolean,
>;
#[doc = " GDatagramBasedSourceFunc:\n @datagram_based: the #GDatagramBased\n @condition: the current condition at the source fired\n @data: data passed in by the user\n\n This is the function type of the callback used for the #GSource\n returned by g_datagram_based_create_source().\n\n Returns: %G_SOURCE_REMOVE if the source should be removed,\n   %G_SOURCE_CONTINUE otherwise\n\n Since: 2.48"]
pub type GDatagramBasedSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[doc = " GInputVector:\n @buffer: Pointer to a buffer where data will be written.\n @size: the available size in @buffer.\n\n Structure used for scatter/gather data input.\n You generally pass in an array of #GInputVectors\n and the operation will store the read data starting in the\n first buffer, switching to the next as needed.\n\n Since: 2.22"]
pub type GInputVector = _GInputVector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputVector {
    pub buffer: gpointer,
    pub size: gsize,
}
#[test]
fn bindgen_test_layout__GInputVector() {
    const UNINIT: ::std::mem::MaybeUninit<_GInputVector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInputVector>(),
        16usize,
        concat!("Size of: ", stringify!(_GInputVector))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInputVector>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInputVector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputVector),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputVector),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " GInputMessage:\n @address: (optional) (out) (transfer full): return location\n   for a #GSocketAddress, or %NULL\n @vectors: (array length=num_vectors) (out): pointer to an\n   array of input vectors\n @num_vectors: the number of input vectors pointed to by @vectors\n @bytes_received: (out): will be set to the number of bytes that have been\n   received\n @flags: (out): collection of #GSocketMsgFlags for the received message,\n   outputted by the call\n @control_messages: (array length=num_control_messages) (optional)\n   (out) (transfer full): return location for a\n   caller-allocated array of #GSocketControlMessages, or %NULL\n @num_control_messages: (out) (optional): return location for the number of\n   elements in @control_messages\n\n Structure used for scatter/gather data input when receiving multiple\n messages or packets in one go. You generally pass in an array of empty\n #GInputVectors and the operation will use all the buffers as if they\n were one buffer, and will set @bytes_received to the total number of bytes\n received across all #GInputVectors.\n\n This structure closely mirrors `struct mmsghdr` and `struct msghdr` from\n the POSIX sockets API (see `man 2 recvmmsg`).\n\n If @address is non-%NULL then it is set to the source address the message\n was received from, and the caller must free it afterwards.\n\n If @control_messages is non-%NULL then it is set to an array of control\n messages received with the message (if any), and the caller must free it\n afterwards. @num_control_messages is set to the number of elements in\n this array, which may be zero.\n\n Flags relevant to this message will be returned in @flags. For example,\n `MSG_EOR` or `MSG_TRUNC`.\n\n Since: 2.48"]
pub type GInputMessage = _GInputMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputMessage {
    pub address: *mut *mut GSocketAddress,
    pub vectors: *mut GInputVector,
    pub num_vectors: guint,
    pub bytes_received: gsize,
    pub flags: gint,
    pub control_messages: *mut *mut *mut GSocketControlMessage,
    pub num_control_messages: *mut guint,
}
#[test]
fn bindgen_test_layout__GInputMessage() {
    const UNINIT: ::std::mem::MaybeUninit<_GInputMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInputMessage>(),
        56usize,
        concat!("Size of: ", stringify!(_GInputMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInputMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInputMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vectors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(vectors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_vectors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(num_vectors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_received) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(bytes_received)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_messages) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(control_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_control_messages) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(num_control_messages)
        )
    );
}
#[doc = " GOutputVector:\n @buffer: Pointer to a buffer of data to read.\n @size: the size of @buffer.\n\n Structure used for scatter/gather data output.\n You generally pass in an array of #GOutputVectors\n and the operation will use all the buffers as if they were\n one buffer.\n\n Since: 2.22"]
pub type GOutputVector = _GOutputVector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputVector {
    pub buffer: gconstpointer,
    pub size: gsize,
}
#[test]
fn bindgen_test_layout__GOutputVector() {
    const UNINIT: ::std::mem::MaybeUninit<_GOutputVector> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOutputVector>(),
        16usize,
        concat!("Size of: ", stringify!(_GOutputVector))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOutputVector>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOutputVector))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputVector),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputVector),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " GOutputMessage:\n @address: (nullable): a #GSocketAddress, or %NULL\n @vectors: pointer to an array of output vectors\n @num_vectors: the number of output vectors pointed to by @vectors.\n @bytes_sent: initialize to 0. Will be set to the number of bytes\n     that have been sent\n @control_messages: (array length=num_control_messages) (nullable): a pointer\n   to an array of #GSocketControlMessages, or %NULL.\n @num_control_messages: number of elements in @control_messages.\n\n Structure used for scatter/gather data output when sending multiple\n messages or packets in one go. You generally pass in an array of\n #GOutputVectors and the operation will use all the buffers as if they\n were one buffer.\n\n If @address is %NULL then the message is sent to the default receiver\n (as previously set by g_socket_connect()).\n\n Since: 2.44"]
pub type GOutputMessage = _GOutputMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputMessage {
    pub address: *mut GSocketAddress,
    pub vectors: *mut GOutputVector,
    pub num_vectors: guint,
    pub bytes_sent: guint,
    pub control_messages: *mut *mut GSocketControlMessage,
    pub num_control_messages: guint,
}
#[test]
fn bindgen_test_layout__GOutputMessage() {
    const UNINIT: ::std::mem::MaybeUninit<_GOutputMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOutputMessage>(),
        40usize,
        concat!("Size of: ", stringify!(_GOutputMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOutputMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOutputMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vectors) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(vectors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_vectors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(num_vectors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes_sent) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(bytes_sent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).control_messages) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(control_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_control_messages) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(num_control_messages)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCredentials {
    _unused: [u8; 0],
}
pub type GCredentials = _GCredentials;
#[doc = " GUnixCredentialsMessage:\n\n The #GUnixCredentialsMessage structure contains only private data\n and should only be accessed using the provided API.\n\n Since: 2.26"]
pub type GUnixCredentialsMessage = _GUnixCredentialsMessage;
pub type GUnixFDList = _GUnixFDList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMessage {
    _unused: [u8; 0],
}
pub type GDBusMessage = _GDBusMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusConnection {
    _unused: [u8; 0],
}
pub type GDBusConnection = _GDBusConnection;
#[doc = " GDBusProxy:\n\n The #GDBusProxy structure contains only private data and\n should only be accessed using the provided API.\n\n Since: 2.26"]
pub type GDBusProxy = _GDBusProxy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMethodInvocation {
    _unused: [u8; 0],
}
pub type GDBusMethodInvocation = _GDBusMethodInvocation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusServer {
    _unused: [u8; 0],
}
pub type GDBusServer = _GDBusServer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusAuthObserver {
    _unused: [u8; 0],
}
pub type GDBusAuthObserver = _GDBusAuthObserver;
#[doc = " GDBusErrorEntry:\n @error_code: An error code.\n @dbus_error_name: The D-Bus error name to associate with @error_code.\n\n Struct used in g_dbus_error_register_error_domain().\n\n Since: 2.26"]
pub type GDBusErrorEntry = _GDBusErrorEntry;
#[doc = " GDBusInterfaceVTable:\n @method_call: Function for handling incoming method calls.\n @get_property: Function for getting a property.\n @set_property: Function for setting a property.\n\n Virtual table for handling properties and method calls for a D-Bus\n interface.\n\n Since 2.38, if you want to handle getting/setting D-Bus properties\n asynchronously, give %NULL as your get_property() or set_property()\n function. The D-Bus call will be directed to your @method_call function,\n with the provided @interface_name set to \"org.freedesktop.DBus.Properties\".\n\n Ownership of the #GDBusMethodInvocation object passed to the\n method_call() function is transferred to your handler; you must\n call one of the methods of #GDBusMethodInvocation to return a reply\n (possibly empty), or an error. These functions also take ownership\n of the passed-in invocation object, so unless the invocation\n object has otherwise been referenced, it will be then be freed.\n Calling one of these functions may be done within your\n method_call() implementation but it also can be done at a later\n point to handle the method asynchronously.\n\n The usual checks on the validity of the calls is performed. For\n `Get` calls, an error is automatically returned if the property does\n not exist or the permissions do not allow access. The same checks are\n performed for `Set` calls, and the provided value is also checked for\n being the correct type.\n\n For both `Get` and `Set` calls, the #GDBusMethodInvocation\n passed to the @method_call handler can be queried with\n g_dbus_method_invocation_get_property_info() to get a pointer\n to the #GDBusPropertyInfo of the property.\n\n If you have readable properties specified in your interface info,\n you must ensure that you either provide a non-%NULL @get_property()\n function or provide implementations of both the `Get` and `GetAll`\n methods on org.freedesktop.DBus.Properties interface in your @method_call\n function. Note that the required return type of the `Get` call is\n `(v)`, not the type of the property. `GetAll` expects a return value\n of type `a{sv}`.\n\n If you have writable properties specified in your interface info,\n you must ensure that you either provide a non-%NULL @set_property()\n function or provide an implementation of the `Set` call. If implementing\n the call, you must return the value of type %G_VARIANT_TYPE_UNIT.\n\n Since: 2.26"]
pub type GDBusInterfaceVTable = _GDBusInterfaceVTable;
#[doc = " GDBusSubtreeVTable:\n @enumerate: Function for enumerating child nodes.\n @introspect: Function for introspecting a child node.\n @dispatch: Function for dispatching a remote call on a child node.\n\n Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().\n\n Since: 2.26"]
pub type GDBusSubtreeVTable = _GDBusSubtreeVTable;
#[doc = " GDBusAnnotationInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @key: The name of the annotation, e.g. \"org.freedesktop.DBus.Deprecated\".\n @value: The value of the annotation.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about an annotation.\n\n Since: 2.26"]
pub type GDBusAnnotationInfo = _GDBusAnnotationInfo;
#[doc = " GDBusArgInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: Name of the argument, e.g. @unix_user_id.\n @signature: D-Bus signature of the argument (a single complete type).\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about an argument for a method or a signal.\n\n Since: 2.26"]
pub type GDBusArgInfo = _GDBusArgInfo;
#[doc = " GDBusMethodInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus method, e.g. @RequestName.\n @in_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments.\n @out_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a method on an D-Bus interface.\n\n Since: 2.26"]
pub type GDBusMethodInfo = _GDBusMethodInfo;
#[doc = " GDBusSignalInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus signal, e.g. \"NameOwnerChanged\".\n @args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no arguments.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a signal on a D-Bus interface.\n\n Since: 2.26"]
pub type GDBusSignalInfo = _GDBusSignalInfo;
#[doc = " GDBusPropertyInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus property, e.g. \"SupportedFilesystems\".\n @signature: The D-Bus signature of the property (a single complete type).\n @flags: Access control flags for the property.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a D-Bus property on a D-Bus interface.\n\n Since: 2.26"]
pub type GDBusPropertyInfo = _GDBusPropertyInfo;
#[doc = " GDBusInterfaceInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus interface, e.g. \"org.freedesktop.DBus.Properties\".\n @methods: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.\n @signals: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals.\n @properties: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a D-Bus interface.\n\n Since: 2.26"]
pub type GDBusInterfaceInfo = _GDBusInterfaceInfo;
#[doc = " GDBusNodeInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @path: The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.\n @interfaces: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.\n @nodes: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about nodes in a remote object hierarchy.\n\n Since: 2.26"]
pub type GDBusNodeInfo = _GDBusNodeInfo;
#[doc = " GCancellableSourceFunc:\n @cancellable: the #GCancellable\n @data: data passed in by the user.\n\n This is the function type of the callback used for the #GSource\n returned by g_cancellable_source_new().\n\n Returns: it should return %FALSE if the source should be removed.\n\n Since: 2.28"]
pub type GCancellableSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(cancellable: *mut GCancellable, data: gpointer) -> gboolean,
>;
#[doc = " GPollableSourceFunc:\n @pollable_stream: the #GPollableInputStream or #GPollableOutputStream\n @data: data passed in by the user.\n\n This is the function type of the callback used for the #GSource\n returned by g_pollable_input_stream_create_source() and\n g_pollable_output_stream_create_source().\n\n Returns: it should return %FALSE if the source should be removed.\n\n Since: 2.28"]
pub type GPollableSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(pollable_stream: *mut GObject, data: gpointer) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterface {
    _unused: [u8; 0],
}
pub type GDBusInterface = _GDBusInterface;
#[doc = " GDBusInterfaceSkeleton:\n\n The #GDBusInterfaceSkeleton structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
pub type GDBusInterfaceSkeleton = _GDBusInterfaceSkeleton;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObject {
    _unused: [u8; 0],
}
pub type GDBusObject = _GDBusObject;
#[doc = " GDBusObjectSkeleton:\n\n The #GDBusObjectSkeleton structure contains private data and should only be\n accessed using the provided API.\n\n Since: 2.30"]
pub type GDBusObjectSkeleton = _GDBusObjectSkeleton;
#[doc = " GDBusObjectProxy:\n\n The #GDBusObjectProxy structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
pub type GDBusObjectProxy = _GDBusObjectProxy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManager {
    _unused: [u8; 0],
}
pub type GDBusObjectManager = _GDBusObjectManager;
#[doc = " GDBusObjectManagerClient:\n\n The #GDBusObjectManagerClient structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
pub type GDBusObjectManagerClient = _GDBusObjectManagerClient;
#[doc = " GDBusObjectManagerServer:\n\n The #GDBusObjectManagerServer structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
pub type GDBusObjectManagerServer = _GDBusObjectManagerServer;
#[doc = " GDBusProxyTypeFunc:\n @manager: A #GDBusObjectManagerClient.\n @object_path: The object path of the remote object.\n @interface_name: (nullable): The interface name of the remote object or %NULL if a #GDBusObjectProxy #GType is requested.\n @data: data passed in by the user.\n\n Function signature for a function used to determine the #GType to\n use for an interface proxy (if @interface_name is not %NULL) or\n object proxy (if @interface_name is %NULL).\n\n This function is called in the\n [thread-default main loop][g-main-context-push-thread-default]\n that @manager was constructed in.\n\n Returns: A #GType to use for the remote object. The returned type\n   must be a #GDBusProxy or #GDBusObjectProxy -derived\n   type.\n\n Since: 2.30"]
pub type GDBusProxyTypeFunc = ::std::option::Option<
    unsafe extern "C" fn(
        manager: *mut GDBusObjectManagerClient,
        object_path: *const gchar,
        interface_name: *const gchar,
        data: gpointer,
    ) -> GType,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTestDBus {
    _unused: [u8; 0],
}
pub type GTestDBus = _GTestDBus;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSubprocess {
    _unused: [u8; 0],
}
#[doc = " GSubprocess:\n\n A child process.\n\n Since: 2.40"]
pub type GSubprocess = _GSubprocess;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSubprocessLauncher {
    _unused: [u8; 0],
}
#[doc = " GSubprocessLauncher:\n\n Options for launching a child process.\n\n Since: 2.40"]
pub type GSubprocessLauncher = _GSubprocessLauncher;
pub type GActionInterface = _GActionInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionInterface {
    pub g_iface: GTypeInterface,
    pub get_name: ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *const gchar>,
    pub get_parameter_type:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *const GVariantType>,
    pub get_state_type:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *const GVariantType>,
    pub get_state_hint:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *mut GVariant>,
    pub get_enabled: ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> gboolean>,
    pub get_state:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *mut GVariant>,
    pub change_state:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction, value: *mut GVariant)>,
    pub activate:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction, parameter: *mut GVariant)>,
}
#[test]
fn bindgen_test_layout__GActionInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GActionInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GActionInterface>(),
        80usize,
        concat!("Size of: ", stringify!(_GActionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GActionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GActionInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_parameter_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_parameter_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_state_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_state_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_state_hint) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_state_hint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_enabled) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_state) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_state) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(change_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(activate)
        )
    );
}
extern "C" {
    pub fn g_action_get_type() -> GType;
}
extern "C" {
    pub fn g_action_get_name(action: *mut GAction) -> *const gchar;
}
extern "C" {
    pub fn g_action_get_parameter_type(action: *mut GAction) -> *const GVariantType;
}
extern "C" {
    pub fn g_action_get_state_type(action: *mut GAction) -> *const GVariantType;
}
extern "C" {
    pub fn g_action_get_state_hint(action: *mut GAction) -> *mut GVariant;
}
extern "C" {
    pub fn g_action_get_enabled(action: *mut GAction) -> gboolean;
}
extern "C" {
    pub fn g_action_get_state(action: *mut GAction) -> *mut GVariant;
}
extern "C" {
    pub fn g_action_change_state(action: *mut GAction, value: *mut GVariant);
}
extern "C" {
    pub fn g_action_activate(action: *mut GAction, parameter: *mut GVariant);
}
extern "C" {
    pub fn g_action_name_is_valid(action_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_action_parse_detailed_name(
        detailed_name: *const gchar,
        action_name: *mut *mut gchar,
        target_value: *mut *mut GVariant,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_action_print_detailed_name(
        action_name: *const gchar,
        target_value: *mut GVariant,
    ) -> *mut gchar;
}
pub type GActionGroupInterface = _GActionGroupInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionGroupInterface {
    pub g_iface: GTypeInterface,
    pub has_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> gboolean,
    >,
    pub list_actions: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup) -> *mut *mut gchar,
    >,
    pub get_action_enabled: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> gboolean,
    >,
    pub get_action_parameter_type: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> *const GVariantType,
    >,
    pub get_action_state_type: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> *const GVariantType,
    >,
    pub get_action_state_hint: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> *mut GVariant,
    >,
    pub get_action_state: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
        ) -> *mut GVariant,
    >,
    pub change_action_state: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            value: *mut GVariant,
        ),
    >,
    pub activate_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            parameter: *mut GVariant,
        ),
    >,
    pub action_added: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar),
    >,
    pub action_removed: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar),
    >,
    pub action_enabled_changed: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            enabled: gboolean,
        ),
    >,
    pub action_state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            state: *mut GVariant,
        ),
    >,
    pub query_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            enabled: *mut gboolean,
            parameter_type: *mut *const GVariantType,
            state_type: *mut *const GVariantType,
            state_hint: *mut *mut GVariant,
            state: *mut *mut GVariant,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GActionGroupInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GActionGroupInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GActionGroupInterface>(),
        128usize,
        concat!("Size of: ", stringify!(_GActionGroupInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GActionGroupInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GActionGroupInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_action) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(has_action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).list_actions) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(list_actions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_action_enabled) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_action_parameter_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_parameter_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_action_state_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_state_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_action_state_hint) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_state_hint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_action_state) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_action_state) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(change_action_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate_action) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(activate_action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_added) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(action_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_removed) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(action_removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_enabled_changed) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(action_enabled_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).action_state_changed) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(action_state_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_action) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(query_action)
        )
    );
}
extern "C" {
    pub fn g_action_group_get_type() -> GType;
}
extern "C" {
    pub fn g_action_group_has_action(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_action_group_list_actions(action_group: *mut GActionGroup) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_action_group_get_action_parameter_type(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *const GVariantType;
}
extern "C" {
    pub fn g_action_group_get_action_state_type(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *const GVariantType;
}
extern "C" {
    pub fn g_action_group_get_action_state_hint(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_action_group_get_action_enabled(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_action_group_get_action_state(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_action_group_change_action_state(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_action_group_activate_action(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        parameter: *mut GVariant,
    );
}
extern "C" {
    pub fn g_action_group_action_added(action_group: *mut GActionGroup, action_name: *const gchar);
}
extern "C" {
    pub fn g_action_group_action_removed(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    );
}
extern "C" {
    pub fn g_action_group_action_enabled_changed(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        enabled: gboolean,
    );
}
extern "C" {
    pub fn g_action_group_action_state_changed(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        state: *mut GVariant,
    );
}
extern "C" {
    pub fn g_action_group_query_action(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        enabled: *mut gboolean,
        parameter_type: *mut *const GVariantType,
        state_type: *mut *const GVariantType,
        state_hint: *mut *mut GVariant,
        state: *mut *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_export_action_group(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        action_group: *mut GActionGroup,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_unexport_action_group(
        connection: *mut GDBusConnection,
        export_id: guint,
    );
}
pub type GActionMapInterface = _GActionMapInterface;
pub type GActionEntry = _GActionEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionMapInterface {
    pub g_iface: GTypeInterface,
    pub lookup_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_map: *mut GActionMap,
            action_name: *const gchar,
        ) -> *mut GAction,
    >,
    pub add_action: ::std::option::Option<
        unsafe extern "C" fn(action_map: *mut GActionMap, action: *mut GAction),
    >,
    pub remove_action: ::std::option::Option<
        unsafe extern "C" fn(action_map: *mut GActionMap, action_name: *const gchar),
    >,
}
#[test]
fn bindgen_test_layout__GActionMapInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GActionMapInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GActionMapInterface>(),
        40usize,
        concat!("Size of: ", stringify!(_GActionMapInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GActionMapInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GActionMapInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionMapInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_action) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionMapInterface),
            "::",
            stringify!(lookup_action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_action) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionMapInterface),
            "::",
            stringify!(add_action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_action) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionMapInterface),
            "::",
            stringify!(remove_action)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionEntry {
    pub name: *const gchar,
    pub activate: ::std::option::Option<
        unsafe extern "C" fn(
            action: *mut GSimpleAction,
            parameter: *mut GVariant,
            user_data: gpointer,
        ),
    >,
    pub parameter_type: *const gchar,
    pub state: *const gchar,
    pub change_state: ::std::option::Option<
        unsafe extern "C" fn(action: *mut GSimpleAction, value: *mut GVariant, user_data: gpointer),
    >,
    pub padding: [gsize; 3usize],
}
#[test]
fn bindgen_test_layout__GActionEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_GActionEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GActionEntry>(),
        64usize,
        concat!("Size of: ", stringify!(_GActionEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GActionEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GActionEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parameter_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(parameter_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(change_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_action_map_get_type() -> GType;
}
extern "C" {
    pub fn g_action_map_lookup_action(
        action_map: *mut GActionMap,
        action_name: *const gchar,
    ) -> *mut GAction;
}
extern "C" {
    pub fn g_action_map_add_action(action_map: *mut GActionMap, action: *mut GAction);
}
extern "C" {
    pub fn g_action_map_remove_action(action_map: *mut GActionMap, action_name: *const gchar);
}
extern "C" {
    pub fn g_action_map_add_action_entries(
        action_map: *mut GActionMap,
        entries: *const GActionEntry,
        n_entries: gint,
        user_data: gpointer,
    );
}
pub type GAppLaunchContextClass = _GAppLaunchContextClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppLaunchContextPrivate {
    _unused: [u8; 0],
}
pub type GAppLaunchContextPrivate = _GAppLaunchContextPrivate;
#[doc = " GAppInfoIface:\n @g_iface: The parent interface.\n @dup: Copies a #GAppInfo.\n @equal: Checks two #GAppInfos for equality.\n @get_id: Gets a string identifier for a #GAppInfo.\n @get_name: Gets the name of the application for a #GAppInfo.\n @get_description: Gets a short description for the application described by the #GAppInfo.\n @get_executable: Gets the executable name for the #GAppInfo.\n @get_icon: Gets the #GIcon for the #GAppInfo.\n @launch: Launches an application specified by the #GAppInfo.\n @supports_uris: Indicates whether the application specified supports launching URIs.\n @supports_files: Indicates whether the application specified accepts filename arguments.\n @launch_uris: Launches an application with a list of URIs.\n @should_show: Returns whether an application should be shown (e.g. when getting a list of installed applications).\n [FreeDesktop.Org Startup Notification Specification](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).\n @set_as_default_for_type: Sets an application as default for a given content type.\n @set_as_default_for_extension: Sets an application as default for a given file extension.\n @add_supports_type: Adds to the #GAppInfo information about supported file types.\n @can_remove_supports_type: Checks for support for removing supported file types from a #GAppInfo.\n @remove_supports_type: Removes a supported application type from a #GAppInfo.\n @can_delete: Checks if a #GAppInfo can be deleted. Since 2.20\n @do_delete: Deletes a #GAppInfo. Since 2.20\n @get_commandline: Gets the commandline for the #GAppInfo. Since 2.20\n @get_display_name: Gets the display name for the #GAppInfo. Since 2.24\n @set_as_last_used_for_type: Sets the application as the last used. See g_app_info_set_as_last_used_for_type().\n @get_supported_types: Retrieves the list of content types that @app_info claims to support.\n @launch_uris_async: Asynchronously launches an application with a list of URIs. (Since: 2.60)\n @launch_uris_finish: Finishes an operation started with @launch_uris_async. (Since: 2.60)\n\n Application Information interface, for operating system portability."]
pub type GAppInfoIface = _GAppInfoIface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppInfoIface {
    pub g_iface: GTypeInterface,
    pub dup: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *mut GAppInfo>,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(appinfo1: *mut GAppInfo, appinfo2: *mut GAppInfo) -> gboolean,
    >,
    pub get_id: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_description: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_executable: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *mut GIcon>,
    pub launch: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            files: *mut GList,
            context: *mut GAppLaunchContext,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub supports_uris:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub supports_files:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub launch_uris: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            uris: *mut GList,
            context: *mut GAppLaunchContext,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub should_show:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub set_as_default_for_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_as_default_for_extension: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            extension: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub add_supports_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_remove_supports_type:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub remove_supports_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_delete: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub do_delete: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub get_commandline: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_display_name: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub set_as_last_used_for_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_supported_types: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *mut *const ::std::os::raw::c_char,
    >,
    pub launch_uris_async: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            uris: *mut GList,
            context: *mut GAppLaunchContext,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub launch_uris_finish: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GAppInfoIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GAppInfoIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GAppInfoIface>(),
        216usize,
        concat!("Size of: ", stringify!(_GAppInfoIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAppInfoIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAppInfoIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(dup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_id) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_description) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_executable) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_executable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_icon) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_icon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(launch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_uris) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(supports_uris)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_files) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(supports_files)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch_uris) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(launch_uris)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).should_show) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(should_show)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_as_default_for_type) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(set_as_default_for_type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).set_as_default_for_extension) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(set_as_default_for_extension)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_supports_type) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(add_supports_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_remove_supports_type) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(can_remove_supports_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove_supports_type) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(remove_supports_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_delete) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(can_delete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_delete) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(do_delete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_commandline) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_commandline)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_display_name) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_display_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_as_last_used_for_type) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(set_as_last_used_for_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_supported_types) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_supported_types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch_uris_async) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(launch_uris_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch_uris_finish) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(launch_uris_finish)
        )
    );
}
extern "C" {
    pub fn g_app_info_get_type() -> GType;
}
extern "C" {
    pub fn g_app_info_create_from_commandline(
        commandline: *const ::std::os::raw::c_char,
        application_name: *const ::std::os::raw::c_char,
        flags: GAppInfoCreateFlags,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_app_info_dup(appinfo: *mut GAppInfo) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_app_info_equal(appinfo1: *mut GAppInfo, appinfo2: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_get_id(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_get_name(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_get_display_name(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_get_description(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_get_executable(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_get_commandline(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_get_icon(appinfo: *mut GAppInfo) -> *mut GIcon;
}
extern "C" {
    pub fn g_app_info_launch(
        appinfo: *mut GAppInfo,
        files: *mut GList,
        context: *mut GAppLaunchContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_supports_uris(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_supports_files(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_launch_uris(
        appinfo: *mut GAppInfo,
        uris: *mut GList,
        context: *mut GAppLaunchContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_launch_uris_async(
        appinfo: *mut GAppInfo,
        uris: *mut GList,
        context: *mut GAppLaunchContext,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_app_info_launch_uris_finish(
        appinfo: *mut GAppInfo,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_should_show(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_set_as_default_for_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_set_as_default_for_extension(
        appinfo: *mut GAppInfo,
        extension: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_add_supports_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_can_remove_supports_type(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_remove_supports_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_get_supported_types(
        appinfo: *mut GAppInfo,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_info_can_delete(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_delete(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    pub fn g_app_info_set_as_last_used_for_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_get_all() -> *mut GList;
}
extern "C" {
    pub fn g_app_info_get_all_for_type(content_type: *const ::std::os::raw::c_char) -> *mut GList;
}
extern "C" {
    pub fn g_app_info_get_recommended_for_type(content_type: *const gchar) -> *mut GList;
}
extern "C" {
    pub fn g_app_info_get_fallback_for_type(content_type: *const gchar) -> *mut GList;
}
extern "C" {
    pub fn g_app_info_reset_type_associations(content_type: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_app_info_get_default_for_type(
        content_type: *const ::std::os::raw::c_char,
        must_support_uris: gboolean,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_app_info_get_default_for_type_async(
        content_type: *const ::std::os::raw::c_char,
        must_support_uris: gboolean,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_app_info_get_default_for_type_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_app_info_get_default_for_uri_scheme(
        uri_scheme: *const ::std::os::raw::c_char,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_app_info_get_default_for_uri_scheme_async(
        uri_scheme: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_app_info_get_default_for_uri_scheme_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_app_info_launch_default_for_uri(
        uri: *const ::std::os::raw::c_char,
        context: *mut GAppLaunchContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_app_info_launch_default_for_uri_async(
        uri: *const ::std::os::raw::c_char,
        context: *mut GAppLaunchContext,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_app_info_launch_default_for_uri_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " GAppLaunchContext:\n\n Integrating the launch with the launching application. This is used to\n handle for instance startup notification and launching the new application\n on the same screen as the launching window."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppLaunchContext {
    pub parent_instance: GObject,
    pub priv_: *mut GAppLaunchContextPrivate,
}
#[test]
fn bindgen_test_layout__GAppLaunchContext() {
    const UNINIT: ::std::mem::MaybeUninit<_GAppLaunchContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GAppLaunchContext>(),
        32usize,
        concat!("Size of: ", stringify!(_GAppLaunchContext))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAppLaunchContext>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAppLaunchContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContext),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContext),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppLaunchContextClass {
    pub parent_class: GObjectClass,
    pub get_display: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            files: *mut GList,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub get_startup_notify_id: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            files: *mut GList,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub launch_failed: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            startup_notify_id: *const ::std::os::raw::c_char,
        ),
    >,
    pub launched: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            platform_data: *mut GVariant,
        ),
    >,
    pub launch_started: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            platform_data: *mut GVariant,
        ),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GAppLaunchContextClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GAppLaunchContextClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GAppLaunchContextClass>(),
        200usize,
        concat!("Size of: ", stringify!(_GAppLaunchContextClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAppLaunchContextClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAppLaunchContextClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_display) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(get_display)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_startup_notify_id) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(get_startup_notify_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch_failed) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(launch_failed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launched) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(launched)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).launch_started) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(launch_started)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
}
extern "C" {
    pub fn g_app_launch_context_get_type() -> GType;
}
extern "C" {
    pub fn g_app_launch_context_new() -> *mut GAppLaunchContext;
}
extern "C" {
    pub fn g_app_launch_context_setenv(
        context: *mut GAppLaunchContext,
        variable: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_app_launch_context_unsetenv(
        context: *mut GAppLaunchContext,
        variable: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_app_launch_context_get_environment(
        context: *mut GAppLaunchContext,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_launch_context_get_display(
        context: *mut GAppLaunchContext,
        info: *mut GAppInfo,
        files: *mut GList,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_launch_context_get_startup_notify_id(
        context: *mut GAppLaunchContext,
        info: *mut GAppInfo,
        files: *mut GList,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_app_launch_context_launch_failed(
        context: *mut GAppLaunchContext,
        startup_notify_id: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppInfoMonitor {
    _unused: [u8; 0],
}
pub type GAppInfoMonitor = _GAppInfoMonitor;
extern "C" {
    pub fn g_app_info_monitor_get_type() -> GType;
}
extern "C" {
    pub fn g_app_info_monitor_get() -> *mut GAppInfoMonitor;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationPrivate {
    _unused: [u8; 0],
}
pub type GApplicationPrivate = _GApplicationPrivate;
pub type GApplicationClass = _GApplicationClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplication {
    pub parent_instance: GObject,
    pub priv_: *mut GApplicationPrivate,
}
#[test]
fn bindgen_test_layout__GApplication() {
    const UNINIT: ::std::mem::MaybeUninit<_GApplication> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GApplication>(),
        32usize,
        concat!("Size of: ", stringify!(_GApplication))
    );
    assert_eq!(
        ::std::mem::align_of::<_GApplication>(),
        8usize,
        concat!("Alignment of ", stringify!(_GApplication))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplication),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplication),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationClass {
    pub parent_class: GObjectClass,
    pub startup: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub activate: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            files: *mut *mut GFile,
            n_files: gint,
            hint: *const gchar,
        ),
    >,
    pub command_line: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            command_line: *mut GApplicationCommandLine,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " GApplicationClass::local_command_line:\n @application: a #GApplication\n @arguments: (inout) (array zero-terminated=1): array of command line arguments\n @exit_status: (out): exit status to fill after processing the command line.\n\n This virtual function is always invoked in the local instance. It\n gets passed a pointer to a %NULL-terminated copy of @argv and is\n expected to remove arguments that it handled (shifting up remaining\n arguments).\n\n The last argument to local_command_line() is a pointer to the @status\n variable which can used to set the exit status that is returned from\n g_application_run().\n\n See g_application_run() for more details on #GApplication startup.\n\n Returns: %TRUE if the commandline has been completely handled"]
    pub local_command_line: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            arguments: *mut *mut *mut gchar,
            exit_status: *mut ::std::os::raw::c_int,
        ) -> gboolean,
    >,
    pub before_emit: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, platform_data: *mut GVariant),
    >,
    pub after_emit: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, platform_data: *mut GVariant),
    >,
    pub add_platform_data: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, builder: *mut GVariantBuilder),
    >,
    pub quit_mainloop: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub run_mainloop: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub shutdown: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub dbus_register: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            connection: *mut GDBusConnection,
            object_path: *const gchar,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub dbus_unregister: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            connection: *mut GDBusConnection,
            object_path: *const gchar,
        ),
    >,
    pub handle_local_options: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, options: *mut GVariantDict) -> gint,
    >,
    pub name_lost:
        ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication) -> gboolean>,
    pub padding: [gpointer; 7usize],
}
#[test]
fn bindgen_test_layout__GApplicationClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GApplicationClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GApplicationClass>(),
        312usize,
        concat!("Size of: ", stringify!(_GApplicationClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GApplicationClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GApplicationClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startup) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(startup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).command_line) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(command_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_command_line) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(local_command_line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).before_emit) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(before_emit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).after_emit) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(after_emit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_platform_data) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(add_platform_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quit_mainloop) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(quit_mainloop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run_mainloop) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(run_mainloop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbus_register) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(dbus_register)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbus_unregister) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(dbus_unregister)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle_local_options) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(handle_local_options)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name_lost) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(name_lost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_application_get_type() -> GType;
}
extern "C" {
    pub fn g_application_id_is_valid(application_id: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_application_new(
        application_id: *const gchar,
        flags: GApplicationFlags,
    ) -> *mut GApplication;
}
extern "C" {
    pub fn g_application_get_application_id(application: *mut GApplication) -> *const gchar;
}
extern "C" {
    pub fn g_application_set_application_id(
        application: *mut GApplication,
        application_id: *const gchar,
    );
}
extern "C" {
    pub fn g_application_get_dbus_connection(
        application: *mut GApplication,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_application_get_dbus_object_path(application: *mut GApplication) -> *const gchar;
}
extern "C" {
    pub fn g_application_get_inactivity_timeout(application: *mut GApplication) -> guint;
}
extern "C" {
    pub fn g_application_set_inactivity_timeout(
        application: *mut GApplication,
        inactivity_timeout: guint,
    );
}
extern "C" {
    pub fn g_application_get_flags(application: *mut GApplication) -> GApplicationFlags;
}
extern "C" {
    pub fn g_application_set_flags(application: *mut GApplication, flags: GApplicationFlags);
}
extern "C" {
    pub fn g_application_get_resource_base_path(application: *mut GApplication) -> *const gchar;
}
extern "C" {
    pub fn g_application_set_resource_base_path(
        application: *mut GApplication,
        resource_path: *const gchar,
    );
}
extern "C" {
    pub fn g_application_set_action_group(
        application: *mut GApplication,
        action_group: *mut GActionGroup,
    );
}
extern "C" {
    pub fn g_application_add_main_option_entries(
        application: *mut GApplication,
        entries: *const GOptionEntry,
    );
}
extern "C" {
    pub fn g_application_add_main_option(
        application: *mut GApplication,
        long_name: *const ::std::os::raw::c_char,
        short_name: ::std::os::raw::c_char,
        flags: GOptionFlags,
        arg: GOptionArg,
        description: *const ::std::os::raw::c_char,
        arg_description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_application_add_option_group(application: *mut GApplication, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_application_set_option_context_parameter_string(
        application: *mut GApplication,
        parameter_string: *const gchar,
    );
}
extern "C" {
    pub fn g_application_set_option_context_summary(
        application: *mut GApplication,
        summary: *const gchar,
    );
}
extern "C" {
    pub fn g_application_set_option_context_description(
        application: *mut GApplication,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_application_get_is_registered(application: *mut GApplication) -> gboolean;
}
extern "C" {
    pub fn g_application_get_is_remote(application: *mut GApplication) -> gboolean;
}
extern "C" {
    pub fn g_application_register(
        application: *mut GApplication,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_application_hold(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_release(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_activate(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_open(
        application: *mut GApplication,
        files: *mut *mut GFile,
        n_files: gint,
        hint: *const gchar,
    );
}
extern "C" {
    pub fn g_application_run(
        application: *mut GApplication,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_application_quit(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_get_default() -> *mut GApplication;
}
extern "C" {
    pub fn g_application_set_default(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_mark_busy(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_unmark_busy(application: *mut GApplication);
}
extern "C" {
    pub fn g_application_get_is_busy(application: *mut GApplication) -> gboolean;
}
extern "C" {
    pub fn g_application_send_notification(
        application: *mut GApplication,
        id: *const gchar,
        notification: *mut GNotification,
    );
}
extern "C" {
    pub fn g_application_withdraw_notification(application: *mut GApplication, id: *const gchar);
}
extern "C" {
    pub fn g_application_bind_busy_property(
        application: *mut GApplication,
        object: gpointer,
        property: *const gchar,
    );
}
extern "C" {
    pub fn g_application_unbind_busy_property(
        application: *mut GApplication,
        object: gpointer,
        property: *const gchar,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationCommandLinePrivate {
    _unused: [u8; 0],
}
pub type GApplicationCommandLinePrivate = _GApplicationCommandLinePrivate;
pub type GApplicationCommandLineClass = _GApplicationCommandLineClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationCommandLine {
    pub parent_instance: GObject,
    pub priv_: *mut GApplicationCommandLinePrivate,
}
#[test]
fn bindgen_test_layout__GApplicationCommandLine() {
    const UNINIT: ::std::mem::MaybeUninit<_GApplicationCommandLine> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GApplicationCommandLine>(),
        32usize,
        concat!("Size of: ", stringify!(_GApplicationCommandLine))
    );
    assert_eq!(
        ::std::mem::align_of::<_GApplicationCommandLine>(),
        8usize,
        concat!("Alignment of ", stringify!(_GApplicationCommandLine))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLine),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLine),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationCommandLineClass {
    pub parent_class: GObjectClass,
    pub print_literal: ::std::option::Option<
        unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine, message: *const gchar),
    >,
    pub printerr_literal: ::std::option::Option<
        unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine, message: *const gchar),
    >,
    pub get_stdin: ::std::option::Option<
        unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine) -> *mut GInputStream,
    >,
    pub padding: [gpointer; 11usize],
}
#[test]
fn bindgen_test_layout__GApplicationCommandLineClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GApplicationCommandLineClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GApplicationCommandLineClass>(),
        248usize,
        concat!("Size of: ", stringify!(_GApplicationCommandLineClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GApplicationCommandLineClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GApplicationCommandLineClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).print_literal) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(print_literal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).printerr_literal) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(printerr_literal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_stdin) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(get_stdin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_application_command_line_get_type() -> GType;
}
extern "C" {
    pub fn g_application_command_line_get_arguments(
        cmdline: *mut GApplicationCommandLine,
        argc: *mut ::std::os::raw::c_int,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_application_command_line_get_options_dict(
        cmdline: *mut GApplicationCommandLine,
    ) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_application_command_line_get_stdin(
        cmdline: *mut GApplicationCommandLine,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_application_command_line_get_environ(
        cmdline: *mut GApplicationCommandLine,
    ) -> *const *const gchar;
}
extern "C" {
    pub fn g_application_command_line_getenv(
        cmdline: *mut GApplicationCommandLine,
        name: *const gchar,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_application_command_line_get_cwd(
        cmdline: *mut GApplicationCommandLine,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_application_command_line_get_is_remote(
        cmdline: *mut GApplicationCommandLine,
    ) -> gboolean;
}
extern "C" {
    pub fn g_application_command_line_print(
        cmdline: *mut GApplicationCommandLine,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_application_command_line_printerr(
        cmdline: *mut GApplicationCommandLine,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_application_command_line_get_exit_status(
        cmdline: *mut GApplicationCommandLine,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_application_command_line_set_exit_status(
        cmdline: *mut GApplicationCommandLine,
        exit_status: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn g_application_command_line_get_platform_data(
        cmdline: *mut GApplicationCommandLine,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_application_command_line_create_file_for_arg(
        cmdline: *mut GApplicationCommandLine,
        arg: *const gchar,
    ) -> *mut GFile;
}
#[doc = " GInitable:\n\n Interface for initializable objects.\n\n Since: 2.22"]
pub type GInitableIface = _GInitableIface;
#[doc = " GInitableIface:\n @g_iface: The parent interface.\n @init: Initializes the object.\n\n Provides an interface for initializing object such that initialization\n may fail.\n\n Since: 2.22"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInitableIface {
    pub g_iface: GTypeInterface,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            initable: *mut GInitable,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GInitableIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GInitableIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInitableIface>(),
        24usize,
        concat!("Size of: ", stringify!(_GInitableIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInitableIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInitableIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInitableIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInitableIface),
            "::",
            stringify!(init)
        )
    );
}
extern "C" {
    pub fn g_initable_get_type() -> GType;
}
extern "C" {
    pub fn g_initable_init(
        initable: *mut GInitable,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_initable_new(
        object_type: GType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
        first_property_name: *const gchar,
        ...
    ) -> gpointer;
}
extern "C" {
    pub fn g_initable_newv(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gpointer;
}
extern "C" {
    pub fn g_initable_new_valist(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GObject;
}
#[doc = " GAsyncInitable:\n\n Interface for asynchronously initializable objects.\n\n Since: 2.22"]
pub type GAsyncInitableIface = _GAsyncInitableIface;
#[doc = " GAsyncInitableIface:\n @g_iface: The parent interface.\n @init_async: Starts initialization of the object.\n @init_finish: Finishes initialization of the object.\n\n Provides an interface for asynchronous initializing object such that\n initialization may fail.\n\n Since: 2.22"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncInitableIface {
    pub g_iface: GTypeInterface,
    pub init_async: ::std::option::Option<
        unsafe extern "C" fn(
            initable: *mut GAsyncInitable,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub init_finish: ::std::option::Option<
        unsafe extern "C" fn(
            initable: *mut GAsyncInitable,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GAsyncInitableIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GAsyncInitableIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GAsyncInitableIface>(),
        32usize,
        concat!("Size of: ", stringify!(_GAsyncInitableIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAsyncInitableIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAsyncInitableIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncInitableIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_async) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncInitableIface),
            "::",
            stringify!(init_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init_finish) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncInitableIface),
            "::",
            stringify!(init_finish)
        )
    );
}
extern "C" {
    pub fn g_async_initable_get_type() -> GType;
}
extern "C" {
    pub fn g_async_initable_init_async(
        initable: *mut GAsyncInitable,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_initable_init_finish(
        initable: *mut GAsyncInitable,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_async_initable_new_async(
        object_type: GType,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        first_property_name: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_async_initable_newv_async(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_initable_new_valist_async(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_initable_new_finish(
        initable: *mut GAsyncInitable,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GObject;
}
#[doc = " GAsyncResult:\n\n Holds results information for an asynchronous operation,\n usually passed directly to an asynchronous _finish() operation."]
pub type GAsyncResultIface = _GAsyncResultIface;
#[doc = " GAsyncResultIface:\n @g_iface: The parent interface.\n @get_user_data: Gets the user data passed to the callback.\n @get_source_object: Gets the source object that issued the asynchronous operation.\n @is_tagged: Checks if a result is tagged with a particular source.\n\n Interface definition for #GAsyncResult."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncResultIface {
    pub g_iface: GTypeInterface,
    pub get_user_data:
        ::std::option::Option<unsafe extern "C" fn(res: *mut GAsyncResult) -> gpointer>,
    pub get_source_object:
        ::std::option::Option<unsafe extern "C" fn(res: *mut GAsyncResult) -> *mut GObject>,
    pub is_tagged: ::std::option::Option<
        unsafe extern "C" fn(res: *mut GAsyncResult, source_tag: gpointer) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GAsyncResultIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GAsyncResultIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GAsyncResultIface>(),
        40usize,
        concat!("Size of: ", stringify!(_GAsyncResultIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAsyncResultIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAsyncResultIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncResultIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_user_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncResultIface),
            "::",
            stringify!(get_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_source_object) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncResultIface),
            "::",
            stringify!(get_source_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_tagged) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncResultIface),
            "::",
            stringify!(is_tagged)
        )
    );
}
extern "C" {
    pub fn g_async_result_get_type() -> GType;
}
extern "C" {
    pub fn g_async_result_get_user_data(res: *mut GAsyncResult) -> gpointer;
}
extern "C" {
    pub fn g_async_result_get_source_object(res: *mut GAsyncResult) -> *mut GObject;
}
extern "C" {
    pub fn g_async_result_legacy_propagate_error(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_async_result_is_tagged(res: *mut GAsyncResult, source_tag: gpointer) -> gboolean;
}
#[doc = " GInputStream:\n\n Base class for streaming input operations."]
pub type GInputStreamClass = _GInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GInputStreamPrivate = _GInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputStream {
    pub parent_instance: GObject,
    pub priv_: *mut GInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GInputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInputStream>(),
        32usize,
        concat!("Size of: ", stringify!(_GInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputStreamClass {
    pub parent_class: GObjectClass,
    pub read_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            buffer: *mut ::std::os::raw::c_void,
            count: gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub skip: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            count: gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub read_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            buffer: *mut ::std::os::raw::c_void,
            count: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub read_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub skip_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            count: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub skip_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GInputStreamClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInputStreamClass>(),
        248usize,
        concat!("Size of: ", stringify!(_GInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_fn) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(read_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_fn) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_async) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(read_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_finish) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(read_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_async) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(skip_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_finish) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(skip_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_async) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(close_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_finish) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(close_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_input_stream_read(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_input_stream_read_all(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        bytes_read: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_read_bytes(
        stream: *mut GInputStream,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_input_stream_skip(
        stream: *mut GInputStream,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_input_stream_close(
        stream: *mut GInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_read_async(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_input_stream_read_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_input_stream_read_all_async(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_input_stream_read_all_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_read_bytes_async(
        stream: *mut GInputStream,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_input_stream_read_bytes_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_input_stream_skip_async(
        stream: *mut GInputStream,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_input_stream_skip_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_input_stream_close_async(
        stream: *mut GInputStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_input_stream_close_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_is_closed(stream: *mut GInputStream) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_has_pending(stream: *mut GInputStream) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_set_pending(
        stream: *mut GInputStream,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_input_stream_clear_pending(stream: *mut GInputStream);
}
#[doc = " GFilterInputStream:\n\n A base class for all input streams that work on an underlying stream."]
pub type GFilterInputStreamClass = _GFilterInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilterInputStream {
    pub parent_instance: GInputStream,
    pub base_stream: *mut GInputStream,
}
#[test]
fn bindgen_test_layout__GFilterInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GFilterInputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFilterInputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFilterInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilterInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilterInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_stream) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStream),
            "::",
            stringify!(base_stream)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilterInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFilterInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFilterInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFilterInputStreamClass>(),
        272usize,
        concat!("Size of: ", stringify!(_GFilterInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilterInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilterInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
}
extern "C" {
    pub fn g_filter_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_filter_input_stream_get_base_stream(
        stream: *mut GFilterInputStream,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_filter_input_stream_get_close_base_stream(stream: *mut GFilterInputStream)
        -> gboolean;
}
extern "C" {
    pub fn g_filter_input_stream_set_close_base_stream(
        stream: *mut GFilterInputStream,
        close_base: gboolean,
    );
}
#[doc = " GBufferedInputStream:\n\n Implements #GFilterInputStream with a sized input buffer."]
pub type GBufferedInputStreamClass = _GBufferedInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GBufferedInputStreamPrivate = _GBufferedInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedInputStream {
    pub parent_instance: GFilterInputStream,
    pub priv_: *mut GBufferedInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GBufferedInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GBufferedInputStream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GBufferedInputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GBufferedInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GBufferedInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GBufferedInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub fill: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GBufferedInputStream,
            count: gssize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub fill_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GBufferedInputStream,
            count: gssize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub fill_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GBufferedInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GBufferedInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GBufferedInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GBufferedInputStreamClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GBufferedInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GBufferedInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GBufferedInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(fill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill_async) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(fill_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill_finish) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(fill_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_buffered_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_buffered_input_stream_new(base_stream: *mut GInputStream) -> *mut GInputStream;
}
extern "C" {
    pub fn g_buffered_input_stream_new_sized(
        base_stream: *mut GInputStream,
        size: gsize,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_buffered_input_stream_get_buffer_size(stream: *mut GBufferedInputStream) -> gsize;
}
extern "C" {
    pub fn g_buffered_input_stream_set_buffer_size(stream: *mut GBufferedInputStream, size: gsize);
}
extern "C" {
    pub fn g_buffered_input_stream_get_available(stream: *mut GBufferedInputStream) -> gsize;
}
extern "C" {
    pub fn g_buffered_input_stream_peek(
        stream: *mut GBufferedInputStream,
        buffer: *mut ::std::os::raw::c_void,
        offset: gsize,
        count: gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_buffered_input_stream_peek_buffer(
        stream: *mut GBufferedInputStream,
        count: *mut gsize,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn g_buffered_input_stream_fill(
        stream: *mut GBufferedInputStream,
        count: gssize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_buffered_input_stream_fill_async(
        stream: *mut GBufferedInputStream,
        count: gssize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_buffered_input_stream_fill_finish(
        stream: *mut GBufferedInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_buffered_input_stream_read_byte(
        stream: *mut GBufferedInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> ::std::os::raw::c_int;
}
#[doc = " GOutputStream:\n\n Base class for writing output.\n\n All classes derived from GOutputStream should implement synchronous\n writing, splicing, flushing and closing streams, but may implement\n asynchronous versions."]
pub type GOutputStreamClass = _GOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GOutputStreamPrivate = _GOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputStream {
    pub parent_instance: GObject,
    pub priv_: *mut GOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GOutputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOutputStream>(),
        32usize,
        concat!("Size of: ", stringify!(_GOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputStreamClass {
    pub parent_class: GObjectClass,
    pub write_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            buffer: *const ::std::os::raw::c_void,
            count: gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub splice: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            source: *mut GInputStream,
            flags: GOutputStreamSpliceFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub write_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            buffer: *const ::std::os::raw::c_void,
            count: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub write_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub splice_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            source: *mut GInputStream,
            flags: GOutputStreamSpliceFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub splice_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub flush_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub flush_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub writev_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            vectors: *const GOutputVector,
            n_vectors: gsize,
            bytes_written: *mut gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub writev_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            vectors: *const GOutputVector,
            n_vectors: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub writev_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            bytes_written: *mut gsize,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GOutputStreamClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GOutputStreamClass>(),
        296usize,
        concat!("Size of: ", stringify!(_GOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_fn) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(write_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).splice) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(splice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_fn) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_async) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(write_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_finish) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(write_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).splice_async) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(splice_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).splice_finish) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(splice_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_async) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(flush_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush_finish) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(flush_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_async) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(close_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_finish) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(close_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writev_fn) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(writev_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writev_async) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(writev_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writev_finish) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(writev_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved7) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved8) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved8)
        )
    );
}
extern "C" {
    pub fn g_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_output_stream_write(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_output_stream_write_all(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_writev(
        stream: *mut GOutputStream,
        vectors: *const GOutputVector,
        n_vectors: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_writev_all(
        stream: *mut GOutputStream,
        vectors: *mut GOutputVector,
        n_vectors: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_printf(
        stream: *mut GOutputStream,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
        format: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_vprintf(
        stream: *mut GOutputStream,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_write_bytes(
        stream: *mut GOutputStream,
        bytes: *mut GBytes,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_output_stream_splice(
        stream: *mut GOutputStream,
        source: *mut GInputStream,
        flags: GOutputStreamSpliceFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_output_stream_flush(
        stream: *mut GOutputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_close(
        stream: *mut GOutputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_write_async(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_write_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_output_stream_write_all_async(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_write_all_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_writev_async(
        stream: *mut GOutputStream,
        vectors: *const GOutputVector,
        n_vectors: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_writev_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_writev_all_async(
        stream: *mut GOutputStream,
        vectors: *mut GOutputVector,
        n_vectors: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_writev_all_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_write_bytes_async(
        stream: *mut GOutputStream,
        bytes: *mut GBytes,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_write_bytes_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_output_stream_splice_async(
        stream: *mut GOutputStream,
        source: *mut GInputStream,
        flags: GOutputStreamSpliceFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_splice_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_output_stream_flush_async(
        stream: *mut GOutputStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_flush_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_close_async(
        stream: *mut GOutputStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_output_stream_close_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_is_closed(stream: *mut GOutputStream) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_is_closing(stream: *mut GOutputStream) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_has_pending(stream: *mut GOutputStream) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_set_pending(
        stream: *mut GOutputStream,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_output_stream_clear_pending(stream: *mut GOutputStream);
}
#[doc = " GFilterOutputStream:\n\n A base class for all output streams that work on an underlying stream."]
pub type GFilterOutputStreamClass = _GFilterOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilterOutputStream {
    pub parent_instance: GOutputStream,
    pub base_stream: *mut GOutputStream,
}
#[test]
fn bindgen_test_layout__GFilterOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GFilterOutputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFilterOutputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFilterOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilterOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilterOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_stream) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStream),
            "::",
            stringify!(base_stream)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilterOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFilterOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFilterOutputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFilterOutputStreamClass>(),
        320usize,
        concat!("Size of: ", stringify!(_GFilterOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilterOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilterOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
}
extern "C" {
    pub fn g_filter_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_filter_output_stream_get_base_stream(
        stream: *mut GFilterOutputStream,
    ) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_filter_output_stream_get_close_base_stream(
        stream: *mut GFilterOutputStream,
    ) -> gboolean;
}
extern "C" {
    pub fn g_filter_output_stream_set_close_base_stream(
        stream: *mut GFilterOutputStream,
        close_base: gboolean,
    );
}
#[doc = " GBufferedOutputStream:\n\n An implementation of #GFilterOutputStream with a sized buffer."]
pub type GBufferedOutputStreamClass = _GBufferedOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GBufferedOutputStreamPrivate = _GBufferedOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GBufferedOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GBufferedOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GBufferedOutputStream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GBufferedOutputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GBufferedOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GBufferedOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GBufferedOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GBufferedOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GBufferedOutputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GBufferedOutputStreamClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GBufferedOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GBufferedOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GBufferedOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
}
extern "C" {
    pub fn g_buffered_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_buffered_output_stream_new(base_stream: *mut GOutputStream) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_buffered_output_stream_new_sized(
        base_stream: *mut GOutputStream,
        size: gsize,
    ) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_buffered_output_stream_get_buffer_size(stream: *mut GBufferedOutputStream) -> gsize;
}
extern "C" {
    pub fn g_buffered_output_stream_set_buffer_size(
        stream: *mut GBufferedOutputStream,
        size: gsize,
    );
}
extern "C" {
    pub fn g_buffered_output_stream_get_auto_grow(stream: *mut GBufferedOutputStream) -> gboolean;
}
extern "C" {
    pub fn g_buffered_output_stream_set_auto_grow(
        stream: *mut GBufferedOutputStream,
        auto_grow: gboolean,
    );
}
extern "C" {
    #[doc = " GBytesIcon:\n\n Gets an icon for a #GBytes. Implements #GLoadableIcon."]
    pub fn g_bytes_icon_get_type() -> GType;
}
extern "C" {
    pub fn g_bytes_icon_new(bytes: *mut GBytes) -> *mut GIcon;
}
extern "C" {
    pub fn g_bytes_icon_get_bytes(icon: *mut GBytesIcon) -> *mut GBytes;
}
#[doc = " GCancellable:\n\n Allows actions to be cancelled."]
pub type GCancellableClass = _GCancellableClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCancellablePrivate {
    _unused: [u8; 0],
}
pub type GCancellablePrivate = _GCancellablePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCancellable {
    pub parent_instance: GObject,
    pub priv_: *mut GCancellablePrivate,
}
#[test]
fn bindgen_test_layout__GCancellable() {
    const UNINIT: ::std::mem::MaybeUninit<_GCancellable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCancellable>(),
        32usize,
        concat!("Size of: ", stringify!(_GCancellable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCancellable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCancellable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellable),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellable),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCancellableClass {
    pub parent_class: GObjectClass,
    pub cancelled: ::std::option::Option<unsafe extern "C" fn(cancellable: *mut GCancellable)>,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GCancellableClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GCancellableClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCancellableClass>(),
        184usize,
        concat!("Size of: ", stringify!(_GCancellableClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCancellableClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCancellableClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancelled) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(cancelled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_cancellable_get_type() -> GType;
}
extern "C" {
    pub fn g_cancellable_new() -> *mut GCancellable;
}
extern "C" {
    pub fn g_cancellable_is_cancelled(cancellable: *mut GCancellable) -> gboolean;
}
extern "C" {
    pub fn g_cancellable_set_error_if_cancelled(
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_cancellable_get_fd(cancellable: *mut GCancellable) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_cancellable_make_pollfd(
        cancellable: *mut GCancellable,
        pollfd: *mut GPollFD,
    ) -> gboolean;
}
extern "C" {
    pub fn g_cancellable_release_fd(cancellable: *mut GCancellable);
}
extern "C" {
    pub fn g_cancellable_source_new(cancellable: *mut GCancellable) -> *mut GSource;
}
extern "C" {
    pub fn g_cancellable_get_current() -> *mut GCancellable;
}
extern "C" {
    pub fn g_cancellable_push_current(cancellable: *mut GCancellable);
}
extern "C" {
    pub fn g_cancellable_pop_current(cancellable: *mut GCancellable);
}
extern "C" {
    pub fn g_cancellable_reset(cancellable: *mut GCancellable);
}
extern "C" {
    pub fn g_cancellable_connect(
        cancellable: *mut GCancellable,
        callback: GCallback,
        data: gpointer,
        data_destroy_func: GDestroyNotify,
    ) -> gulong;
}
extern "C" {
    pub fn g_cancellable_disconnect(cancellable: *mut GCancellable, handler_id: gulong);
}
extern "C" {
    pub fn g_cancellable_cancel(cancellable: *mut GCancellable);
}
#[doc = " GConverter:\n\n Seek object for streaming operations.\n\n Since: 2.24"]
pub type GConverterIface = _GConverterIface;
#[doc = " GConverterIface:\n @g_iface: The parent interface.\n @convert: Converts data.\n @reset: Reverts the internal state of the converter to its initial state.\n\n Provides an interface for converting data from one type\n to another type. The conversion can be stateful\n and may fail at any place.\n\n Since: 2.24"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterIface {
    pub g_iface: GTypeInterface,
    pub convert: ::std::option::Option<
        unsafe extern "C" fn(
            converter: *mut GConverter,
            inbuf: *const ::std::os::raw::c_void,
            inbuf_size: gsize,
            outbuf: *mut ::std::os::raw::c_void,
            outbuf_size: gsize,
            flags: GConverterFlags,
            bytes_read: *mut gsize,
            bytes_written: *mut gsize,
            error: *mut *mut GError,
        ) -> GConverterResult,
    >,
    pub reset: ::std::option::Option<unsafe extern "C" fn(converter: *mut GConverter)>,
}
#[test]
fn bindgen_test_layout__GConverterIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GConverterIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GConverterIface>(),
        32usize,
        concat!("Size of: ", stringify!(_GConverterIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).convert) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterIface),
            "::",
            stringify!(convert)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterIface),
            "::",
            stringify!(reset)
        )
    );
}
extern "C" {
    pub fn g_converter_get_type() -> GType;
}
extern "C" {
    pub fn g_converter_convert(
        converter: *mut GConverter,
        inbuf: *const ::std::os::raw::c_void,
        inbuf_size: gsize,
        outbuf: *mut ::std::os::raw::c_void,
        outbuf_size: gsize,
        flags: GConverterFlags,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GConverterResult;
}
extern "C" {
    pub fn g_converter_reset(converter: *mut GConverter);
}
pub type GCharsetConverterClass = _GCharsetConverterClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCharsetConverterClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GCharsetConverterClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GCharsetConverterClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GCharsetConverterClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GCharsetConverterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCharsetConverterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCharsetConverterClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCharsetConverterClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_charset_converter_get_type() -> GType;
}
extern "C" {
    pub fn g_charset_converter_new(
        to_charset: *const gchar,
        from_charset: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GCharsetConverter;
}
extern "C" {
    pub fn g_charset_converter_set_use_fallback(
        converter: *mut GCharsetConverter,
        use_fallback: gboolean,
    );
}
extern "C" {
    pub fn g_charset_converter_get_use_fallback(converter: *mut GCharsetConverter) -> gboolean;
}
extern "C" {
    pub fn g_charset_converter_get_num_fallbacks(converter: *mut GCharsetConverter) -> guint;
}
extern "C" {
    pub fn g_content_type_equals(type1: *const gchar, type2: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_content_type_is_a(type_: *const gchar, supertype: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_content_type_is_mime_type(type_: *const gchar, mime_type: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_content_type_is_unknown(type_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_content_type_get_description(type_: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_content_type_get_mime_type(type_: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_content_type_get_icon(type_: *const gchar) -> *mut GIcon;
}
extern "C" {
    pub fn g_content_type_get_symbolic_icon(type_: *const gchar) -> *mut GIcon;
}
extern "C" {
    pub fn g_content_type_get_generic_icon_name(type_: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_content_type_can_be_executable(type_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_content_type_from_mime_type(mime_type: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_content_type_guess(
        filename: *const gchar,
        data: *const guchar,
        data_size: gsize,
        result_uncertain: *mut gboolean,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_content_type_guess_for_tree(root: *mut GFile) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_content_types_get_registered() -> *mut GList;
}
extern "C" {
    pub fn g_content_type_get_mime_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_content_type_set_mime_dirs(dirs: *const *const gchar);
}
#[doc = " GConverterInputStream:\n\n An implementation of #GFilterInputStream that allows data\n conversion."]
pub type GConverterInputStreamClass = _GConverterInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GConverterInputStreamPrivate = _GConverterInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterInputStream {
    pub parent_instance: GFilterInputStream,
    pub priv_: *mut GConverterInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GConverterInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GConverterInputStream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GConverterInputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GConverterInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GConverterInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GConverterInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GConverterInputStreamClass>(),
        312usize,
        concat!("Size of: ", stringify!(_GConverterInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_converter_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_converter_input_stream_new(
        base_stream: *mut GInputStream,
        converter: *mut GConverter,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_converter_input_stream_get_converter(
        converter_stream: *mut GConverterInputStream,
    ) -> *mut GConverter;
}
#[doc = " GConverterOutputStream:\n\n An implementation of #GFilterOutputStream that allows data\n conversion."]
pub type GConverterOutputStreamClass = _GConverterOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GConverterOutputStreamPrivate = _GConverterOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GConverterOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GConverterOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GConverterOutputStream> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GConverterOutputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GConverterOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GConverterOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GConverterOutputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GConverterOutputStreamClass>(),
        360usize,
        concat!("Size of: ", stringify!(_GConverterOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_converter_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_converter_output_stream_new(
        base_stream: *mut GOutputStream,
        converter: *mut GConverter,
    ) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_converter_output_stream_get_converter(
        converter_stream: *mut GConverterOutputStream,
    ) -> *mut GConverter;
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_21 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_21 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_21 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_21 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_21 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_21 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_21 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_21 = 7;
pub const _PC_VDISABLE: _bindgen_ty_21 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_21 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_21 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_21 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_21 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_21 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_21 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_21 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_21 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_21 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_21 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_21 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_21 = 20;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_22 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_22 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_22 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_22 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_22 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_22 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_22 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_22 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_22 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_22 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_22 = 10;
pub const _SC_TIMERS: _bindgen_ty_22 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_22 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_22 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_22 = 14;
pub const _SC_FSYNC: _bindgen_ty_22 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_22 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_22 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_22 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_22 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_22 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_22 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_22 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_22 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_22 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_22 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_22 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_22 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_22 = 28;
pub const _SC_VERSION: _bindgen_ty_22 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_22 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_22 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_22 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_22 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_22 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_22 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_22 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_22 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_22 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_22 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_22 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_22 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_22 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_22 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_22 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_22 = 45;
pub const _SC_2_VERSION: _bindgen_ty_22 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_22 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_22 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_22 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_22 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_22 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_22 = 52;
pub const _SC_PII: _bindgen_ty_22 = 53;
pub const _SC_PII_XTI: _bindgen_ty_22 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_22 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_22 = 56;
pub const _SC_PII_OSI: _bindgen_ty_22 = 57;
pub const _SC_POLL: _bindgen_ty_22 = 58;
pub const _SC_SELECT: _bindgen_ty_22 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_22 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_22 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_22 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_22 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_22 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_22 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_22 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_22 = 66;
pub const _SC_THREADS: _bindgen_ty_22 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_22 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_22 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_22 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_22 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_22 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_22 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_22 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_22 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_22 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_22 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_22 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_22 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_22 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_22 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_22 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_22 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_22 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_22 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_22 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_22 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_22 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_22 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_22 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_22 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_22 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_22 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_22 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_22 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_22 = 96;
pub const _SC_2_UPE: _bindgen_ty_22 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_22 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_22 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_22 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_22 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_22 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_22 = 103;
pub const _SC_INT_MAX: _bindgen_ty_22 = 104;
pub const _SC_INT_MIN: _bindgen_ty_22 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_22 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_22 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_22 = 108;
pub const _SC_NZERO: _bindgen_ty_22 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_22 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_22 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_22 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_22 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_22 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_22 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_22 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_22 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_22 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_22 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_22 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_22 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_22 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_22 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_22 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_22 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_22 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_22 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_22 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_22 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_22 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_22 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_22 = 132;
pub const _SC_BARRIERS: _bindgen_ty_22 = 133;
pub const _SC_BASE: _bindgen_ty_22 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_22 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_22 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_22 = 137;
pub const _SC_CPUTIME: _bindgen_ty_22 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_22 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_22 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_22 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_22 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_22 = 143;
pub const _SC_FIFO: _bindgen_ty_22 = 144;
pub const _SC_PIPE: _bindgen_ty_22 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_22 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_22 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_22 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_22 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_22 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_22 = 151;
pub const _SC_NETWORKING: _bindgen_ty_22 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_22 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_22 = 154;
pub const _SC_REGEXP: _bindgen_ty_22 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_22 = 156;
pub const _SC_SHELL: _bindgen_ty_22 = 157;
pub const _SC_SIGNALS: _bindgen_ty_22 = 158;
pub const _SC_SPAWN: _bindgen_ty_22 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_22 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_22 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_22 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_22 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_22 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_22 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_22 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_22 = 167;
pub const _SC_2_PBS: _bindgen_ty_22 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_22 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_22 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_22 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_22 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_22 = 173;
pub const _SC_STREAMS: _bindgen_ty_22 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_22 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_22 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_22 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_22 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_22 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_22 = 180;
pub const _SC_TRACE: _bindgen_ty_22 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_22 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_22 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_22 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_22 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_22 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_22 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_22 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_22 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_22 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_22 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_22 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_22 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_22 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_22 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_22 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_22 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_22 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_22 = 199;
pub const _SC_IPV6: _bindgen_ty_22 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_22 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_22 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_22 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_22 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_22 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_22 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_22 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_22 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_22 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_22 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_22 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_22 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_22 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_22 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_22 = 250;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub const _CS_PATH: _bindgen_ty_23 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_23 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_23 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_23 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_23 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_23 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_23 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_23 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_23 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_23 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_23 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_23 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_23 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_23 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_23 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_23 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_23 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_23 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_23 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_23 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_23 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_23 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_23 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_23 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_23 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_23 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_23 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_23 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_23 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_23 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_23 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_23 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_23 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_23 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_23 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_23 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_23 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_23 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_23 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_23 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_23 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_23 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_23 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_23 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_23 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_23 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_23 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_23 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_23 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_23 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_23 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_23 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_23 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_23 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_23 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_23 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_23 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_23 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_23 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_23 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_23 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_23 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_23 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_23 = 1149;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCredentialsClass {
    _unused: [u8; 0],
}
pub type GCredentialsClass = _GCredentialsClass;
extern "C" {
    pub fn g_credentials_get_type() -> GType;
}
extern "C" {
    pub fn g_credentials_new() -> *mut GCredentials;
}
extern "C" {
    pub fn g_credentials_to_string(credentials: *mut GCredentials) -> *mut gchar;
}
extern "C" {
    pub fn g_credentials_get_native(
        credentials: *mut GCredentials,
        native_type: GCredentialsType,
    ) -> gpointer;
}
extern "C" {
    pub fn g_credentials_set_native(
        credentials: *mut GCredentials,
        native_type: GCredentialsType,
        native: gpointer,
    );
}
extern "C" {
    pub fn g_credentials_is_same_user(
        credentials: *mut GCredentials,
        other_credentials: *mut GCredentials,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_credentials_get_unix_pid(
        credentials: *mut GCredentials,
        error: *mut *mut GError,
    ) -> pid_t;
}
extern "C" {
    pub fn g_credentials_get_unix_user(
        credentials: *mut GCredentials,
        error: *mut *mut GError,
    ) -> uid_t;
}
extern "C" {
    pub fn g_credentials_set_unix_user(
        credentials: *mut GCredentials,
        uid: uid_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " GDatagramBased:\n\n Interface for socket-like objects with datagram semantics.\n\n Since: 2.48"]
pub type GDatagramBasedInterface = _GDatagramBasedInterface;
#[doc = " GDatagramBasedInterface:\n @g_iface: The parent interface.\n @receive_messages: Virtual method for g_datagram_based_receive_messages().\n @send_messages: Virtual method for g_datagram_based_send_messages().\n @create_source: Virtual method for g_datagram_based_create_source().\n @condition_check: Virtual method for g_datagram_based_condition_check().\n @condition_wait: Virtual method for\n   g_datagram_based_condition_wait().\n\n Provides an interface for socket-like objects which have datagram semantics,\n following the Berkeley sockets API. The interface methods are thin wrappers\n around the corresponding virtual methods, and no pre-processing of inputs is\n implemented  so implementations of this API must handle all functionality\n documented in the interface methods.\n\n Since: 2.48"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDatagramBasedInterface {
    pub g_iface: GTypeInterface,
    pub receive_messages: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            messages: *mut GInputMessage,
            num_messages: guint,
            flags: gint,
            timeout: gint64,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gint,
    >,
    pub send_messages: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            messages: *mut GOutputMessage,
            num_messages: guint,
            flags: gint,
            timeout: gint64,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gint,
    >,
    pub create_source: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            condition: GIOCondition,
            cancellable: *mut GCancellable,
        ) -> *mut GSource,
    >,
    pub condition_check: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            condition: GIOCondition,
        ) -> GIOCondition,
    >,
    pub condition_wait: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            condition: GIOCondition,
            timeout: gint64,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GDatagramBasedInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDatagramBasedInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDatagramBasedInterface>(),
        56usize,
        concat!("Size of: ", stringify!(_GDatagramBasedInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDatagramBasedInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDatagramBasedInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_messages) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(receive_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_messages) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(send_messages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_source) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(create_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).condition_check) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(condition_check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).condition_wait) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(condition_wait)
        )
    );
}
extern "C" {
    pub fn g_datagram_based_get_type() -> GType;
}
extern "C" {
    pub fn g_datagram_based_receive_messages(
        datagram_based: *mut GDatagramBased,
        messages: *mut GInputMessage,
        num_messages: guint,
        flags: gint,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_datagram_based_send_messages(
        datagram_based: *mut GDatagramBased,
        messages: *mut GOutputMessage,
        num_messages: guint,
        flags: gint,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_datagram_based_create_source(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_datagram_based_condition_check(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
    ) -> GIOCondition;
}
extern "C" {
    pub fn g_datagram_based_condition_wait(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " GDataInputStream:\n\n An implementation of #GBufferedInputStream that allows for high-level\n data manipulation of arbitrary data (including binary operations)."]
pub type GDataInputStreamClass = _GDataInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GDataInputStreamPrivate = _GDataInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataInputStream {
    pub parent_instance: GBufferedInputStream,
    pub priv_: *mut GDataInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GDataInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GDataInputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDataInputStream>(),
        56usize,
        concat!("Size of: ", stringify!(_GDataInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDataInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDataInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataInputStreamClass {
    pub parent_class: GBufferedInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GDataInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDataInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDataInputStreamClass>(),
        376usize,
        concat!("Size of: ", stringify!(_GDataInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDataInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDataInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_data_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_data_input_stream_new(base_stream: *mut GInputStream) -> *mut GDataInputStream;
}
extern "C" {
    pub fn g_data_input_stream_set_byte_order(
        stream: *mut GDataInputStream,
        order: GDataStreamByteOrder,
    );
}
extern "C" {
    pub fn g_data_input_stream_get_byte_order(
        stream: *mut GDataInputStream,
    ) -> GDataStreamByteOrder;
}
extern "C" {
    pub fn g_data_input_stream_set_newline_type(
        stream: *mut GDataInputStream,
        type_: GDataStreamNewlineType,
    );
}
extern "C" {
    pub fn g_data_input_stream_get_newline_type(
        stream: *mut GDataInputStream,
    ) -> GDataStreamNewlineType;
}
extern "C" {
    pub fn g_data_input_stream_read_byte(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guchar;
}
extern "C" {
    pub fn g_data_input_stream_read_int16(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint16;
}
extern "C" {
    pub fn g_data_input_stream_read_uint16(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guint16;
}
extern "C" {
    pub fn g_data_input_stream_read_int32(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint32;
}
extern "C" {
    pub fn g_data_input_stream_read_uint32(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guint32;
}
extern "C" {
    pub fn g_data_input_stream_read_int64(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint64;
}
extern "C" {
    pub fn g_data_input_stream_read_uint64(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guint64;
}
extern "C" {
    pub fn g_data_input_stream_read_line(
        stream: *mut GDataInputStream,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_line_utf8(
        stream: *mut GDataInputStream,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_line_async(
        stream: *mut GDataInputStream,
        io_priority: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_data_input_stream_read_line_finish(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_line_finish_utf8(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_until(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_until_async(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        io_priority: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_data_input_stream_read_until_finish(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_upto(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        stop_chars_len: gssize,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_data_input_stream_read_upto_async(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        stop_chars_len: gssize,
        io_priority: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_data_input_stream_read_upto_finish(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " GDataOutputStream:\n\n An implementation of #GBufferedOutputStream that allows for high-level\n data manipulation of arbitrary data (including binary operations)."]
pub type GDataOutputStream = _GDataOutputStream;
pub type GDataOutputStreamClass = _GDataOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GDataOutputStreamPrivate = _GDataOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GDataOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GDataOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GDataOutputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDataOutputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GDataOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDataOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDataOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GDataOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDataOutputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDataOutputStreamClass>(),
        360usize,
        concat!("Size of: ", stringify!(_GDataOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDataOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDataOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_data_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_data_output_stream_new(base_stream: *mut GOutputStream) -> *mut GDataOutputStream;
}
extern "C" {
    pub fn g_data_output_stream_set_byte_order(
        stream: *mut GDataOutputStream,
        order: GDataStreamByteOrder,
    );
}
extern "C" {
    pub fn g_data_output_stream_get_byte_order(
        stream: *mut GDataOutputStream,
    ) -> GDataStreamByteOrder;
}
extern "C" {
    pub fn g_data_output_stream_put_byte(
        stream: *mut GDataOutputStream,
        data: guchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_int16(
        stream: *mut GDataOutputStream,
        data: gint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_uint16(
        stream: *mut GDataOutputStream,
        data: guint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_int32(
        stream: *mut GDataOutputStream,
        data: gint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_uint32(
        stream: *mut GDataOutputStream,
        data: guint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_int64(
        stream: *mut GDataOutputStream,
        data: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_uint64(
        stream: *mut GDataOutputStream,
        data: guint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_data_output_stream_put_string(
        stream: *mut GDataOutputStream,
        str_: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_action_group_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_action_group_get(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
    ) -> *mut GDBusActionGroup;
}
extern "C" {
    pub fn g_dbus_address_escape_value(string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_is_address(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_is_supported_address(string: *const gchar, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_dbus_address_get_stream(
        address: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_address_get_stream_finish(
        res: *mut GAsyncResult,
        out_guid: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_dbus_address_get_stream_sync(
        address: *const gchar,
        out_guid: *mut *mut gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_dbus_address_get_for_bus_sync(
        bus_type: GBusType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_auth_observer_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_auth_observer_new() -> *mut GDBusAuthObserver;
}
extern "C" {
    pub fn g_dbus_auth_observer_authorize_authenticated_peer(
        observer: *mut GDBusAuthObserver,
        stream: *mut GIOStream,
        credentials: *mut GCredentials,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_auth_observer_allow_mechanism(
        observer: *mut GDBusAuthObserver,
        mechanism: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_bus_get(
        bus_type: GBusType,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_bus_get_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_bus_get_sync(
        bus_type: GBusType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_connection_new(
        stream: *mut GIOStream,
        guid: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_new_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_connection_new_sync(
        stream: *mut GIOStream,
        guid: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_connection_new_for_address(
        address: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_new_for_address_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_connection_new_for_address_sync(
        address: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_connection_start_message_processing(connection: *mut GDBusConnection);
}
extern "C" {
    pub fn g_dbus_connection_is_closed(connection: *mut GDBusConnection) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_get_stream(connection: *mut GDBusConnection) -> *mut GIOStream;
}
extern "C" {
    pub fn g_dbus_connection_get_guid(connection: *mut GDBusConnection) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_connection_get_unique_name(connection: *mut GDBusConnection) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_connection_get_peer_credentials(
        connection: *mut GDBusConnection,
    ) -> *mut GCredentials;
}
extern "C" {
    pub fn g_dbus_connection_get_last_serial(connection: *mut GDBusConnection) -> guint32;
}
extern "C" {
    pub fn g_dbus_connection_get_exit_on_close(connection: *mut GDBusConnection) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_set_exit_on_close(
        connection: *mut GDBusConnection,
        exit_on_close: gboolean,
    );
}
extern "C" {
    pub fn g_dbus_connection_get_capabilities(
        connection: *mut GDBusConnection,
    ) -> GDBusCapabilityFlags;
}
extern "C" {
    pub fn g_dbus_connection_get_flags(connection: *mut GDBusConnection) -> GDBusConnectionFlags;
}
extern "C" {
    pub fn g_dbus_connection_close(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_close_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_close_sync(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_flush(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_flush_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_flush_sync(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_send_message(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        flags: GDBusSendMessageFlags,
        out_serial: *mut guint32,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_send_message_with_reply(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        flags: GDBusSendMessageFlags,
        timeout_msec: gint,
        out_serial: *mut guint32,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_send_message_with_reply_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_connection_send_message_with_reply_sync(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        flags: GDBusSendMessageFlags,
        timeout_msec: gint,
        out_serial: *mut guint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_connection_emit_signal(
        connection: *mut GDBusConnection,
        destination_bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        signal_name: *const gchar,
        parameters: *mut GVariant,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_connection_call(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_call_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_connection_call_sync(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_connection_call_with_unix_fd_list(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_connection_call_with_unix_fd_list_finish(
        connection: *mut GDBusConnection,
        out_fd_list: *mut *mut GUnixFDList,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_connection_call_with_unix_fd_list_sync(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        out_fd_list: *mut *mut GUnixFDList,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
#[doc = " GDBusInterfaceMethodCallFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that the method was invoked on.\n @interface_name: The D-Bus interface name the method was invoked on.\n @method_name: The name of the method that was invoked.\n @parameters: A #GVariant tuple with parameters.\n @invocation: (transfer full): A #GDBusMethodInvocation object that must be used to return a value or error.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().\n\n The type of the @method_call function in #GDBusInterfaceVTable.\n\n Since: 2.26"]
pub type GDBusInterfaceMethodCallFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        invocation: *mut GDBusMethodInvocation,
        user_data: gpointer,
    ),
>;
#[doc = " GDBusInterfaceGetPropertyFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that the method was invoked on.\n @interface_name: The D-Bus interface name for the property.\n @property_name: The name of the property to get the value of.\n @error: Return location for error.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().\n\n The type of the @get_property function in #GDBusInterfaceVTable.\n\n Returns: A #GVariant with the value for @property_name or %NULL if\n     @error is set. If the returned #GVariant is floating, it is\n     consumed - otherwise its reference count is decreased by one.\n\n Since: 2.26"]
pub type GDBusInterfaceGetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        property_name: *const gchar,
        error: *mut *mut GError,
        user_data: gpointer,
    ) -> *mut GVariant,
>;
#[doc = " GDBusInterfaceSetPropertyFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that the method was invoked on.\n @interface_name: The D-Bus interface name for the property.\n @property_name: The name of the property to get the value of.\n @value: The value to set the property to.\n @error: Return location for error.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().\n\n The type of the @set_property function in #GDBusInterfaceVTable.\n\n Returns: %TRUE if the property was set to @value, %FALSE if @error is set.\n\n Since: 2.26"]
pub type GDBusInterfaceSetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        property_name: *const gchar,
        value: *mut GVariant,
        error: *mut *mut GError,
        user_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GDBusInterfaceVTable:\n @method_call: Function for handling incoming method calls.\n @get_property: Function for getting a property.\n @set_property: Function for setting a property.\n\n Virtual table for handling properties and method calls for a D-Bus\n interface.\n\n Since 2.38, if you want to handle getting/setting D-Bus properties\n asynchronously, give %NULL as your get_property() or set_property()\n function. The D-Bus call will be directed to your @method_call function,\n with the provided @interface_name set to \"org.freedesktop.DBus.Properties\".\n\n Ownership of the #GDBusMethodInvocation object passed to the\n method_call() function is transferred to your handler; you must\n call one of the methods of #GDBusMethodInvocation to return a reply\n (possibly empty), or an error. These functions also take ownership\n of the passed-in invocation object, so unless the invocation\n object has otherwise been referenced, it will be then be freed.\n Calling one of these functions may be done within your\n method_call() implementation but it also can be done at a later\n point to handle the method asynchronously.\n\n The usual checks on the validity of the calls is performed. For\n `Get` calls, an error is automatically returned if the property does\n not exist or the permissions do not allow access. The same checks are\n performed for `Set` calls, and the provided value is also checked for\n being the correct type.\n\n For both `Get` and `Set` calls, the #GDBusMethodInvocation\n passed to the @method_call handler can be queried with\n g_dbus_method_invocation_get_property_info() to get a pointer\n to the #GDBusPropertyInfo of the property.\n\n If you have readable properties specified in your interface info,\n you must ensure that you either provide a non-%NULL @get_property()\n function or provide implementations of both the `Get` and `GetAll`\n methods on org.freedesktop.DBus.Properties interface in your @method_call\n function. Note that the required return type of the `Get` call is\n `(v)`, not the type of the property. `GetAll` expects a return value\n of type `a{sv}`.\n\n If you have writable properties specified in your interface info,\n you must ensure that you either provide a non-%NULL @set_property()\n function or provide an implementation of the `Set` call. If implementing\n the call, you must return the value of type %G_VARIANT_TYPE_UNIT.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceVTable {
    pub method_call: GDBusInterfaceMethodCallFunc,
    pub get_property: GDBusInterfaceGetPropertyFunc,
    pub set_property: GDBusInterfaceSetPropertyFunc,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusInterfaceVTable() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusInterfaceVTable> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceVTable>(),
        88usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceVTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method_call) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceVTable),
            "::",
            stringify!(method_call)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceVTable),
            "::",
            stringify!(get_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_property) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceVTable),
            "::",
            stringify!(set_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceVTable),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_connection_register_object(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        interface_info: *mut GDBusInterfaceInfo,
        vtable: *const GDBusInterfaceVTable,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_register_object_with_closures(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        interface_info: *mut GDBusInterfaceInfo,
        method_call_closure: *mut GClosure,
        get_property_closure: *mut GClosure,
        set_property_closure: *mut GClosure,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_unregister_object(
        connection: *mut GDBusConnection,
        registration_id: guint,
    ) -> gboolean;
}
#[doc = " GDBusSubtreeEnumerateFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that was registered with g_dbus_connection_register_subtree().\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().\n\n The type of the @enumerate function in #GDBusSubtreeVTable.\n\n This function is called when generating introspection data and also\n when preparing to dispatch incoming messages in the event that the\n %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not\n specified (ie: to verify that the object path is valid).\n\n Hierarchies are not supported; the items that you return should not\n contain the `/` character.\n\n The return value will be freed with g_strfreev().\n\n Returns: (array zero-terminated=1) (transfer full): A newly allocated array of strings for node names that are children of @object_path.\n\n Since: 2.26"]
pub type GDBusSubtreeEnumerateFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        user_data: gpointer,
    ) -> *mut *mut gchar,
>;
#[doc = " GDBusSubtreeIntrospectFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that was registered with g_dbus_connection_register_subtree().\n @node: A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().\n\n The type of the @introspect function in #GDBusSubtreeVTable.\n\n Subtrees are flat.  @node, if non-%NULL, is always exactly one\n segment of the object path (ie: it never contains a slash).\n\n This function should return %NULL to indicate that there is no object\n at this node.\n\n If this function returns non-%NULL, the return value is expected to\n be a %NULL-terminated array of pointers to #GDBusInterfaceInfo\n structures describing the interfaces implemented by @node.  This\n array will have g_dbus_interface_info_unref() called on each item\n before being freed with g_free().\n\n The difference between returning %NULL and an array containing zero\n items is that the standard DBus interfaces will returned to the\n remote introspector in the empty array case, but not in the %NULL\n case.\n\n Returns: (array zero-terminated=1) (nullable) (transfer full): A %NULL-terminated array of pointers to #GDBusInterfaceInfo, or %NULL.\n\n Since: 2.26"]
pub type GDBusSubtreeIntrospectFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        node: *const gchar,
        user_data: gpointer,
    ) -> *mut *mut GDBusInterfaceInfo,
>;
#[doc = " GDBusSubtreeDispatchFunc:\n @connection: A #GDBusConnection.\n @sender: The unique bus name of the remote caller.\n @object_path: The object path that was registered with g_dbus_connection_register_subtree().\n @interface_name: The D-Bus interface name that the method call or property access is for.\n @node: A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.\n @out_user_data: (nullable) (not optional): Return location for user data to pass to functions in the returned #GDBusInterfaceVTable.\n @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().\n\n The type of the @dispatch function in #GDBusSubtreeVTable.\n\n Subtrees are flat.  @node, if non-%NULL, is always exactly one\n segment of the object path (ie: it never contains a slash).\n\n Returns: (nullable): A #GDBusInterfaceVTable or %NULL if you don't want to handle the methods.\n\n Since: 2.26"]
pub type GDBusSubtreeDispatchFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        node: *const gchar,
        out_user_data: *mut gpointer,
        user_data: gpointer,
    ) -> *const GDBusInterfaceVTable,
>;
#[doc = " GDBusSubtreeVTable:\n @enumerate: Function for enumerating child nodes.\n @introspect: Function for introspecting a child node.\n @dispatch: Function for dispatching a remote call on a child node.\n\n Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusSubtreeVTable {
    pub enumerate: GDBusSubtreeEnumerateFunc,
    pub introspect: GDBusSubtreeIntrospectFunc,
    pub dispatch: GDBusSubtreeDispatchFunc,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusSubtreeVTable() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusSubtreeVTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusSubtreeVTable>(),
        88usize,
        concat!("Size of: ", stringify!(_GDBusSubtreeVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusSubtreeVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusSubtreeVTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSubtreeVTable),
            "::",
            stringify!(enumerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).introspect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSubtreeVTable),
            "::",
            stringify!(introspect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dispatch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSubtreeVTable),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSubtreeVTable),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_connection_register_subtree(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        vtable: *const GDBusSubtreeVTable,
        flags: GDBusSubtreeFlags,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_unregister_subtree(
        connection: *mut GDBusConnection,
        registration_id: guint,
    ) -> gboolean;
}
#[doc = " GDBusSignalCallback:\n @connection: A #GDBusConnection.\n @sender_name: (nullable): The unique bus name of the sender of the signal,\nor %NULL on a peer-to-peer D-Bus connection.\n @object_path: The object path that the signal was emitted on.\n @interface_name: The name of the interface.\n @signal_name: The name of the signal.\n @parameters: A #GVariant tuple with parameters for the signal.\n @user_data: User data passed when subscribing to the signal.\n\n Signature for callback function used in g_dbus_connection_signal_subscribe().\n\n Since: 2.26"]
pub type GDBusSignalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        signal_name: *const gchar,
        parameters: *mut GVariant,
        user_data: gpointer,
    ),
>;
extern "C" {
    pub fn g_dbus_connection_signal_subscribe(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        interface_name: *const gchar,
        member: *const gchar,
        object_path: *const gchar,
        arg0: *const gchar,
        flags: GDBusSignalFlags,
        callback: GDBusSignalCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_signal_unsubscribe(
        connection: *mut GDBusConnection,
        subscription_id: guint,
    );
}
#[doc = " GDBusMessageFilterFunction:\n @connection: (transfer none): A #GDBusConnection.\n @message: (transfer full): A locked #GDBusMessage that the filter function takes ownership of.\n @incoming: %TRUE if it is a message received from the other peer, %FALSE if it is\n a message to be sent to the other peer.\n @user_data: User data passed when adding the filter.\n\n Signature for function used in g_dbus_connection_add_filter().\n\n A filter function is passed a #GDBusMessage and expected to return\n a #GDBusMessage too. Passive filter functions that don't modify the\n message can simply return the @message object:\n |[\n static GDBusMessage *\n passive_filter (GDBusConnection *connection\n                 GDBusMessage    *message,\n                 gboolean         incoming,\n                 gpointer         user_data)\n {\n   // inspect @message\n   return message;\n }\n ]|\n Filter functions that wants to drop a message can simply return %NULL:\n |[\n static GDBusMessage *\n drop_filter (GDBusConnection *connection\n              GDBusMessage    *message,\n              gboolean         incoming,\n              gpointer         user_data)\n {\n   if (should_drop_message)\n     {\n       g_object_unref (message);\n       message = NULL;\n     }\n   return message;\n }\n ]|\n Finally, a filter function may modify a message by copying it:\n |[\n static GDBusMessage *\n modifying_filter (GDBusConnection *connection\n                   GDBusMessage    *message,\n                   gboolean         incoming,\n                   gpointer         user_data)\n {\n   GDBusMessage *copy;\n   GError *error;\n\n   error = NULL;\n   copy = g_dbus_message_copy (message, &error);\n   // handle @error being set\n   g_object_unref (message);\n\n   // modify @copy\n\n   return copy;\n }\n ]|\n If the returned #GDBusMessage is different from @message and cannot\n be sent on @connection (it could use features, such as file\n descriptors, not compatible with @connection), then a warning is\n logged to standard error. Applications can\n check this ahead of time using g_dbus_message_to_blob() passing a\n #GDBusCapabilityFlags value obtained from @connection.\n\n Returns: (transfer full) (nullable): A #GDBusMessage that will be freed with\n g_object_unref() or %NULL to drop the message. Passive filter\n functions can simply return the passed @message object.\n\n Since: 2.26"]
pub type GDBusMessageFilterFunction = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        incoming: gboolean,
        user_data: gpointer,
    ) -> *mut GDBusMessage,
>;
extern "C" {
    pub fn g_dbus_connection_add_filter(
        connection: *mut GDBusConnection,
        filter_function: GDBusMessageFilterFunction,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_remove_filter(connection: *mut GDBusConnection, filter_id: guint);
}
extern "C" {
    pub fn g_dbus_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_dbus_error_is_remote_error(error: *const GError) -> gboolean;
}
extern "C" {
    pub fn g_dbus_error_get_remote_error(error: *const GError) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_error_strip_remote_error(error: *mut GError) -> gboolean;
}
#[doc = " GDBusErrorEntry:\n @error_code: An error code.\n @dbus_error_name: The D-Bus error name to associate with @error_code.\n\n Struct used in g_dbus_error_register_error_domain().\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusErrorEntry {
    pub error_code: gint,
    pub dbus_error_name: *const gchar,
}
#[test]
fn bindgen_test_layout__GDBusErrorEntry() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusErrorEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusErrorEntry>(),
        16usize,
        concat!("Size of: ", stringify!(_GDBusErrorEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusErrorEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusErrorEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusErrorEntry),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dbus_error_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusErrorEntry),
            "::",
            stringify!(dbus_error_name)
        )
    );
}
extern "C" {
    pub fn g_dbus_error_register_error(
        error_domain: GQuark,
        error_code: gint,
        dbus_error_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_error_unregister_error(
        error_domain: GQuark,
        error_code: gint,
        dbus_error_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_error_register_error_domain(
        error_domain_quark_name: *const gchar,
        quark_volatile: *mut gsize,
        entries: *const GDBusErrorEntry,
        num_entries: guint,
    );
}
extern "C" {
    pub fn g_dbus_error_new_for_dbus_error(
        dbus_error_name: *const gchar,
        dbus_error_message: *const gchar,
    ) -> *mut GError;
}
extern "C" {
    pub fn g_dbus_error_set_dbus_error(
        error: *mut *mut GError,
        dbus_error_name: *const gchar,
        dbus_error_message: *const gchar,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_dbus_error_set_dbus_error_valist(
        error: *mut *mut GError,
        dbus_error_name: *const gchar,
        dbus_error_message: *const gchar,
        format: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn g_dbus_error_encode_gerror(error: *const GError) -> *mut gchar;
}
#[doc = " GDBusInterface:\n\n Base type for D-Bus interfaces.\n\n Since: 2.30"]
pub type GDBusInterfaceIface = _GDBusInterfaceIface;
#[doc = " GDBusInterfaceIface:\n @parent_iface: The parent interface.\n @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_get_info().\n @get_object: Gets the enclosing #GDBusObject. See g_dbus_interface_get_object().\n @set_object: Sets the enclosing #GDBusObject. See g_dbus_interface_set_object().\n @dup_object: Gets a reference to the enclosing #GDBusObject. See g_dbus_interface_dup_object(). Added in 2.32.\n\n Base type for D-Bus interfaces.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceIface {
    pub parent_iface: GTypeInterface,
    pub get_info: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface) -> *mut GDBusInterfaceInfo,
    >,
    pub get_object: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface) -> *mut GDBusObject,
    >,
    pub set_object: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface, object: *mut GDBusObject),
    >,
    pub dup_object: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface) -> *mut GDBusObject,
    >,
}
#[test]
fn bindgen_test_layout__GDBusInterfaceIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusInterfaceIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceIface>(),
        48usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(parent_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_info) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(get_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_object) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(get_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_object) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(set_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dup_object) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(dup_object)
        )
    );
}
extern "C" {
    pub fn g_dbus_interface_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_interface_get_info(interface_: *mut GDBusInterface) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    pub fn g_dbus_interface_get_object(interface_: *mut GDBusInterface) -> *mut GDBusObject;
}
extern "C" {
    pub fn g_dbus_interface_set_object(interface_: *mut GDBusInterface, object: *mut GDBusObject);
}
extern "C" {
    pub fn g_dbus_interface_dup_object(interface_: *mut GDBusInterface) -> *mut GDBusObject;
}
#[doc = " GDBusInterfaceSkeletonClass:\n @parent_class: The parent class.\n @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_skeleton_get_info() for details.\n @get_vtable: Returns a #GDBusInterfaceVTable. See g_dbus_interface_skeleton_get_vtable() for details.\n @get_properties: Returns a #GVariant with all properties. See g_dbus_interface_skeleton_get_properties().\n @flush: Emits outstanding changes, if any. See g_dbus_interface_skeleton_flush().\n @g_authorize_method: Signal class handler for the #GDBusInterfaceSkeleton::g-authorize-method signal.\n\n Class structure for #GDBusInterfaceSkeleton.\n\n Since: 2.30"]
pub type GDBusInterfaceSkeletonClass = _GDBusInterfaceSkeletonClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceSkeletonPrivate {
    _unused: [u8; 0],
}
pub type GDBusInterfaceSkeletonPrivate = _GDBusInterfaceSkeletonPrivate;
#[doc = " GDBusInterfaceSkeleton:\n\n The #GDBusInterfaceSkeleton structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceSkeleton {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusInterfaceSkeletonPrivate,
}
#[test]
fn bindgen_test_layout__GDBusInterfaceSkeleton() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusInterfaceSkeleton> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceSkeleton>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceSkeleton))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceSkeleton>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceSkeleton))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeleton),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeleton),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GDBusInterfaceSkeletonClass:\n @parent_class: The parent class.\n @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_skeleton_get_info() for details.\n @get_vtable: Returns a #GDBusInterfaceVTable. See g_dbus_interface_skeleton_get_vtable() for details.\n @get_properties: Returns a #GVariant with all properties. See g_dbus_interface_skeleton_get_properties().\n @flush: Emits outstanding changes, if any. See g_dbus_interface_skeleton_flush().\n @g_authorize_method: Signal class handler for the #GDBusInterfaceSkeleton::g-authorize-method signal.\n\n Class structure for #GDBusInterfaceSkeleton.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceSkeletonClass {
    pub parent_class: GObjectClass,
    pub get_info: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceInfo,
    >,
    pub get_vtable: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceVTable,
    >,
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton) -> *mut GVariant,
    >,
    pub flush: ::std::option::Option<unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton)>,
    pub vfunc_padding: [gpointer; 8usize],
    pub g_authorize_method: ::std::option::Option<
        unsafe extern "C" fn(
            interface_: *mut GDBusInterfaceSkeleton,
            invocation: *mut GDBusMethodInvocation,
        ) -> gboolean,
    >,
    pub signal_padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusInterfaceSkeletonClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusInterfaceSkeletonClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceSkeletonClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceSkeletonClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceSkeletonClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceSkeletonClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_info) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(get_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_vtable) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(get_vtable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_properties) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(get_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vfunc_padding) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(vfunc_padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_authorize_method) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(g_authorize_method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal_padding) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(signal_padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_flags(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> GDBusInterfaceSkeletonFlags;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_set_flags(
        interface_: *mut GDBusInterfaceSkeleton,
        flags: GDBusInterfaceSkeletonFlags,
    );
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_info(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_vtable(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GDBusInterfaceVTable;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_properties(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_flush(interface_: *mut GDBusInterfaceSkeleton);
}
extern "C" {
    pub fn g_dbus_interface_skeleton_export(
        interface_: *mut GDBusInterfaceSkeleton,
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_unexport(interface_: *mut GDBusInterfaceSkeleton);
}
extern "C" {
    pub fn g_dbus_interface_skeleton_unexport_from_connection(
        interface_: *mut GDBusInterfaceSkeleton,
        connection: *mut GDBusConnection,
    );
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_connection(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_connections(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_has_connection(
        interface_: *mut GDBusInterfaceSkeleton,
        connection: *mut GDBusConnection,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_get_object_path(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *const gchar;
}
#[doc = " GDBusAnnotationInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @key: The name of the annotation, e.g. \"org.freedesktop.DBus.Deprecated\".\n @value: The value of the annotation.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about an annotation.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusAnnotationInfo {
    pub ref_count: gint,
    pub key: *mut gchar,
    pub value: *mut gchar,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusAnnotationInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusAnnotationInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusAnnotationInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusAnnotationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusAnnotationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusAnnotationInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusAnnotationInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusAnnotationInfo),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusAnnotationInfo),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusAnnotationInfo),
            "::",
            stringify!(annotations)
        )
    );
}
#[doc = " GDBusArgInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: Name of the argument, e.g. @unix_user_id.\n @signature: D-Bus signature of the argument (a single complete type).\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about an argument for a method or a signal.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusArgInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub signature: *mut gchar,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusArgInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusArgInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusArgInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusArgInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusArgInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusArgInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusArgInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusArgInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusArgInfo),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusArgInfo),
            "::",
            stringify!(annotations)
        )
    );
}
#[doc = " GDBusMethodInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus method, e.g. @RequestName.\n @in_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments.\n @out_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a method on an D-Bus interface.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMethodInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub in_args: *mut *mut GDBusArgInfo,
    pub out_args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusMethodInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusMethodInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusMethodInfo>(),
        40usize,
        concat!("Size of: ", stringify!(_GDBusMethodInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusMethodInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusMethodInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).in_args) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(in_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_args) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(out_args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(annotations)
        )
    );
}
#[doc = " GDBusSignalInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus signal, e.g. \"NameOwnerChanged\".\n @args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no arguments.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a signal on a D-Bus interface.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusSignalInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusSignalInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusSignalInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusSignalInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusSignalInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusSignalInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusSignalInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSignalInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSignalInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSignalInfo),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSignalInfo),
            "::",
            stringify!(annotations)
        )
    );
}
#[doc = " GDBusPropertyInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus property, e.g. \"SupportedFilesystems\".\n @signature: The D-Bus signature of the property (a single complete type).\n @flags: Access control flags for the property.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a D-Bus property on a D-Bus interface.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusPropertyInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub signature: *mut gchar,
    pub flags: GDBusPropertyInfoFlags,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusPropertyInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusPropertyInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusPropertyInfo>(),
        40usize,
        concat!("Size of: ", stringify!(_GDBusPropertyInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusPropertyInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusPropertyInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(annotations)
        )
    );
}
#[doc = " GDBusInterfaceInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @name: The name of the D-Bus interface, e.g. \"org.freedesktop.DBus.Properties\".\n @methods: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.\n @signals: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals.\n @properties: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about a D-Bus interface.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub methods: *mut *mut GDBusMethodInfo,
    pub signals: *mut *mut GDBusSignalInfo,
    pub properties: *mut *mut GDBusPropertyInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusInterfaceInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusInterfaceInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceInfo>(),
        48usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).methods) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(methods)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signals) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(signals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(annotations)
        )
    );
}
#[doc = " GDBusNodeInfo:\n @ref_count: The reference count or -1 if statically allocated.\n @path: The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.\n @interfaces: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.\n @nodes: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes.\n @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.\n\n Information about nodes in a remote object hierarchy.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusNodeInfo {
    pub ref_count: gint,
    pub path: *mut gchar,
    pub interfaces: *mut *mut GDBusInterfaceInfo,
    pub nodes: *mut *mut GDBusNodeInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusNodeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusNodeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusNodeInfo>(),
        40usize,
        concat!("Size of: ", stringify!(_GDBusNodeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusNodeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusNodeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interfaces) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(interfaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nodes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(nodes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).annotations) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(annotations)
        )
    );
}
extern "C" {
    pub fn g_dbus_annotation_info_lookup(
        annotations: *mut *mut GDBusAnnotationInfo,
        name: *const gchar,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_interface_info_lookup_method(
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
    ) -> *mut GDBusMethodInfo;
}
extern "C" {
    pub fn g_dbus_interface_info_lookup_signal(
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
    ) -> *mut GDBusSignalInfo;
}
extern "C" {
    pub fn g_dbus_interface_info_lookup_property(
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
    ) -> *mut GDBusPropertyInfo;
}
extern "C" {
    pub fn g_dbus_interface_info_cache_build(info: *mut GDBusInterfaceInfo);
}
extern "C" {
    pub fn g_dbus_interface_info_cache_release(info: *mut GDBusInterfaceInfo);
}
extern "C" {
    pub fn g_dbus_interface_info_generate_xml(
        info: *mut GDBusInterfaceInfo,
        indent: guint,
        string_builder: *mut GString,
    );
}
extern "C" {
    pub fn g_dbus_node_info_new_for_xml(
        xml_data: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GDBusNodeInfo;
}
extern "C" {
    pub fn g_dbus_node_info_lookup_interface(
        info: *mut GDBusNodeInfo,
        name: *const gchar,
    ) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    pub fn g_dbus_node_info_generate_xml(
        info: *mut GDBusNodeInfo,
        indent: guint,
        string_builder: *mut GString,
    );
}
extern "C" {
    pub fn g_dbus_node_info_ref(info: *mut GDBusNodeInfo) -> *mut GDBusNodeInfo;
}
extern "C" {
    pub fn g_dbus_interface_info_ref(info: *mut GDBusInterfaceInfo) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    pub fn g_dbus_method_info_ref(info: *mut GDBusMethodInfo) -> *mut GDBusMethodInfo;
}
extern "C" {
    pub fn g_dbus_signal_info_ref(info: *mut GDBusSignalInfo) -> *mut GDBusSignalInfo;
}
extern "C" {
    pub fn g_dbus_property_info_ref(info: *mut GDBusPropertyInfo) -> *mut GDBusPropertyInfo;
}
extern "C" {
    pub fn g_dbus_arg_info_ref(info: *mut GDBusArgInfo) -> *mut GDBusArgInfo;
}
extern "C" {
    pub fn g_dbus_annotation_info_ref(info: *mut GDBusAnnotationInfo) -> *mut GDBusAnnotationInfo;
}
extern "C" {
    pub fn g_dbus_node_info_unref(info: *mut GDBusNodeInfo);
}
extern "C" {
    pub fn g_dbus_interface_info_unref(info: *mut GDBusInterfaceInfo);
}
extern "C" {
    pub fn g_dbus_method_info_unref(info: *mut GDBusMethodInfo);
}
extern "C" {
    pub fn g_dbus_signal_info_unref(info: *mut GDBusSignalInfo);
}
extern "C" {
    pub fn g_dbus_property_info_unref(info: *mut GDBusPropertyInfo);
}
extern "C" {
    pub fn g_dbus_arg_info_unref(info: *mut GDBusArgInfo);
}
extern "C" {
    pub fn g_dbus_annotation_info_unref(info: *mut GDBusAnnotationInfo);
}
extern "C" {
    pub fn g_dbus_node_info_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_interface_info_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_method_info_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_signal_info_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_property_info_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_arg_info_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_annotation_info_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMenuModel {
    _unused: [u8; 0],
}
pub type GDBusMenuModel = _GDBusMenuModel;
extern "C" {
    pub fn g_dbus_menu_model_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_menu_model_get(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
    ) -> *mut GDBusMenuModel;
}
extern "C" {
    pub fn g_dbus_message_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_message_new() -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_new_signal(
        path: *const gchar,
        interface_: *const gchar,
        signal: *const gchar,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_new_method_call(
        name: *const gchar,
        path: *const gchar,
        interface_: *const gchar,
        method: *const gchar,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_new_method_reply(
        method_call_message: *mut GDBusMessage,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_new_method_error(
        method_call_message: *mut GDBusMessage,
        error_name: *const gchar,
        error_message_format: *const gchar,
        ...
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_new_method_error_valist(
        method_call_message: *mut GDBusMessage,
        error_name: *const gchar,
        error_message_format: *const gchar,
        var_args: *mut __va_list_tag,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_new_method_error_literal(
        method_call_message: *mut GDBusMessage,
        error_name: *const gchar,
        error_message: *const gchar,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_print(message: *mut GDBusMessage, indent: guint) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_message_get_locked(message: *mut GDBusMessage) -> gboolean;
}
extern "C" {
    pub fn g_dbus_message_lock(message: *mut GDBusMessage);
}
extern "C" {
    pub fn g_dbus_message_copy(
        message: *mut GDBusMessage,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_get_byte_order(message: *mut GDBusMessage) -> GDBusMessageByteOrder;
}
extern "C" {
    pub fn g_dbus_message_set_byte_order(
        message: *mut GDBusMessage,
        byte_order: GDBusMessageByteOrder,
    );
}
extern "C" {
    pub fn g_dbus_message_get_message_type(message: *mut GDBusMessage) -> GDBusMessageType;
}
extern "C" {
    pub fn g_dbus_message_set_message_type(message: *mut GDBusMessage, type_: GDBusMessageType);
}
extern "C" {
    pub fn g_dbus_message_get_flags(message: *mut GDBusMessage) -> GDBusMessageFlags;
}
extern "C" {
    pub fn g_dbus_message_set_flags(message: *mut GDBusMessage, flags: GDBusMessageFlags);
}
extern "C" {
    pub fn g_dbus_message_get_serial(message: *mut GDBusMessage) -> guint32;
}
extern "C" {
    pub fn g_dbus_message_set_serial(message: *mut GDBusMessage, serial: guint32);
}
extern "C" {
    pub fn g_dbus_message_get_header(
        message: *mut GDBusMessage,
        header_field: GDBusMessageHeaderField,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_message_set_header(
        message: *mut GDBusMessage,
        header_field: GDBusMessageHeaderField,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_dbus_message_get_header_fields(message: *mut GDBusMessage) -> *mut guchar;
}
extern "C" {
    pub fn g_dbus_message_get_body(message: *mut GDBusMessage) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_message_set_body(message: *mut GDBusMessage, body: *mut GVariant);
}
extern "C" {
    pub fn g_dbus_message_get_unix_fd_list(message: *mut GDBusMessage) -> *mut GUnixFDList;
}
extern "C" {
    pub fn g_dbus_message_set_unix_fd_list(message: *mut GDBusMessage, fd_list: *mut GUnixFDList);
}
extern "C" {
    pub fn g_dbus_message_get_reply_serial(message: *mut GDBusMessage) -> guint32;
}
extern "C" {
    pub fn g_dbus_message_set_reply_serial(message: *mut GDBusMessage, value: guint32);
}
extern "C" {
    pub fn g_dbus_message_get_interface(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_interface(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_member(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_member(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_path(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_path(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_sender(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_sender(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_destination(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_destination(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_error_name(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_error_name(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_signature(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_set_signature(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    pub fn g_dbus_message_get_num_unix_fds(message: *mut GDBusMessage) -> guint32;
}
extern "C" {
    pub fn g_dbus_message_set_num_unix_fds(message: *mut GDBusMessage, value: guint32);
}
extern "C" {
    pub fn g_dbus_message_get_arg0(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_message_new_from_blob(
        blob: *mut guchar,
        blob_len: gsize,
        capabilities: GDBusCapabilityFlags,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_message_bytes_needed(
        blob: *mut guchar,
        blob_len: gsize,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_dbus_message_to_blob(
        message: *mut GDBusMessage,
        out_size: *mut gsize,
        capabilities: GDBusCapabilityFlags,
        error: *mut *mut GError,
    ) -> *mut guchar;
}
extern "C" {
    pub fn g_dbus_message_to_gerror(
        message: *mut GDBusMessage,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_sender(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_object_path(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_interface_name(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_method_name(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_method_info(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const GDBusMethodInfo;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_property_info(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const GDBusPropertyInfo;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_connection(
        invocation: *mut GDBusMethodInvocation,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_message(
        invocation: *mut GDBusMethodInvocation,
    ) -> *mut GDBusMessage;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_parameters(
        invocation: *mut GDBusMethodInvocation,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_method_invocation_get_user_data(
        invocation: *mut GDBusMethodInvocation,
    ) -> gpointer;
}
extern "C" {
    pub fn g_dbus_method_invocation_return_value(
        invocation: *mut GDBusMethodInvocation,
        parameters: *mut GVariant,
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_return_value_with_unix_fd_list(
        invocation: *mut GDBusMethodInvocation,
        parameters: *mut GVariant,
        fd_list: *mut GUnixFDList,
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_return_error(
        invocation: *mut GDBusMethodInvocation,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_return_error_valist(
        invocation: *mut GDBusMethodInvocation,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_return_error_literal(
        invocation: *mut GDBusMethodInvocation,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_return_gerror(
        invocation: *mut GDBusMethodInvocation,
        error: *const GError,
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_take_error(
        invocation: *mut GDBusMethodInvocation,
        error: *mut GError,
    );
}
extern "C" {
    pub fn g_dbus_method_invocation_return_dbus_error(
        invocation: *mut GDBusMethodInvocation,
        error_name: *const gchar,
        error_message: *const gchar,
    );
}
#[doc = " GBusAcquiredCallback:\n @connection: The #GDBusConnection to a message bus.\n @name: The name that is requested to be owned.\n @user_data: User data passed to g_bus_own_name().\n\n Invoked when a connection to a message bus has been obtained.\n\n Since: 2.26"]
pub type GBusAcquiredCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
#[doc = " GBusNameAcquiredCallback:\n @connection: The #GDBusConnection on which to acquired the name.\n @name: The name being owned.\n @user_data: User data passed to g_bus_own_name() or g_bus_own_name_on_connection().\n\n Invoked when the name is acquired.\n\n Since: 2.26"]
pub type GBusNameAcquiredCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
#[doc = " GBusNameLostCallback:\n @connection: The #GDBusConnection on which to acquire the name or %NULL if\n the connection was disconnected.\n @name: The name being owned.\n @user_data: User data passed to g_bus_own_name() or g_bus_own_name_on_connection().\n\n Invoked when the name is lost or @connection has been closed.\n\n Since: 2.26"]
pub type GBusNameLostCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
extern "C" {
    pub fn g_bus_own_name(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        bus_acquired_handler: GBusAcquiredCallback,
        name_acquired_handler: GBusNameAcquiredCallback,
        name_lost_handler: GBusNameLostCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_own_name_on_connection(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        name_acquired_handler: GBusNameAcquiredCallback,
        name_lost_handler: GBusNameLostCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_own_name_with_closures(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        bus_acquired_closure: *mut GClosure,
        name_acquired_closure: *mut GClosure,
        name_lost_closure: *mut GClosure,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_own_name_on_connection_with_closures(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        name_acquired_closure: *mut GClosure,
        name_lost_closure: *mut GClosure,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_unown_name(owner_id: guint);
}
#[doc = " GBusNameAppearedCallback:\n @connection: The #GDBusConnection the name is being watched on.\n @name: The name being watched.\n @name_owner: Unique name of the owner of the name being watched.\n @user_data: User data passed to g_bus_watch_name().\n\n Invoked when the name being watched is known to have to have an owner.\n\n Since: 2.26"]
pub type GBusNameAppearedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        name: *const gchar,
        name_owner: *const gchar,
        user_data: gpointer,
    ),
>;
#[doc = " GBusNameVanishedCallback:\n @connection: The #GDBusConnection the name is being watched on, or\n     %NULL.\n @name: The name being watched.\n @user_data: User data passed to g_bus_watch_name().\n\n Invoked when the name being watched is known not to have to have an owner.\n\n This is also invoked when the #GDBusConnection on which the watch was\n established has been closed.  In that case, @connection will be\n %NULL.\n\n Since: 2.26"]
pub type GBusNameVanishedCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
extern "C" {
    pub fn g_bus_watch_name(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_handler: GBusNameAppearedCallback,
        name_vanished_handler: GBusNameVanishedCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_watch_name_on_connection(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_handler: GBusNameAppearedCallback,
        name_vanished_handler: GBusNameVanishedCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_watch_name_with_closures(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_closure: *mut GClosure,
        name_vanished_closure: *mut GClosure,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_watch_name_on_connection_with_closures(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_closure: *mut GClosure,
        name_vanished_closure: *mut GClosure,
    ) -> guint;
}
extern "C" {
    pub fn g_bus_unwatch_name(watcher_id: guint);
}
#[doc = " GDBusObjectIface:\n @parent_iface: The parent interface.\n @get_object_path: Returns the object path. See g_dbus_object_get_object_path().\n @get_interfaces: Returns all interfaces. See g_dbus_object_get_interfaces().\n @get_interface: Returns an interface by name. See g_dbus_object_get_interface().\n @interface_added: Signal handler for the #GDBusObject::interface-added signal.\n @interface_removed: Signal handler for the #GDBusObject::interface-removed signal.\n\n Base object type for D-Bus objects.\n\n Since: 2.30"]
pub type GDBusObjectIface = _GDBusObjectIface;
#[doc = " GDBusObjectIface:\n @parent_iface: The parent interface.\n @get_object_path: Returns the object path. See g_dbus_object_get_object_path().\n @get_interfaces: Returns all interfaces. See g_dbus_object_get_interfaces().\n @get_interface: Returns an interface by name. See g_dbus_object_get_interface().\n @interface_added: Signal handler for the #GDBusObject::interface-added signal.\n @interface_removed: Signal handler for the #GDBusObject::interface-removed signal.\n\n Base object type for D-Bus objects.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectIface {
    pub parent_iface: GTypeInterface,
    pub get_object_path:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GDBusObject) -> *const gchar>,
    pub get_interfaces:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GDBusObject) -> *mut GList>,
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GDBusObject,
            interface_name: *const gchar,
        ) -> *mut GDBusInterface,
    >,
    pub interface_added: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GDBusObject, interface_: *mut GDBusInterface),
    >,
    pub interface_removed: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GDBusObject, interface_: *mut GDBusInterface),
    >,
}
#[test]
fn bindgen_test_layout__GDBusObjectIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectIface>(),
        56usize,
        concat!("Size of: ", stringify!(_GDBusObjectIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(parent_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_object_path) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(get_object_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_interfaces) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(get_interfaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_interface) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(get_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_added) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(interface_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_removed) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(interface_removed)
        )
    );
}
extern "C" {
    pub fn g_dbus_object_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_get_object_path(object: *mut GDBusObject) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_object_get_interfaces(object: *mut GDBusObject) -> *mut GList;
}
extern "C" {
    pub fn g_dbus_object_get_interface(
        object: *mut GDBusObject,
        interface_name: *const gchar,
    ) -> *mut GDBusInterface;
}
#[doc = " GDBusObjectManagerIface:\n @parent_iface: The parent interface.\n @get_object_path: Virtual function for g_dbus_object_manager_get_object_path().\n @get_objects: Virtual function for g_dbus_object_manager_get_objects().\n @get_object: Virtual function for g_dbus_object_manager_get_object().\n @get_interface: Virtual function for g_dbus_object_manager_get_interface().\n @object_added: Signal handler for the #GDBusObjectManager::object-added signal.\n @object_removed: Signal handler for the #GDBusObjectManager::object-removed signal.\n @interface_added: Signal handler for the #GDBusObjectManager::interface-added signal.\n @interface_removed: Signal handler for the #GDBusObjectManager::interface-removed signal.\n\n Base type for D-Bus object managers.\n\n Since: 2.30"]
pub type GDBusObjectManagerIface = _GDBusObjectManagerIface;
#[doc = " GDBusObjectManagerIface:\n @parent_iface: The parent interface.\n @get_object_path: Virtual function for g_dbus_object_manager_get_object_path().\n @get_objects: Virtual function for g_dbus_object_manager_get_objects().\n @get_object: Virtual function for g_dbus_object_manager_get_object().\n @get_interface: Virtual function for g_dbus_object_manager_get_interface().\n @object_added: Signal handler for the #GDBusObjectManager::object-added signal.\n @object_removed: Signal handler for the #GDBusObjectManager::object-removed signal.\n @interface_added: Signal handler for the #GDBusObjectManager::interface-added signal.\n @interface_removed: Signal handler for the #GDBusObjectManager::interface-removed signal.\n\n Base type for D-Bus object managers.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerIface {
    pub parent_iface: GTypeInterface,
    pub get_object_path: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager) -> *const gchar,
    >,
    pub get_objects:
        ::std::option::Option<unsafe extern "C" fn(manager: *mut GDBusObjectManager) -> *mut GList>,
    pub get_object: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object_path: *const gchar,
        ) -> *mut GDBusObject,
    >,
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object_path: *const gchar,
            interface_name: *const gchar,
        ) -> *mut GDBusInterface,
    >,
    pub object_added: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager, object: *mut GDBusObject),
    >,
    pub object_removed: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager, object: *mut GDBusObject),
    >,
    pub interface_added: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object: *mut GDBusObject,
            interface_: *mut GDBusInterface,
        ),
    >,
    pub interface_removed: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object: *mut GDBusObject,
            interface_: *mut GDBusInterface,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectManagerIface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerIface>(),
        80usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(parent_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_object_path) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(get_object_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_objects) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(get_objects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_object) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(get_object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_interface) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(get_interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_added) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(object_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_removed) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(object_removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_added) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(interface_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_removed) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(interface_removed)
        )
    );
}
extern "C" {
    pub fn g_dbus_object_manager_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_manager_get_object_path(manager: *mut GDBusObjectManager) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_object_manager_get_objects(manager: *mut GDBusObjectManager) -> *mut GList;
}
extern "C" {
    pub fn g_dbus_object_manager_get_object(
        manager: *mut GDBusObjectManager,
        object_path: *const gchar,
    ) -> *mut GDBusObject;
}
extern "C" {
    pub fn g_dbus_object_manager_get_interface(
        manager: *mut GDBusObjectManager,
        object_path: *const gchar,
        interface_name: *const gchar,
    ) -> *mut GDBusInterface;
}
#[doc = " GDBusObjectManagerClientClass:\n @parent_class: The parent class.\n @interface_proxy_signal: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.\n @interface_proxy_properties_changed: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.\n\n Class structure for #GDBusObjectManagerClient.\n\n Since: 2.30"]
pub type GDBusObjectManagerClientClass = _GDBusObjectManagerClientClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerClientPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectManagerClientPrivate = _GDBusObjectManagerClientPrivate;
#[doc = " GDBusObjectManagerClient:\n\n The #GDBusObjectManagerClient structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerClient {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectManagerClientPrivate,
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerClient() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectManagerClient> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerClient>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerClient))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerClient>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerClient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClient),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClient),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GDBusObjectManagerClientClass:\n @parent_class: The parent class.\n @interface_proxy_signal: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.\n @interface_proxy_properties_changed: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.\n\n Class structure for #GDBusObjectManagerClient.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerClientClass {
    pub parent_class: GObjectClass,
    pub interface_proxy_signal: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManagerClient,
            object_proxy: *mut GDBusObjectProxy,
            interface_proxy: *mut GDBusProxy,
            sender_name: *const gchar,
            signal_name: *const gchar,
            parameters: *mut GVariant,
        ),
    >,
    pub interface_proxy_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManagerClient,
            object_proxy: *mut GDBusObjectProxy,
            interface_proxy: *mut GDBusProxy,
            changed_properties: *mut GVariant,
            invalidated_properties: *const *const gchar,
        ),
    >,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerClientClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectManagerClientClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerClientClass>(),
        216usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerClientClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerClientClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerClientClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClientClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_proxy_signal) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClientClass),
            "::",
            stringify!(interface_proxy_signal)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).interface_proxy_properties_changed) as usize - ptr as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClientClass),
            "::",
            stringify!(interface_proxy_properties_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClientClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_object_manager_client_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_manager_client_new(
        connection: *mut GDBusConnection,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_object_manager_client_new_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
extern "C" {
    pub fn g_dbus_object_manager_client_new_sync(
        connection: *mut GDBusConnection,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
extern "C" {
    pub fn g_dbus_object_manager_client_new_for_bus(
        bus_type: GBusType,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_object_manager_client_new_for_bus_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
extern "C" {
    pub fn g_dbus_object_manager_client_new_for_bus_sync(
        bus_type: GBusType,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
extern "C" {
    pub fn g_dbus_object_manager_client_get_connection(
        manager: *mut GDBusObjectManagerClient,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_object_manager_client_get_flags(
        manager: *mut GDBusObjectManagerClient,
    ) -> GDBusObjectManagerClientFlags;
}
extern "C" {
    pub fn g_dbus_object_manager_client_get_name(
        manager: *mut GDBusObjectManagerClient,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_object_manager_client_get_name_owner(
        manager: *mut GDBusObjectManagerClient,
    ) -> *mut gchar;
}
#[doc = " GDBusObjectManagerServerClass:\n @parent_class: The parent class.\n\n Class structure for #GDBusObjectManagerServer.\n\n Since: 2.30"]
pub type GDBusObjectManagerServerClass = _GDBusObjectManagerServerClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerServerPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectManagerServerPrivate = _GDBusObjectManagerServerPrivate;
#[doc = " GDBusObjectManagerServer:\n\n The #GDBusObjectManagerServer structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerServer {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectManagerServerPrivate,
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerServer() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectManagerServer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerServer>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerServer))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerServer>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerServer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerServer),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerServer),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GDBusObjectManagerServerClass:\n @parent_class: The parent class.\n\n Class structure for #GDBusObjectManagerServer.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerServerClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerServerClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectManagerServerClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerServerClass>(),
        200usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerServerClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerServerClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerServerClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerServerClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerServerClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_object_manager_server_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_manager_server_new(
        object_path: *const gchar,
    ) -> *mut GDBusObjectManagerServer;
}
extern "C" {
    pub fn g_dbus_object_manager_server_get_connection(
        manager: *mut GDBusObjectManagerServer,
    ) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_object_manager_server_set_connection(
        manager: *mut GDBusObjectManagerServer,
        connection: *mut GDBusConnection,
    );
}
extern "C" {
    pub fn g_dbus_object_manager_server_export(
        manager: *mut GDBusObjectManagerServer,
        object: *mut GDBusObjectSkeleton,
    );
}
extern "C" {
    pub fn g_dbus_object_manager_server_export_uniquely(
        manager: *mut GDBusObjectManagerServer,
        object: *mut GDBusObjectSkeleton,
    );
}
extern "C" {
    pub fn g_dbus_object_manager_server_is_exported(
        manager: *mut GDBusObjectManagerServer,
        object: *mut GDBusObjectSkeleton,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dbus_object_manager_server_unexport(
        manager: *mut GDBusObjectManagerServer,
        object_path: *const gchar,
    ) -> gboolean;
}
#[doc = " GDBusObjectProxyClass:\n @parent_class: The parent class.\n\n Class structure for #GDBusObjectProxy.\n\n Since: 2.30"]
pub type GDBusObjectProxyClass = _GDBusObjectProxyClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectProxyPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectProxyPrivate = _GDBusObjectProxyPrivate;
#[doc = " GDBusObjectProxy:\n\n The #GDBusObjectProxy structure contains private data and should\n only be accessed using the provided API.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectProxy {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectProxyPrivate,
}
#[test]
fn bindgen_test_layout__GDBusObjectProxy() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectProxy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectProxy>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusObjectProxy))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectProxy>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectProxy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectProxy),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectProxy),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GDBusObjectProxyClass:\n @parent_class: The parent class.\n\n Class structure for #GDBusObjectProxy.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectProxyClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusObjectProxyClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectProxyClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectProxyClass>(),
        200usize,
        concat!("Size of: ", stringify!(_GDBusObjectProxyClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectProxyClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectProxyClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectProxyClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectProxyClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_object_proxy_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_proxy_new(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
    ) -> *mut GDBusObjectProxy;
}
extern "C" {
    pub fn g_dbus_object_proxy_get_connection(proxy: *mut GDBusObjectProxy)
        -> *mut GDBusConnection;
}
#[doc = " GDBusObjectSkeletonClass:\n @parent_class: The parent class.\n @authorize_method: Signal class handler for the #GDBusObjectSkeleton::authorize-method signal.\n\n Class structure for #GDBusObjectSkeleton.\n\n Since: 2.30"]
pub type GDBusObjectSkeletonClass = _GDBusObjectSkeletonClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectSkeletonPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectSkeletonPrivate = _GDBusObjectSkeletonPrivate;
#[doc = " GDBusObjectSkeleton:\n\n The #GDBusObjectSkeleton structure contains private data and should only be\n accessed using the provided API.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectSkeleton {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectSkeletonPrivate,
}
#[test]
fn bindgen_test_layout__GDBusObjectSkeleton() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectSkeleton> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectSkeleton>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusObjectSkeleton))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectSkeleton>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectSkeleton))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeleton),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeleton),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GDBusObjectSkeletonClass:\n @parent_class: The parent class.\n @authorize_method: Signal class handler for the #GDBusObjectSkeleton::authorize-method signal.\n\n Class structure for #GDBusObjectSkeleton.\n\n Since: 2.30"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectSkeletonClass {
    pub parent_class: GObjectClass,
    pub authorize_method: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GDBusObjectSkeleton,
            interface_: *mut GDBusInterfaceSkeleton,
            invocation: *mut GDBusMethodInvocation,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusObjectSkeletonClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusObjectSkeletonClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectSkeletonClass>(),
        208usize,
        concat!("Size of: ", stringify!(_GDBusObjectSkeletonClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectSkeletonClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectSkeletonClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeletonClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authorize_method) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeletonClass),
            "::",
            stringify!(authorize_method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeletonClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_object_skeleton_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_skeleton_new(object_path: *const gchar) -> *mut GDBusObjectSkeleton;
}
extern "C" {
    pub fn g_dbus_object_skeleton_flush(object: *mut GDBusObjectSkeleton);
}
extern "C" {
    pub fn g_dbus_object_skeleton_add_interface(
        object: *mut GDBusObjectSkeleton,
        interface_: *mut GDBusInterfaceSkeleton,
    );
}
extern "C" {
    pub fn g_dbus_object_skeleton_remove_interface(
        object: *mut GDBusObjectSkeleton,
        interface_: *mut GDBusInterfaceSkeleton,
    );
}
extern "C" {
    pub fn g_dbus_object_skeleton_remove_interface_by_name(
        object: *mut GDBusObjectSkeleton,
        interface_name: *const gchar,
    );
}
extern "C" {
    pub fn g_dbus_object_skeleton_set_object_path(
        object: *mut GDBusObjectSkeleton,
        object_path: *const gchar,
    );
}
#[doc = " GDBusProxyClass:\n @g_properties_changed: Signal class handler for the #GDBusProxy::g-properties-changed signal.\n @g_signal: Signal class handler for the #GDBusProxy::g-signal signal.\n\n Class structure for #GDBusProxy.\n\n Since: 2.26"]
pub type GDBusProxyClass = _GDBusProxyClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusProxyPrivate {
    _unused: [u8; 0],
}
pub type GDBusProxyPrivate = _GDBusProxyPrivate;
#[doc = " GDBusProxy:\n\n The #GDBusProxy structure contains only private data and\n should only be accessed using the provided API.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusProxy {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusProxyPrivate,
}
#[test]
fn bindgen_test_layout__GDBusProxy() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusProxy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusProxy>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusProxy))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusProxy>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusProxy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxy),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxy),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GDBusProxyClass:\n @g_properties_changed: Signal class handler for the #GDBusProxy::g-properties-changed signal.\n @g_signal: Signal class handler for the #GDBusProxy::g-signal signal.\n\n Class structure for #GDBusProxy.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusProxyClass {
    pub parent_class: GObjectClass,
    pub g_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GDBusProxy,
            changed_properties: *mut GVariant,
            invalidated_properties: *const *const gchar,
        ),
    >,
    pub g_signal: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GDBusProxy,
            sender_name: *const gchar,
            signal_name: *const gchar,
            parameters: *mut GVariant,
        ),
    >,
    pub padding: [gpointer; 32usize],
}
#[test]
fn bindgen_test_layout__GDBusProxyClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDBusProxyClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDBusProxyClass>(),
        408usize,
        concat!("Size of: ", stringify!(_GDBusProxyClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusProxyClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusProxyClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxyClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_properties_changed) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxyClass),
            "::",
            stringify!(g_properties_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_signal) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxyClass),
            "::",
            stringify!(g_signal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxyClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_dbus_proxy_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_proxy_new(
        connection: *mut GDBusConnection,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_proxy_new_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
extern "C" {
    pub fn g_dbus_proxy_new_sync(
        connection: *mut GDBusConnection,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
extern "C" {
    pub fn g_dbus_proxy_new_for_bus(
        bus_type: GBusType,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_proxy_new_for_bus_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
extern "C" {
    pub fn g_dbus_proxy_new_for_bus_sync(
        bus_type: GBusType,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
extern "C" {
    pub fn g_dbus_proxy_get_connection(proxy: *mut GDBusProxy) -> *mut GDBusConnection;
}
extern "C" {
    pub fn g_dbus_proxy_get_flags(proxy: *mut GDBusProxy) -> GDBusProxyFlags;
}
extern "C" {
    pub fn g_dbus_proxy_get_name(proxy: *mut GDBusProxy) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_proxy_get_name_owner(proxy: *mut GDBusProxy) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_proxy_get_object_path(proxy: *mut GDBusProxy) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_proxy_get_interface_name(proxy: *mut GDBusProxy) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_proxy_get_default_timeout(proxy: *mut GDBusProxy) -> gint;
}
extern "C" {
    pub fn g_dbus_proxy_set_default_timeout(proxy: *mut GDBusProxy, timeout_msec: gint);
}
extern "C" {
    pub fn g_dbus_proxy_get_interface_info(proxy: *mut GDBusProxy) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    pub fn g_dbus_proxy_set_interface_info(proxy: *mut GDBusProxy, info: *mut GDBusInterfaceInfo);
}
extern "C" {
    pub fn g_dbus_proxy_get_cached_property(
        proxy: *mut GDBusProxy,
        property_name: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_proxy_set_cached_property(
        proxy: *mut GDBusProxy,
        property_name: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_dbus_proxy_get_cached_property_names(proxy: *mut GDBusProxy) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_dbus_proxy_call(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_proxy_call_finish(
        proxy: *mut GDBusProxy,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_proxy_call_sync(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_proxy_call_with_unix_fd_list(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dbus_proxy_call_with_unix_fd_list_finish(
        proxy: *mut GDBusProxy,
        out_fd_list: *mut *mut GUnixFDList,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_proxy_call_with_unix_fd_list_sync(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        out_fd_list: *mut *mut GUnixFDList,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_server_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_server_new_sync(
        address: *const gchar,
        flags: GDBusServerFlags,
        guid: *const gchar,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusServer;
}
extern "C" {
    pub fn g_dbus_server_get_client_address(server: *mut GDBusServer) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_server_get_guid(server: *mut GDBusServer) -> *const gchar;
}
extern "C" {
    pub fn g_dbus_server_get_flags(server: *mut GDBusServer) -> GDBusServerFlags;
}
extern "C" {
    pub fn g_dbus_server_start(server: *mut GDBusServer);
}
extern "C" {
    pub fn g_dbus_server_stop(server: *mut GDBusServer);
}
extern "C" {
    pub fn g_dbus_server_is_active(server: *mut GDBusServer) -> gboolean;
}
extern "C" {
    pub fn g_dbus_is_guid(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_generate_guid() -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_is_name(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_is_unique_name(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_is_member_name(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_is_interface_name(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_is_error_name(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_dbus_gvariant_to_gvalue(value: *mut GVariant, out_gvalue: *mut GValue);
}
extern "C" {
    pub fn g_dbus_gvalue_to_gvariant(
        gvalue: *const GValue,
        type_: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_dbus_escape_object_path_bytestring(bytes: *const guint8) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_escape_object_path(s: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_dbus_unescape_object_path(s: *const gchar) -> *mut guint8;
}
extern "C" {
    pub fn g_debug_controller_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugController {
    _unused: [u8; 0],
}
pub type GDebugController = _GDebugController;
#[doc = " GDebugControllerInterface:\n @g_iface: The parent interface.\n\n The virtual function table for #GDebugController.\n\n Since: 2.72"]
pub type GDebugControllerInterface = _GDebugControllerInterface;
pub type GDebugController_autoptr = *mut GDebugController;
pub type GDebugController_listautoptr = *mut GList;
pub type GDebugController_slistautoptr = *mut GSList;
pub type GDebugController_queueautoptr = *mut GQueue;
#[doc = " GDebugControllerInterface:\n @g_iface: The parent interface.\n\n The virtual function table for #GDebugController.\n\n Since: 2.72"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugControllerInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GDebugControllerInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDebugControllerInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDebugControllerInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GDebugControllerInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugControllerInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugControllerInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugControllerInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    pub fn g_debug_controller_get_debug_enabled(self_: *mut GDebugController) -> gboolean;
}
extern "C" {
    pub fn g_debug_controller_set_debug_enabled(
        self_: *mut GDebugController,
        debug_enabled: gboolean,
    );
}
extern "C" {
    pub fn g_debug_controller_dbus_get_type() -> GType;
}
pub type GDebugControllerDBus = _GDebugControllerDBus;
#[doc = " GDebugControllerDBusClass:\n @parent_class: The parent class.\n @authorize: Default handler for the #GDebugControllerDBus::authorize signal.\n\n The virtual function table for #GDebugControllerDBus.\n\n Since: 2.72"]
pub type GDebugControllerDBusClass = _GDebugControllerDBusClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugControllerDBus {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__GDebugControllerDBus() {
    const UNINIT: ::std::mem::MaybeUninit<_GDebugControllerDBus> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDebugControllerDBus>(),
        24usize,
        concat!("Size of: ", stringify!(_GDebugControllerDBus))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugControllerDBus>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugControllerDBus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugControllerDBus),
            "::",
            stringify!(parent_instance)
        )
    );
}
pub type GDebugControllerDBus_autoptr = *mut GDebugControllerDBus;
pub type GDebugControllerDBus_listautoptr = *mut GList;
pub type GDebugControllerDBus_slistautoptr = *mut GSList;
pub type GDebugControllerDBus_queueautoptr = *mut GQueue;
pub type GDebugControllerDBusClass_autoptr = *mut GDebugControllerDBusClass;
pub type GDebugControllerDBusClass_listautoptr = *mut GList;
pub type GDebugControllerDBusClass_slistautoptr = *mut GSList;
pub type GDebugControllerDBusClass_queueautoptr = *mut GQueue;
#[doc = " GDebugControllerDBusClass:\n @parent_class: The parent class.\n @authorize: Default handler for the #GDebugControllerDBus::authorize signal.\n\n The virtual function table for #GDebugControllerDBus.\n\n Since: 2.72"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugControllerDBusClass {
    pub parent_class: GObjectClass,
    pub authorize: ::std::option::Option<
        unsafe extern "C" fn(
            controller: *mut GDebugControllerDBus,
            invocation: *mut GDBusMethodInvocation,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 12usize],
}
#[test]
fn bindgen_test_layout__GDebugControllerDBusClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GDebugControllerDBusClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDebugControllerDBusClass>(),
        240usize,
        concat!("Size of: ", stringify!(_GDebugControllerDBusClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugControllerDBusClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugControllerDBusClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugControllerDBusClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authorize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugControllerDBusClass),
            "::",
            stringify!(authorize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugControllerDBusClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_debug_controller_dbus_new(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDebugControllerDBus;
}
extern "C" {
    pub fn g_debug_controller_dbus_stop(self_: *mut GDebugControllerDBus);
}
#[doc = " GDriveIface:\n @g_iface: The parent interface.\n @changed: Signal emitted when the drive is changed.\n @disconnected: The removed signal that is emitted when the #GDrive have been disconnected. If the recipient is holding references to the object they should release them so the object can be finalized.\n @eject_button: Signal emitted when the physical eject button (if any) of a drive have been pressed.\n @get_name: Returns the name for the given #GDrive.\n @get_icon: Returns a #GIcon for the given #GDrive.\n @has_volumes: Returns %TRUE if the #GDrive has mountable volumes.\n @get_volumes: Returns a list #GList of #GVolume for the #GDrive.\n @is_removable: Returns %TRUE if the #GDrive and/or its media is considered removable by the user. Since 2.50.\n @is_media_removable: Returns %TRUE if the #GDrive supports removal and insertion of media.\n @has_media: Returns %TRUE if the #GDrive has media inserted.\n @is_media_check_automatic: Returns %TRUE if the #GDrive is capable of automatically detecting media changes.\n @can_poll_for_media: Returns %TRUE if the #GDrive is capable of manually polling for media change.\n @can_eject: Returns %TRUE if the #GDrive can eject media.\n @eject: Ejects a #GDrive.\n @eject_finish: Finishes an eject operation.\n @poll_for_media: Poll for media insertion/removal on a #GDrive.\n @poll_for_media_finish: Finishes a media poll operation.\n @get_identifier: Returns the identifier of the given kind, or %NULL if\n    the #GDrive doesn't have one.\n @enumerate_identifiers: Returns an array strings listing the kinds\n    of identifiers which the #GDrive has.\n @get_start_stop_type: Gets a #GDriveStartStopType with details about starting/stopping the drive. Since 2.22.\n @can_stop: Returns %TRUE if a #GDrive can be stopped. Since 2.22.\n @stop: Stops a #GDrive. Since 2.22.\n @stop_finish: Finishes a stop operation. Since 2.22.\n @can_start: Returns %TRUE if a #GDrive can be started. Since 2.22.\n @can_start_degraded: Returns %TRUE if a #GDrive can be started degraded. Since 2.22.\n @start: Starts a #GDrive. Since 2.22.\n @start_finish: Finishes a start operation. Since 2.22.\n @stop_button: Signal emitted when the physical stop button (if any) of a drive have been pressed. Since 2.22.\n @eject_with_operation: Starts ejecting a #GDrive using a #GMountOperation. Since 2.22.\n @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @get_sort_key: Gets a key used for sorting #GDrive instances or %NULL if no such key exists. Since 2.32.\n @get_symbolic_icon: Returns a symbolic #GIcon for the given #GDrive. Since 2.34.\n\n Interface for creating #GDrive implementations."]
pub type GDriveIface = _GDriveIface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDriveIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub disconnected: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub eject_button: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(drive: *mut GDrive) -> *mut ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *mut GIcon>,
    pub has_volumes: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub get_volumes: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *mut GList>,
    pub is_media_removable:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub has_media: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub is_media_check_automatic:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub can_poll_for_media:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub eject: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub poll_for_media: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub poll_for_media_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_identifier: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            kind: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub enumerate_identifiers: ::std::option::Option<
        unsafe extern "C" fn(drive: *mut GDrive) -> *mut *mut ::std::os::raw::c_char,
    >,
    pub get_start_stop_type:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> GDriveStartStopType>,
    pub can_start: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub can_start_degraded:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub start: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GDriveStartFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub start_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_stop: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub stop: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub stop_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub stop_button: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub eject_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_sort_key:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *const gchar>,
    pub get_symbolic_icon:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *mut GIcon>,
    pub is_removable: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
}
#[test]
fn bindgen_test_layout__GDriveIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDriveIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDriveIface>(),
        272usize,
        concat!("Size of: ", stringify!(_GDriveIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDriveIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDriveIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disconnected) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(disconnected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_button) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject_button)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_icon) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_icon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_volumes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(has_volumes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_volumes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_volumes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_media_removable) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(is_media_removable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_media) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(has_media)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_media_check_automatic) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(is_media_check_automatic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_eject) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_eject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_poll_for_media) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_poll_for_media)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_finish) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll_for_media) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(poll_for_media)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll_for_media_finish) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(poll_for_media_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_identifier) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate_identifiers) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(enumerate_identifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_start_stop_type) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_start_stop_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_start) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_start_degraded) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_start_degraded)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_finish) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(start_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_stop) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_finish) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(stop_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_button) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(stop_button)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_with_operation) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject_with_operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_with_operation_finish) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_sort_key) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_sort_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_symbolic_icon) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_symbolic_icon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_removable) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(is_removable)
        )
    );
}
extern "C" {
    pub fn g_drive_get_type() -> GType;
}
extern "C" {
    pub fn g_drive_get_name(drive: *mut GDrive) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_drive_get_icon(drive: *mut GDrive) -> *mut GIcon;
}
extern "C" {
    pub fn g_drive_get_symbolic_icon(drive: *mut GDrive) -> *mut GIcon;
}
extern "C" {
    pub fn g_drive_has_volumes(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_get_volumes(drive: *mut GDrive) -> *mut GList;
}
extern "C" {
    pub fn g_drive_is_removable(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_is_media_removable(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_has_media(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_is_media_check_automatic(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_can_poll_for_media(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_can_eject(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_eject(
        drive: *mut GDrive,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_drive_eject_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_drive_poll_for_media(
        drive: *mut GDrive,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_drive_poll_for_media_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_drive_get_identifier(
        drive: *mut GDrive,
        kind: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_drive_enumerate_identifiers(drive: *mut GDrive) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_drive_get_start_stop_type(drive: *mut GDrive) -> GDriveStartStopType;
}
extern "C" {
    pub fn g_drive_can_start(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_can_start_degraded(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_start(
        drive: *mut GDrive,
        flags: GDriveStartFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_drive_start_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_drive_can_stop(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    pub fn g_drive_stop(
        drive: *mut GDrive,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_drive_stop_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_drive_eject_with_operation(
        drive: *mut GDrive,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_drive_eject_with_operation_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_drive_get_sort_key(drive: *mut GDrive) -> *const gchar;
}
#[doc = " GDtlsConnectionInterface:\n @g_iface: The parent interface.\n @accept_certificate: Check whether to accept a certificate.\n @handshake: Perform a handshake operation.\n @handshake_async: Start an asynchronous handshake operation.\n @handshake_finish: Finish an asynchronous handshake operation.\n @shutdown: Shut down one or both directions of the connection.\n @shutdown_async: Start an asynchronous shutdown operation.\n @shutdown_finish: Finish an asynchronous shutdown operation.\n @set_advertised_protocols: Set APLN protocol list (Since: 2.60)\n @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.60)\n @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)\n\n Virtual method table for a #GDtlsConnection implementation.\n\n Since: 2.48"]
pub type GDtlsConnectionInterface = _GDtlsConnectionInterface;
#[doc = " GDtlsConnectionInterface:\n @g_iface: The parent interface.\n @accept_certificate: Check whether to accept a certificate.\n @handshake: Perform a handshake operation.\n @handshake_async: Start an asynchronous handshake operation.\n @handshake_finish: Finish an asynchronous handshake operation.\n @shutdown: Shut down one or both directions of the connection.\n @shutdown_async: Start an asynchronous shutdown operation.\n @shutdown_finish: Finish an asynchronous shutdown operation.\n @set_advertised_protocols: Set APLN protocol list (Since: 2.60)\n @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.60)\n @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)\n\n Virtual method table for a #GDtlsConnection implementation.\n\n Since: 2.48"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsConnectionInterface {
    pub g_iface: GTypeInterface,
    pub accept_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            connection: *mut GDtlsConnection,
            peer_cert: *mut GTlsCertificate,
            errors: GTlsCertificateFlags,
        ) -> gboolean,
    >,
    pub handshake: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub handshake_async: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub handshake_finish: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub shutdown: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            shutdown_read: gboolean,
            shutdown_write: gboolean,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub shutdown_async: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            shutdown_read: gboolean,
            shutdown_write: gboolean,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub shutdown_finish: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_advertised_protocols: ::std::option::Option<
        unsafe extern "C" fn(conn: *mut GDtlsConnection, protocols: *const *const gchar),
    >,
    pub get_negotiated_protocol:
        ::std::option::Option<unsafe extern "C" fn(conn: *mut GDtlsConnection) -> *const gchar>,
    pub get_binding_data: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            type_: GTlsChannelBindingType,
            data: *mut GByteArray,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GDtlsConnectionInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDtlsConnectionInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDtlsConnectionInterface>(),
        96usize,
        concat!("Size of: ", stringify!(_GDtlsConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDtlsConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDtlsConnectionInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accept_certificate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(accept_certificate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(handshake)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake_async) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(handshake_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake_finish) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(handshake_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_async) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(shutdown_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).shutdown_finish) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(shutdown_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_advertised_protocols) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(set_advertised_protocols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_negotiated_protocol) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(get_negotiated_protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_binding_data) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(get_binding_data)
        )
    );
}
extern "C" {
    pub fn g_dtls_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_dtls_connection_set_database(conn: *mut GDtlsConnection, database: *mut GTlsDatabase);
}
extern "C" {
    pub fn g_dtls_connection_get_database(conn: *mut GDtlsConnection) -> *mut GTlsDatabase;
}
extern "C" {
    pub fn g_dtls_connection_set_certificate(
        conn: *mut GDtlsConnection,
        certificate: *mut GTlsCertificate,
    );
}
extern "C" {
    pub fn g_dtls_connection_get_certificate(conn: *mut GDtlsConnection) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_dtls_connection_set_interaction(
        conn: *mut GDtlsConnection,
        interaction: *mut GTlsInteraction,
    );
}
extern "C" {
    pub fn g_dtls_connection_get_interaction(conn: *mut GDtlsConnection) -> *mut GTlsInteraction;
}
extern "C" {
    pub fn g_dtls_connection_get_peer_certificate(
        conn: *mut GDtlsConnection,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_dtls_connection_get_peer_certificate_errors(
        conn: *mut GDtlsConnection,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_dtls_connection_set_require_close_notify(
        conn: *mut GDtlsConnection,
        require_close_notify: gboolean,
    );
}
extern "C" {
    pub fn g_dtls_connection_get_require_close_notify(conn: *mut GDtlsConnection) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_set_rehandshake_mode(
        conn: *mut GDtlsConnection,
        mode: GTlsRehandshakeMode,
    );
}
extern "C" {
    pub fn g_dtls_connection_get_rehandshake_mode(
        conn: *mut GDtlsConnection,
    ) -> GTlsRehandshakeMode;
}
extern "C" {
    pub fn g_dtls_connection_handshake(
        conn: *mut GDtlsConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_handshake_async(
        conn: *mut GDtlsConnection,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dtls_connection_handshake_finish(
        conn: *mut GDtlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_shutdown(
        conn: *mut GDtlsConnection,
        shutdown_read: gboolean,
        shutdown_write: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_shutdown_async(
        conn: *mut GDtlsConnection,
        shutdown_read: gboolean,
        shutdown_write: gboolean,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dtls_connection_shutdown_finish(
        conn: *mut GDtlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_close(
        conn: *mut GDtlsConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_close_async(
        conn: *mut GDtlsConnection,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_dtls_connection_close_finish(
        conn: *mut GDtlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_emit_accept_certificate(
        conn: *mut GDtlsConnection,
        peer_cert: *mut GTlsCertificate,
        errors: GTlsCertificateFlags,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_set_advertised_protocols(
        conn: *mut GDtlsConnection,
        protocols: *const *const gchar,
    );
}
extern "C" {
    pub fn g_dtls_connection_get_negotiated_protocol(conn: *mut GDtlsConnection) -> *const gchar;
}
extern "C" {
    pub fn g_dtls_connection_get_channel_binding_data(
        conn: *mut GDtlsConnection,
        type_: GTlsChannelBindingType,
        data: *mut GByteArray,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_dtls_connection_get_protocol_version(
        conn: *mut GDtlsConnection,
    ) -> GTlsProtocolVersion;
}
extern "C" {
    pub fn g_dtls_connection_get_ciphersuite_name(conn: *mut GDtlsConnection) -> *mut gchar;
}
#[doc = " GDtlsClientConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GDtlsClientConnection implementation.\n\n Since: 2.48"]
pub type GDtlsClientConnectionInterface = _GDtlsClientConnectionInterface;
#[doc = " GDtlsClientConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GDtlsClientConnection implementation.\n\n Since: 2.48"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsClientConnectionInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GDtlsClientConnectionInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDtlsClientConnectionInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDtlsClientConnectionInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GDtlsClientConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDtlsClientConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDtlsClientConnectionInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsClientConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    pub fn g_dtls_client_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_dtls_client_connection_new(
        base_socket: *mut GDatagramBased,
        server_identity: *mut GSocketConnectable,
        error: *mut *mut GError,
    ) -> *mut GDatagramBased;
}
extern "C" {
    pub fn g_dtls_client_connection_get_validation_flags(
        conn: *mut GDtlsClientConnection,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_dtls_client_connection_set_validation_flags(
        conn: *mut GDtlsClientConnection,
        flags: GTlsCertificateFlags,
    );
}
extern "C" {
    pub fn g_dtls_client_connection_get_server_identity(
        conn: *mut GDtlsClientConnection,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_dtls_client_connection_set_server_identity(
        conn: *mut GDtlsClientConnection,
        identity: *mut GSocketConnectable,
    );
}
extern "C" {
    pub fn g_dtls_client_connection_get_accepted_cas(
        conn: *mut GDtlsClientConnection,
    ) -> *mut GList;
}
#[doc = " GDtlsServerConnection:\n\n DTLS server-side connection. This is the server-side implementation\n of a #GDtlsConnection.\n\n Since: 2.48"]
pub type GDtlsServerConnectionInterface = _GDtlsServerConnectionInterface;
#[doc = " GDtlsServerConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GDtlsServerConnection implementation.\n\n Since: 2.48"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsServerConnectionInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GDtlsServerConnectionInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GDtlsServerConnectionInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GDtlsServerConnectionInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GDtlsServerConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDtlsServerConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDtlsServerConnectionInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsServerConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    pub fn g_dtls_server_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_dtls_server_connection_new(
        base_socket: *mut GDatagramBased,
        certificate: *mut GTlsCertificate,
        error: *mut *mut GError,
    ) -> *mut GDatagramBased;
}
#[doc = " GIcon:\n\n An abstract type that specifies an icon."]
pub type GIconIface = _GIconIface;
#[doc = " GIconIface:\n @g_iface: The parent interface.\n @hash: A hash for a given #GIcon.\n @equal: Checks if two #GIcons are equal.\n @to_tokens: Serializes a #GIcon into tokens. The tokens must not\n contain any whitespace. Don't implement if the #GIcon can't be\n serialized (Since 2.20).\n @from_tokens: Constructs a #GIcon from tokens. Set the #GError if\n the tokens are malformed. Don't implement if the #GIcon can't be\n serialized (Since 2.20).\n @serialize: Serializes a #GIcon into a #GVariant. Since: 2.38\n\n GIconIface is used to implement GIcon types for various\n different systems. See #GThemedIcon and #GLoadableIcon for\n examples of how to implement this interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIconIface {
    pub g_iface: GTypeInterface,
    pub hash: ::std::option::Option<unsafe extern "C" fn(icon: *mut GIcon) -> guint>,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(icon1: *mut GIcon, icon2: *mut GIcon) -> gboolean,
    >,
    #[doc = " GIconIface::to_tokens:\n @icon: The #GIcon\n @tokens: (element-type utf8) (out caller-allocates):\n   The array to fill with tokens\n @out_version: (out): version of serialized tokens\n\n Serializes the @icon into string tokens.\n This is can be invoked when g_icon_new_for_string() is called.\n\n Returns: %TRUE if serialization took place, %FALSE otherwise\n\n Since: 2.20"]
    pub to_tokens: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GIcon,
            tokens: *mut GPtrArray,
            out_version: *mut gint,
        ) -> gboolean,
    >,
    #[doc = " GIconIface::from_tokens:\n @tokens: (array length=num_tokens): An array of tokens\n @num_tokens: The number of tokens in @tokens\n @version: Version of the serialized tokens\n @error: Return location for errors, or %NULL to ignore\n\n Constructs a #GIcon from a list of @tokens.\n\n Returns: (nullable) (transfer full): the #GIcon or %NULL on error\n\n Since: 2.20"]
    pub from_tokens: ::std::option::Option<
        unsafe extern "C" fn(
            tokens: *mut *mut gchar,
            num_tokens: gint,
            version: gint,
            error: *mut *mut GError,
        ) -> *mut GIcon,
    >,
    pub serialize: ::std::option::Option<unsafe extern "C" fn(icon: *mut GIcon) -> *mut GVariant>,
}
#[test]
fn bindgen_test_layout__GIconIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GIconIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GIconIface>(),
        56usize,
        concat!("Size of: ", stringify!(_GIconIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIconIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIconIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_tokens) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(to_tokens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from_tokens) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(from_tokens)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(serialize)
        )
    );
}
extern "C" {
    pub fn g_icon_get_type() -> GType;
}
extern "C" {
    pub fn g_icon_hash(icon: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_icon_equal(icon1: *mut GIcon, icon2: *mut GIcon) -> gboolean;
}
extern "C" {
    pub fn g_icon_to_string(icon: *mut GIcon) -> *mut gchar;
}
extern "C" {
    pub fn g_icon_new_for_string(str_: *const gchar, error: *mut *mut GError) -> *mut GIcon;
}
extern "C" {
    pub fn g_icon_serialize(icon: *mut GIcon) -> *mut GVariant;
}
extern "C" {
    pub fn g_icon_deserialize(value: *mut GVariant) -> *mut GIcon;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblem {
    _unused: [u8; 0],
}
#[doc = " GEmblem:\n\n An object for Emblems"]
pub type GEmblem = _GEmblem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemClass {
    _unused: [u8; 0],
}
pub type GEmblemClass = _GEmblemClass;
extern "C" {
    pub fn g_emblem_get_type() -> GType;
}
extern "C" {
    pub fn g_emblem_new(icon: *mut GIcon) -> *mut GEmblem;
}
extern "C" {
    pub fn g_emblem_new_with_origin(icon: *mut GIcon, origin: GEmblemOrigin) -> *mut GEmblem;
}
extern "C" {
    pub fn g_emblem_get_icon(emblem: *mut GEmblem) -> *mut GIcon;
}
extern "C" {
    pub fn g_emblem_get_origin(emblem: *mut GEmblem) -> GEmblemOrigin;
}
#[doc = " GEmblemedIcon:\n\n An implementation of #GIcon for icons with emblems."]
pub type GEmblemedIcon = _GEmblemedIcon;
pub type GEmblemedIconClass = _GEmblemedIconClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemedIconPrivate {
    _unused: [u8; 0],
}
pub type GEmblemedIconPrivate = _GEmblemedIconPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemedIcon {
    pub parent_instance: GObject,
    pub priv_: *mut GEmblemedIconPrivate,
}
#[test]
fn bindgen_test_layout__GEmblemedIcon() {
    const UNINIT: ::std::mem::MaybeUninit<_GEmblemedIcon> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GEmblemedIcon>(),
        32usize,
        concat!("Size of: ", stringify!(_GEmblemedIcon))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEmblemedIcon>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEmblemedIcon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEmblemedIcon),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEmblemedIcon),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemedIconClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GEmblemedIconClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GEmblemedIconClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GEmblemedIconClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GEmblemedIconClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEmblemedIconClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEmblemedIconClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEmblemedIconClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_emblemed_icon_get_type() -> GType;
}
extern "C" {
    pub fn g_emblemed_icon_new(icon: *mut GIcon, emblem: *mut GEmblem) -> *mut GIcon;
}
extern "C" {
    pub fn g_emblemed_icon_get_icon(emblemed: *mut GEmblemedIcon) -> *mut GIcon;
}
extern "C" {
    pub fn g_emblemed_icon_get_emblems(emblemed: *mut GEmblemedIcon) -> *mut GList;
}
extern "C" {
    pub fn g_emblemed_icon_add_emblem(emblemed: *mut GEmblemedIcon, emblem: *mut GEmblem);
}
extern "C" {
    pub fn g_emblemed_icon_clear_emblems(emblemed: *mut GEmblemedIcon);
}
#[doc = " GFileIface:\n @g_iface: The parent interface.\n @dup: Duplicates a #GFile.\n @hash: Creates a hash of a #GFile.\n @equal: Checks equality of two given #GFiles.\n @is_native: Checks to see if a file is native to the system.\n @has_uri_scheme: Checks to see if a #GFile has a given URI scheme.\n @get_uri_scheme: Gets the URI scheme for a #GFile.\n @get_basename: Gets the basename for a given #GFile.\n @get_path: Gets the current path within a #GFile.\n @get_uri: Gets a URI for the path within a #GFile.\n @get_parse_name: Gets the parsed name for the #GFile.\n @get_parent: Gets the parent directory for the #GFile.\n @prefix_matches: Checks whether a #GFile contains a specified file.\n @get_relative_path: Gets the path for a #GFile relative to a given path.\n @resolve_relative_path: Resolves a relative path for a #GFile to an absolute path.\n @get_child_for_display_name: Gets the child #GFile for a given display name.\n @enumerate_children: Gets a #GFileEnumerator with the children of a #GFile.\n @enumerate_children_async: Asynchronously gets a #GFileEnumerator with the children of a #GFile.\n @enumerate_children_finish: Finishes asynchronously enumerating the children.\n @query_info: Gets the #GFileInfo for a #GFile.\n @query_info_async: Asynchronously gets the #GFileInfo for a #GFile.\n @query_info_finish: Finishes an asynchronous query info operation.\n @query_filesystem_info: Gets a #GFileInfo for the file system #GFile is on.\n @query_filesystem_info_async: Asynchronously gets a #GFileInfo for the file system #GFile is on.\n @query_filesystem_info_finish: Finishes asynchronously getting the file system info.\n @find_enclosing_mount: Gets a #GMount for the #GFile.\n @find_enclosing_mount_async: Asynchronously gets the #GMount for a #GFile.\n @find_enclosing_mount_finish: Finishes asynchronously getting the volume.\n @set_display_name: Sets the display name for a #GFile.\n @set_display_name_async: Asynchronously sets a #GFile's display name.\n @set_display_name_finish: Finishes asynchronously setting a #GFile's display name.\n @query_settable_attributes: Returns a list of #GFileAttributeInfos that can be set.\n @_query_settable_attributes_async: Asynchronously gets a list of #GFileAttributeInfos that can be set.\n @_query_settable_attributes_finish: Finishes asynchronously querying settable attributes.\n @query_writable_namespaces: Returns a list of #GFileAttributeInfo namespaces that are writable.\n @_query_writable_namespaces_async: Asynchronously gets a list of #GFileAttributeInfo namespaces that are writable.\n @_query_writable_namespaces_finish: Finishes asynchronously querying the writable namespaces.\n @set_attribute: Sets a #GFileAttributeInfo.\n @set_attributes_from_info: Sets a #GFileAttributeInfo with information from a #GFileInfo.\n @set_attributes_async: Asynchronously sets a file's attributes.\n @set_attributes_finish: Finishes setting a file's attributes asynchronously.\n @read_fn: Reads a file asynchronously.\n @read_async: Asynchronously reads a file.\n @read_finish: Finishes asynchronously reading a file.\n @append_to: Writes to the end of a file.\n @append_to_async: Asynchronously writes to the end of a file.\n @append_to_finish: Finishes an asynchronous file append operation.\n @create: Creates a new file.\n @create_async: Asynchronously creates a file.\n @create_finish: Finishes asynchronously creating a file.\n @replace: Replaces the contents of a file.\n @replace_async: Asynchronously replaces the contents of a file.\n @replace_finish: Finishes asynchronously replacing a file.\n @delete_file: Deletes a file.\n @delete_file_async: Asynchronously deletes a file.\n @delete_file_finish: Finishes an asynchronous delete.\n @trash: Sends a #GFile to the Trash location.\n @trash_async: Asynchronously sends a #GFile to the Trash location.\n @trash_finish: Finishes an asynchronous file trashing operation.\n @make_directory: Makes a directory.\n @make_directory_async: Asynchronously makes a directory.\n @make_directory_finish: Finishes making a directory asynchronously.\n @make_symbolic_link: (nullable): Makes a symbolic link. %NULL if symbolic\n    links are unsupported.\n @make_symbolic_link_async: Asynchronously makes a symbolic link\n @make_symbolic_link_finish: Finishes making a symbolic link asynchronously.\n @copy: (nullable): Copies a file. %NULL if copying is unsupported, which will\n     cause `GFile` to use a fallback copy method where it reads from the\n     source and writes to the destination.\n @copy_async: Asynchronously copies a file.\n @copy_finish: Finishes an asynchronous copy operation.\n @move: Moves a file.\n @move_async: Asynchronously moves a file. Since: 2.72\n @move_finish: Finishes an asynchronous move operation. Since: 2.72\n @mount_mountable: Mounts a mountable object.\n @mount_mountable_finish: Finishes a mounting operation.\n @unmount_mountable: Unmounts a mountable object.\n @unmount_mountable_finish: Finishes an unmount operation.\n @eject_mountable: Ejects a mountable.\n @eject_mountable_finish: Finishes an eject operation.\n @mount_enclosing_volume: Mounts a specified location.\n @mount_enclosing_volume_finish: Finishes mounting a specified location.\n @monitor_dir: Creates a #GFileMonitor for the location.\n @monitor_file: Creates a #GFileMonitor for the location.\n @open_readwrite: Open file read/write. Since 2.22.\n @open_readwrite_async: Asynchronously opens file read/write. Since 2.22.\n @open_readwrite_finish: Finishes an asynchronous open read/write. Since 2.22.\n @create_readwrite: Creates file read/write. Since 2.22.\n @create_readwrite_async: Asynchronously creates file read/write. Since 2.22.\n @create_readwrite_finish: Finishes an asynchronous creates read/write. Since 2.22.\n @replace_readwrite: Replaces file read/write. Since 2.22.\n @replace_readwrite_async: Asynchronously replaces file read/write. Since 2.22.\n @replace_readwrite_finish: Finishes an asynchronous replace read/write. Since 2.22.\n @start_mountable: Starts a mountable object. Since 2.22.\n @start_mountable_finish: Finishes a start operation. Since 2.22.\n @stop_mountable: Stops a mountable. Since 2.22.\n @stop_mountable_finish: Finishes a stop operation. Since 2.22.\n @supports_thread_contexts: a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.\n @unmount_mountable_with_operation: Unmounts a mountable object using a #GMountOperation. Since 2.22.\n @unmount_mountable_with_operation_finish: Finishes an unmount operation using a #GMountOperation. Since 2.22.\n @eject_mountable_with_operation: Ejects a mountable object using a #GMountOperation. Since 2.22.\n @eject_mountable_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @poll_mountable: Polls a mountable object for media changes. Since 2.22.\n @poll_mountable_finish: Finishes a poll operation for media changes. Since 2.22.\n @measure_disk_usage: Recursively measures the disk usage of @file. Since 2.38\n @measure_disk_usage_async: Asynchronously recursively measures the disk usage of @file. Since 2.38\n @measure_disk_usage_finish: Finishes an asynchronous recursive measurement of the disk usage of @file. Since 2.38\n\n An interface for writing VFS file handles."]
pub type GFileIface = _GFileIface;
#[doc = " GFileIface:\n @g_iface: The parent interface.\n @dup: Duplicates a #GFile.\n @hash: Creates a hash of a #GFile.\n @equal: Checks equality of two given #GFiles.\n @is_native: Checks to see if a file is native to the system.\n @has_uri_scheme: Checks to see if a #GFile has a given URI scheme.\n @get_uri_scheme: Gets the URI scheme for a #GFile.\n @get_basename: Gets the basename for a given #GFile.\n @get_path: Gets the current path within a #GFile.\n @get_uri: Gets a URI for the path within a #GFile.\n @get_parse_name: Gets the parsed name for the #GFile.\n @get_parent: Gets the parent directory for the #GFile.\n @prefix_matches: Checks whether a #GFile contains a specified file.\n @get_relative_path: Gets the path for a #GFile relative to a given path.\n @resolve_relative_path: Resolves a relative path for a #GFile to an absolute path.\n @get_child_for_display_name: Gets the child #GFile for a given display name.\n @enumerate_children: Gets a #GFileEnumerator with the children of a #GFile.\n @enumerate_children_async: Asynchronously gets a #GFileEnumerator with the children of a #GFile.\n @enumerate_children_finish: Finishes asynchronously enumerating the children.\n @query_info: Gets the #GFileInfo for a #GFile.\n @query_info_async: Asynchronously gets the #GFileInfo for a #GFile.\n @query_info_finish: Finishes an asynchronous query info operation.\n @query_filesystem_info: Gets a #GFileInfo for the file system #GFile is on.\n @query_filesystem_info_async: Asynchronously gets a #GFileInfo for the file system #GFile is on.\n @query_filesystem_info_finish: Finishes asynchronously getting the file system info.\n @find_enclosing_mount: Gets a #GMount for the #GFile.\n @find_enclosing_mount_async: Asynchronously gets the #GMount for a #GFile.\n @find_enclosing_mount_finish: Finishes asynchronously getting the volume.\n @set_display_name: Sets the display name for a #GFile.\n @set_display_name_async: Asynchronously sets a #GFile's display name.\n @set_display_name_finish: Finishes asynchronously setting a #GFile's display name.\n @query_settable_attributes: Returns a list of #GFileAttributeInfos that can be set.\n @_query_settable_attributes_async: Asynchronously gets a list of #GFileAttributeInfos that can be set.\n @_query_settable_attributes_finish: Finishes asynchronously querying settable attributes.\n @query_writable_namespaces: Returns a list of #GFileAttributeInfo namespaces that are writable.\n @_query_writable_namespaces_async: Asynchronously gets a list of #GFileAttributeInfo namespaces that are writable.\n @_query_writable_namespaces_finish: Finishes asynchronously querying the writable namespaces.\n @set_attribute: Sets a #GFileAttributeInfo.\n @set_attributes_from_info: Sets a #GFileAttributeInfo with information from a #GFileInfo.\n @set_attributes_async: Asynchronously sets a file's attributes.\n @set_attributes_finish: Finishes setting a file's attributes asynchronously.\n @read_fn: Reads a file asynchronously.\n @read_async: Asynchronously reads a file.\n @read_finish: Finishes asynchronously reading a file.\n @append_to: Writes to the end of a file.\n @append_to_async: Asynchronously writes to the end of a file.\n @append_to_finish: Finishes an asynchronous file append operation.\n @create: Creates a new file.\n @create_async: Asynchronously creates a file.\n @create_finish: Finishes asynchronously creating a file.\n @replace: Replaces the contents of a file.\n @replace_async: Asynchronously replaces the contents of a file.\n @replace_finish: Finishes asynchronously replacing a file.\n @delete_file: Deletes a file.\n @delete_file_async: Asynchronously deletes a file.\n @delete_file_finish: Finishes an asynchronous delete.\n @trash: Sends a #GFile to the Trash location.\n @trash_async: Asynchronously sends a #GFile to the Trash location.\n @trash_finish: Finishes an asynchronous file trashing operation.\n @make_directory: Makes a directory.\n @make_directory_async: Asynchronously makes a directory.\n @make_directory_finish: Finishes making a directory asynchronously.\n @make_symbolic_link: (nullable): Makes a symbolic link. %NULL if symbolic\n    links are unsupported.\n @make_symbolic_link_async: Asynchronously makes a symbolic link\n @make_symbolic_link_finish: Finishes making a symbolic link asynchronously.\n @copy: (nullable): Copies a file. %NULL if copying is unsupported, which will\n     cause `GFile` to use a fallback copy method where it reads from the\n     source and writes to the destination.\n @copy_async: Asynchronously copies a file.\n @copy_finish: Finishes an asynchronous copy operation.\n @move: Moves a file.\n @move_async: Asynchronously moves a file. Since: 2.72\n @move_finish: Finishes an asynchronous move operation. Since: 2.72\n @mount_mountable: Mounts a mountable object.\n @mount_mountable_finish: Finishes a mounting operation.\n @unmount_mountable: Unmounts a mountable object.\n @unmount_mountable_finish: Finishes an unmount operation.\n @eject_mountable: Ejects a mountable.\n @eject_mountable_finish: Finishes an eject operation.\n @mount_enclosing_volume: Mounts a specified location.\n @mount_enclosing_volume_finish: Finishes mounting a specified location.\n @monitor_dir: Creates a #GFileMonitor for the location.\n @monitor_file: Creates a #GFileMonitor for the location.\n @open_readwrite: Open file read/write. Since 2.22.\n @open_readwrite_async: Asynchronously opens file read/write. Since 2.22.\n @open_readwrite_finish: Finishes an asynchronous open read/write. Since 2.22.\n @create_readwrite: Creates file read/write. Since 2.22.\n @create_readwrite_async: Asynchronously creates file read/write. Since 2.22.\n @create_readwrite_finish: Finishes an asynchronous creates read/write. Since 2.22.\n @replace_readwrite: Replaces file read/write. Since 2.22.\n @replace_readwrite_async: Asynchronously replaces file read/write. Since 2.22.\n @replace_readwrite_finish: Finishes an asynchronous replace read/write. Since 2.22.\n @start_mountable: Starts a mountable object. Since 2.22.\n @start_mountable_finish: Finishes a start operation. Since 2.22.\n @stop_mountable: Stops a mountable. Since 2.22.\n @stop_mountable_finish: Finishes a stop operation. Since 2.22.\n @supports_thread_contexts: a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.\n @unmount_mountable_with_operation: Unmounts a mountable object using a #GMountOperation. Since 2.22.\n @unmount_mountable_with_operation_finish: Finishes an unmount operation using a #GMountOperation. Since 2.22.\n @eject_mountable_with_operation: Ejects a mountable object using a #GMountOperation. Since 2.22.\n @eject_mountable_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @poll_mountable: Polls a mountable object for media changes. Since 2.22.\n @poll_mountable_finish: Finishes a poll operation for media changes. Since 2.22.\n @measure_disk_usage: Recursively measures the disk usage of @file. Since 2.38\n @measure_disk_usage_async: Asynchronously recursively measures the disk usage of @file. Since 2.38\n @measure_disk_usage_finish: Finishes an asynchronous recursive measurement of the disk usage of @file. Since 2.38\n\n An interface for writing VFS file handles."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIface {
    pub g_iface: GTypeInterface,
    pub dup: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> *mut GFile>,
    pub hash: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> guint>,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(file1: *mut GFile, file2: *mut GFile) -> gboolean,
    >,
    pub is_native: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> gboolean>,
    pub has_uri_scheme: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            uri_scheme: *const ::std::os::raw::c_char,
        ) -> gboolean,
    >,
    pub get_uri_scheme: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_basename: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_path: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_uri: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_parse_name: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_parent: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> *mut GFile>,
    pub prefix_matches: ::std::option::Option<
        unsafe extern "C" fn(prefix: *mut GFile, file: *mut GFile) -> gboolean,
    >,
    pub get_relative_path: ::std::option::Option<
        unsafe extern "C" fn(
            parent: *mut GFile,
            descendant: *mut GFile,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub resolve_relative_path: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            relative_path: *const ::std::os::raw::c_char,
        ) -> *mut GFile,
    >,
    pub get_child_for_display_name: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            display_name: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub enumerate_children: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileEnumerator,
    >,
    pub enumerate_children_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub enumerate_children_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileEnumerator,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_filesystem_info: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_filesystem_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_filesystem_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub find_enclosing_mount: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GMount,
    >,
    pub find_enclosing_mount_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub find_enclosing_mount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GMount,
    >,
    pub set_display_name: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            display_name: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub set_display_name_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            display_name: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub set_display_name_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub query_settable_attributes: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileAttributeInfoList,
    >,
    pub _query_settable_attributes_async: ::std::option::Option<unsafe extern "C" fn()>,
    pub _query_settable_attributes_finish: ::std::option::Option<unsafe extern "C" fn()>,
    pub query_writable_namespaces: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileAttributeInfoList,
    >,
    pub _query_writable_namespaces_async: ::std::option::Option<unsafe extern "C" fn()>,
    pub _query_writable_namespaces_finish: ::std::option::Option<unsafe extern "C" fn()>,
    pub set_attribute: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attribute: *const ::std::os::raw::c_char,
            type_: GFileAttributeType,
            value_p: gpointer,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_attributes_from_info: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            info: *mut GFileInfo,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_attributes_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            info: *mut GFileInfo,
            flags: GFileQueryInfoFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub set_attributes_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            info: *mut *mut GFileInfo,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub read_fn: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInputStream,
    >,
    pub read_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub read_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInputStream,
    >,
    pub append_to: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub append_to_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub append_to_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub create_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub create_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub replace: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub replace_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub replace_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub delete_file: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub delete_file_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub delete_file_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub trash: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub trash_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub trash_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_directory: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_directory_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub make_directory_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_symbolic_link: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            symlink_value: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_symbolic_link_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            symlink_value: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub make_symbolic_link_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub copy_async: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub copy_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub move_: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub move_async: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub move_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub mount_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub mount_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub unmount_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub mount_enclosing_volume: ::std::option::Option<
        unsafe extern "C" fn(
            location: *mut GFile,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub mount_enclosing_volume_finish: ::std::option::Option<
        unsafe extern "C" fn(
            location: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub monitor_dir: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMonitorFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileMonitor,
    >,
    pub monitor_file: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMonitorFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileMonitor,
    >,
    pub open_readwrite: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub open_readwrite_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub open_readwrite_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub create_readwrite: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub create_readwrite_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub create_readwrite_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub replace_readwrite: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub replace_readwrite_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub replace_readwrite_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub start_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GDriveStartFlags,
            start_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub start_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub stop_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub stop_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub supports_thread_contexts: gboolean,
    pub unmount_mountable_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_mountable_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject_mountable_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_mountable_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub poll_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub poll_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub measure_disk_usage: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMeasureFlags,
            cancellable: *mut GCancellable,
            progress_callback: GFileMeasureProgressCallback,
            progress_data: gpointer,
            disk_usage: *mut guint64,
            num_dirs: *mut guint64,
            num_files: *mut guint64,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub measure_disk_usage_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMeasureFlags,
            io_priority: gint,
            cancellable: *mut GCancellable,
            progress_callback: GFileMeasureProgressCallback,
            progress_data: gpointer,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub measure_disk_usage_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            disk_usage: *mut guint64,
            num_dirs: *mut guint64,
            num_files: *mut guint64,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GFileIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileIface>(),
        840usize,
        concat!("Size of: ", stringify!(_GFileIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(dup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_native) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(is_native)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_uri_scheme) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(has_uri_scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_uri_scheme) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_uri_scheme)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_basename) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_basename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_path) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_uri) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_parse_name) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_parse_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_parent) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefix_matches) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(prefix_matches)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_relative_path) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_relative_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resolve_relative_path) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(resolve_relative_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_child_for_display_name) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_child_for_display_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate_children) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(enumerate_children)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate_children_async) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(enumerate_children_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate_children_finish) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(enumerate_children_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_async) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_info_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_finish) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_info_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_filesystem_info) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_filesystem_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_filesystem_info_async) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_filesystem_info_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).query_filesystem_info_finish) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_filesystem_info_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).find_enclosing_mount) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(find_enclosing_mount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).find_enclosing_mount_async) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(find_enclosing_mount_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).find_enclosing_mount_finish) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(find_enclosing_mount_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_display_name) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_display_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_display_name_async) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_display_name_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_display_name_finish) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_display_name_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_settable_attributes) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_settable_attributes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr)._query_settable_attributes_async) as usize - ptr as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_query_settable_attributes_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr)._query_settable_attributes_finish) as usize - ptr as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_query_settable_attributes_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_writable_namespaces) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_writable_namespaces)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr)._query_writable_namespaces_async) as usize - ptr as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_query_writable_namespaces_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr)._query_writable_namespaces_finish) as usize - ptr as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_query_writable_namespaces_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_attribute) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_attribute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_attributes_from_info) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_attributes_from_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_attributes_async) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_attributes_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_attributes_finish) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_attributes_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_fn) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(read_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_async) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(read_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_finish) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(read_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).append_to) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(append_to)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).append_to_async) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(append_to_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).append_to_finish) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(append_to_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_async) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_finish) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace_async) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace_finish) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_file) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(delete_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_file_async) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(delete_file_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delete_file_finish) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(delete_file_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trash) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(trash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trash_async) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(trash_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trash_finish) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(trash_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_directory) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_directory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_directory_async) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_directory_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_directory_finish) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_directory_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_symbolic_link) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_symbolic_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_symbolic_link_async) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_symbolic_link_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).make_symbolic_link_finish) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_symbolic_link_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy_async) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(copy_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy_finish) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(copy_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).move_) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(move_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).move_async) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(move_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).move_finish) as usize - ptr as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(move_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_mountable) as usize - ptr as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(mount_mountable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_mountable_finish) as usize - ptr as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(mount_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmount_mountable) as usize - ptr as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(unmount_mountable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmount_mountable_finish) as usize - ptr as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(unmount_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_mountable) as usize - ptr as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(eject_mountable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_mountable_finish) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(eject_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_enclosing_volume) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(mount_enclosing_volume)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).mount_enclosing_volume_finish) as usize - ptr as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(mount_enclosing_volume_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monitor_dir) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(monitor_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monitor_file) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(monitor_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open_readwrite) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(open_readwrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open_readwrite_async) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(open_readwrite_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open_readwrite_finish) as usize - ptr as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(open_readwrite_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_readwrite) as usize - ptr as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_readwrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_readwrite_async) as usize - ptr as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_readwrite_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_readwrite_finish) as usize - ptr as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_readwrite_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace_readwrite) as usize - ptr as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_readwrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace_readwrite_async) as usize - ptr as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_readwrite_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replace_readwrite_finish) as usize - ptr as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_readwrite_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_mountable) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(start_mountable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_mountable_finish) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(start_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_mountable) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(stop_mountable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_mountable_finish) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(stop_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_thread_contexts) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(supports_thread_contexts)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unmount_mountable_with_operation) as usize - ptr as usize
        },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(unmount_mountable_with_operation)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unmount_mountable_with_operation_finish) as usize
                - ptr as usize
        },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(unmount_mountable_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).eject_mountable_with_operation) as usize - ptr as usize
        },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(eject_mountable_with_operation)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).eject_mountable_with_operation_finish) as usize
                - ptr as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(eject_mountable_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll_mountable) as usize - ptr as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(poll_mountable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poll_mountable_finish) as usize - ptr as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(poll_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).measure_disk_usage) as usize - ptr as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(measure_disk_usage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).measure_disk_usage_async) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(measure_disk_usage_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).measure_disk_usage_finish) as usize - ptr as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(measure_disk_usage_finish)
        )
    );
}
extern "C" {
    pub fn g_file_get_type() -> GType;
}
extern "C" {
    pub fn g_file_new_for_path(path: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_for_uri(uri: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_for_commandline_arg(arg: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_for_commandline_arg_and_cwd(
        arg: *const gchar,
        cwd: *const gchar,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_tmp(
        tmpl: *const ::std::os::raw::c_char,
        iostream: *mut *mut GFileIOStream,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_tmp_async(
        tmpl: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_new_tmp_finish(
        result: *mut GAsyncResult,
        iostream: *mut *mut GFileIOStream,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_tmp_dir_async(
        tmpl: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_new_tmp_dir_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_parse_name(parse_name: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    pub fn g_file_new_build_filename(first_element: *const gchar, ...) -> *mut GFile;
}
extern "C" {
    pub fn g_file_dup(file: *mut GFile) -> *mut GFile;
}
extern "C" {
    pub fn g_file_hash(file: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_file_equal(file1: *mut GFile, file2: *mut GFile) -> gboolean;
}
extern "C" {
    pub fn g_file_get_basename(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_get_path(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_peek_path(file: *mut GFile) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_get_uri(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_get_parse_name(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_get_parent(file: *mut GFile) -> *mut GFile;
}
extern "C" {
    pub fn g_file_has_parent(file: *mut GFile, parent: *mut GFile) -> gboolean;
}
extern "C" {
    pub fn g_file_get_child(file: *mut GFile, name: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    pub fn g_file_get_child_for_display_name(
        file: *mut GFile,
        display_name: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_has_prefix(file: *mut GFile, prefix: *mut GFile) -> gboolean;
}
extern "C" {
    pub fn g_file_get_relative_path(
        parent: *mut GFile,
        descendant: *mut GFile,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_resolve_relative_path(
        file: *mut GFile,
        relative_path: *const ::std::os::raw::c_char,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_is_native(file: *mut GFile) -> gboolean;
}
extern "C" {
    pub fn g_file_has_uri_scheme(
        file: *mut GFile,
        uri_scheme: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_get_uri_scheme(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_read(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInputStream;
}
extern "C" {
    pub fn g_file_read_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_read_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInputStream;
}
extern "C" {
    pub fn g_file_append_to(
        file: *mut GFile,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    pub fn g_file_create(
        file: *mut GFile,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    pub fn g_file_replace(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    pub fn g_file_append_to_async(
        file: *mut GFile,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_append_to_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    pub fn g_file_create_async(
        file: *mut GFile,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_create_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    pub fn g_file_replace_async(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_replace_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    pub fn g_file_open_readwrite(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    pub fn g_file_open_readwrite_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_open_readwrite_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    pub fn g_file_create_readwrite(
        file: *mut GFile,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    pub fn g_file_create_readwrite_async(
        file: *mut GFile,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_create_readwrite_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    pub fn g_file_replace_readwrite(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    pub fn g_file_replace_readwrite_async(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_replace_readwrite_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    pub fn g_file_query_exists(file: *mut GFile, cancellable: *mut GCancellable) -> gboolean;
}
extern "C" {
    pub fn g_file_query_file_type(
        file: *mut GFile,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
    ) -> GFileType;
}
extern "C" {
    pub fn g_file_query_info(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_query_info_async(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_query_info_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_query_filesystem_info(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_query_filesystem_info_async(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_query_filesystem_info_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_find_enclosing_mount(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GMount;
}
extern "C" {
    pub fn g_file_find_enclosing_mount_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_find_enclosing_mount_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GMount;
}
extern "C" {
    pub fn g_file_enumerate_children(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileEnumerator;
}
extern "C" {
    pub fn g_file_enumerate_children_async(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_enumerate_children_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileEnumerator;
}
extern "C" {
    pub fn g_file_set_display_name(
        file: *mut GFile,
        display_name: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_set_display_name_async(
        file: *mut GFile,
        display_name: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_set_display_name_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_delete(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_delete_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_delete_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_trash(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_trash_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_trash_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_copy(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_copy_async(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_copy_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_move(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_move_async(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_move_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_make_directory(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_make_directory_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_make_directory_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_make_directory_with_parents(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_make_symbolic_link(
        file: *mut GFile,
        symlink_value: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_make_symbolic_link_async(
        file: *mut GFile,
        symlink_value: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_make_symbolic_link_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_query_settable_attributes(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileAttributeInfoList;
}
extern "C" {
    pub fn g_file_query_writable_namespaces(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileAttributeInfoList;
}
extern "C" {
    pub fn g_file_set_attribute(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        type_: GFileAttributeType,
        value_p: gpointer,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attributes_from_info(
        file: *mut GFile,
        info: *mut GFileInfo,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attributes_async(
        file: *mut GFile,
        info: *mut GFileInfo,
        flags: GFileQueryInfoFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_set_attributes_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        info: *mut *mut GFileInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attribute_string(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attribute_byte_string(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attribute_uint32(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: guint32,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attribute_int32(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: gint32,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attribute_uint64(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: guint64,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_attribute_int64(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: gint64,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_mount_enclosing_volume(
        location: *mut GFile,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_mount_enclosing_volume_finish(
        location: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_mount_mountable(
        file: *mut GFile,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_mount_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_unmount_mountable(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_unmount_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_unmount_mountable_with_operation(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_unmount_mountable_with_operation_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_eject_mountable(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_eject_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_eject_mountable_with_operation(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_eject_mountable_with_operation_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_build_attribute_list_for_copy(
        file: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_copy_attributes(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_monitor_directory(
        file: *mut GFile,
        flags: GFileMonitorFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileMonitor;
}
extern "C" {
    pub fn g_file_monitor_file(
        file: *mut GFile,
        flags: GFileMonitorFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileMonitor;
}
extern "C" {
    pub fn g_file_monitor(
        file: *mut GFile,
        flags: GFileMonitorFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileMonitor;
}
extern "C" {
    pub fn g_file_measure_disk_usage(
        file: *mut GFile,
        flags: GFileMeasureFlags,
        cancellable: *mut GCancellable,
        progress_callback: GFileMeasureProgressCallback,
        progress_data: gpointer,
        disk_usage: *mut guint64,
        num_dirs: *mut guint64,
        num_files: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_measure_disk_usage_async(
        file: *mut GFile,
        flags: GFileMeasureFlags,
        io_priority: gint,
        cancellable: *mut GCancellable,
        progress_callback: GFileMeasureProgressCallback,
        progress_data: gpointer,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_measure_disk_usage_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        disk_usage: *mut guint64,
        num_dirs: *mut guint64,
        num_files: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_start_mountable(
        file: *mut GFile,
        flags: GDriveStartFlags,
        start_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_start_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_stop_mountable(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_stop_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_poll_mountable(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_poll_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_query_default_handler(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_file_query_default_handler_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_query_default_handler_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
extern "C" {
    pub fn g_file_load_contents(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        contents: *mut *mut ::std::os::raw::c_char,
        length: *mut gsize,
        etag_out: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_load_contents_async(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_load_contents_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        contents: *mut *mut ::std::os::raw::c_char,
        length: *mut gsize,
        etag_out: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_load_partial_contents_async(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        read_more_callback: GFileReadMoreCallback,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_load_partial_contents_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        contents: *mut *mut ::std::os::raw::c_char,
        length: *mut gsize,
        etag_out: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_replace_contents(
        file: *mut GFile,
        contents: *const ::std::os::raw::c_char,
        length: gsize,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        new_etag: *mut *mut ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_replace_contents_async(
        file: *mut GFile,
        contents: *const ::std::os::raw::c_char,
        length: gsize,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_replace_contents_bytes_async(
        file: *mut GFile,
        contents: *mut GBytes,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_replace_contents_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        new_etag: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_supports_thread_contexts(file: *mut GFile) -> gboolean;
}
extern "C" {
    pub fn g_file_load_bytes(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        etag_out: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_file_load_bytes_async(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_load_bytes_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        etag_out: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
#[doc = " GFileAttributeInfo:\n @name: the name of the attribute.\n @type: the #GFileAttributeType type of the attribute.\n @flags: a set of #GFileAttributeInfoFlags.\n\n Information about a specific attribute."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileAttributeInfo {
    pub name: *mut ::std::os::raw::c_char,
    pub type_: GFileAttributeType,
    pub flags: GFileAttributeInfoFlags,
}
#[test]
fn bindgen_test_layout__GFileAttributeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileAttributeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileAttributeInfo>(),
        16usize,
        concat!("Size of: ", stringify!(_GFileAttributeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileAttributeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileAttributeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfo),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " GFileAttributeInfoList:\n @infos: an array of #GFileAttributeInfos.\n @n_infos: the number of values in the array.\n\n Acts as a lightweight registry for possible valid file attributes.\n The registry stores Key-Value pair formats as #GFileAttributeInfos."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileAttributeInfoList {
    pub infos: *mut GFileAttributeInfo,
    pub n_infos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__GFileAttributeInfoList() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileAttributeInfoList> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileAttributeInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(_GFileAttributeInfoList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileAttributeInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileAttributeInfoList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).infos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfoList),
            "::",
            stringify!(infos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_infos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfoList),
            "::",
            stringify!(n_infos)
        )
    );
}
extern "C" {
    pub fn g_file_attribute_info_list_get_type() -> GType;
}
extern "C" {
    pub fn g_file_attribute_info_list_new() -> *mut GFileAttributeInfoList;
}
extern "C" {
    pub fn g_file_attribute_info_list_ref(
        list: *mut GFileAttributeInfoList,
    ) -> *mut GFileAttributeInfoList;
}
extern "C" {
    pub fn g_file_attribute_info_list_unref(list: *mut GFileAttributeInfoList);
}
extern "C" {
    pub fn g_file_attribute_info_list_dup(
        list: *mut GFileAttributeInfoList,
    ) -> *mut GFileAttributeInfoList;
}
extern "C" {
    pub fn g_file_attribute_info_list_lookup(
        list: *mut GFileAttributeInfoList,
        name: *const ::std::os::raw::c_char,
    ) -> *const GFileAttributeInfo;
}
extern "C" {
    pub fn g_file_attribute_info_list_add(
        list: *mut GFileAttributeInfoList,
        name: *const ::std::os::raw::c_char,
        type_: GFileAttributeType,
        flags: GFileAttributeInfoFlags,
    );
}
#[doc = " GFileEnumerator:\n\n A per matched file iterator."]
pub type GFileEnumeratorClass = _GFileEnumeratorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileEnumeratorPrivate {
    _unused: [u8; 0],
}
pub type GFileEnumeratorPrivate = _GFileEnumeratorPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileEnumerator {
    pub parent_instance: GObject,
    pub priv_: *mut GFileEnumeratorPrivate,
}
#[test]
fn bindgen_test_layout__GFileEnumerator() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileEnumerator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileEnumerator>(),
        32usize,
        concat!("Size of: ", stringify!(_GFileEnumerator))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileEnumerator>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileEnumerator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumerator),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumerator),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileEnumeratorClass {
    pub parent_class: GObjectClass,
    pub next_file: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub next_files_async: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            num_files: ::std::os::raw::c_int,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub next_files_finish: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileEnumeratorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileEnumeratorClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileEnumeratorClass>(),
        240usize,
        concat!("Size of: ", stringify!(_GFileEnumeratorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileEnumeratorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileEnumeratorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_file) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(next_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_fn) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_files_async) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(next_files_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_files_finish) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(next_files_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_async) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(close_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_finish) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(close_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved7) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
}
extern "C" {
    pub fn g_file_enumerator_get_type() -> GType;
}
extern "C" {
    pub fn g_file_enumerator_next_file(
        enumerator: *mut GFileEnumerator,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_enumerator_close(
        enumerator: *mut GFileEnumerator,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_enumerator_next_files_async(
        enumerator: *mut GFileEnumerator,
        num_files: ::std::os::raw::c_int,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_enumerator_next_files_finish(
        enumerator: *mut GFileEnumerator,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_file_enumerator_close_async(
        enumerator: *mut GFileEnumerator,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_enumerator_close_finish(
        enumerator: *mut GFileEnumerator,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_enumerator_is_closed(enumerator: *mut GFileEnumerator) -> gboolean;
}
extern "C" {
    pub fn g_file_enumerator_has_pending(enumerator: *mut GFileEnumerator) -> gboolean;
}
extern "C" {
    pub fn g_file_enumerator_set_pending(enumerator: *mut GFileEnumerator, pending: gboolean);
}
extern "C" {
    pub fn g_file_enumerator_get_container(enumerator: *mut GFileEnumerator) -> *mut GFile;
}
extern "C" {
    pub fn g_file_enumerator_get_child(
        enumerator: *mut GFileEnumerator,
        info: *mut GFileInfo,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_file_enumerator_iterate(
        direnum: *mut GFileEnumerator,
        out_info: *mut *mut GFileInfo,
        out_child: *mut *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIconClass {
    _unused: [u8; 0],
}
#[doc = " GFileIcon:\n\n Gets an icon for a #GFile. Implements #GLoadableIcon."]
pub type GFileIconClass = _GFileIconClass;
extern "C" {
    pub fn g_file_icon_get_type() -> GType;
}
extern "C" {
    pub fn g_file_icon_new(file: *mut GFile) -> *mut GIcon;
}
extern "C" {
    pub fn g_file_icon_get_file(icon: *mut GFileIcon) -> *mut GFile;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInfoClass {
    _unused: [u8; 0],
}
#[doc = " GFileInfo:\n\n Stores information about a file system object referenced by a #GFile."]
pub type GFileInfoClass = _GFileInfoClass;
extern "C" {
    pub fn g_file_info_get_type() -> GType;
}
extern "C" {
    pub fn g_file_info_new() -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_info_dup(other: *mut GFileInfo) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_info_copy_into(src_info: *mut GFileInfo, dest_info: *mut GFileInfo);
}
extern "C" {
    pub fn g_file_info_has_attribute(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_info_has_namespace(
        info: *mut GFileInfo,
        name_space: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_info_list_attributes(
        info: *mut GFileInfo,
        name_space: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_attribute_data(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        type_: *mut GFileAttributeType,
        value_pp: *mut gpointer,
        status: *mut GFileAttributeStatus,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_info_get_attribute_type(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> GFileAttributeType;
}
extern "C" {
    pub fn g_file_info_remove_attribute(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_get_attribute_status(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> GFileAttributeStatus;
}
extern "C" {
    pub fn g_file_info_set_attribute_status(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        status: GFileAttributeStatus,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_info_get_attribute_as_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_attribute_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_attribute_byte_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_attribute_boolean(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_info_get_attribute_uint32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> guint32;
}
extern "C" {
    pub fn g_file_info_get_attribute_int32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gint32;
}
extern "C" {
    pub fn g_file_info_get_attribute_uint64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> guint64;
}
extern "C" {
    pub fn g_file_info_get_attribute_int64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gint64;
}
extern "C" {
    pub fn g_file_info_get_attribute_object(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *mut GObject;
}
extern "C" {
    pub fn g_file_info_get_attribute_stringv(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_set_attribute(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        type_: GFileAttributeType,
        value_p: gpointer,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_byte_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_boolean(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: gboolean,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_uint32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: guint32,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_int32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: gint32,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_uint64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: guint64,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_int64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: gint64,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_object(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *mut GObject,
    );
}
extern "C" {
    pub fn g_file_info_set_attribute_stringv(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_clear_status(info: *mut GFileInfo);
}
extern "C" {
    pub fn g_file_info_get_deletion_date(info: *mut GFileInfo) -> *mut GDateTime;
}
extern "C" {
    pub fn g_file_info_get_file_type(info: *mut GFileInfo) -> GFileType;
}
extern "C" {
    pub fn g_file_info_get_is_hidden(info: *mut GFileInfo) -> gboolean;
}
extern "C" {
    pub fn g_file_info_get_is_backup(info: *mut GFileInfo) -> gboolean;
}
extern "C" {
    pub fn g_file_info_get_is_symlink(info: *mut GFileInfo) -> gboolean;
}
extern "C" {
    pub fn g_file_info_get_name(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_display_name(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_edit_name(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_icon(info: *mut GFileInfo) -> *mut GIcon;
}
extern "C" {
    pub fn g_file_info_get_symbolic_icon(info: *mut GFileInfo) -> *mut GIcon;
}
extern "C" {
    pub fn g_file_info_get_content_type(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_size(info: *mut GFileInfo) -> goffset;
}
extern "C" {
    pub fn g_file_info_get_modification_time(info: *mut GFileInfo, result: *mut GTimeVal);
}
extern "C" {
    pub fn g_file_info_get_modification_date_time(info: *mut GFileInfo) -> *mut GDateTime;
}
extern "C" {
    pub fn g_file_info_get_access_date_time(info: *mut GFileInfo) -> *mut GDateTime;
}
extern "C" {
    pub fn g_file_info_get_creation_date_time(info: *mut GFileInfo) -> *mut GDateTime;
}
extern "C" {
    pub fn g_file_info_get_symlink_target(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_etag(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_info_get_sort_order(info: *mut GFileInfo) -> gint32;
}
extern "C" {
    pub fn g_file_info_set_attribute_mask(info: *mut GFileInfo, mask: *mut GFileAttributeMatcher);
}
extern "C" {
    pub fn g_file_info_unset_attribute_mask(info: *mut GFileInfo);
}
extern "C" {
    pub fn g_file_info_set_file_type(info: *mut GFileInfo, type_: GFileType);
}
extern "C" {
    pub fn g_file_info_set_is_hidden(info: *mut GFileInfo, is_hidden: gboolean);
}
extern "C" {
    pub fn g_file_info_set_is_symlink(info: *mut GFileInfo, is_symlink: gboolean);
}
extern "C" {
    pub fn g_file_info_set_name(info: *mut GFileInfo, name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_file_info_set_display_name(
        info: *mut GFileInfo,
        display_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_edit_name(
        info: *mut GFileInfo,
        edit_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_icon(info: *mut GFileInfo, icon: *mut GIcon);
}
extern "C" {
    pub fn g_file_info_set_symbolic_icon(info: *mut GFileInfo, icon: *mut GIcon);
}
extern "C" {
    pub fn g_file_info_set_content_type(
        info: *mut GFileInfo,
        content_type: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_size(info: *mut GFileInfo, size: goffset);
}
extern "C" {
    pub fn g_file_info_set_modification_time(info: *mut GFileInfo, mtime: *mut GTimeVal);
}
extern "C" {
    pub fn g_file_info_set_modification_date_time(info: *mut GFileInfo, mtime: *mut GDateTime);
}
extern "C" {
    pub fn g_file_info_set_access_date_time(info: *mut GFileInfo, atime: *mut GDateTime);
}
extern "C" {
    pub fn g_file_info_set_creation_date_time(info: *mut GFileInfo, creation_time: *mut GDateTime);
}
extern "C" {
    pub fn g_file_info_set_symlink_target(
        info: *mut GFileInfo,
        symlink_target: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_file_info_set_sort_order(info: *mut GFileInfo, sort_order: gint32);
}
extern "C" {
    pub fn g_file_attribute_matcher_get_type() -> GType;
}
extern "C" {
    pub fn g_file_attribute_matcher_new(
        attributes: *const ::std::os::raw::c_char,
    ) -> *mut GFileAttributeMatcher;
}
extern "C" {
    pub fn g_file_attribute_matcher_ref(
        matcher: *mut GFileAttributeMatcher,
    ) -> *mut GFileAttributeMatcher;
}
extern "C" {
    pub fn g_file_attribute_matcher_unref(matcher: *mut GFileAttributeMatcher);
}
extern "C" {
    pub fn g_file_attribute_matcher_subtract(
        matcher: *mut GFileAttributeMatcher,
        subtract: *mut GFileAttributeMatcher,
    ) -> *mut GFileAttributeMatcher;
}
extern "C" {
    pub fn g_file_attribute_matcher_matches(
        matcher: *mut GFileAttributeMatcher,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_attribute_matcher_matches_only(
        matcher: *mut GFileAttributeMatcher,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_attribute_matcher_enumerate_namespace(
        matcher: *mut GFileAttributeMatcher,
        ns: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_attribute_matcher_enumerate_next(
        matcher: *mut GFileAttributeMatcher,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_file_attribute_matcher_to_string(
        matcher: *mut GFileAttributeMatcher,
    ) -> *mut ::std::os::raw::c_char;
}
#[doc = " GFileInputStream:\n\n A subclass of GInputStream for opened files. This adds\n a few file-specific operations and seeking.\n\n #GFileInputStream implements #GSeekable."]
pub type GFileInputStreamClass = _GFileInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GFileInputStreamPrivate = _GFileInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInputStream {
    pub parent_instance: GInputStream,
    pub priv_: *mut GFileInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GFileInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileInputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileInputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFileInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub tell: ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileInputStream) -> goffset>,
    pub can_seek:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileInputStream) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileInputStreamClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GFileInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_seek) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(can_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(query_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_async) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(query_info_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_finish) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(query_info_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_file_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_file_input_stream_query_info(
        stream: *mut GFileInputStream,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_input_stream_query_info_async(
        stream: *mut GFileInputStream,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_input_stream_query_info_finish(
        stream: *mut GFileInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_io_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_io_error_from_errno(err_no: gint) -> GIOErrorEnum;
}
extern "C" {
    pub fn g_io_error_from_file_error(file_error: GFileError) -> GIOErrorEnum;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStreamPrivate {
    _unused: [u8; 0],
}
pub type GIOStreamPrivate = _GIOStreamPrivate;
pub type GIOStreamClass = _GIOStreamClass;
#[doc = " GIOStream:\n\n Base class for read-write streams."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStream {
    pub parent_instance: GObject,
    pub priv_: *mut GIOStreamPrivate,
}
#[test]
fn bindgen_test_layout__GIOStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GIOStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GIOStream>(),
        32usize,
        concat!("Size of: ", stringify!(_GIOStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStreamClass {
    pub parent_class: GObjectClass,
    pub get_input_stream:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GIOStream) -> *mut GInputStream>,
    pub get_output_stream:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GIOStream) -> *mut GOutputStream>,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GIOStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GIOStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GIOStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved10: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GIOStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GIOStreamClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GIOStreamClass>(),
        256usize,
        concat!("Size of: ", stringify!(_GIOStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_input_stream) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(get_input_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_output_stream) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(get_output_stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_fn) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_async) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(close_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_finish) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(close_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved7) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved8) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved9) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved10) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved10)
        )
    );
}
extern "C" {
    pub fn g_io_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_io_stream_get_input_stream(stream: *mut GIOStream) -> *mut GInputStream;
}
extern "C" {
    pub fn g_io_stream_get_output_stream(stream: *mut GIOStream) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_io_stream_splice_async(
        stream1: *mut GIOStream,
        stream2: *mut GIOStream,
        flags: GIOStreamSpliceFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_io_stream_splice_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_io_stream_close(
        stream: *mut GIOStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_io_stream_close_async(
        stream: *mut GIOStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_io_stream_close_finish(
        stream: *mut GIOStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_io_stream_is_closed(stream: *mut GIOStream) -> gboolean;
}
extern "C" {
    pub fn g_io_stream_has_pending(stream: *mut GIOStream) -> gboolean;
}
extern "C" {
    pub fn g_io_stream_set_pending(stream: *mut GIOStream, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_io_stream_clear_pending(stream: *mut GIOStream);
}
#[doc = " GFileIOStream:\n\n A subclass of GIOStream for opened files. This adds\n a few file-specific operations and seeking and truncating.\n\n #GFileIOStream implements GSeekable."]
pub type GFileIOStreamClass = _GFileIOStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIOStreamPrivate {
    _unused: [u8; 0],
}
pub type GFileIOStreamPrivate = _GFileIOStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIOStream {
    pub parent_instance: GIOStream,
    pub priv_: *mut GFileIOStreamPrivate,
}
#[test]
fn bindgen_test_layout__GFileIOStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileIOStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileIOStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFileIOStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileIOStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileIOStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIOStreamClass {
    pub parent_class: GIOStreamClass,
    pub tell: ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileIOStream) -> goffset>,
    pub can_seek:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileIOStream) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_truncate:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileIOStream) -> gboolean>,
    pub truncate_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            size: goffset,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub get_etag: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut GFileIOStream) -> *mut ::std::os::raw::c_char,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileIOStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileIOStreamClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileIOStreamClass>(),
        368usize,
        concat!("Size of: ", stringify!(_GFileIOStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileIOStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileIOStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_seek) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(can_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_truncate) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(can_truncate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate_fn) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(truncate_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(query_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_async) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(query_info_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_finish) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(query_info_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_etag) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(get_etag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_file_io_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_file_io_stream_query_info(
        stream: *mut GFileIOStream,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_io_stream_query_info_async(
        stream: *mut GFileIOStream,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_io_stream_query_info_finish(
        stream: *mut GFileIOStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_io_stream_get_etag(stream: *mut GFileIOStream) -> *mut ::std::os::raw::c_char;
}
pub type GFileMonitorClass = _GFileMonitorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileMonitorPrivate {
    _unused: [u8; 0],
}
pub type GFileMonitorPrivate = _GFileMonitorPrivate;
#[doc = " GFileMonitor:\n\n Watches for changes to a file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileMonitor {
    pub parent_instance: GObject,
    pub priv_: *mut GFileMonitorPrivate,
}
#[test]
fn bindgen_test_layout__GFileMonitor() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileMonitor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileMonitor>(),
        32usize,
        concat!("Size of: ", stringify!(_GFileMonitor))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileMonitor>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileMonitor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitor),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitor),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileMonitorClass {
    pub parent_class: GObjectClass,
    pub changed: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GFileMonitor,
            file: *mut GFile,
            other_file: *mut GFile,
            event_type: GFileMonitorEvent,
        ),
    >,
    pub cancel: ::std::option::Option<unsafe extern "C" fn(monitor: *mut GFileMonitor) -> gboolean>,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileMonitorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileMonitorClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileMonitorClass>(),
        192usize,
        concat!("Size of: ", stringify!(_GFileMonitorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileMonitorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileMonitorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changed) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(cancel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_file_monitor_get_type() -> GType;
}
extern "C" {
    pub fn g_file_monitor_cancel(monitor: *mut GFileMonitor) -> gboolean;
}
extern "C" {
    pub fn g_file_monitor_is_cancelled(monitor: *mut GFileMonitor) -> gboolean;
}
extern "C" {
    pub fn g_file_monitor_set_rate_limit(monitor: *mut GFileMonitor, limit_msecs: gint);
}
extern "C" {
    pub fn g_file_monitor_emit_event(
        monitor: *mut GFileMonitor,
        child: *mut GFile,
        other_file: *mut GFile,
        event_type: GFileMonitorEvent,
    );
}
#[doc = " GFilenameCompleter:\n\n Completes filenames based on files that exist within the file system."]
pub type GFilenameCompleterClass = _GFilenameCompleterClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilenameCompleterClass {
    pub parent_class: GObjectClass,
    pub got_completion_data:
        ::std::option::Option<unsafe extern "C" fn(filename_completer: *mut GFilenameCompleter)>,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFilenameCompleterClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFilenameCompleterClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFilenameCompleterClass>(),
        168usize,
        concat!("Size of: ", stringify!(_GFilenameCompleterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilenameCompleterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilenameCompleterClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).got_completion_data) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(got_completion_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
}
extern "C" {
    pub fn g_filename_completer_get_type() -> GType;
}
extern "C" {
    pub fn g_filename_completer_new() -> *mut GFilenameCompleter;
}
extern "C" {
    pub fn g_filename_completer_get_completion_suffix(
        completer: *mut GFilenameCompleter,
        initial_text: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_filename_completer_get_completions(
        completer: *mut GFilenameCompleter,
        initial_text: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_filename_completer_set_dirs_only(
        completer: *mut GFilenameCompleter,
        dirs_only: gboolean,
    );
}
#[doc = " GFileOutputStream:\n\n A subclass of GOutputStream for opened files. This adds\n a few file-specific operations and seeking and truncating.\n\n #GFileOutputStream implements GSeekable."]
pub type GFileOutputStreamClass = _GFileOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GFileOutputStreamPrivate = _GFileOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileOutputStream {
    pub parent_instance: GOutputStream,
    pub priv_: *mut GFileOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GFileOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileOutputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileOutputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFileOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub tell:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileOutputStream) -> goffset>,
    pub can_seek:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileOutputStream) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_truncate:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileOutputStream) -> gboolean>,
    pub truncate_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            size: goffset,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub get_etag: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut GFileOutputStream) -> *mut ::std::os::raw::c_char,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GFileOutputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GFileOutputStreamClass>(),
        408usize,
        concat!("Size of: ", stringify!(_GFileOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_seek) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(can_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_truncate) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(can_truncate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate_fn) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(truncate_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(query_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_async) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(query_info_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).query_info_finish) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(query_info_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_etag) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(get_etag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_file_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_file_output_stream_query_info(
        stream: *mut GFileOutputStream,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_output_stream_query_info_async(
        stream: *mut GFileOutputStream,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_file_output_stream_query_info_finish(
        stream: *mut GFileOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_file_output_stream_get_etag(
        stream: *mut GFileOutputStream,
    ) -> *mut ::std::os::raw::c_char;
}
pub type GInetAddressClass = _GInetAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressPrivate {
    _unused: [u8; 0],
}
pub type GInetAddressPrivate = _GInetAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddress {
    pub parent_instance: GObject,
    pub priv_: *mut GInetAddressPrivate,
}
#[test]
fn bindgen_test_layout__GInetAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GInetAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInetAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GInetAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressClass {
    pub parent_class: GObjectClass,
    pub to_string:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GInetAddress) -> *mut gchar>,
    pub to_bytes:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GInetAddress) -> *const guint8>,
}
#[test]
fn bindgen_test_layout__GInetAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GInetAddressClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInetAddressClass>(),
        152usize,
        concat!("Size of: ", stringify!(_GInetAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_string) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressClass),
            "::",
            stringify!(to_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_bytes) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressClass),
            "::",
            stringify!(to_bytes)
        )
    );
}
extern "C" {
    pub fn g_inet_address_get_type() -> GType;
}
extern "C" {
    pub fn g_inet_address_new_from_string(string: *const gchar) -> *mut GInetAddress;
}
extern "C" {
    pub fn g_inet_address_new_from_bytes(
        bytes: *const guint8,
        family: GSocketFamily,
    ) -> *mut GInetAddress;
}
extern "C" {
    pub fn g_inet_address_new_loopback(family: GSocketFamily) -> *mut GInetAddress;
}
extern "C" {
    pub fn g_inet_address_new_any(family: GSocketFamily) -> *mut GInetAddress;
}
extern "C" {
    pub fn g_inet_address_equal(
        address: *mut GInetAddress,
        other_address: *mut GInetAddress,
    ) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_to_string(address: *mut GInetAddress) -> *mut gchar;
}
extern "C" {
    pub fn g_inet_address_to_bytes(address: *mut GInetAddress) -> *const guint8;
}
extern "C" {
    pub fn g_inet_address_get_native_size(address: *mut GInetAddress) -> gsize;
}
extern "C" {
    pub fn g_inet_address_get_family(address: *mut GInetAddress) -> GSocketFamily;
}
extern "C" {
    pub fn g_inet_address_get_is_any(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_loopback(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_link_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_site_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_multicast(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_mc_global(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_mc_link_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_mc_node_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_mc_org_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_get_is_mc_site_local(address: *mut GInetAddress) -> gboolean;
}
pub type GInetAddressMaskClass = _GInetAddressMaskClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressMaskPrivate {
    _unused: [u8; 0],
}
pub type GInetAddressMaskPrivate = _GInetAddressMaskPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressMask {
    pub parent_instance: GObject,
    pub priv_: *mut GInetAddressMaskPrivate,
}
#[test]
fn bindgen_test_layout__GInetAddressMask() {
    const UNINIT: ::std::mem::MaybeUninit<_GInetAddressMask> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInetAddressMask>(),
        32usize,
        concat!("Size of: ", stringify!(_GInetAddressMask))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetAddressMask>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetAddressMask))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressMask),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressMask),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressMaskClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GInetAddressMaskClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GInetAddressMaskClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInetAddressMaskClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GInetAddressMaskClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetAddressMaskClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetAddressMaskClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressMaskClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_inet_address_mask_get_type() -> GType;
}
extern "C" {
    pub fn g_inet_address_mask_new(
        addr: *mut GInetAddress,
        length: guint,
        error: *mut *mut GError,
    ) -> *mut GInetAddressMask;
}
extern "C" {
    pub fn g_inet_address_mask_new_from_string(
        mask_string: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GInetAddressMask;
}
extern "C" {
    pub fn g_inet_address_mask_to_string(mask: *mut GInetAddressMask) -> *mut gchar;
}
extern "C" {
    pub fn g_inet_address_mask_get_family(mask: *mut GInetAddressMask) -> GSocketFamily;
}
extern "C" {
    pub fn g_inet_address_mask_get_address(mask: *mut GInetAddressMask) -> *mut GInetAddress;
}
extern "C" {
    pub fn g_inet_address_mask_get_length(mask: *mut GInetAddressMask) -> guint;
}
extern "C" {
    pub fn g_inet_address_mask_matches(
        mask: *mut GInetAddressMask,
        address: *mut GInetAddress,
    ) -> gboolean;
}
extern "C" {
    pub fn g_inet_address_mask_equal(
        mask: *mut GInetAddressMask,
        mask2: *mut GInetAddressMask,
    ) -> gboolean;
}
pub type GSocketAddressClass = _GSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketAddress {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__GSocketAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketAddress>(),
        24usize,
        concat!("Size of: ", stringify!(_GSocketAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddress),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketAddressClass {
    pub parent_class: GObjectClass,
    pub get_family:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GSocketAddress) -> GSocketFamily>,
    pub get_native_size:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GSocketAddress) -> gssize>,
    pub to_native: ::std::option::Option<
        unsafe extern "C" fn(
            address: *mut GSocketAddress,
            dest: gpointer,
            destlen: gsize,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GSocketAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketAddressClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GSocketAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_family) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressClass),
            "::",
            stringify!(get_family)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_native_size) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressClass),
            "::",
            stringify!(get_native_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_native) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressClass),
            "::",
            stringify!(to_native)
        )
    );
}
extern "C" {
    pub fn g_socket_address_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_address_get_family(address: *mut GSocketAddress) -> GSocketFamily;
}
extern "C" {
    pub fn g_socket_address_new_from_native(native: gpointer, len: gsize) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_address_to_native(
        address: *mut GSocketAddress,
        dest: gpointer,
        destlen: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_address_get_native_size(address: *mut GSocketAddress) -> gssize;
}
pub type GInetSocketAddressClass = _GInetSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetSocketAddressPrivate {
    _unused: [u8; 0],
}
pub type GInetSocketAddressPrivate = _GInetSocketAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetSocketAddress {
    pub parent_instance: GSocketAddress,
    pub priv_: *mut GInetSocketAddressPrivate,
}
#[test]
fn bindgen_test_layout__GInetSocketAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GInetSocketAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInetSocketAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GInetSocketAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetSocketAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetSocketAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetSocketAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}
#[test]
fn bindgen_test_layout__GInetSocketAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GInetSocketAddressClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GInetSocketAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GInetSocketAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetSocketAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetSocketAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetSocketAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_inet_socket_address_get_type() -> GType;
}
extern "C" {
    pub fn g_inet_socket_address_new(
        address: *mut GInetAddress,
        port: guint16,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_inet_socket_address_new_from_string(
        address: *const ::std::os::raw::c_char,
        port: guint,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_inet_socket_address_get_address(address: *mut GInetSocketAddress)
        -> *mut GInetAddress;
}
extern "C" {
    pub fn g_inet_socket_address_get_port(address: *mut GInetSocketAddress) -> guint16;
}
extern "C" {
    pub fn g_inet_socket_address_get_flowinfo(address: *mut GInetSocketAddress) -> guint32;
}
extern "C" {
    pub fn g_inet_socket_address_get_scope_id(address: *mut GInetSocketAddress) -> guint32;
}
extern "C" {
    pub fn g_app_info_create_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_converter_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_converter_result_get_type() -> GType;
}
extern "C" {
    pub fn g_data_stream_byte_order_get_type() -> GType;
}
extern "C" {
    pub fn g_data_stream_newline_type_get_type() -> GType;
}
extern "C" {
    pub fn g_file_attribute_type_get_type() -> GType;
}
extern "C" {
    pub fn g_file_attribute_info_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_file_attribute_status_get_type() -> GType;
}
extern "C" {
    pub fn g_file_query_info_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_file_create_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_file_measure_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_mount_mount_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_mount_unmount_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_drive_start_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_drive_start_stop_type_get_type() -> GType;
}
extern "C" {
    pub fn g_file_copy_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_file_monitor_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_file_type_get_type() -> GType;
}
extern "C" {
    pub fn g_filesystem_preview_type_get_type() -> GType;
}
extern "C" {
    pub fn g_file_monitor_event_get_type() -> GType;
}
extern "C" {
    pub fn g_io_error_enum_get_type() -> GType;
}
extern "C" {
    pub fn g_ask_password_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_password_save_get_type() -> GType;
}
extern "C" {
    pub fn g_mount_operation_result_get_type() -> GType;
}
extern "C" {
    pub fn g_output_stream_splice_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_io_stream_splice_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_emblem_origin_get_type() -> GType;
}
extern "C" {
    pub fn g_resolver_error_get_type() -> GType;
}
extern "C" {
    pub fn g_resolver_record_type_get_type() -> GType;
}
extern "C" {
    pub fn g_resource_error_get_type() -> GType;
}
extern "C" {
    pub fn g_resource_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_resource_lookup_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_family_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_type_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_msg_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_protocol_get_type() -> GType;
}
extern "C" {
    pub fn g_zlib_compressor_format_get_type() -> GType;
}
extern "C" {
    pub fn g_unix_socket_address_type_get_type() -> GType;
}
extern "C" {
    pub fn g_bus_type_get_type() -> GType;
}
extern "C" {
    pub fn g_bus_name_owner_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_bus_name_watcher_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_proxy_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_error_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_connection_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_capability_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_call_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_message_type_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_message_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_message_header_field_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_property_info_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_subtree_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_server_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_signal_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_send_message_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_credentials_type_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_message_byte_order_get_type() -> GType;
}
extern "C" {
    pub fn g_application_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_error_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_certificate_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_authentication_mode_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_channel_binding_type_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_channel_binding_error_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_rehandshake_mode_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_password_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_interaction_result_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_interface_skeleton_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_dbus_object_manager_client_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_database_verify_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_database_lookup_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_certificate_request_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_protocol_version_get_type() -> GType;
}
extern "C" {
    pub fn g_io_module_scope_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_client_event_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_listener_event_get_type() -> GType;
}
extern "C" {
    pub fn g_test_dbus_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_subprocess_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_notification_priority_get_type() -> GType;
}
extern "C" {
    pub fn g_network_connectivity_get_type() -> GType;
}
extern "C" {
    pub fn g_pollable_return_get_type() -> GType;
}
extern "C" {
    pub fn g_memory_monitor_warning_level_get_type() -> GType;
}
extern "C" {
    pub fn g_resolver_name_lookup_flags_get_type() -> GType;
}
extern "C" {
    pub fn g_settings_bind_flags_get_type() -> GType;
}
pub const GModuleFlags_G_MODULE_BIND_LAZY: GModuleFlags = 1;
pub const GModuleFlags_G_MODULE_BIND_LOCAL: GModuleFlags = 2;
pub const GModuleFlags_G_MODULE_BIND_MASK: GModuleFlags = 3;
#[doc = " GModuleFlags:\n @G_MODULE_BIND_LAZY: specifies that symbols are only resolved when\n     needed. The default action is to bind all symbols when the module\n     is loaded.\n @G_MODULE_BIND_LOCAL: specifies that symbols in the module should\n     not be added to the global name space. The default action on most\n     platforms is to place symbols in the module in the global name space,\n     which may cause conflicts with existing symbols.\n @G_MODULE_BIND_MASK: mask for all flags.\n\n Flags passed to g_module_open().\n Note that these flags are not supported on all platforms."]
pub type GModuleFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GModule {
    _unused: [u8; 0],
}
pub type GModule = _GModule;
pub type GModuleCheckInit =
    ::std::option::Option<unsafe extern "C" fn(module: *mut GModule) -> *const gchar>;
pub type GModuleUnload = ::std::option::Option<unsafe extern "C" fn(module: *mut GModule)>;
extern "C" {
    pub fn g_module_error_quark() -> GQuark;
}
pub const GModuleError_G_MODULE_ERROR_FAILED: GModuleError = 0;
pub const GModuleError_G_MODULE_ERROR_CHECK_FAILED: GModuleError = 1;
#[doc = " GModuleError:\n @G_MODULE_ERROR_FAILED: there was an error loading or opening a module file\n @G_MODULE_ERROR_CHECK_FAILED: a module returned an error from its `g_module_check_init()` function\n\n Errors returned by g_module_open_full().\n\n Since: 2.70"]
pub type GModuleError = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_module_supported() -> gboolean;
}
extern "C" {
    pub fn g_module_open(file_name: *const gchar, flags: GModuleFlags) -> *mut GModule;
}
extern "C" {
    pub fn g_module_open_full(
        file_name: *const gchar,
        flags: GModuleFlags,
        error: *mut *mut GError,
    ) -> *mut GModule;
}
extern "C" {
    pub fn g_module_close(module: *mut GModule) -> gboolean;
}
extern "C" {
    pub fn g_module_make_resident(module: *mut GModule);
}
extern "C" {
    pub fn g_module_error() -> *const gchar;
}
extern "C" {
    pub fn g_module_symbol(
        module: *mut GModule,
        symbol_name: *const gchar,
        symbol: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_module_name(module: *mut GModule) -> *const gchar;
}
extern "C" {
    pub fn g_module_build_path(directory: *const gchar, module_name: *const gchar) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOModuleScope {
    _unused: [u8; 0],
}
pub type GIOModuleScope = _GIOModuleScope;
extern "C" {
    pub fn g_io_module_scope_new(flags: GIOModuleScopeFlags) -> *mut GIOModuleScope;
}
extern "C" {
    pub fn g_io_module_scope_free(scope: *mut GIOModuleScope);
}
extern "C" {
    pub fn g_io_module_scope_block(scope: *mut GIOModuleScope, basename: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOModuleClass {
    _unused: [u8; 0],
}
#[doc = " GIOModule:\n\n Opaque module base class for extending GIO."]
pub type GIOModuleClass = _GIOModuleClass;
extern "C" {
    pub fn g_io_module_get_type() -> GType;
}
extern "C" {
    pub fn g_io_module_new(filename: *const gchar) -> *mut GIOModule;
}
extern "C" {
    pub fn g_io_modules_scan_all_in_directory(dirname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn g_io_modules_load_all_in_directory(dirname: *const gchar) -> *mut GList;
}
extern "C" {
    pub fn g_io_modules_scan_all_in_directory_with_scope(
        dirname: *const gchar,
        scope: *mut GIOModuleScope,
    );
}
extern "C" {
    pub fn g_io_modules_load_all_in_directory_with_scope(
        dirname: *const gchar,
        scope: *mut GIOModuleScope,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_io_extension_point_register(
        name: *const ::std::os::raw::c_char,
    ) -> *mut GIOExtensionPoint;
}
extern "C" {
    pub fn g_io_extension_point_lookup(
        name: *const ::std::os::raw::c_char,
    ) -> *mut GIOExtensionPoint;
}
extern "C" {
    pub fn g_io_extension_point_set_required_type(
        extension_point: *mut GIOExtensionPoint,
        type_: GType,
    );
}
extern "C" {
    pub fn g_io_extension_point_get_required_type(extension_point: *mut GIOExtensionPoint)
        -> GType;
}
extern "C" {
    pub fn g_io_extension_point_get_extensions(
        extension_point: *mut GIOExtensionPoint,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_io_extension_point_get_extension_by_name(
        extension_point: *mut GIOExtensionPoint,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GIOExtension;
}
extern "C" {
    pub fn g_io_extension_point_implement(
        extension_point_name: *const ::std::os::raw::c_char,
        type_: GType,
        extension_name: *const ::std::os::raw::c_char,
        priority: gint,
    ) -> *mut GIOExtension;
}
extern "C" {
    pub fn g_io_extension_get_type(extension: *mut GIOExtension) -> GType;
}
extern "C" {
    pub fn g_io_extension_get_name(extension: *mut GIOExtension) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_io_extension_get_priority(extension: *mut GIOExtension) -> gint;
}
extern "C" {
    pub fn g_io_extension_ref_class(extension: *mut GIOExtension) -> *mut GTypeClass;
}
extern "C" {
    #[doc = " g_io_module_load: (skip)\n @module: a #GIOModule.\n\n Required API for GIO modules to implement.\n\n This function is run after the module has been loaded into GIO,\n to initialize the module. Typically, this function will call\n g_io_extension_point_implement().\n\n Since 2.56, this function should be named `g_io_<modulename>_load`, where\n `modulename` is the plugins filename with the `lib` or `libgio` prefix and\n everything after the first dot removed, and with `-` replaced with `_`\n throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.\n Using the new symbol names avoids name clashes when building modules\n statically. The old symbol names continue to be supported, but cannot be used\n for static builds."]
    pub fn g_io_module_load(module: *mut GIOModule);
}
extern "C" {
    #[doc = " g_io_module_unload: (skip)\n @module: a #GIOModule.\n\n Required API for GIO modules to implement.\n\n This function is run when the module is being unloaded from GIO,\n to finalize the module.\n\n Since 2.56, this function should be named `g_io_<modulename>_unload`, where\n `modulename` is the plugins filename with the `lib` or `libgio` prefix and\n everything after the first dot removed, and with `-` replaced with `_`\n throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.\n Using the new symbol names avoids name clashes when building modules\n statically. The old symbol names continue to be supported, but cannot be used\n for static builds."]
    pub fn g_io_module_unload(module: *mut GIOModule);
}
extern "C" {
    #[doc = " g_io_module_query:\n\n Optional API for GIO modules to implement.\n\n Should return a list of all the extension points that may be\n implemented in this module.\n\n This method will not be called in normal use, however it may be\n called when probing existing modules and recording which extension\n points that this model is used for. This means we won't have to\n load and initialize this module unless its needed.\n\n If this function is not implemented by the module the module will\n always be loaded, initialized and then unloaded on application\n startup so that it can register its extension points during init.\n\n Note that a module need not actually implement all the extension\n points that g_io_module_query() returns, since the exact list of\n extension may depend on runtime issues. However all extension\n points actually implemented must be returned by g_io_module_query()\n (if defined).\n\n When installing a module that implements g_io_module_query() you must\n run gio-querymodules in order to build the cache files required for\n lazy loading.\n\n Since 2.56, this function should be named `g_io_<modulename>_query`, where\n `modulename` is the plugins filename with the `lib` or `libgio` prefix and\n everything after the first dot removed, and with `-` replaced with `_`\n throughout. For example, `libgiognutls-helper.so` becomes `gnutls_helper`.\n Using the new symbol names avoids name clashes when building modules\n statically. The old symbol names continue to be supported, but cannot be used\n for static builds.\n\n Returns: (transfer full): A %NULL-terminated array of strings,\n     listing the supported extension points of the module. The array\n     must be suitable for freeing with g_strfreev().\n\n Since: 2.24"]
    pub fn g_io_module_query() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_io_scheduler_push_job(
        job_func: GIOSchedulerJobFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
        io_priority: gint,
        cancellable: *mut GCancellable,
    );
}
extern "C" {
    pub fn g_io_scheduler_cancel_all_jobs();
}
extern "C" {
    pub fn g_io_scheduler_job_send_to_mainloop(
        job: *mut GIOSchedulerJob,
        func: GSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_io_scheduler_job_send_to_mainloop_async(
        job: *mut GIOSchedulerJob,
        func: GSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_list_model_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GListModel {
    _unused: [u8; 0],
}
pub type GListModel = _GListModel;
pub type GListModelInterface = _GListModelInterface;
pub type GListModel_autoptr = *mut GListModel;
pub type GListModel_listautoptr = *mut GList;
pub type GListModel_slistautoptr = *mut GSList;
pub type GListModel_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GListModelInterface {
    pub g_iface: GTypeInterface,
    pub get_item_type: ::std::option::Option<unsafe extern "C" fn(list: *mut GListModel) -> GType>,
    pub get_n_items: ::std::option::Option<unsafe extern "C" fn(list: *mut GListModel) -> guint>,
    pub get_item: ::std::option::Option<
        unsafe extern "C" fn(list: *mut GListModel, position: guint) -> gpointer,
    >,
}
#[test]
fn bindgen_test_layout__GListModelInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GListModelInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GListModelInterface>(),
        40usize,
        concat!("Size of: ", stringify!(_GListModelInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GListModelInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GListModelInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GListModelInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_item_type) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GListModelInterface),
            "::",
            stringify!(get_item_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_n_items) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GListModelInterface),
            "::",
            stringify!(get_n_items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_item) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GListModelInterface),
            "::",
            stringify!(get_item)
        )
    );
}
extern "C" {
    pub fn g_list_model_get_item_type(list: *mut GListModel) -> GType;
}
extern "C" {
    pub fn g_list_model_get_n_items(list: *mut GListModel) -> guint;
}
extern "C" {
    pub fn g_list_model_get_item(list: *mut GListModel, position: guint) -> gpointer;
}
extern "C" {
    pub fn g_list_model_get_object(list: *mut GListModel, position: guint) -> *mut GObject;
}
extern "C" {
    pub fn g_list_model_items_changed(
        list: *mut GListModel,
        position: guint,
        removed: guint,
        added: guint,
    );
}
extern "C" {
    pub fn g_list_store_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GListStore {
    _unused: [u8; 0],
}
pub type GListStore = _GListStore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GListStoreClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout_GListStoreClass() {
    const UNINIT: ::std::mem::MaybeUninit<GListStoreClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GListStoreClass>(),
        136usize,
        concat!("Size of: ", stringify!(GListStoreClass))
    );
    assert_eq!(
        ::std::mem::align_of::<GListStoreClass>(),
        8usize,
        concat!("Alignment of ", stringify!(GListStoreClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GListStoreClass),
            "::",
            stringify!(parent_class)
        )
    );
}
pub type GListStore_autoptr = *mut GListStore;
pub type GListStore_listautoptr = *mut GList;
pub type GListStore_slistautoptr = *mut GSList;
pub type GListStore_queueautoptr = *mut GQueue;
pub type GListStoreClass_autoptr = *mut GListStoreClass;
pub type GListStoreClass_listautoptr = *mut GList;
pub type GListStoreClass_slistautoptr = *mut GSList;
pub type GListStoreClass_queueautoptr = *mut GQueue;
extern "C" {
    pub fn g_list_store_new(item_type: GType) -> *mut GListStore;
}
extern "C" {
    pub fn g_list_store_insert(store: *mut GListStore, position: guint, item: gpointer);
}
extern "C" {
    pub fn g_list_store_insert_sorted(
        store: *mut GListStore,
        item: gpointer,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_list_store_sort(
        store: *mut GListStore,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_list_store_append(store: *mut GListStore, item: gpointer);
}
extern "C" {
    pub fn g_list_store_remove(store: *mut GListStore, position: guint);
}
extern "C" {
    pub fn g_list_store_remove_all(store: *mut GListStore);
}
extern "C" {
    pub fn g_list_store_splice(
        store: *mut GListStore,
        position: guint,
        n_removals: guint,
        additions: *mut gpointer,
        n_additions: guint,
    );
}
extern "C" {
    pub fn g_list_store_find(
        store: *mut GListStore,
        item: gpointer,
        position: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_list_store_find_with_equal_func(
        store: *mut GListStore,
        item: gpointer,
        equal_func: GEqualFunc,
        position: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_list_store_find_with_equal_func_full(
        store: *mut GListStore,
        item: gpointer,
        equal_func: GEqualFuncFull,
        user_data: gpointer,
        position: *mut guint,
    ) -> gboolean;
}
#[doc = " GLoadableIcon:\n\n Generic type for all kinds of icons that can be loaded\n as a stream."]
pub type GLoadableIconIface = _GLoadableIconIface;
#[doc = " GLoadableIconIface:\n @g_iface: The parent interface.\n @load: Loads an icon.\n @load_async: Loads an icon asynchronously.\n @load_finish: Finishes an asynchronous icon load.\n\n Interface for icons that can be loaded as a stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLoadableIconIface {
    pub g_iface: GTypeInterface,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GLoadableIcon,
            size: ::std::os::raw::c_int,
            type_: *mut *mut ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GInputStream,
    >,
    pub load_async: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GLoadableIcon,
            size: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub load_finish: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GLoadableIcon,
            res: *mut GAsyncResult,
            type_: *mut *mut ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> *mut GInputStream,
    >,
}
#[test]
fn bindgen_test_layout__GLoadableIconIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GLoadableIconIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GLoadableIconIface>(),
        40usize,
        concat!("Size of: ", stringify!(_GLoadableIconIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GLoadableIconIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GLoadableIconIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLoadableIconIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLoadableIconIface),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_async) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLoadableIconIface),
            "::",
            stringify!(load_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).load_finish) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLoadableIconIface),
            "::",
            stringify!(load_finish)
        )
    );
}
extern "C" {
    pub fn g_loadable_icon_get_type() -> GType;
}
extern "C" {
    pub fn g_loadable_icon_load(
        icon: *mut GLoadableIcon,
        size: ::std::os::raw::c_int,
        type_: *mut *mut ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_loadable_icon_load_async(
        icon: *mut GLoadableIcon,
        size: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_loadable_icon_load_finish(
        icon: *mut GLoadableIcon,
        res: *mut GAsyncResult,
        type_: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
#[doc = " GMemoryInputStream:\n\n Implements #GInputStream for arbitrary memory chunks."]
pub type GMemoryInputStreamClass = _GMemoryInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GMemoryInputStreamPrivate = _GMemoryInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryInputStream {
    pub parent_instance: GInputStream,
    pub priv_: *mut GMemoryInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GMemoryInputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemoryInputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemoryInputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GMemoryInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryInputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GMemoryInputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemoryInputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemoryInputStreamClass>(),
        288usize,
        concat!("Size of: ", stringify!(_GMemoryInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryInputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_memory_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_memory_input_stream_new() -> *mut GInputStream;
}
extern "C" {
    pub fn g_memory_input_stream_new_from_data(
        data: *const ::std::os::raw::c_void,
        len: gssize,
        destroy: GDestroyNotify,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_memory_input_stream_new_from_bytes(bytes: *mut GBytes) -> *mut GInputStream;
}
extern "C" {
    pub fn g_memory_input_stream_add_data(
        stream: *mut GMemoryInputStream,
        data: *const ::std::os::raw::c_void,
        len: gssize,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_memory_input_stream_add_bytes(stream: *mut GMemoryInputStream, bytes: *mut GBytes);
}
extern "C" {
    pub fn g_memory_monitor_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryMonitor {
    _unused: [u8; 0],
}
pub type GMemoryMonitor = _GMemoryMonitor;
pub type GMemoryMonitorInterface = _GMemoryMonitorInterface;
pub type GMemoryMonitor_autoptr = *mut GMemoryMonitor;
pub type GMemoryMonitor_listautoptr = *mut GList;
pub type GMemoryMonitor_slistautoptr = *mut GSList;
pub type GMemoryMonitor_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryMonitorInterface {
    pub g_iface: GTypeInterface,
    pub low_memory_warning: ::std::option::Option<
        unsafe extern "C" fn(monitor: *mut GMemoryMonitor, level: GMemoryMonitorWarningLevel),
    >,
}
#[test]
fn bindgen_test_layout__GMemoryMonitorInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemoryMonitorInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemoryMonitorInterface>(),
        24usize,
        concat!("Size of: ", stringify!(_GMemoryMonitorInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryMonitorInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryMonitorInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryMonitorInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_memory_warning) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryMonitorInterface),
            "::",
            stringify!(low_memory_warning)
        )
    );
}
extern "C" {
    pub fn g_memory_monitor_dup_default() -> *mut GMemoryMonitor;
}
#[doc = " GMemoryOutputStream:\n\n Implements #GOutputStream for arbitrary memory chunks."]
pub type GMemoryOutputStreamClass = _GMemoryOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GMemoryOutputStreamPrivate = _GMemoryOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryOutputStream {
    pub parent_instance: GOutputStream,
    pub priv_: *mut GMemoryOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GMemoryOutputStream() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemoryOutputStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemoryOutputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GMemoryOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryOutputStream))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GMemoryOutputStreamClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GMemoryOutputStreamClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMemoryOutputStreamClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GMemoryOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryOutputStreamClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
#[doc = " GReallocFunc:\n @data: memory block to reallocate\n @size: size to reallocate @data to\n\n Changes the size of the memory block pointed to by @data to\n @size bytes.\n\n The function should have the same semantics as realloc().\n\n Returns: a pointer to the reallocated memory"]
pub type GReallocFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, size: gsize) -> gpointer>;
extern "C" {
    pub fn g_memory_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_memory_output_stream_new(
        data: gpointer,
        size: gsize,
        realloc_function: GReallocFunc,
        destroy_function: GDestroyNotify,
    ) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_memory_output_stream_new_resizable() -> *mut GOutputStream;
}
extern "C" {
    pub fn g_memory_output_stream_get_data(ostream: *mut GMemoryOutputStream) -> gpointer;
}
extern "C" {
    pub fn g_memory_output_stream_get_size(ostream: *mut GMemoryOutputStream) -> gsize;
}
extern "C" {
    pub fn g_memory_output_stream_get_data_size(ostream: *mut GMemoryOutputStream) -> gsize;
}
extern "C" {
    pub fn g_memory_output_stream_steal_data(ostream: *mut GMemoryOutputStream) -> gpointer;
}
extern "C" {
    pub fn g_memory_output_stream_steal_as_bytes(ostream: *mut GMemoryOutputStream) -> *mut GBytes;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuModelPrivate {
    _unused: [u8; 0],
}
pub type GMenuModelPrivate = _GMenuModelPrivate;
#[doc = " GMenuModelClass::get_item_attributes:\n @model: the #GMenuModel to query\n @item_index: The #GMenuItem to query\n @attributes: (out) (element-type utf8 GLib.Variant): Attributes on the item\n\n Gets all the attributes associated with the item in the menu model.\n/\n/**\n GMenuModelClass::get_item_links:\n @model: the #GMenuModel to query\n @item_index: The #GMenuItem to query\n @links: (out) (element-type utf8 Gio.MenuModel): Links from the item\n\n Gets all the links associated with the item in the menu model."]
pub type GMenuModelClass = _GMenuModelClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuAttributeIterPrivate {
    _unused: [u8; 0],
}
pub type GMenuAttributeIterPrivate = _GMenuAttributeIterPrivate;
pub type GMenuAttributeIterClass = _GMenuAttributeIterClass;
pub type GMenuAttributeIter = _GMenuAttributeIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuLinkIterPrivate {
    _unused: [u8; 0],
}
pub type GMenuLinkIterPrivate = _GMenuLinkIterPrivate;
pub type GMenuLinkIterClass = _GMenuLinkIterClass;
pub type GMenuLinkIter = _GMenuLinkIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuModel {
    pub parent_instance: GObject,
    pub priv_: *mut GMenuModelPrivate,
}
#[test]
fn bindgen_test_layout__GMenuModel() {
    const UNINIT: ::std::mem::MaybeUninit<_GMenuModel> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMenuModel>(),
        32usize,
        concat!("Size of: ", stringify!(_GMenuModel))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuModel>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuModel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModel),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModel),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GMenuModelClass::get_item_attributes:\n @model: the #GMenuModel to query\n @item_index: The #GMenuItem to query\n @attributes: (out) (element-type utf8 GLib.Variant): Attributes on the item\n\n Gets all the attributes associated with the item in the menu model.\n/\n/**\n GMenuModelClass::get_item_links:\n @model: the #GMenuModel to query\n @item_index: The #GMenuItem to query\n @links: (out) (element-type utf8 Gio.MenuModel): Links from the item\n\n Gets all the links associated with the item in the menu model."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuModelClass {
    pub parent_class: GObjectClass,
    pub is_mutable: ::std::option::Option<unsafe extern "C" fn(model: *mut GMenuModel) -> gboolean>,
    pub get_n_items: ::std::option::Option<unsafe extern "C" fn(model: *mut GMenuModel) -> gint>,
    pub get_item_attributes: ::std::option::Option<
        unsafe extern "C" fn(
            model: *mut GMenuModel,
            item_index: gint,
            attributes: *mut *mut GHashTable,
        ),
    >,
    pub iterate_item_attributes: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint) -> *mut GMenuAttributeIter,
    >,
    pub get_item_attribute_value: ::std::option::Option<
        unsafe extern "C" fn(
            model: *mut GMenuModel,
            item_index: gint,
            attribute: *const gchar,
            expected_type: *const GVariantType,
        ) -> *mut GVariant,
    >,
    pub get_item_links: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint, links: *mut *mut GHashTable),
    >,
    pub iterate_item_links: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint) -> *mut GMenuLinkIter,
    >,
    pub get_item_link: ::std::option::Option<
        unsafe extern "C" fn(
            model: *mut GMenuModel,
            item_index: gint,
            link: *const gchar,
        ) -> *mut GMenuModel,
    >,
}
#[test]
fn bindgen_test_layout__GMenuModelClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GMenuModelClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMenuModelClass>(),
        200usize,
        concat!("Size of: ", stringify!(_GMenuModelClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuModelClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuModelClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_mutable) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(is_mutable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_n_items) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_n_items)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_item_attributes) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_item_attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iterate_item_attributes) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(iterate_item_attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_item_attribute_value) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_item_attribute_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_item_links) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_item_links)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iterate_item_links) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(iterate_item_links)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_item_link) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_item_link)
        )
    );
}
extern "C" {
    pub fn g_menu_model_get_type() -> GType;
}
extern "C" {
    pub fn g_menu_model_is_mutable(model: *mut GMenuModel) -> gboolean;
}
extern "C" {
    pub fn g_menu_model_get_n_items(model: *mut GMenuModel) -> gint;
}
extern "C" {
    pub fn g_menu_model_iterate_item_attributes(
        model: *mut GMenuModel,
        item_index: gint,
    ) -> *mut GMenuAttributeIter;
}
extern "C" {
    pub fn g_menu_model_get_item_attribute_value(
        model: *mut GMenuModel,
        item_index: gint,
        attribute: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_menu_model_get_item_attribute(
        model: *mut GMenuModel,
        item_index: gint,
        attribute: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_menu_model_iterate_item_links(
        model: *mut GMenuModel,
        item_index: gint,
    ) -> *mut GMenuLinkIter;
}
extern "C" {
    pub fn g_menu_model_get_item_link(
        model: *mut GMenuModel,
        item_index: gint,
        link: *const gchar,
    ) -> *mut GMenuModel;
}
extern "C" {
    pub fn g_menu_model_items_changed(
        model: *mut GMenuModel,
        position: gint,
        removed: gint,
        added: gint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuAttributeIter {
    pub parent_instance: GObject,
    pub priv_: *mut GMenuAttributeIterPrivate,
}
#[test]
fn bindgen_test_layout__GMenuAttributeIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GMenuAttributeIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMenuAttributeIter>(),
        32usize,
        concat!("Size of: ", stringify!(_GMenuAttributeIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuAttributeIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuAttributeIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuAttributeIter),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuAttributeIter),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuAttributeIterClass {
    pub parent_class: GObjectClass,
    pub get_next: ::std::option::Option<
        unsafe extern "C" fn(
            iter: *mut GMenuAttributeIter,
            out_name: *mut *const gchar,
            value: *mut *mut GVariant,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GMenuAttributeIterClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GMenuAttributeIterClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMenuAttributeIterClass>(),
        144usize,
        concat!("Size of: ", stringify!(_GMenuAttributeIterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuAttributeIterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuAttributeIterClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuAttributeIterClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_next) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuAttributeIterClass),
            "::",
            stringify!(get_next)
        )
    );
}
extern "C" {
    pub fn g_menu_attribute_iter_get_type() -> GType;
}
extern "C" {
    pub fn g_menu_attribute_iter_get_next(
        iter: *mut GMenuAttributeIter,
        out_name: *mut *const gchar,
        value: *mut *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    pub fn g_menu_attribute_iter_next(iter: *mut GMenuAttributeIter) -> gboolean;
}
extern "C" {
    pub fn g_menu_attribute_iter_get_name(iter: *mut GMenuAttributeIter) -> *const gchar;
}
extern "C" {
    pub fn g_menu_attribute_iter_get_value(iter: *mut GMenuAttributeIter) -> *mut GVariant;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuLinkIter {
    pub parent_instance: GObject,
    pub priv_: *mut GMenuLinkIterPrivate,
}
#[test]
fn bindgen_test_layout__GMenuLinkIter() {
    const UNINIT: ::std::mem::MaybeUninit<_GMenuLinkIter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMenuLinkIter>(),
        32usize,
        concat!("Size of: ", stringify!(_GMenuLinkIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuLinkIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuLinkIter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuLinkIter),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuLinkIter),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuLinkIterClass {
    pub parent_class: GObjectClass,
    pub get_next: ::std::option::Option<
        unsafe extern "C" fn(
            iter: *mut GMenuLinkIter,
            out_link: *mut *const gchar,
            value: *mut *mut GMenuModel,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GMenuLinkIterClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GMenuLinkIterClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMenuLinkIterClass>(),
        144usize,
        concat!("Size of: ", stringify!(_GMenuLinkIterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuLinkIterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuLinkIterClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuLinkIterClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_next) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuLinkIterClass),
            "::",
            stringify!(get_next)
        )
    );
}
extern "C" {
    pub fn g_menu_link_iter_get_type() -> GType;
}
extern "C" {
    pub fn g_menu_link_iter_get_next(
        iter: *mut GMenuLinkIter,
        out_link: *mut *const gchar,
        value: *mut *mut GMenuModel,
    ) -> gboolean;
}
extern "C" {
    pub fn g_menu_link_iter_next(iter: *mut GMenuLinkIter) -> gboolean;
}
extern "C" {
    pub fn g_menu_link_iter_get_name(iter: *mut GMenuLinkIter) -> *const gchar;
}
extern "C" {
    pub fn g_menu_link_iter_get_value(iter: *mut GMenuLinkIter) -> *mut GMenuModel;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuItem {
    _unused: [u8; 0],
}
pub type GMenuItem = _GMenuItem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenu {
    _unused: [u8; 0],
}
pub type GMenu = _GMenu;
extern "C" {
    pub fn g_menu_get_type() -> GType;
}
extern "C" {
    pub fn g_menu_new() -> *mut GMenu;
}
extern "C" {
    pub fn g_menu_freeze(menu: *mut GMenu);
}
extern "C" {
    pub fn g_menu_insert_item(menu: *mut GMenu, position: gint, item: *mut GMenuItem);
}
extern "C" {
    pub fn g_menu_prepend_item(menu: *mut GMenu, item: *mut GMenuItem);
}
extern "C" {
    pub fn g_menu_append_item(menu: *mut GMenu, item: *mut GMenuItem);
}
extern "C" {
    pub fn g_menu_remove(menu: *mut GMenu, position: gint);
}
extern "C" {
    pub fn g_menu_remove_all(menu: *mut GMenu);
}
extern "C" {
    pub fn g_menu_insert(
        menu: *mut GMenu,
        position: gint,
        label: *const gchar,
        detailed_action: *const gchar,
    );
}
extern "C" {
    pub fn g_menu_prepend(menu: *mut GMenu, label: *const gchar, detailed_action: *const gchar);
}
extern "C" {
    pub fn g_menu_append(menu: *mut GMenu, label: *const gchar, detailed_action: *const gchar);
}
extern "C" {
    pub fn g_menu_insert_section(
        menu: *mut GMenu,
        position: gint,
        label: *const gchar,
        section: *mut GMenuModel,
    );
}
extern "C" {
    pub fn g_menu_prepend_section(menu: *mut GMenu, label: *const gchar, section: *mut GMenuModel);
}
extern "C" {
    pub fn g_menu_append_section(menu: *mut GMenu, label: *const gchar, section: *mut GMenuModel);
}
extern "C" {
    pub fn g_menu_insert_submenu(
        menu: *mut GMenu,
        position: gint,
        label: *const gchar,
        submenu: *mut GMenuModel,
    );
}
extern "C" {
    pub fn g_menu_prepend_submenu(menu: *mut GMenu, label: *const gchar, submenu: *mut GMenuModel);
}
extern "C" {
    pub fn g_menu_append_submenu(menu: *mut GMenu, label: *const gchar, submenu: *mut GMenuModel);
}
extern "C" {
    pub fn g_menu_item_get_type() -> GType;
}
extern "C" {
    pub fn g_menu_item_new(label: *const gchar, detailed_action: *const gchar) -> *mut GMenuItem;
}
extern "C" {
    pub fn g_menu_item_new_from_model(model: *mut GMenuModel, item_index: gint) -> *mut GMenuItem;
}
extern "C" {
    pub fn g_menu_item_new_submenu(label: *const gchar, submenu: *mut GMenuModel)
        -> *mut GMenuItem;
}
extern "C" {
    pub fn g_menu_item_new_section(label: *const gchar, section: *mut GMenuModel)
        -> *mut GMenuItem;
}
extern "C" {
    pub fn g_menu_item_get_attribute_value(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_menu_item_get_attribute(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_menu_item_get_link(menu_item: *mut GMenuItem, link: *const gchar) -> *mut GMenuModel;
}
extern "C" {
    pub fn g_menu_item_set_attribute_value(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_menu_item_set_attribute(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_menu_item_set_link(
        menu_item: *mut GMenuItem,
        link: *const gchar,
        model: *mut GMenuModel,
    );
}
extern "C" {
    pub fn g_menu_item_set_label(menu_item: *mut GMenuItem, label: *const gchar);
}
extern "C" {
    pub fn g_menu_item_set_submenu(menu_item: *mut GMenuItem, submenu: *mut GMenuModel);
}
extern "C" {
    pub fn g_menu_item_set_section(menu_item: *mut GMenuItem, section: *mut GMenuModel);
}
extern "C" {
    pub fn g_menu_item_set_action_and_target_value(
        menu_item: *mut GMenuItem,
        action: *const gchar,
        target_value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_menu_item_set_action_and_target(
        menu_item: *mut GMenuItem,
        action: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_menu_item_set_detailed_action(
        menu_item: *mut GMenuItem,
        detailed_action: *const gchar,
    );
}
extern "C" {
    pub fn g_menu_item_set_icon(menu_item: *mut GMenuItem, icon: *mut GIcon);
}
extern "C" {
    pub fn g_dbus_connection_export_menu_model(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        menu: *mut GMenuModel,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    pub fn g_dbus_connection_unexport_menu_model(
        connection: *mut GDBusConnection,
        export_id: guint,
    );
}
#[doc = " GMountIface:\n @g_iface: The parent interface.\n @changed: Changed signal that is emitted when the mount's state has changed.\n @unmounted: The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.\n @pre_unmount: The ::pre-unmount signal that is emitted when the #GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.\n @get_root: Gets a #GFile to the root directory of the #GMount.\n @get_name: Gets a string containing the name of the #GMount.\n @get_icon: Gets a #GIcon for the #GMount.\n @get_uuid: Gets the UUID for the #GMount. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.\n @get_volume: Gets a #GVolume the mount is located on. Returns %NULL if the #GMount is not associated with a #GVolume.\n @get_drive: Gets a #GDrive the volume of the mount is located on. Returns %NULL if the #GMount is not associated with a #GDrive or a #GVolume. This is convenience method for getting the #GVolume and using that to get the #GDrive.\n @can_unmount: Checks if a #GMount can be unmounted.\n @can_eject: Checks if a #GMount can be ejected.\n @unmount: Starts unmounting a #GMount.\n @unmount_finish: Finishes an unmounting operation.\n @eject: Starts ejecting a #GMount.\n @eject_finish: Finishes an eject operation.\n @remount: Starts remounting a #GMount.\n @remount_finish: Finishes a remounting operation.\n @guess_content_type: Starts guessing the type of the content of a #GMount.\n     See g_mount_guess_content_type() for more information on content\n     type guessing. This operation was added in 2.18.\n @guess_content_type_finish: Finishes a content type guessing operation. Added in 2.18.\n @guess_content_type_sync: Synchronous variant of @guess_content_type. Added in 2.18\n @unmount_with_operation: Starts unmounting a #GMount using a #GMountOperation. Since 2.22.\n @unmount_with_operation_finish: Finishes an unmounting operation using a #GMountOperation. Since 2.22.\n @eject_with_operation: Starts ejecting a #GMount using a #GMountOperation. Since 2.22.\n @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @get_default_location: Gets a #GFile indication a start location that can be use as the entry point for this mount. Since 2.24.\n @get_sort_key: Gets a key used for sorting #GMount instance or %NULL if no such key exists. Since 2.32.\n @get_symbolic_icon: Gets a symbolic #GIcon for the #GMount. Since 2.34.\n\n Interface for implementing operations for mounts."]
pub type GMountIface = _GMountIface;
#[doc = " GMountIface:\n @g_iface: The parent interface.\n @changed: Changed signal that is emitted when the mount's state has changed.\n @unmounted: The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.\n @pre_unmount: The ::pre-unmount signal that is emitted when the #GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.\n @get_root: Gets a #GFile to the root directory of the #GMount.\n @get_name: Gets a string containing the name of the #GMount.\n @get_icon: Gets a #GIcon for the #GMount.\n @get_uuid: Gets the UUID for the #GMount. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.\n @get_volume: Gets a #GVolume the mount is located on. Returns %NULL if the #GMount is not associated with a #GVolume.\n @get_drive: Gets a #GDrive the volume of the mount is located on. Returns %NULL if the #GMount is not associated with a #GDrive or a #GVolume. This is convenience method for getting the #GVolume and using that to get the #GDrive.\n @can_unmount: Checks if a #GMount can be unmounted.\n @can_eject: Checks if a #GMount can be ejected.\n @unmount: Starts unmounting a #GMount.\n @unmount_finish: Finishes an unmounting operation.\n @eject: Starts ejecting a #GMount.\n @eject_finish: Finishes an eject operation.\n @remount: Starts remounting a #GMount.\n @remount_finish: Finishes a remounting operation.\n @guess_content_type: Starts guessing the type of the content of a #GMount.\n     See g_mount_guess_content_type() for more information on content\n     type guessing. This operation was added in 2.18.\n @guess_content_type_finish: Finishes a content type guessing operation. Added in 2.18.\n @guess_content_type_sync: Synchronous variant of @guess_content_type. Added in 2.18\n @unmount_with_operation: Starts unmounting a #GMount using a #GMountOperation. Since 2.22.\n @unmount_with_operation_finish: Finishes an unmounting operation using a #GMountOperation. Since 2.22.\n @eject_with_operation: Starts ejecting a #GMount using a #GMountOperation. Since 2.22.\n @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @get_default_location: Gets a #GFile indication a start location that can be use as the entry point for this mount. Since 2.24.\n @get_sort_key: Gets a key used for sorting #GMount instance or %NULL if no such key exists. Since 2.32.\n @get_symbolic_icon: Gets a symbolic #GIcon for the #GMount. Since 2.34.\n\n Interface for implementing operations for mounts."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount)>,
    pub unmounted: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount)>,
    pub get_root: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GFile>,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(mount: *mut GMount) -> *mut ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GIcon>,
    pub get_uuid: ::std::option::Option<
        unsafe extern "C" fn(mount: *mut GMount) -> *mut ::std::os::raw::c_char,
    >,
    pub get_volume: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GVolume>,
    pub get_drive: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GDrive>,
    pub can_unmount: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> gboolean>,
    pub unmount: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub remount: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub remount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub guess_content_type: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            force_rescan: gboolean,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub guess_content_type_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
    pub guess_content_type_sync: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            force_rescan: gboolean,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
    pub pre_unmount: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount)>,
    pub unmount_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_default_location:
        ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GFile>,
    pub get_sort_key:
        ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *const gchar>,
    pub get_symbolic_icon:
        ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GIcon>,
}
#[test]
fn bindgen_test_layout__GMountIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GMountIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMountIface>(),
        232usize,
        concat!("Size of: ", stringify!(_GMountIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMountIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMountIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmounted) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmounted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_root) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_icon) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_icon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_uuid) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_volume) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_volume)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_drive) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_drive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_unmount) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(can_unmount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_eject) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(can_eject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmount) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmount_finish) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmount_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(eject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_finish) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(eject_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remount) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(remount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remount_finish) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(remount_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guess_content_type) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(guess_content_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guess_content_type_finish) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(guess_content_type_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).guess_content_type_sync) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(guess_content_type_sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pre_unmount) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(pre_unmount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unmount_with_operation) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmount_with_operation)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).unmount_with_operation_finish) as usize - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmount_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_with_operation) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(eject_with_operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_with_operation_finish) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(eject_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_default_location) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_default_location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_sort_key) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_sort_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_symbolic_icon) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_symbolic_icon)
        )
    );
}
extern "C" {
    pub fn g_mount_get_type() -> GType;
}
extern "C" {
    pub fn g_mount_get_root(mount: *mut GMount) -> *mut GFile;
}
extern "C" {
    pub fn g_mount_get_default_location(mount: *mut GMount) -> *mut GFile;
}
extern "C" {
    pub fn g_mount_get_name(mount: *mut GMount) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_mount_get_icon(mount: *mut GMount) -> *mut GIcon;
}
extern "C" {
    pub fn g_mount_get_symbolic_icon(mount: *mut GMount) -> *mut GIcon;
}
extern "C" {
    pub fn g_mount_get_uuid(mount: *mut GMount) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_mount_get_volume(mount: *mut GMount) -> *mut GVolume;
}
extern "C" {
    pub fn g_mount_get_drive(mount: *mut GMount) -> *mut GDrive;
}
extern "C" {
    pub fn g_mount_can_unmount(mount: *mut GMount) -> gboolean;
}
extern "C" {
    pub fn g_mount_can_eject(mount: *mut GMount) -> gboolean;
}
extern "C" {
    pub fn g_mount_unmount(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_mount_unmount_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_mount_eject(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_mount_eject_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_mount_remount(
        mount: *mut GMount,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_mount_remount_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_mount_guess_content_type(
        mount: *mut GMount,
        force_rescan: gboolean,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_mount_guess_content_type_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_mount_guess_content_type_sync(
        mount: *mut GMount,
        force_rescan: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_mount_is_shadowed(mount: *mut GMount) -> gboolean;
}
extern "C" {
    pub fn g_mount_shadow(mount: *mut GMount);
}
extern "C" {
    pub fn g_mount_unshadow(mount: *mut GMount);
}
extern "C" {
    pub fn g_mount_unmount_with_operation(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_mount_unmount_with_operation_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_mount_eject_with_operation(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_mount_eject_with_operation_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_mount_get_sort_key(mount: *mut GMount) -> *const gchar;
}
#[doc = " GMountOperation:\n\n Class for providing authentication methods for mounting operations,\n such as mounting a file locally, or authenticating with a server."]
pub type GMountOperationClass = _GMountOperationClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountOperationPrivate {
    _unused: [u8; 0],
}
pub type GMountOperationPrivate = _GMountOperationPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountOperation {
    pub parent_instance: GObject,
    pub priv_: *mut GMountOperationPrivate,
}
#[test]
fn bindgen_test_layout__GMountOperation() {
    const UNINIT: ::std::mem::MaybeUninit<_GMountOperation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMountOperation>(),
        32usize,
        concat!("Size of: ", stringify!(_GMountOperation))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMountOperation>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMountOperation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperation),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperation),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountOperationClass {
    pub parent_class: GObjectClass,
    pub ask_password: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const ::std::os::raw::c_char,
            default_user: *const ::std::os::raw::c_char,
            default_domain: *const ::std::os::raw::c_char,
            flags: GAskPasswordFlags,
        ),
    >,
    #[doc = " GMountOperationClass::ask_question:\n @op: a #GMountOperation\n @message: string containing a message to display to the user\n @choices: (array zero-terminated=1) (element-type utf8): an array of\n    strings for each possible choice\n\n Virtual implementation of #GMountOperation::ask-question."]
    pub ask_question: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const ::std::os::raw::c_char,
            choices: *mut *const ::std::os::raw::c_char,
        ),
    >,
    pub reply: ::std::option::Option<
        unsafe extern "C" fn(op: *mut GMountOperation, result: GMountOperationResult),
    >,
    pub aborted: ::std::option::Option<unsafe extern "C" fn(op: *mut GMountOperation)>,
    #[doc = " GMountOperationClass::show_processes:\n @op: a #GMountOperation\n @message: string containing a message to display to the user\n @processes: (element-type GPid): an array of #GPid for processes blocking\n    the operation\n @choices: (array zero-terminated=1) (element-type utf8): an array of\n    strings for each possible choice\n\n Virtual implementation of #GMountOperation::show-processes.\n\n Since: 2.22"]
    pub show_processes: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const gchar,
            processes: *mut GArray,
            choices: *mut *const gchar,
        ),
    >,
    pub show_unmount_progress: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const gchar,
            time_left: gint64,
            bytes_left: gint64,
        ),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GMountOperationClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GMountOperationClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GMountOperationClass>(),
        256usize,
        concat!("Size of: ", stringify!(_GMountOperationClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMountOperationClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMountOperationClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ask_password) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(ask_password)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ask_question) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(ask_question)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reply) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(reply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aborted) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(aborted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_processes) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(show_processes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_unmount_progress) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(show_unmount_progress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved7) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved8) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved9) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved9)
        )
    );
}
extern "C" {
    pub fn g_mount_operation_get_type() -> GType;
}
extern "C" {
    pub fn g_mount_operation_new() -> *mut GMountOperation;
}
extern "C" {
    pub fn g_mount_operation_get_username(
        op: *mut GMountOperation,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_mount_operation_set_username(
        op: *mut GMountOperation,
        username: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_mount_operation_get_password(
        op: *mut GMountOperation,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_mount_operation_set_password(
        op: *mut GMountOperation,
        password: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_mount_operation_get_anonymous(op: *mut GMountOperation) -> gboolean;
}
extern "C" {
    pub fn g_mount_operation_set_anonymous(op: *mut GMountOperation, anonymous: gboolean);
}
extern "C" {
    pub fn g_mount_operation_get_domain(op: *mut GMountOperation) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_mount_operation_set_domain(
        op: *mut GMountOperation,
        domain: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_mount_operation_get_password_save(op: *mut GMountOperation) -> GPasswordSave;
}
extern "C" {
    pub fn g_mount_operation_set_password_save(op: *mut GMountOperation, save: GPasswordSave);
}
extern "C" {
    pub fn g_mount_operation_get_choice(op: *mut GMountOperation) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_mount_operation_set_choice(op: *mut GMountOperation, choice: ::std::os::raw::c_int);
}
extern "C" {
    pub fn g_mount_operation_reply(op: *mut GMountOperation, result: GMountOperationResult);
}
extern "C" {
    pub fn g_mount_operation_get_is_tcrypt_hidden_volume(op: *mut GMountOperation) -> gboolean;
}
extern "C" {
    pub fn g_mount_operation_set_is_tcrypt_hidden_volume(
        op: *mut GMountOperation,
        hidden_volume: gboolean,
    );
}
extern "C" {
    pub fn g_mount_operation_get_is_tcrypt_system_volume(op: *mut GMountOperation) -> gboolean;
}
extern "C" {
    pub fn g_mount_operation_set_is_tcrypt_system_volume(
        op: *mut GMountOperation,
        system_volume: gboolean,
    );
}
extern "C" {
    pub fn g_mount_operation_get_pim(op: *mut GMountOperation) -> guint;
}
extern "C" {
    pub fn g_mount_operation_set_pim(op: *mut GMountOperation, pim: guint);
}
pub type GNativeSocketAddressClass = _GNativeSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeSocketAddressPrivate {
    _unused: [u8; 0],
}
pub type GNativeSocketAddressPrivate = _GNativeSocketAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeSocketAddress {
    pub parent_instance: GSocketAddress,
    pub priv_: *mut GNativeSocketAddressPrivate,
}
#[test]
fn bindgen_test_layout__GNativeSocketAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GNativeSocketAddress> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNativeSocketAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GNativeSocketAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNativeSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNativeSocketAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeSocketAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeSocketAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}
#[test]
fn bindgen_test_layout__GNativeSocketAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GNativeSocketAddressClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNativeSocketAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GNativeSocketAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNativeSocketAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNativeSocketAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeSocketAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_native_socket_address_get_type() -> GType;
}
extern "C" {
    pub fn g_native_socket_address_new(native: gpointer, len: gsize) -> *mut GSocketAddress;
}
#[doc = " GVolumeMonitor:\n\n A Volume Monitor that watches for volume events."]
pub type GVolumeMonitorClass = _GVolumeMonitorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolumeMonitor {
    pub parent_instance: GObject,
    pub priv_: gpointer,
}
#[test]
fn bindgen_test_layout__GVolumeMonitor() {
    const UNINIT: ::std::mem::MaybeUninit<_GVolumeMonitor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVolumeMonitor>(),
        32usize,
        concat!("Size of: ", stringify!(_GVolumeMonitor))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVolumeMonitor>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVolumeMonitor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitor),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitor),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolumeMonitorClass {
    pub parent_class: GObjectClass,
    pub volume_added: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, volume: *mut GVolume),
    >,
    pub volume_removed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, volume: *mut GVolume),
    >,
    pub volume_changed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, volume: *mut GVolume),
    >,
    pub mount_added: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub mount_removed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub mount_pre_unmount: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub mount_changed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub drive_connected: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub drive_disconnected: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub drive_changed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub is_supported: ::std::option::Option<unsafe extern "C" fn() -> gboolean>,
    pub get_connected_drives: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor) -> *mut GList,
    >,
    pub get_volumes: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor) -> *mut GList,
    >,
    pub get_mounts: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor) -> *mut GList,
    >,
    pub get_volume_for_uuid: ::std::option::Option<
        unsafe extern "C" fn(
            volume_monitor: *mut GVolumeMonitor,
            uuid: *const ::std::os::raw::c_char,
        ) -> *mut GVolume,
    >,
    pub get_mount_for_uuid: ::std::option::Option<
        unsafe extern "C" fn(
            volume_monitor: *mut GVolumeMonitor,
            uuid: *const ::std::os::raw::c_char,
        ) -> *mut GMount,
    >,
    pub adopt_orphan_mount: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            volume_monitor: *mut GVolumeMonitor,
        ) -> *mut GVolume,
    >,
    pub drive_eject_button: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub drive_stop_button: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GVolumeMonitorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GVolumeMonitorClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVolumeMonitorClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GVolumeMonitorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVolumeMonitorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVolumeMonitorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volume_added) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(volume_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volume_removed) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(volume_removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).volume_changed) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(volume_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_added) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(mount_added)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_removed) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(mount_removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_pre_unmount) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(mount_pre_unmount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_changed) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(mount_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drive_connected) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_connected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drive_disconnected) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_disconnected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drive_changed) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_supported) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(is_supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_connected_drives) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_connected_drives)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_volumes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_volumes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mounts) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_mounts)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_volume_for_uuid) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_volume_for_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mount_for_uuid) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_mount_for_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adopt_orphan_mount) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(adopt_orphan_mount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drive_eject_button) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_eject_button)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drive_stop_button) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_stop_button)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
extern "C" {
    pub fn g_volume_monitor_get_type() -> GType;
}
extern "C" {
    pub fn g_volume_monitor_get() -> *mut GVolumeMonitor;
}
extern "C" {
    pub fn g_volume_monitor_get_connected_drives(volume_monitor: *mut GVolumeMonitor)
        -> *mut GList;
}
extern "C" {
    pub fn g_volume_monitor_get_volumes(volume_monitor: *mut GVolumeMonitor) -> *mut GList;
}
extern "C" {
    pub fn g_volume_monitor_get_mounts(volume_monitor: *mut GVolumeMonitor) -> *mut GList;
}
extern "C" {
    pub fn g_volume_monitor_get_volume_for_uuid(
        volume_monitor: *mut GVolumeMonitor,
        uuid: *const ::std::os::raw::c_char,
    ) -> *mut GVolume;
}
extern "C" {
    pub fn g_volume_monitor_get_mount_for_uuid(
        volume_monitor: *mut GVolumeMonitor,
        uuid: *const ::std::os::raw::c_char,
    ) -> *mut GMount;
}
extern "C" {
    pub fn g_volume_monitor_adopt_orphan_mount(mount: *mut GMount) -> *mut GVolume;
}
pub type GNativeVolumeMonitor = _GNativeVolumeMonitor;
pub type GNativeVolumeMonitorClass = _GNativeVolumeMonitorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeVolumeMonitor {
    pub parent_instance: GVolumeMonitor,
}
#[test]
fn bindgen_test_layout__GNativeVolumeMonitor() {
    const UNINIT: ::std::mem::MaybeUninit<_GNativeVolumeMonitor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNativeVolumeMonitor>(),
        32usize,
        concat!("Size of: ", stringify!(_GNativeVolumeMonitor))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNativeVolumeMonitor>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNativeVolumeMonitor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeVolumeMonitor),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeVolumeMonitorClass {
    pub parent_class: GVolumeMonitorClass,
    pub get_mount_for_mount_path: ::std::option::Option<
        unsafe extern "C" fn(
            mount_path: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
        ) -> *mut GMount,
    >,
}
#[test]
fn bindgen_test_layout__GNativeVolumeMonitorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GNativeVolumeMonitorClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNativeVolumeMonitorClass>(),
        344usize,
        concat!("Size of: ", stringify!(_GNativeVolumeMonitorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNativeVolumeMonitorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNativeVolumeMonitorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeVolumeMonitorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mount_for_mount_path) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeVolumeMonitorClass),
            "::",
            stringify!(get_mount_for_mount_path)
        )
    );
}
extern "C" {
    pub fn g_native_volume_monitor_get_type() -> GType;
}
pub type GNetworkAddressClass = _GNetworkAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkAddressPrivate {
    _unused: [u8; 0],
}
pub type GNetworkAddressPrivate = _GNetworkAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkAddress {
    pub parent_instance: GObject,
    pub priv_: *mut GNetworkAddressPrivate,
}
#[test]
fn bindgen_test_layout__GNetworkAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GNetworkAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNetworkAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GNetworkAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkAddressClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GNetworkAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GNetworkAddressClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNetworkAddressClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GNetworkAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_network_address_get_type() -> GType;
}
extern "C" {
    pub fn g_network_address_new(hostname: *const gchar, port: guint16) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_network_address_new_loopback(port: guint16) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_network_address_parse(
        host_and_port: *const gchar,
        default_port: guint16,
        error: *mut *mut GError,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_network_address_parse_uri(
        uri: *const gchar,
        default_port: guint16,
        error: *mut *mut GError,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_network_address_get_hostname(addr: *mut GNetworkAddress) -> *const gchar;
}
extern "C" {
    pub fn g_network_address_get_port(addr: *mut GNetworkAddress) -> guint16;
}
extern "C" {
    pub fn g_network_address_get_scheme(addr: *mut GNetworkAddress) -> *const gchar;
}
pub type GNetworkMonitorInterface = _GNetworkMonitorInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkMonitorInterface {
    pub g_iface: GTypeInterface,
    pub network_changed: ::std::option::Option<
        unsafe extern "C" fn(monitor: *mut GNetworkMonitor, network_available: gboolean),
    >,
    pub can_reach: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GNetworkMonitor,
            connectable: *mut GSocketConnectable,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_reach_async: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GNetworkMonitor,
            connectable: *mut GSocketConnectable,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub can_reach_finish: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GNetworkMonitor,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GNetworkMonitorInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GNetworkMonitorInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNetworkMonitorInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GNetworkMonitorInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkMonitorInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkMonitorInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).network_changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(network_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_reach) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(can_reach)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_reach_async) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(can_reach_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_reach_finish) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(can_reach_finish)
        )
    );
}
extern "C" {
    pub fn g_network_monitor_get_type() -> GType;
}
extern "C" {
    pub fn g_network_monitor_get_default() -> *mut GNetworkMonitor;
}
extern "C" {
    pub fn g_network_monitor_get_network_available(monitor: *mut GNetworkMonitor) -> gboolean;
}
extern "C" {
    pub fn g_network_monitor_get_network_metered(monitor: *mut GNetworkMonitor) -> gboolean;
}
extern "C" {
    pub fn g_network_monitor_get_connectivity(
        monitor: *mut GNetworkMonitor,
    ) -> GNetworkConnectivity;
}
extern "C" {
    pub fn g_network_monitor_can_reach(
        monitor: *mut GNetworkMonitor,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_network_monitor_can_reach_async(
        monitor: *mut GNetworkMonitor,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_network_monitor_can_reach_finish(
        monitor: *mut GNetworkMonitor,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub type GNetworkServiceClass = _GNetworkServiceClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkServicePrivate {
    _unused: [u8; 0],
}
pub type GNetworkServicePrivate = _GNetworkServicePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkService {
    pub parent_instance: GObject,
    pub priv_: *mut GNetworkServicePrivate,
}
#[test]
fn bindgen_test_layout__GNetworkService() {
    const UNINIT: ::std::mem::MaybeUninit<_GNetworkService> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNetworkService>(),
        32usize,
        concat!("Size of: ", stringify!(_GNetworkService))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkService>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkService))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkService),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkService),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkServiceClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GNetworkServiceClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GNetworkServiceClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GNetworkServiceClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GNetworkServiceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkServiceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkServiceClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkServiceClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_network_service_get_type() -> GType;
}
extern "C" {
    pub fn g_network_service_new(
        service: *const gchar,
        protocol: *const gchar,
        domain: *const gchar,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_network_service_get_service(srv: *mut GNetworkService) -> *const gchar;
}
extern "C" {
    pub fn g_network_service_get_protocol(srv: *mut GNetworkService) -> *const gchar;
}
extern "C" {
    pub fn g_network_service_get_domain(srv: *mut GNetworkService) -> *const gchar;
}
extern "C" {
    pub fn g_network_service_get_scheme(srv: *mut GNetworkService) -> *const gchar;
}
extern "C" {
    pub fn g_network_service_set_scheme(srv: *mut GNetworkService, scheme: *const gchar);
}
extern "C" {
    pub fn g_notification_get_type() -> GType;
}
extern "C" {
    pub fn g_notification_new(title: *const gchar) -> *mut GNotification;
}
extern "C" {
    pub fn g_notification_set_title(notification: *mut GNotification, title: *const gchar);
}
extern "C" {
    pub fn g_notification_set_body(notification: *mut GNotification, body: *const gchar);
}
extern "C" {
    pub fn g_notification_set_icon(notification: *mut GNotification, icon: *mut GIcon);
}
extern "C" {
    pub fn g_notification_set_urgent(notification: *mut GNotification, urgent: gboolean);
}
extern "C" {
    pub fn g_notification_set_priority(
        notification: *mut GNotification,
        priority: GNotificationPriority,
    );
}
extern "C" {
    pub fn g_notification_set_category(notification: *mut GNotification, category: *const gchar);
}
extern "C" {
    pub fn g_notification_add_button(
        notification: *mut GNotification,
        label: *const gchar,
        detailed_action: *const gchar,
    );
}
extern "C" {
    pub fn g_notification_add_button_with_target(
        notification: *mut GNotification,
        label: *const gchar,
        action: *const gchar,
        target_format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_notification_add_button_with_target_value(
        notification: *mut GNotification,
        label: *const gchar,
        action: *const gchar,
        target: *mut GVariant,
    );
}
extern "C" {
    pub fn g_notification_set_default_action(
        notification: *mut GNotification,
        detailed_action: *const gchar,
    );
}
extern "C" {
    pub fn g_notification_set_default_action_and_target(
        notification: *mut GNotification,
        action: *const gchar,
        target_format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_notification_set_default_action_and_target_value(
        notification: *mut GNotification,
        action: *const gchar,
        target: *mut GVariant,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPermissionPrivate {
    _unused: [u8; 0],
}
pub type GPermissionPrivate = _GPermissionPrivate;
pub type GPermissionClass = _GPermissionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPermission {
    pub parent_instance: GObject,
    pub priv_: *mut GPermissionPrivate,
}
#[test]
fn bindgen_test_layout__GPermission() {
    const UNINIT: ::std::mem::MaybeUninit<_GPermission> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPermission>(),
        32usize,
        concat!("Size of: ", stringify!(_GPermission))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPermission>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPermission))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermission),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermission),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPermissionClass {
    pub parent_class: GObjectClass,
    pub acquire: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub acquire_async: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub acquire_finish: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub release: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub release_async: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub release_finish: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub reserved: [gpointer; 16usize],
}
#[test]
fn bindgen_test_layout__GPermissionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GPermissionClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPermissionClass>(),
        312usize,
        concat!("Size of: ", stringify!(_GPermissionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPermissionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPermissionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acquire) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(acquire)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acquire_async) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(acquire_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acquire_finish) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(acquire_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_async) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(release_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_finish) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(release_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn g_permission_get_type() -> GType;
}
extern "C" {
    pub fn g_permission_acquire(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_permission_acquire_async(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_permission_acquire_finish(
        permission: *mut GPermission,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_permission_release(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_permission_release_async(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_permission_release_finish(
        permission: *mut GPermission,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_permission_get_allowed(permission: *mut GPermission) -> gboolean;
}
extern "C" {
    pub fn g_permission_get_can_acquire(permission: *mut GPermission) -> gboolean;
}
extern "C" {
    pub fn g_permission_get_can_release(permission: *mut GPermission) -> gboolean;
}
extern "C" {
    pub fn g_permission_impl_update(
        permission: *mut GPermission,
        allowed: gboolean,
        can_acquire: gboolean,
        can_release: gboolean,
    );
}
#[doc = " GPollableInputStream:\n\n An interface for a #GInputStream that can be polled for readability.\n\n Since: 2.28"]
pub type GPollableInputStreamInterface = _GPollableInputStreamInterface;
#[doc = " GPollableInputStreamInterface:\n @g_iface: The parent interface.\n @can_poll: Checks if the #GPollableInputStream instance is actually pollable\n @is_readable: Checks if the stream is readable\n @create_source: Creates a #GSource to poll the stream\n @read_nonblocking: Does a non-blocking read or returns\n   %G_IO_ERROR_WOULD_BLOCK\n\n The interface for pollable input streams.\n\n The default implementation of @can_poll always returns %TRUE.\n\n The default implementation of @read_nonblocking calls\n g_pollable_input_stream_is_readable(), and then calls\n g_input_stream_read() if it returns %TRUE. This means you only need\n to override it if it is possible that your @is_readable\n implementation may return %TRUE when the stream is not actually\n readable.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableInputStreamInterface {
    pub g_iface: GTypeInterface,
    pub can_poll:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableInputStream) -> gboolean>,
    pub is_readable:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableInputStream) -> gboolean>,
    pub create_source: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableInputStream,
            cancellable: *mut GCancellable,
        ) -> *mut GSource,
    >,
    pub read_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableInputStream,
            buffer: *mut ::std::os::raw::c_void,
            count: gsize,
            error: *mut *mut GError,
        ) -> gssize,
    >,
}
#[test]
fn bindgen_test_layout__GPollableInputStreamInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GPollableInputStreamInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPollableInputStreamInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GPollableInputStreamInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollableInputStreamInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPollableInputStreamInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_poll) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(can_poll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_readable) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(is_readable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_source) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(create_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_nonblocking) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(read_nonblocking)
        )
    );
}
extern "C" {
    pub fn g_pollable_input_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_pollable_input_stream_can_poll(stream: *mut GPollableInputStream) -> gboolean;
}
extern "C" {
    pub fn g_pollable_input_stream_is_readable(stream: *mut GPollableInputStream) -> gboolean;
}
extern "C" {
    pub fn g_pollable_input_stream_create_source(
        stream: *mut GPollableInputStream,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_pollable_input_stream_read_nonblocking(
        stream: *mut GPollableInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
#[doc = " GPollableOutputStream:\n\n An interface for a #GOutputStream that can be polled for writeability.\n\n Since: 2.28"]
pub type GPollableOutputStreamInterface = _GPollableOutputStreamInterface;
#[doc = " GPollableOutputStreamInterface:\n @g_iface: The parent interface.\n @can_poll: Checks if the #GPollableOutputStream instance is actually pollable\n @is_writable: Checks if the stream is writable\n @create_source: Creates a #GSource to poll the stream\n @write_nonblocking: Does a non-blocking write or returns\n   %G_IO_ERROR_WOULD_BLOCK\n @writev_nonblocking: Does a vectored non-blocking write, or returns\n   %G_POLLABLE_RETURN_WOULD_BLOCK\n\n The interface for pollable output streams.\n\n The default implementation of @can_poll always returns %TRUE.\n\n The default implementation of @write_nonblocking calls\n g_pollable_output_stream_is_writable(), and then calls\n g_output_stream_write() if it returns %TRUE. This means you only\n need to override it if it is possible that your @is_writable\n implementation may return %TRUE when the stream is not actually\n writable.\n\n The default implementation of @writev_nonblocking calls\n g_pollable_output_stream_write_nonblocking() for each vector, and converts\n its return value and error (if set) to a #GPollableReturn. You should\n override this where possible to avoid having to allocate a #GError to return\n %G_IO_ERROR_WOULD_BLOCK.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableOutputStreamInterface {
    pub g_iface: GTypeInterface,
    pub can_poll:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableOutputStream) -> gboolean>,
    pub is_writable:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableOutputStream) -> gboolean>,
    pub create_source: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableOutputStream,
            cancellable: *mut GCancellable,
        ) -> *mut GSource,
    >,
    pub write_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableOutputStream,
            buffer: *const ::std::os::raw::c_void,
            count: gsize,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub writev_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableOutputStream,
            vectors: *const GOutputVector,
            n_vectors: gsize,
            bytes_written: *mut gsize,
            error: *mut *mut GError,
        ) -> GPollableReturn,
    >,
}
#[test]
fn bindgen_test_layout__GPollableOutputStreamInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GPollableOutputStreamInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPollableOutputStreamInterface>(),
        56usize,
        concat!("Size of: ", stringify!(_GPollableOutputStreamInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollableOutputStreamInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPollableOutputStreamInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_poll) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(can_poll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_writable) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(is_writable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_source) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(create_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write_nonblocking) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(write_nonblocking)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writev_nonblocking) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(writev_nonblocking)
        )
    );
}
extern "C" {
    pub fn g_pollable_output_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_pollable_output_stream_can_poll(stream: *mut GPollableOutputStream) -> gboolean;
}
extern "C" {
    pub fn g_pollable_output_stream_is_writable(stream: *mut GPollableOutputStream) -> gboolean;
}
extern "C" {
    pub fn g_pollable_output_stream_create_source(
        stream: *mut GPollableOutputStream,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_pollable_output_stream_write_nonblocking(
        stream: *mut GPollableOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_pollable_output_stream_writev_nonblocking(
        stream: *mut GPollableOutputStream,
        vectors: *const GOutputVector,
        n_vectors: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GPollableReturn;
}
extern "C" {
    pub fn g_pollable_source_new(pollable_stream: *mut GObject) -> *mut GSource;
}
extern "C" {
    pub fn g_pollable_source_new_full(
        pollable_stream: gpointer,
        child_source: *mut GSource,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_pollable_stream_read(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_pollable_stream_write(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_pollable_stream_write_all(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        blocking: gboolean,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_power_profile_monitor_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPowerProfileMonitor {
    _unused: [u8; 0],
}
pub type GPowerProfileMonitor = _GPowerProfileMonitor;
pub type GPowerProfileMonitorInterface = _GPowerProfileMonitorInterface;
pub type GPowerProfileMonitor_autoptr = *mut GPowerProfileMonitor;
pub type GPowerProfileMonitor_listautoptr = *mut GList;
pub type GPowerProfileMonitor_slistautoptr = *mut GSList;
pub type GPowerProfileMonitor_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPowerProfileMonitorInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GPowerProfileMonitorInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GPowerProfileMonitorInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GPowerProfileMonitorInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GPowerProfileMonitorInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPowerProfileMonitorInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPowerProfileMonitorInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPowerProfileMonitorInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    pub fn g_power_profile_monitor_dup_default() -> *mut GPowerProfileMonitor;
}
extern "C" {
    pub fn g_power_profile_monitor_get_power_saver_enabled(
        monitor: *mut GPowerProfileMonitor,
    ) -> gboolean;
}
extern "C" {
    pub fn g_property_action_get_type() -> GType;
}
extern "C" {
    pub fn g_property_action_new(
        name: *const gchar,
        object: gpointer,
        property_name: *const gchar,
    ) -> *mut GPropertyAction;
}
#[doc = " GProxy:\n\n Interface that handles proxy connection and payload.\n\n Since: 2.26"]
pub type GProxyInterface = _GProxyInterface;
#[doc = " GProxyInterface:\n @g_iface: The parent interface.\n @connect: Connect to proxy server and wrap (if required) the #connection\n           to handle payload.\n @connect_async: Same as connect() but asynchronous.\n @connect_finish: Returns the result of connect_async()\n @supports_hostname: Returns whether the proxy supports hostname lookups.\n\n Provides an interface for handling proxy connection and payload.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyInterface {
    pub g_iface: GTypeInterface,
    pub connect: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GProxy,
            connection: *mut GIOStream,
            proxy_address: *mut GProxyAddress,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GIOStream,
    >,
    pub connect_async: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GProxy,
            connection: *mut GIOStream,
            proxy_address: *mut GProxyAddress,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub connect_finish: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GProxy,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GIOStream,
    >,
    pub supports_hostname:
        ::std::option::Option<unsafe extern "C" fn(proxy: *mut GProxy) -> gboolean>,
}
#[test]
fn bindgen_test_layout__GProxyInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GProxyInterface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GProxyInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GProxyInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_async) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(connect_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connect_finish) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(connect_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_hostname) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(supports_hostname)
        )
    );
}
extern "C" {
    pub fn g_proxy_get_type() -> GType;
}
extern "C" {
    pub fn g_proxy_get_default_for_protocol(protocol: *const gchar) -> *mut GProxy;
}
extern "C" {
    pub fn g_proxy_connect(
        proxy: *mut GProxy,
        connection: *mut GIOStream,
        proxy_address: *mut GProxyAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_proxy_connect_async(
        proxy: *mut GProxy,
        connection: *mut GIOStream,
        proxy_address: *mut GProxyAddress,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_proxy_connect_finish(
        proxy: *mut GProxy,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_proxy_supports_hostname(proxy: *mut GProxy) -> gboolean;
}
pub type GProxyAddressClass = _GProxyAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressPrivate {
    _unused: [u8; 0],
}
pub type GProxyAddressPrivate = _GProxyAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddress {
    pub parent_instance: GInetSocketAddress,
    pub priv_: *mut GProxyAddressPrivate,
}
#[test]
fn bindgen_test_layout__GProxyAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GProxyAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GProxyAddress>(),
        40usize,
        concat!("Size of: ", stringify!(_GProxyAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressClass {
    pub parent_class: GInetSocketAddressClass,
}
#[test]
fn bindgen_test_layout__GProxyAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GProxyAddressClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GProxyAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GProxyAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_proxy_address_get_type() -> GType;
}
extern "C" {
    pub fn g_proxy_address_new(
        inetaddr: *mut GInetAddress,
        port: guint16,
        protocol: *const gchar,
        dest_hostname: *const gchar,
        dest_port: guint16,
        username: *const gchar,
        password: *const gchar,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_proxy_address_get_protocol(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    pub fn g_proxy_address_get_destination_protocol(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    pub fn g_proxy_address_get_destination_hostname(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    pub fn g_proxy_address_get_destination_port(proxy: *mut GProxyAddress) -> guint16;
}
extern "C" {
    pub fn g_proxy_address_get_username(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    pub fn g_proxy_address_get_password(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    pub fn g_proxy_address_get_uri(proxy: *mut GProxyAddress) -> *const gchar;
}
#[doc = " GSocketAddressEnumerator:\n\n Enumerator type for objects that contain or generate\n #GSocketAddress instances."]
pub type GSocketAddressEnumeratorClass = _GSocketAddressEnumeratorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketAddressEnumerator {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__GSocketAddressEnumerator() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketAddressEnumerator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketAddressEnumerator>(),
        24usize,
        concat!("Size of: ", stringify!(_GSocketAddressEnumerator))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketAddressEnumerator>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketAddressEnumerator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumerator),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[doc = " GSocketAddressEnumeratorClass:\n @next: Virtual method for g_socket_address_enumerator_next().\n @next_async: Virtual method for g_socket_address_enumerator_next_async().\n @next_finish: Virtual method for g_socket_address_enumerator_next_finish().\n\n Class structure for #GSocketAddressEnumerator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketAddressEnumeratorClass {
    pub parent_class: GObjectClass,
    pub next: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GSocketAddressEnumerator,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GSocketAddress,
    >,
    pub next_async: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GSocketAddressEnumerator,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub next_finish: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GSocketAddressEnumerator,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GSocketAddress,
    >,
}
#[test]
fn bindgen_test_layout__GSocketAddressEnumeratorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketAddressEnumeratorClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketAddressEnumeratorClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GSocketAddressEnumeratorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketAddressEnumeratorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketAddressEnumeratorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumeratorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumeratorClass),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_async) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumeratorClass),
            "::",
            stringify!(next_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next_finish) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumeratorClass),
            "::",
            stringify!(next_finish)
        )
    );
}
extern "C" {
    pub fn g_socket_address_enumerator_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_address_enumerator_next(
        enumerator: *mut GSocketAddressEnumerator,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_address_enumerator_next_async(
        enumerator: *mut GSocketAddressEnumerator,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_address_enumerator_next_finish(
        enumerator: *mut GSocketAddressEnumerator,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
#[doc = " GProxyAddressEnumerator:\n\n A subclass of #GSocketAddressEnumerator that takes another address\n enumerator and wraps each of its results in a #GProxyAddress as\n directed by the default #GProxyResolver."]
pub type GProxyAddressEnumeratorClass = _GProxyAddressEnumeratorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressEnumeratorPrivate {
    _unused: [u8; 0],
}
pub type GProxyAddressEnumeratorPrivate = _GProxyAddressEnumeratorPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressEnumerator {
    pub parent_instance: GSocketAddressEnumerator,
    pub priv_: *mut GProxyAddressEnumeratorPrivate,
}
#[test]
fn bindgen_test_layout__GProxyAddressEnumerator() {
    const UNINIT: ::std::mem::MaybeUninit<_GProxyAddressEnumerator> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GProxyAddressEnumerator>(),
        32usize,
        concat!("Size of: ", stringify!(_GProxyAddressEnumerator))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyAddressEnumerator>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyAddressEnumerator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumerator),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumerator),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GProxyAddressEnumeratorClass:\n\n Class structure for #GProxyAddressEnumerator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressEnumeratorClass {
    pub parent_class: GSocketAddressEnumeratorClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GProxyAddressEnumeratorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GProxyAddressEnumeratorClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GProxyAddressEnumeratorClass>(),
        216usize,
        concat!("Size of: ", stringify!(_GProxyAddressEnumeratorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyAddressEnumeratorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyAddressEnumeratorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved7) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
}
extern "C" {
    pub fn g_proxy_address_enumerator_get_type() -> GType;
}
pub type GProxyResolverInterface = _GProxyResolverInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyResolverInterface {
    pub g_iface: GTypeInterface,
    pub is_supported:
        ::std::option::Option<unsafe extern "C" fn(resolver: *mut GProxyResolver) -> gboolean>,
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GProxyResolver,
            uri: *const gchar,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
    pub lookup_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GProxyResolver,
            uri: *const gchar,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GProxyResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
}
#[test]
fn bindgen_test_layout__GProxyResolverInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GProxyResolverInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GProxyResolverInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GProxyResolverInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyResolverInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyResolverInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_supported) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(is_supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_async) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(lookup_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_finish) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(lookup_finish)
        )
    );
}
extern "C" {
    pub fn g_proxy_resolver_get_type() -> GType;
}
extern "C" {
    pub fn g_proxy_resolver_get_default() -> *mut GProxyResolver;
}
extern "C" {
    pub fn g_proxy_resolver_is_supported(resolver: *mut GProxyResolver) -> gboolean;
}
extern "C" {
    pub fn g_proxy_resolver_lookup(
        resolver: *mut GProxyResolver,
        uri: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_proxy_resolver_lookup_async(
        resolver: *mut GProxyResolver,
        uri: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_proxy_resolver_lookup_finish(
        resolver: *mut GProxyResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
pub type GRemoteActionGroupInterface = _GRemoteActionGroupInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRemoteActionGroupInterface {
    pub g_iface: GTypeInterface,
    pub activate_action_full: ::std::option::Option<
        unsafe extern "C" fn(
            remote: *mut GRemoteActionGroup,
            action_name: *const gchar,
            parameter: *mut GVariant,
            platform_data: *mut GVariant,
        ),
    >,
    pub change_action_state_full: ::std::option::Option<
        unsafe extern "C" fn(
            remote: *mut GRemoteActionGroup,
            action_name: *const gchar,
            value: *mut GVariant,
            platform_data: *mut GVariant,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GRemoteActionGroupInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GRemoteActionGroupInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GRemoteActionGroupInterface>(),
        32usize,
        concat!("Size of: ", stringify!(_GRemoteActionGroupInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRemoteActionGroupInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRemoteActionGroupInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRemoteActionGroupInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activate_action_full) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRemoteActionGroupInterface),
            "::",
            stringify!(activate_action_full)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_action_state_full) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRemoteActionGroupInterface),
            "::",
            stringify!(change_action_state_full)
        )
    );
}
extern "C" {
    pub fn g_remote_action_group_get_type() -> GType;
}
extern "C" {
    pub fn g_remote_action_group_activate_action_full(
        remote: *mut GRemoteActionGroup,
        action_name: *const gchar,
        parameter: *mut GVariant,
        platform_data: *mut GVariant,
    );
}
extern "C" {
    pub fn g_remote_action_group_change_action_state_full(
        remote: *mut GRemoteActionGroup,
        action_name: *const gchar,
        value: *mut GVariant,
        platform_data: *mut GVariant,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResolverPrivate {
    _unused: [u8; 0],
}
pub type GResolverPrivate = _GResolverPrivate;
pub type GResolverClass = _GResolverClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResolver {
    pub parent_instance: GObject,
    pub priv_: *mut GResolverPrivate,
}
#[test]
fn bindgen_test_layout__GResolver() {
    const UNINIT: ::std::mem::MaybeUninit<_GResolver> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GResolver>(),
        32usize,
        concat!("Size of: ", stringify!(_GResolver))
    );
    assert_eq!(
        ::std::mem::align_of::<_GResolver>(),
        8usize,
        concat!("Alignment of ", stringify!(_GResolver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolver),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolver),
            "::",
            stringify!(priv_)
        )
    );
}
pub const GResolverNameLookupFlags_G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT: GResolverNameLookupFlags =
    0;
pub const GResolverNameLookupFlags_G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY:
    GResolverNameLookupFlags = 1;
pub const GResolverNameLookupFlags_G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY:
    GResolverNameLookupFlags = 2;
#[doc = " GResolverNameLookupFlags:\n @G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT: default behavior (same as g_resolver_lookup_by_name())\n @G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY: only resolve ipv4 addresses\n @G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY: only resolve ipv6 addresses\n\n Flags to modify lookup behavior.\n\n Since: 2.60"]
pub type GResolverNameLookupFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResolverClass {
    pub parent_class: GObjectClass,
    pub reload: ::std::option::Option<unsafe extern "C" fn(resolver: *mut GResolver)>,
    pub lookup_by_name: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_by_name_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_by_name_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_by_address: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            address: *mut GInetAddress,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut gchar,
    >,
    pub lookup_by_address_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            address: *mut GInetAddress,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_by_address_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut gchar,
    >,
    pub lookup_service: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_service_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_service_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_records: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            record_type: GResolverRecordType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_records_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            record_type: GResolverRecordType,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_records_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    #[doc = " GResolverClass::lookup_by_name_with_flags_async:\n @resolver: a #GResolver\n @hostname: the hostname to resolve\n @flags: extra #GResolverNameLookupFlags to modify the lookup\n @cancellable: (nullable): a #GCancellable\n @callback: (scope async): a #GAsyncReadyCallback to call when completed\n @user_data: (closure): data to pass to @callback\n\n Asynchronous version of GResolverClass::lookup_by_name_with_flags\n\n GResolverClass::lookup_by_name_with_flags_finish will be called to get\n the result.\n\n Since: 2.60"]
    pub lookup_by_name_with_flags_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            flags: GResolverNameLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    #[doc = " GResolverClass::lookup_by_name_with_flags_finish:\n @resolver: a #GResolver\n @result: a #GAsyncResult\n @error: (nullable): a pointer to a %NULL #GError\n\n Gets the result from GResolverClass::lookup_by_name_with_flags_async\n\n Returns: (element-type GInetAddress) (transfer full): List of #GInetAddress.\n Since: 2.60"]
    pub lookup_by_name_with_flags_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    #[doc = " GResolverClass::lookup_by_name_with_flags:\n @resolver: a #GResolver\n @hostname: the hostname to resolve\n @flags: extra #GResolverNameLookupFlags to modify the lookup\n @cancellable: (nullable): a #GCancellable\n @error: (nullable): a pointer to a %NULL #GError\n\n This is identical to GResolverClass::lookup_by_name except it takes\n @flags which modifies the behavior of the lookup. See #GResolverNameLookupFlags\n for more details.\n\n Returns: (element-type GInetAddress) (transfer full): List of #GInetAddress.\n Since: 2.60"]
    pub lookup_by_name_with_flags: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            flags: GResolverNameLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
}
#[test]
fn bindgen_test_layout__GResolverClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GResolverClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GResolverClass>(),
        264usize,
        concat!("Size of: ", stringify!(_GResolverClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GResolverClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GResolverClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reload) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(reload)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_name) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_name_async) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_name_finish) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_address) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_address_async) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_address_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_address_finish) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_address_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_service) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_service)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_service_async) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_service_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_service_finish) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_service_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_records) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_records)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_records_async) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_records_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_records_finish) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_records_finish)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_by_name_with_flags_async) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name_with_flags_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_by_name_with_flags_finish) as usize - ptr as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name_with_flags_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_by_name_with_flags) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name_with_flags)
        )
    );
}
extern "C" {
    pub fn g_resolver_get_type() -> GType;
}
extern "C" {
    pub fn g_resolver_get_default() -> *mut GResolver;
}
extern "C" {
    pub fn g_resolver_set_default(resolver: *mut GResolver);
}
extern "C" {
    pub fn g_resolver_lookup_by_name(
        resolver: *mut GResolver,
        hostname: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_lookup_by_name_async(
        resolver: *mut GResolver,
        hostname: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_resolver_lookup_by_name_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_lookup_by_name_with_flags_async(
        resolver: *mut GResolver,
        hostname: *const gchar,
        flags: GResolverNameLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_resolver_lookup_by_name_with_flags_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_lookup_by_name_with_flags(
        resolver: *mut GResolver,
        hostname: *const gchar,
        flags: GResolverNameLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_free_addresses(addresses: *mut GList);
}
extern "C" {
    pub fn g_resolver_lookup_by_address(
        resolver: *mut GResolver,
        address: *mut GInetAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_resolver_lookup_by_address_async(
        resolver: *mut GResolver,
        address: *mut GInetAddress,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_resolver_lookup_by_address_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_resolver_lookup_service(
        resolver: *mut GResolver,
        service: *const gchar,
        protocol: *const gchar,
        domain: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_lookup_service_async(
        resolver: *mut GResolver,
        service: *const gchar,
        protocol: *const gchar,
        domain: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_resolver_lookup_service_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_lookup_records(
        resolver: *mut GResolver,
        rrname: *const gchar,
        record_type: GResolverRecordType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_lookup_records_async(
        resolver: *mut GResolver,
        rrname: *const gchar,
        record_type: GResolverRecordType,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_resolver_lookup_records_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_resolver_free_targets(targets: *mut GList);
}
extern "C" {
    pub fn g_resolver_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_resource_error_quark() -> GQuark;
}
pub type GStaticResource = _GStaticResource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticResource {
    pub data: *const guint8,
    pub data_len: gsize,
    pub resource: *mut GResource,
    pub next: *mut GStaticResource,
    pub padding: gpointer,
}
#[test]
fn bindgen_test_layout__GStaticResource() {
    const UNINIT: ::std::mem::MaybeUninit<_GStaticResource> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GStaticResource>(),
        40usize,
        concat!("Size of: ", stringify!(_GStaticResource))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticResource>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticResource))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resource) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_resource_get_type() -> GType;
}
extern "C" {
    pub fn g_resource_new_from_data(data: *mut GBytes, error: *mut *mut GError) -> *mut GResource;
}
extern "C" {
    pub fn g_resource_ref(resource: *mut GResource) -> *mut GResource;
}
extern "C" {
    pub fn g_resource_unref(resource: *mut GResource);
}
extern "C" {
    pub fn g_resource_load(filename: *const gchar, error: *mut *mut GError) -> *mut GResource;
}
extern "C" {
    pub fn g_resource_open_stream(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_resource_lookup_data(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_resource_enumerate_children(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_resource_get_info(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        size: *mut gsize,
        flags: *mut guint32,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_resources_register(resource: *mut GResource);
}
extern "C" {
    pub fn g_resources_unregister(resource: *mut GResource);
}
extern "C" {
    pub fn g_resources_open_stream(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
extern "C" {
    pub fn g_resources_lookup_data(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_resources_enumerate_children(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_resources_get_info(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        size: *mut gsize,
        flags: *mut guint32,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_static_resource_init(static_resource: *mut GStaticResource);
}
extern "C" {
    pub fn g_static_resource_fini(static_resource: *mut GStaticResource);
}
extern "C" {
    pub fn g_static_resource_get_resource(static_resource: *mut GStaticResource) -> *mut GResource;
}
#[doc = " GSeekable:\n\n Seek object for streaming operations."]
pub type GSeekableIface = _GSeekableIface;
#[doc = " GSeekableIface:\n @g_iface: The parent interface.\n @tell: Tells the current location within a stream.\n @can_seek: Checks if seeking is supported by the stream.\n @seek: Seeks to a location within a stream.\n @can_truncate: Checks if truncation is supported by the stream.\n @truncate_fn: Truncates a stream.\n\n Provides an interface for implementing seekable functionality on I/O Streams."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSeekableIface {
    pub g_iface: GTypeInterface,
    pub tell: ::std::option::Option<unsafe extern "C" fn(seekable: *mut GSeekable) -> goffset>,
    pub can_seek: ::std::option::Option<unsafe extern "C" fn(seekable: *mut GSeekable) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            seekable: *mut GSeekable,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_truncate:
        ::std::option::Option<unsafe extern "C" fn(seekable: *mut GSeekable) -> gboolean>,
    pub truncate_fn: ::std::option::Option<
        unsafe extern "C" fn(
            seekable: *mut GSeekable,
            offset: goffset,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GSeekableIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GSeekableIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSeekableIface>(),
        56usize,
        concat!("Size of: ", stringify!(_GSeekableIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSeekableIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSeekableIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_seek) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(can_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_truncate) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(can_truncate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate_fn) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(truncate_fn)
        )
    );
}
extern "C" {
    pub fn g_seekable_get_type() -> GType;
}
extern "C" {
    pub fn g_seekable_tell(seekable: *mut GSeekable) -> goffset;
}
extern "C" {
    pub fn g_seekable_can_seek(seekable: *mut GSeekable) -> gboolean;
}
extern "C" {
    pub fn g_seekable_seek(
        seekable: *mut GSeekable,
        offset: goffset,
        type_: GSeekType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_seekable_can_truncate(seekable: *mut GSeekable) -> gboolean;
}
extern "C" {
    pub fn g_seekable_truncate(
        seekable: *mut GSeekable,
        offset: goffset,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsSchemaSource {
    _unused: [u8; 0],
}
pub type GSettingsSchemaSource = _GSettingsSchemaSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsSchema {
    _unused: [u8; 0],
}
pub type GSettingsSchema = _GSettingsSchema;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsSchemaKey {
    _unused: [u8; 0],
}
pub type GSettingsSchemaKey = _GSettingsSchemaKey;
extern "C" {
    pub fn g_settings_schema_source_get_type() -> GType;
}
extern "C" {
    pub fn g_settings_schema_source_get_default() -> *mut GSettingsSchemaSource;
}
extern "C" {
    pub fn g_settings_schema_source_ref(
        source: *mut GSettingsSchemaSource,
    ) -> *mut GSettingsSchemaSource;
}
extern "C" {
    pub fn g_settings_schema_source_unref(source: *mut GSettingsSchemaSource);
}
extern "C" {
    pub fn g_settings_schema_source_new_from_directory(
        directory: *const gchar,
        parent: *mut GSettingsSchemaSource,
        trusted: gboolean,
        error: *mut *mut GError,
    ) -> *mut GSettingsSchemaSource;
}
extern "C" {
    pub fn g_settings_schema_source_lookup(
        source: *mut GSettingsSchemaSource,
        schema_id: *const gchar,
        recursive: gboolean,
    ) -> *mut GSettingsSchema;
}
extern "C" {
    pub fn g_settings_schema_source_list_schemas(
        source: *mut GSettingsSchemaSource,
        recursive: gboolean,
        non_relocatable: *mut *mut *mut gchar,
        relocatable: *mut *mut *mut gchar,
    );
}
extern "C" {
    pub fn g_settings_schema_get_type() -> GType;
}
extern "C" {
    pub fn g_settings_schema_ref(schema: *mut GSettingsSchema) -> *mut GSettingsSchema;
}
extern "C" {
    pub fn g_settings_schema_unref(schema: *mut GSettingsSchema);
}
extern "C" {
    pub fn g_settings_schema_get_id(schema: *mut GSettingsSchema) -> *const gchar;
}
extern "C" {
    pub fn g_settings_schema_get_path(schema: *mut GSettingsSchema) -> *const gchar;
}
extern "C" {
    pub fn g_settings_schema_get_key(
        schema: *mut GSettingsSchema,
        name: *const gchar,
    ) -> *mut GSettingsSchemaKey;
}
extern "C" {
    pub fn g_settings_schema_has_key(schema: *mut GSettingsSchema, name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_settings_schema_list_keys(schema: *mut GSettingsSchema) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_settings_schema_list_children(schema: *mut GSettingsSchema) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_settings_schema_key_get_type() -> GType;
}
extern "C" {
    pub fn g_settings_schema_key_ref(key: *mut GSettingsSchemaKey) -> *mut GSettingsSchemaKey;
}
extern "C" {
    pub fn g_settings_schema_key_unref(key: *mut GSettingsSchemaKey);
}
extern "C" {
    pub fn g_settings_schema_key_get_value_type(
        key: *mut GSettingsSchemaKey,
    ) -> *const GVariantType;
}
extern "C" {
    pub fn g_settings_schema_key_get_default_value(key: *mut GSettingsSchemaKey) -> *mut GVariant;
}
extern "C" {
    pub fn g_settings_schema_key_get_range(key: *mut GSettingsSchemaKey) -> *mut GVariant;
}
extern "C" {
    pub fn g_settings_schema_key_range_check(
        key: *mut GSettingsSchemaKey,
        value: *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_schema_key_get_name(key: *mut GSettingsSchemaKey) -> *const gchar;
}
extern "C" {
    pub fn g_settings_schema_key_get_summary(key: *mut GSettingsSchemaKey) -> *const gchar;
}
extern "C" {
    pub fn g_settings_schema_key_get_description(key: *mut GSettingsSchemaKey) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsPrivate {
    _unused: [u8; 0],
}
pub type GSettingsPrivate = _GSettingsPrivate;
pub type GSettingsClass = _GSettingsClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsClass {
    pub parent_class: GObjectClass,
    pub writable_changed:
        ::std::option::Option<unsafe extern "C" fn(settings: *mut GSettings, key: *const gchar)>,
    pub changed:
        ::std::option::Option<unsafe extern "C" fn(settings: *mut GSettings, key: *const gchar)>,
    pub writable_change_event: ::std::option::Option<
        unsafe extern "C" fn(settings: *mut GSettings, key: GQuark) -> gboolean,
    >,
    pub change_event: ::std::option::Option<
        unsafe extern "C" fn(
            settings: *mut GSettings,
            keys: *const GQuark,
            n_keys: gint,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 20usize],
}
#[test]
fn bindgen_test_layout__GSettingsClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSettingsClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSettingsClass>(),
        328usize,
        concat!("Size of: ", stringify!(_GSettingsClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSettingsClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSettingsClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writable_changed) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(writable_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changed) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writable_change_event) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(writable_change_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).change_event) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(change_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettings {
    pub parent_instance: GObject,
    pub priv_: *mut GSettingsPrivate,
}
#[test]
fn bindgen_test_layout__GSettings() {
    const UNINIT: ::std::mem::MaybeUninit<_GSettings> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSettings>(),
        32usize,
        concat!("Size of: ", stringify!(_GSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSettings>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSettings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettings),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettings),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_settings_get_type() -> GType;
}
extern "C" {
    pub fn g_settings_list_schemas() -> *const *const gchar;
}
extern "C" {
    pub fn g_settings_list_relocatable_schemas() -> *const *const gchar;
}
extern "C" {
    pub fn g_settings_new(schema_id: *const gchar) -> *mut GSettings;
}
extern "C" {
    pub fn g_settings_new_with_path(schema_id: *const gchar, path: *const gchar) -> *mut GSettings;
}
extern "C" {
    pub fn g_settings_new_with_backend(
        schema_id: *const gchar,
        backend: *mut GSettingsBackend,
    ) -> *mut GSettings;
}
extern "C" {
    pub fn g_settings_new_with_backend_and_path(
        schema_id: *const gchar,
        backend: *mut GSettingsBackend,
        path: *const gchar,
    ) -> *mut GSettings;
}
extern "C" {
    pub fn g_settings_new_full(
        schema: *mut GSettingsSchema,
        backend: *mut GSettingsBackend,
        path: *const gchar,
    ) -> *mut GSettings;
}
extern "C" {
    pub fn g_settings_list_children(settings: *mut GSettings) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_settings_list_keys(settings: *mut GSettings) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_settings_get_range(settings: *mut GSettings, key: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_settings_range_check(
        settings: *mut GSettings,
        key: *const gchar,
        value: *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_set_value(
        settings: *mut GSettings,
        key: *const gchar,
        value: *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_value(settings: *mut GSettings, key: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_settings_get_user_value(settings: *mut GSettings, key: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_settings_get_default_value(
        settings: *mut GSettings,
        key: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_settings_set(
        settings: *mut GSettings,
        key: *const gchar,
        format: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get(settings: *mut GSettings, key: *const gchar, format: *const gchar, ...);
}
extern "C" {
    pub fn g_settings_reset(settings: *mut GSettings, key: *const gchar);
}
extern "C" {
    pub fn g_settings_get_int(settings: *mut GSettings, key: *const gchar) -> gint;
}
extern "C" {
    pub fn g_settings_set_int(settings: *mut GSettings, key: *const gchar, value: gint)
        -> gboolean;
}
extern "C" {
    pub fn g_settings_get_int64(settings: *mut GSettings, key: *const gchar) -> gint64;
}
extern "C" {
    pub fn g_settings_set_int64(
        settings: *mut GSettings,
        key: *const gchar,
        value: gint64,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_uint(settings: *mut GSettings, key: *const gchar) -> guint;
}
extern "C" {
    pub fn g_settings_set_uint(
        settings: *mut GSettings,
        key: *const gchar,
        value: guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_uint64(settings: *mut GSettings, key: *const gchar) -> guint64;
}
extern "C" {
    pub fn g_settings_set_uint64(
        settings: *mut GSettings,
        key: *const gchar,
        value: guint64,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_string(settings: *mut GSettings, key: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_settings_set_string(
        settings: *mut GSettings,
        key: *const gchar,
        value: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_boolean(settings: *mut GSettings, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_settings_set_boolean(
        settings: *mut GSettings,
        key: *const gchar,
        value: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_double(settings: *mut GSettings, key: *const gchar) -> gdouble;
}
extern "C" {
    pub fn g_settings_set_double(
        settings: *mut GSettings,
        key: *const gchar,
        value: gdouble,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_strv(settings: *mut GSettings, key: *const gchar) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_settings_set_strv(
        settings: *mut GSettings,
        key: *const gchar,
        value: *const *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_enum(settings: *mut GSettings, key: *const gchar) -> gint;
}
extern "C" {
    pub fn g_settings_set_enum(
        settings: *mut GSettings,
        key: *const gchar,
        value: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_flags(settings: *mut GSettings, key: *const gchar) -> guint;
}
extern "C" {
    pub fn g_settings_set_flags(
        settings: *mut GSettings,
        key: *const gchar,
        value: guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_settings_get_child(settings: *mut GSettings, name: *const gchar) -> *mut GSettings;
}
extern "C" {
    pub fn g_settings_is_writable(settings: *mut GSettings, name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_settings_delay(settings: *mut GSettings);
}
extern "C" {
    pub fn g_settings_apply(settings: *mut GSettings);
}
extern "C" {
    pub fn g_settings_revert(settings: *mut GSettings);
}
extern "C" {
    pub fn g_settings_get_has_unapplied(settings: *mut GSettings) -> gboolean;
}
extern "C" {
    pub fn g_settings_sync();
}
#[doc = " GSettingsBindSetMapping:\n @value: a #GValue containing the property value to map\n @expected_type: the #GVariantType to create\n @user_data: user data that was specified when the binding was created\n\n The type for the function that is used to convert an object property\n value to a #GVariant for storing it in #GSettings.\n\n Returns: a new #GVariant holding the data from @value,\n     or %NULL in case of an error"]
pub type GSettingsBindSetMapping = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const GValue,
        expected_type: *const GVariantType,
        user_data: gpointer,
    ) -> *mut GVariant,
>;
#[doc = " GSettingsBindGetMapping:\n @value: return location for the property value\n @variant: the #GVariant\n @user_data: user data that was specified when the binding was created\n\n The type for the function that is used to convert from #GSettings to\n an object property. The @value is already initialized to hold values\n of the appropriate type.\n\n Returns: %TRUE if the conversion succeeded, %FALSE in case of an error"]
pub type GSettingsBindGetMapping = ::std::option::Option<
    unsafe extern "C" fn(
        value: *mut GValue,
        variant: *mut GVariant,
        user_data: gpointer,
    ) -> gboolean,
>;
#[doc = " GSettingsGetMapping:\n @value: the #GVariant to map, or %NULL\n @result: (out): the result of the mapping\n @user_data: (closure): the user data that was passed to\n g_settings_get_mapped()\n\n The type of the function that is used to convert from a value stored\n in a #GSettings to a value that is useful to the application.\n\n If the value is successfully mapped, the result should be stored at\n @result and %TRUE returned.  If mapping fails (for example, if @value\n is not in the right format) then %FALSE should be returned.\n\n If @value is %NULL then it means that the mapping function is being\n given a \"last chance\" to successfully return a valid value.  %TRUE\n must be returned in this case.\n\n Returns: %TRUE if the conversion succeeded, %FALSE in case of an error"]
pub type GSettingsGetMapping = ::std::option::Option<
    unsafe extern "C" fn(
        value: *mut GVariant,
        result: *mut gpointer,
        user_data: gpointer,
    ) -> gboolean,
>;
pub const GSettingsBindFlags_G_SETTINGS_BIND_DEFAULT: GSettingsBindFlags = 0;
pub const GSettingsBindFlags_G_SETTINGS_BIND_GET: GSettingsBindFlags = 1;
pub const GSettingsBindFlags_G_SETTINGS_BIND_SET: GSettingsBindFlags = 2;
pub const GSettingsBindFlags_G_SETTINGS_BIND_NO_SENSITIVITY: GSettingsBindFlags = 4;
pub const GSettingsBindFlags_G_SETTINGS_BIND_GET_NO_CHANGES: GSettingsBindFlags = 8;
pub const GSettingsBindFlags_G_SETTINGS_BIND_INVERT_BOOLEAN: GSettingsBindFlags = 16;
#[doc = " GSettingsBindFlags:\n @G_SETTINGS_BIND_DEFAULT: Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`\n @G_SETTINGS_BIND_GET: Update the #GObject property when the setting changes.\n     It is an error to use this flag if the property is not writable.\n @G_SETTINGS_BIND_SET: Update the setting when the #GObject property changes.\n     It is an error to use this flag if the property is not readable.\n @G_SETTINGS_BIND_NO_SENSITIVITY: Do not try to bind a \"sensitivity\" property to the writability of the setting\n @G_SETTINGS_BIND_GET_NO_CHANGES: When set in addition to %G_SETTINGS_BIND_GET, set the #GObject property\n     value initially from the setting, but do not listen for changes of the setting\n @G_SETTINGS_BIND_INVERT_BOOLEAN: When passed to g_settings_bind(), uses a pair of mapping functions that invert\n     the boolean value when mapping between the setting and the property.  The setting and property must both\n     be booleans.  You cannot pass this flag to g_settings_bind_with_mapping().\n\n Flags used when creating a binding. These flags determine in which\n direction the binding works. The default is to synchronize in both\n directions."]
pub type GSettingsBindFlags = ::std::os::raw::c_uint;
extern "C" {
    pub fn g_settings_bind(
        settings: *mut GSettings,
        key: *const gchar,
        object: gpointer,
        property: *const gchar,
        flags: GSettingsBindFlags,
    );
}
extern "C" {
    pub fn g_settings_bind_with_mapping(
        settings: *mut GSettings,
        key: *const gchar,
        object: gpointer,
        property: *const gchar,
        flags: GSettingsBindFlags,
        get_mapping: GSettingsBindGetMapping,
        set_mapping: GSettingsBindSetMapping,
        user_data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_settings_bind_writable(
        settings: *mut GSettings,
        key: *const gchar,
        object: gpointer,
        property: *const gchar,
        inverted: gboolean,
    );
}
extern "C" {
    pub fn g_settings_unbind(object: gpointer, property: *const gchar);
}
extern "C" {
    pub fn g_settings_create_action(settings: *mut GSettings, key: *const gchar) -> *mut GAction;
}
extern "C" {
    pub fn g_settings_get_mapped(
        settings: *mut GSettings,
        key: *const gchar,
        mapping: GSettingsGetMapping,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_simple_action_get_type() -> GType;
}
extern "C" {
    pub fn g_simple_action_new(
        name: *const gchar,
        parameter_type: *const GVariantType,
    ) -> *mut GSimpleAction;
}
extern "C" {
    pub fn g_simple_action_new_stateful(
        name: *const gchar,
        parameter_type: *const GVariantType,
        state: *mut GVariant,
    ) -> *mut GSimpleAction;
}
extern "C" {
    pub fn g_simple_action_set_enabled(simple: *mut GSimpleAction, enabled: gboolean);
}
extern "C" {
    pub fn g_simple_action_set_state(simple: *mut GSimpleAction, value: *mut GVariant);
}
extern "C" {
    pub fn g_simple_action_set_state_hint(simple: *mut GSimpleAction, state_hint: *mut GVariant);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleActionGroupPrivate {
    _unused: [u8; 0],
}
pub type GSimpleActionGroupPrivate = _GSimpleActionGroupPrivate;
pub type GSimpleActionGroupClass = _GSimpleActionGroupClass;
#[doc = " GSimpleActionGroup:\n\n The #GSimpleActionGroup structure contains private data and should only be accessed using the provided API.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleActionGroup {
    pub parent_instance: GObject,
    pub priv_: *mut GSimpleActionGroupPrivate,
}
#[test]
fn bindgen_test_layout__GSimpleActionGroup() {
    const UNINIT: ::std::mem::MaybeUninit<_GSimpleActionGroup> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSimpleActionGroup>(),
        32usize,
        concat!("Size of: ", stringify!(_GSimpleActionGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSimpleActionGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSimpleActionGroup))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleActionGroup),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleActionGroup),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleActionGroupClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 12usize],
}
#[test]
fn bindgen_test_layout__GSimpleActionGroupClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSimpleActionGroupClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSimpleActionGroupClass>(),
        232usize,
        concat!("Size of: ", stringify!(_GSimpleActionGroupClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSimpleActionGroupClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSimpleActionGroupClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleActionGroupClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleActionGroupClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_simple_action_group_get_type() -> GType;
}
extern "C" {
    pub fn g_simple_action_group_new() -> *mut GSimpleActionGroup;
}
extern "C" {
    pub fn g_simple_action_group_lookup(
        simple: *mut GSimpleActionGroup,
        action_name: *const gchar,
    ) -> *mut GAction;
}
extern "C" {
    pub fn g_simple_action_group_insert(simple: *mut GSimpleActionGroup, action: *mut GAction);
}
extern "C" {
    pub fn g_simple_action_group_remove(simple: *mut GSimpleActionGroup, action_name: *const gchar);
}
extern "C" {
    pub fn g_simple_action_group_add_entries(
        simple: *mut GSimpleActionGroup,
        entries: *const GActionEntry,
        n_entries: gint,
        user_data: gpointer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleAsyncResultClass {
    _unused: [u8; 0],
}
#[doc = " GSimpleAsyncResult:\n\n A simple implementation of #GAsyncResult."]
pub type GSimpleAsyncResultClass = _GSimpleAsyncResultClass;
extern "C" {
    pub fn g_simple_async_result_get_type() -> GType;
}
extern "C" {
    pub fn g_simple_async_result_new(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        source_tag: gpointer,
    ) -> *mut GSimpleAsyncResult;
}
extern "C" {
    pub fn g_simple_async_result_new_error(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut GSimpleAsyncResult;
}
extern "C" {
    pub fn g_simple_async_result_new_from_error(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *const GError,
    ) -> *mut GSimpleAsyncResult;
}
extern "C" {
    pub fn g_simple_async_result_new_take_error(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *mut GError,
    ) -> *mut GSimpleAsyncResult;
}
extern "C" {
    pub fn g_simple_async_result_set_op_res_gpointer(
        simple: *mut GSimpleAsyncResult,
        op_res: gpointer,
        destroy_op_res: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_simple_async_result_get_op_res_gpointer(simple: *mut GSimpleAsyncResult) -> gpointer;
}
extern "C" {
    pub fn g_simple_async_result_set_op_res_gssize(simple: *mut GSimpleAsyncResult, op_res: gssize);
}
extern "C" {
    pub fn g_simple_async_result_get_op_res_gssize(simple: *mut GSimpleAsyncResult) -> gssize;
}
extern "C" {
    pub fn g_simple_async_result_set_op_res_gboolean(
        simple: *mut GSimpleAsyncResult,
        op_res: gboolean,
    );
}
extern "C" {
    pub fn g_simple_async_result_get_op_res_gboolean(simple: *mut GSimpleAsyncResult) -> gboolean;
}
extern "C" {
    pub fn g_simple_async_result_set_check_cancellable(
        simple: *mut GSimpleAsyncResult,
        check_cancellable: *mut GCancellable,
    );
}
extern "C" {
    pub fn g_simple_async_result_get_source_tag(simple: *mut GSimpleAsyncResult) -> gpointer;
}
extern "C" {
    pub fn g_simple_async_result_set_handle_cancellation(
        simple: *mut GSimpleAsyncResult,
        handle_cancellation: gboolean,
    );
}
extern "C" {
    pub fn g_simple_async_result_complete(simple: *mut GSimpleAsyncResult);
}
extern "C" {
    pub fn g_simple_async_result_complete_in_idle(simple: *mut GSimpleAsyncResult);
}
extern "C" {
    pub fn g_simple_async_result_run_in_thread(
        simple: *mut GSimpleAsyncResult,
        func: GSimpleAsyncThreadFunc,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
    );
}
extern "C" {
    pub fn g_simple_async_result_set_from_error(
        simple: *mut GSimpleAsyncResult,
        error: *const GError,
    );
}
extern "C" {
    pub fn g_simple_async_result_take_error(simple: *mut GSimpleAsyncResult, error: *mut GError);
}
extern "C" {
    pub fn g_simple_async_result_propagate_error(
        simple: *mut GSimpleAsyncResult,
        dest: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_simple_async_result_set_error(
        simple: *mut GSimpleAsyncResult,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_simple_async_result_set_error_va(
        simple: *mut GSimpleAsyncResult,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn g_simple_async_result_is_valid(
        result: *mut GAsyncResult,
        source: *mut GObject,
        source_tag: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_simple_async_report_error_in_idle(
        object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_simple_async_report_gerror_in_idle(
        object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *const GError,
    );
}
extern "C" {
    pub fn g_simple_async_report_take_gerror_in_idle(
        object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *mut GError,
    );
}
extern "C" {
    pub fn g_simple_io_stream_get_type() -> GType;
}
extern "C" {
    pub fn g_simple_io_stream_new(
        input_stream: *mut GInputStream,
        output_stream: *mut GOutputStream,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_simple_permission_get_type() -> GType;
}
extern "C" {
    pub fn g_simple_permission_new(allowed: gboolean) -> *mut GPermission;
}
#[doc = " GSimpleProxyResolver:\n\n A #GProxyResolver implementation for using a fixed set of proxies."]
pub type GSimpleProxyResolver = _GSimpleProxyResolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleProxyResolverPrivate {
    _unused: [u8; 0],
}
pub type GSimpleProxyResolverPrivate = _GSimpleProxyResolverPrivate;
pub type GSimpleProxyResolverClass = _GSimpleProxyResolverClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleProxyResolver {
    pub parent_instance: GObject,
    pub priv_: *mut GSimpleProxyResolverPrivate,
}
#[test]
fn bindgen_test_layout__GSimpleProxyResolver() {
    const UNINIT: ::std::mem::MaybeUninit<_GSimpleProxyResolver> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSimpleProxyResolver>(),
        32usize,
        concat!("Size of: ", stringify!(_GSimpleProxyResolver))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSimpleProxyResolver>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSimpleProxyResolver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolver),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolver),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleProxyResolverClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSimpleProxyResolverClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSimpleProxyResolverClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSimpleProxyResolverClass>(),
        176usize,
        concat!("Size of: ", stringify!(_GSimpleProxyResolverClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSimpleProxyResolverClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSimpleProxyResolverClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    pub fn g_simple_proxy_resolver_get_type() -> GType;
}
extern "C" {
    pub fn g_simple_proxy_resolver_new(
        default_proxy: *const gchar,
        ignore_hosts: *mut *mut gchar,
    ) -> *mut GProxyResolver;
}
extern "C" {
    pub fn g_simple_proxy_resolver_set_default_proxy(
        resolver: *mut GSimpleProxyResolver,
        default_proxy: *const gchar,
    );
}
extern "C" {
    pub fn g_simple_proxy_resolver_set_ignore_hosts(
        resolver: *mut GSimpleProxyResolver,
        ignore_hosts: *mut *mut gchar,
    );
}
extern "C" {
    pub fn g_simple_proxy_resolver_set_uri_proxy(
        resolver: *mut GSimpleProxyResolver,
        uri_scheme: *const gchar,
        proxy: *const gchar,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketPrivate {
    _unused: [u8; 0],
}
pub type GSocketPrivate = _GSocketPrivate;
pub type GSocketClass = _GSocketClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved10: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketClass>(),
        216usize,
        concat!("Size of: ", stringify!(_GSocketClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved7) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved8) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved9) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved10) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved10)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocket {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketPrivate,
}
#[test]
fn bindgen_test_layout__GSocket() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocket> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocket>(),
        32usize,
        concat!("Size of: ", stringify!(_GSocket))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocket>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocket))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocket),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocket),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_socket_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_new(
        family: GSocketFamily,
        type_: GSocketType,
        protocol: GSocketProtocol,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
extern "C" {
    pub fn g_socket_new_from_fd(fd: gint, error: *mut *mut GError) -> *mut GSocket;
}
extern "C" {
    pub fn g_socket_get_fd(socket: *mut GSocket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_socket_get_family(socket: *mut GSocket) -> GSocketFamily;
}
extern "C" {
    pub fn g_socket_get_socket_type(socket: *mut GSocket) -> GSocketType;
}
extern "C" {
    pub fn g_socket_get_protocol(socket: *mut GSocket) -> GSocketProtocol;
}
extern "C" {
    pub fn g_socket_get_local_address(
        socket: *mut GSocket,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_get_remote_address(
        socket: *mut GSocket,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_set_blocking(socket: *mut GSocket, blocking: gboolean);
}
extern "C" {
    pub fn g_socket_get_blocking(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_set_keepalive(socket: *mut GSocket, keepalive: gboolean);
}
extern "C" {
    pub fn g_socket_get_keepalive(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_get_listen_backlog(socket: *mut GSocket) -> gint;
}
extern "C" {
    pub fn g_socket_set_listen_backlog(socket: *mut GSocket, backlog: gint);
}
extern "C" {
    pub fn g_socket_get_timeout(socket: *mut GSocket) -> guint;
}
extern "C" {
    pub fn g_socket_set_timeout(socket: *mut GSocket, timeout: guint);
}
extern "C" {
    pub fn g_socket_get_ttl(socket: *mut GSocket) -> guint;
}
extern "C" {
    pub fn g_socket_set_ttl(socket: *mut GSocket, ttl: guint);
}
extern "C" {
    pub fn g_socket_get_broadcast(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_set_broadcast(socket: *mut GSocket, broadcast: gboolean);
}
extern "C" {
    pub fn g_socket_get_multicast_loopback(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_set_multicast_loopback(socket: *mut GSocket, loopback: gboolean);
}
extern "C" {
    pub fn g_socket_get_multicast_ttl(socket: *mut GSocket) -> guint;
}
extern "C" {
    pub fn g_socket_set_multicast_ttl(socket: *mut GSocket, ttl: guint);
}
extern "C" {
    pub fn g_socket_is_connected(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_bind(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        allow_reuse: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_join_multicast_group(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: gboolean,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_leave_multicast_group(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: gboolean,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_join_multicast_group_ssm(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: *mut GInetAddress,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_leave_multicast_group_ssm(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: *mut GInetAddress,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_connect(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_check_connect_result(socket: *mut GSocket, error: *mut *mut GError)
        -> gboolean;
}
extern "C" {
    pub fn g_socket_get_available_bytes(socket: *mut GSocket) -> gssize;
}
extern "C" {
    pub fn g_socket_condition_check(socket: *mut GSocket, condition: GIOCondition) -> GIOCondition;
}
extern "C" {
    pub fn g_socket_condition_wait(
        socket: *mut GSocket,
        condition: GIOCondition,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_condition_timed_wait(
        socket: *mut GSocket,
        condition: GIOCondition,
        timeout_us: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_accept(
        socket: *mut GSocket,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
extern "C" {
    pub fn g_socket_listen(socket: *mut GSocket, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_socket_receive(
        socket: *mut GSocket,
        buffer: *mut gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_receive_from(
        socket: *mut GSocket,
        address: *mut *mut GSocketAddress,
        buffer: *mut gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_send(
        socket: *mut GSocket,
        buffer: *const gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_send_to(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        buffer: *const gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_receive_message(
        socket: *mut GSocket,
        address: *mut *mut GSocketAddress,
        vectors: *mut GInputVector,
        num_vectors: gint,
        messages: *mut *mut *mut GSocketControlMessage,
        num_messages: *mut gint,
        flags: *mut gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_send_message(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        vectors: *mut GOutputVector,
        num_vectors: gint,
        messages: *mut *mut GSocketControlMessage,
        num_messages: gint,
        flags: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_receive_messages(
        socket: *mut GSocket,
        messages: *mut GInputMessage,
        num_messages: guint,
        flags: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_socket_send_messages(
        socket: *mut GSocket,
        messages: *mut GOutputMessage,
        num_messages: guint,
        flags: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_socket_close(socket: *mut GSocket, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_socket_shutdown(
        socket: *mut GSocket,
        shutdown_read: gboolean,
        shutdown_write: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_is_closed(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_create_source(
        socket: *mut GSocket,
        condition: GIOCondition,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_socket_speaks_ipv4(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    pub fn g_socket_get_credentials(
        socket: *mut GSocket,
        error: *mut *mut GError,
    ) -> *mut GCredentials;
}
extern "C" {
    pub fn g_socket_receive_with_blocking(
        socket: *mut GSocket,
        buffer: *mut gchar,
        size: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_send_with_blocking(
        socket: *mut GSocket,
        buffer: *const gchar,
        size: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    pub fn g_socket_send_message_with_timeout(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        vectors: *const GOutputVector,
        num_vectors: gint,
        messages: *mut *mut GSocketControlMessage,
        num_messages: gint,
        flags: gint,
        timeout_us: gint64,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GPollableReturn;
}
extern "C" {
    pub fn g_socket_get_option(
        socket: *mut GSocket,
        level: gint,
        optname: gint,
        value: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_set_option(
        socket: *mut GSocket,
        level: gint,
        optname: gint,
        value: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClientPrivate {
    _unused: [u8; 0],
}
pub type GSocketClientPrivate = _GSocketClientPrivate;
pub type GSocketClientClass = _GSocketClientClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClientClass {
    pub parent_class: GObjectClass,
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut GSocketClient,
            event: GSocketClientEvent,
            connectable: *mut GSocketConnectable,
            connection: *mut GIOStream,
        ),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketClientClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketClientClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketClientClass>(),
        176usize,
        concat!("Size of: ", stringify!(_GSocketClientClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketClientClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketClientClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClient {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketClientPrivate,
}
#[test]
fn bindgen_test_layout__GSocketClient() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketClient> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketClient>(),
        32usize,
        concat!("Size of: ", stringify!(_GSocketClient))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketClient>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketClient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClient),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClient),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_socket_client_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_client_new() -> *mut GSocketClient;
}
extern "C" {
    pub fn g_socket_client_get_family(client: *mut GSocketClient) -> GSocketFamily;
}
extern "C" {
    pub fn g_socket_client_set_family(client: *mut GSocketClient, family: GSocketFamily);
}
extern "C" {
    pub fn g_socket_client_get_socket_type(client: *mut GSocketClient) -> GSocketType;
}
extern "C" {
    pub fn g_socket_client_set_socket_type(client: *mut GSocketClient, type_: GSocketType);
}
extern "C" {
    pub fn g_socket_client_get_protocol(client: *mut GSocketClient) -> GSocketProtocol;
}
extern "C" {
    pub fn g_socket_client_set_protocol(client: *mut GSocketClient, protocol: GSocketProtocol);
}
extern "C" {
    pub fn g_socket_client_get_local_address(client: *mut GSocketClient) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_client_set_local_address(
        client: *mut GSocketClient,
        address: *mut GSocketAddress,
    );
}
extern "C" {
    pub fn g_socket_client_get_timeout(client: *mut GSocketClient) -> guint;
}
extern "C" {
    pub fn g_socket_client_set_timeout(client: *mut GSocketClient, timeout: guint);
}
extern "C" {
    pub fn g_socket_client_get_enable_proxy(client: *mut GSocketClient) -> gboolean;
}
extern "C" {
    pub fn g_socket_client_set_enable_proxy(client: *mut GSocketClient, enable: gboolean);
}
extern "C" {
    pub fn g_socket_client_get_tls(client: *mut GSocketClient) -> gboolean;
}
extern "C" {
    pub fn g_socket_client_set_tls(client: *mut GSocketClient, tls: gboolean);
}
extern "C" {
    pub fn g_socket_client_get_tls_validation_flags(
        client: *mut GSocketClient,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_socket_client_set_tls_validation_flags(
        client: *mut GSocketClient,
        flags: GTlsCertificateFlags,
    );
}
extern "C" {
    pub fn g_socket_client_get_proxy_resolver(client: *mut GSocketClient) -> *mut GProxyResolver;
}
extern "C" {
    pub fn g_socket_client_set_proxy_resolver(
        client: *mut GSocketClient,
        proxy_resolver: *mut GProxyResolver,
    );
}
extern "C" {
    pub fn g_socket_client_connect(
        client: *mut GSocketClient,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_to_host(
        client: *mut GSocketClient,
        host_and_port: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_to_service(
        client: *mut GSocketClient,
        domain: *const gchar,
        service: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_to_uri(
        client: *mut GSocketClient,
        uri: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_async(
        client: *mut GSocketClient,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_client_connect_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_to_host_async(
        client: *mut GSocketClient,
        host_and_port: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_client_connect_to_host_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_to_service_async(
        client: *mut GSocketClient,
        domain: *const gchar,
        service: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_client_connect_to_service_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_connect_to_uri_async(
        client: *mut GSocketClient,
        uri: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_client_connect_to_uri_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_client_add_application_proxy(
        client: *mut GSocketClient,
        protocol: *const gchar,
    );
}
#[doc = " GSocketConnectable:\n\n Interface for objects that contain or generate a #GSocketAddress."]
pub type GSocketConnectableIface = _GSocketConnectableIface;
#[doc = " GSocketConnectableIface:\n @g_iface: The parent interface.\n @enumerate: Creates a #GSocketAddressEnumerator\n @proxy_enumerate: Creates a #GProxyAddressEnumerator\n @to_string: Format the connectables address as a string for debugging.\n    Implementing this is optional. (Since: 2.48)\n\n Provides an interface for returning a #GSocketAddressEnumerator\n and #GProxyAddressEnumerator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectableIface {
    pub g_iface: GTypeInterface,
    pub enumerate: ::std::option::Option<
        unsafe extern "C" fn(connectable: *mut GSocketConnectable) -> *mut GSocketAddressEnumerator,
    >,
    pub proxy_enumerate: ::std::option::Option<
        unsafe extern "C" fn(connectable: *mut GSocketConnectable) -> *mut GSocketAddressEnumerator,
    >,
    pub to_string: ::std::option::Option<
        unsafe extern "C" fn(connectable: *mut GSocketConnectable) -> *mut gchar,
    >,
}
#[test]
fn bindgen_test_layout__GSocketConnectableIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketConnectableIface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketConnectableIface>(),
        40usize,
        concat!("Size of: ", stringify!(_GSocketConnectableIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketConnectableIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketConnectableIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectableIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectableIface),
            "::",
            stringify!(enumerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proxy_enumerate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectableIface),
            "::",
            stringify!(proxy_enumerate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_string) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectableIface),
            "::",
            stringify!(to_string)
        )
    );
}
extern "C" {
    pub fn g_socket_connectable_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_connectable_enumerate(
        connectable: *mut GSocketConnectable,
    ) -> *mut GSocketAddressEnumerator;
}
extern "C" {
    pub fn g_socket_connectable_proxy_enumerate(
        connectable: *mut GSocketConnectable,
    ) -> *mut GSocketAddressEnumerator;
}
extern "C" {
    pub fn g_socket_connectable_to_string(connectable: *mut GSocketConnectable) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectionPrivate {
    _unused: [u8; 0],
}
pub type GSocketConnectionPrivate = _GSocketConnectionPrivate;
pub type GSocketConnectionClass = _GSocketConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectionClass {
    pub parent_class: GIOStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketConnectionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketConnectionClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketConnectionClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GSocketConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketConnectionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnection {
    pub parent_instance: GIOStream,
    pub priv_: *mut GSocketConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GSocketConnection() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketConnection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketConnection>(),
        40usize,
        concat!("Size of: ", stringify!(_GSocketConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketConnection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnection),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_socket_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_connection_is_connected(connection: *mut GSocketConnection) -> gboolean;
}
extern "C" {
    pub fn g_socket_connection_connect(
        connection: *mut GSocketConnection,
        address: *mut GSocketAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_connection_connect_async(
        connection: *mut GSocketConnection,
        address: *mut GSocketAddress,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_connection_connect_finish(
        connection: *mut GSocketConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_connection_get_socket(connection: *mut GSocketConnection) -> *mut GSocket;
}
extern "C" {
    pub fn g_socket_connection_get_local_address(
        connection: *mut GSocketConnection,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_connection_get_remote_address(
        connection: *mut GSocketConnection,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_socket_connection_factory_register_type(
        g_type: GType,
        family: GSocketFamily,
        type_: GSocketType,
        protocol: gint,
    );
}
extern "C" {
    pub fn g_socket_connection_factory_lookup_type(
        family: GSocketFamily,
        type_: GSocketType,
        protocol_id: gint,
    ) -> GType;
}
extern "C" {
    pub fn g_socket_connection_factory_create_connection(
        socket: *mut GSocket,
    ) -> *mut GSocketConnection;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketControlMessagePrivate {
    _unused: [u8; 0],
}
pub type GSocketControlMessagePrivate = _GSocketControlMessagePrivate;
#[doc = " GSocketControlMessageClass:\n @get_size: gets the size of the message.\n @get_level: gets the protocol of the message.\n @get_type: gets the protocol specific type of the message.\n @serialize: Writes out the message data.\n @deserialize: Tries to deserialize a message.\n\n Class structure for #GSocketControlMessage."]
pub type GSocketControlMessageClass = _GSocketControlMessageClass;
#[doc = " GSocketControlMessageClass:\n @get_size: gets the size of the message.\n @get_level: gets the protocol of the message.\n @get_type: gets the protocol specific type of the message.\n @serialize: Writes out the message data.\n @deserialize: Tries to deserialize a message.\n\n Class structure for #GSocketControlMessage."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketControlMessageClass {
    pub parent_class: GObjectClass,
    pub get_size:
        ::std::option::Option<unsafe extern "C" fn(message: *mut GSocketControlMessage) -> gsize>,
    pub get_level: ::std::option::Option<
        unsafe extern "C" fn(message: *mut GSocketControlMessage) -> ::std::os::raw::c_int,
    >,
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(message: *mut GSocketControlMessage) -> ::std::os::raw::c_int,
    >,
    pub serialize: ::std::option::Option<
        unsafe extern "C" fn(message: *mut GSocketControlMessage, data: gpointer),
    >,
    pub deserialize: ::std::option::Option<
        unsafe extern "C" fn(
            level: ::std::os::raw::c_int,
            type_: ::std::os::raw::c_int,
            size: gsize,
            data: gpointer,
        ) -> *mut GSocketControlMessage,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketControlMessageClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketControlMessageClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketControlMessageClass>(),
        216usize,
        concat!("Size of: ", stringify!(_GSocketControlMessageClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketControlMessageClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketControlMessageClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_size) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(get_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_level) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(get_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(get_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialize) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(serialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deserialize) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(deserialize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketControlMessage {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketControlMessagePrivate,
}
#[test]
fn bindgen_test_layout__GSocketControlMessage() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketControlMessage> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketControlMessage>(),
        32usize,
        concat!("Size of: ", stringify!(_GSocketControlMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketControlMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketControlMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessage),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessage),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_socket_control_message_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_control_message_get_size(message: *mut GSocketControlMessage) -> gsize;
}
extern "C" {
    pub fn g_socket_control_message_get_level(
        message: *mut GSocketControlMessage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_socket_control_message_get_msg_type(
        message: *mut GSocketControlMessage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn g_socket_control_message_serialize(message: *mut GSocketControlMessage, data: gpointer);
}
extern "C" {
    pub fn g_socket_control_message_deserialize(
        level: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        size: gsize,
        data: gpointer,
    ) -> *mut GSocketControlMessage;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketListenerPrivate {
    _unused: [u8; 0],
}
pub type GSocketListenerPrivate = _GSocketListenerPrivate;
#[doc = " GSocketListenerClass:\n @changed: virtual method called when the set of socket listened to changes\n\n Class structure for #GSocketListener."]
pub type GSocketListenerClass = _GSocketListenerClass;
#[doc = " GSocketListenerClass:\n @changed: virtual method called when the set of socket listened to changes\n\n Class structure for #GSocketListener."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketListenerClass {
    pub parent_class: GObjectClass,
    pub changed: ::std::option::Option<unsafe extern "C" fn(listener: *mut GSocketListener)>,
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            listener: *mut GSocketListener,
            event: GSocketListenerEvent,
            socket: *mut GSocket,
        ),
    >,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketListenerClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketListenerClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketListenerClass>(),
        192usize,
        concat!("Size of: ", stringify!(_GSocketListenerClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketListenerClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketListenerClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changed) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketListener {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketListenerPrivate,
}
#[test]
fn bindgen_test_layout__GSocketListener() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketListener> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketListener>(),
        32usize,
        concat!("Size of: ", stringify!(_GSocketListener))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketListener>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketListener))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListener),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListener),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_socket_listener_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_listener_new() -> *mut GSocketListener;
}
extern "C" {
    pub fn g_socket_listener_set_backlog(
        listener: *mut GSocketListener,
        listen_backlog: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn g_socket_listener_add_socket(
        listener: *mut GSocketListener,
        socket: *mut GSocket,
        source_object: *mut GObject,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_listener_add_address(
        listener: *mut GSocketListener,
        address: *mut GSocketAddress,
        type_: GSocketType,
        protocol: GSocketProtocol,
        source_object: *mut GObject,
        effective_address: *mut *mut GSocketAddress,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_listener_add_inet_port(
        listener: *mut GSocketListener,
        port: guint16,
        source_object: *mut GObject,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_socket_listener_add_any_inet_port(
        listener: *mut GSocketListener,
        source_object: *mut GObject,
        error: *mut *mut GError,
    ) -> guint16;
}
extern "C" {
    pub fn g_socket_listener_accept_socket(
        listener: *mut GSocketListener,
        source_object: *mut *mut GObject,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
extern "C" {
    pub fn g_socket_listener_accept_socket_async(
        listener: *mut GSocketListener,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_listener_accept_socket_finish(
        listener: *mut GSocketListener,
        result: *mut GAsyncResult,
        source_object: *mut *mut GObject,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
extern "C" {
    pub fn g_socket_listener_accept(
        listener: *mut GSocketListener,
        source_object: *mut *mut GObject,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_listener_accept_async(
        listener: *mut GSocketListener,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_socket_listener_accept_finish(
        listener: *mut GSocketListener,
        result: *mut GAsyncResult,
        source_object: *mut *mut GObject,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_socket_listener_close(listener: *mut GSocketListener);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketServicePrivate {
    _unused: [u8; 0],
}
pub type GSocketServicePrivate = _GSocketServicePrivate;
#[doc = " GSocketServiceClass:\n @incoming: signal emitted when new connections are accepted\n\n Class structure for #GSocketService."]
pub type GSocketServiceClass = _GSocketServiceClass;
#[doc = " GSocketServiceClass:\n @incoming: signal emitted when new connections are accepted\n\n Class structure for #GSocketService."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketServiceClass {
    pub parent_class: GSocketListenerClass,
    pub incoming: ::std::option::Option<
        unsafe extern "C" fn(
            service: *mut GSocketService,
            connection: *mut GSocketConnection,
            source_object: *mut GObject,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketServiceClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketServiceClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketServiceClass>(),
        248usize,
        concat!("Size of: ", stringify!(_GSocketServiceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketServiceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketServiceClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incoming) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(incoming)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketService {
    pub parent_instance: GSocketListener,
    pub priv_: *mut GSocketServicePrivate,
}
#[test]
fn bindgen_test_layout__GSocketService() {
    const UNINIT: ::std::mem::MaybeUninit<_GSocketService> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GSocketService>(),
        40usize,
        concat!("Size of: ", stringify!(_GSocketService))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketService>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketService))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketService),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketService),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_socket_service_get_type() -> GType;
}
extern "C" {
    pub fn g_socket_service_new() -> *mut GSocketService;
}
extern "C" {
    pub fn g_socket_service_start(service: *mut GSocketService);
}
extern "C" {
    pub fn g_socket_service_stop(service: *mut GSocketService);
}
extern "C" {
    pub fn g_socket_service_is_active(service: *mut GSocketService) -> gboolean;
}
extern "C" {
    pub fn g_srv_target_get_type() -> GType;
}
extern "C" {
    pub fn g_srv_target_new(
        hostname: *const gchar,
        port: guint16,
        priority: guint16,
        weight: guint16,
    ) -> *mut GSrvTarget;
}
extern "C" {
    pub fn g_srv_target_copy(target: *mut GSrvTarget) -> *mut GSrvTarget;
}
extern "C" {
    pub fn g_srv_target_free(target: *mut GSrvTarget);
}
extern "C" {
    pub fn g_srv_target_get_hostname(target: *mut GSrvTarget) -> *const gchar;
}
extern "C" {
    pub fn g_srv_target_get_port(target: *mut GSrvTarget) -> guint16;
}
extern "C" {
    pub fn g_srv_target_get_priority(target: *mut GSrvTarget) -> guint16;
}
extern "C" {
    pub fn g_srv_target_get_weight(target: *mut GSrvTarget) -> guint16;
}
extern "C" {
    pub fn g_srv_target_list_sort(targets: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_subprocess_get_type() -> GType;
}
extern "C" {
    #[doc = " Core API"]
    pub fn g_subprocess_new(
        flags: GSubprocessFlags,
        error: *mut *mut GError,
        argv0: *const gchar,
        ...
    ) -> *mut GSubprocess;
}
extern "C" {
    pub fn g_subprocess_newv(
        argv: *const *const gchar,
        flags: GSubprocessFlags,
        error: *mut *mut GError,
    ) -> *mut GSubprocess;
}
extern "C" {
    pub fn g_subprocess_get_stdin_pipe(subprocess: *mut GSubprocess) -> *mut GOutputStream;
}
extern "C" {
    pub fn g_subprocess_get_stdout_pipe(subprocess: *mut GSubprocess) -> *mut GInputStream;
}
extern "C" {
    pub fn g_subprocess_get_stderr_pipe(subprocess: *mut GSubprocess) -> *mut GInputStream;
}
extern "C" {
    pub fn g_subprocess_get_identifier(subprocess: *mut GSubprocess) -> *const gchar;
}
extern "C" {
    pub fn g_subprocess_send_signal(subprocess: *mut GSubprocess, signal_num: gint);
}
extern "C" {
    pub fn g_subprocess_force_exit(subprocess: *mut GSubprocess);
}
extern "C" {
    pub fn g_subprocess_wait(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_wait_async(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_subprocess_wait_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_wait_check(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_wait_check_async(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_subprocess_wait_check_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_get_status(subprocess: *mut GSubprocess) -> gint;
}
extern "C" {
    pub fn g_subprocess_get_successful(subprocess: *mut GSubprocess) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_get_if_exited(subprocess: *mut GSubprocess) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_get_exit_status(subprocess: *mut GSubprocess) -> gint;
}
extern "C" {
    pub fn g_subprocess_get_if_signaled(subprocess: *mut GSubprocess) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_get_term_sig(subprocess: *mut GSubprocess) -> gint;
}
extern "C" {
    pub fn g_subprocess_communicate(
        subprocess: *mut GSubprocess,
        stdin_buf: *mut GBytes,
        cancellable: *mut GCancellable,
        stdout_buf: *mut *mut GBytes,
        stderr_buf: *mut *mut GBytes,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_communicate_async(
        subprocess: *mut GSubprocess,
        stdin_buf: *mut GBytes,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_subprocess_communicate_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        stdout_buf: *mut *mut GBytes,
        stderr_buf: *mut *mut GBytes,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_communicate_utf8(
        subprocess: *mut GSubprocess,
        stdin_buf: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        stdout_buf: *mut *mut ::std::os::raw::c_char,
        stderr_buf: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_communicate_utf8_async(
        subprocess: *mut GSubprocess,
        stdin_buf: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_subprocess_communicate_utf8_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        stdout_buf: *mut *mut ::std::os::raw::c_char,
        stderr_buf: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_subprocess_launcher_get_type() -> GType;
}
extern "C" {
    pub fn g_subprocess_launcher_new(flags: GSubprocessFlags) -> *mut GSubprocessLauncher;
}
extern "C" {
    pub fn g_subprocess_launcher_spawn(
        self_: *mut GSubprocessLauncher,
        error: *mut *mut GError,
        argv0: *const gchar,
        ...
    ) -> *mut GSubprocess;
}
extern "C" {
    pub fn g_subprocess_launcher_spawnv(
        self_: *mut GSubprocessLauncher,
        argv: *const *const gchar,
        error: *mut *mut GError,
    ) -> *mut GSubprocess;
}
extern "C" {
    pub fn g_subprocess_launcher_set_environ(self_: *mut GSubprocessLauncher, env: *mut *mut gchar);
}
extern "C" {
    pub fn g_subprocess_launcher_setenv(
        self_: *mut GSubprocessLauncher,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    );
}
extern "C" {
    pub fn g_subprocess_launcher_unsetenv(self_: *mut GSubprocessLauncher, variable: *const gchar);
}
extern "C" {
    pub fn g_subprocess_launcher_getenv(
        self_: *mut GSubprocessLauncher,
        variable: *const gchar,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_subprocess_launcher_set_cwd(self_: *mut GSubprocessLauncher, cwd: *const gchar);
}
extern "C" {
    pub fn g_subprocess_launcher_set_flags(
        self_: *mut GSubprocessLauncher,
        flags: GSubprocessFlags,
    );
}
extern "C" {
    pub fn g_subprocess_launcher_set_stdin_file_path(
        self_: *mut GSubprocessLauncher,
        path: *const gchar,
    );
}
extern "C" {
    pub fn g_subprocess_launcher_take_stdin_fd(self_: *mut GSubprocessLauncher, fd: gint);
}
extern "C" {
    pub fn g_subprocess_launcher_set_stdout_file_path(
        self_: *mut GSubprocessLauncher,
        path: *const gchar,
    );
}
extern "C" {
    pub fn g_subprocess_launcher_take_stdout_fd(self_: *mut GSubprocessLauncher, fd: gint);
}
extern "C" {
    pub fn g_subprocess_launcher_set_stderr_file_path(
        self_: *mut GSubprocessLauncher,
        path: *const gchar,
    );
}
extern "C" {
    pub fn g_subprocess_launcher_take_stderr_fd(self_: *mut GSubprocessLauncher, fd: gint);
}
extern "C" {
    pub fn g_subprocess_launcher_take_fd(
        self_: *mut GSubprocessLauncher,
        source_fd: gint,
        target_fd: gint,
    );
}
extern "C" {
    pub fn g_subprocess_launcher_close(self_: *mut GSubprocessLauncher);
}
extern "C" {
    pub fn g_subprocess_launcher_set_child_setup(
        self_: *mut GSubprocessLauncher,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTaskClass {
    _unused: [u8; 0],
}
pub type GTaskClass = _GTaskClass;
extern "C" {
    pub fn g_task_get_type() -> GType;
}
extern "C" {
    pub fn g_task_new(
        source_object: gpointer,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
    ) -> *mut GTask;
}
extern "C" {
    pub fn g_task_report_error(
        source_object: gpointer,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
        source_tag: gpointer,
        error: *mut GError,
    );
}
extern "C" {
    pub fn g_task_report_new_error(
        source_object: gpointer,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
        source_tag: gpointer,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_task_set_task_data(
        task: *mut GTask,
        task_data: gpointer,
        task_data_destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_task_set_priority(task: *mut GTask, priority: gint);
}
extern "C" {
    pub fn g_task_set_check_cancellable(task: *mut GTask, check_cancellable: gboolean);
}
extern "C" {
    pub fn g_task_set_source_tag(task: *mut GTask, source_tag: gpointer);
}
extern "C" {
    pub fn g_task_set_name(task: *mut GTask, name: *const gchar);
}
extern "C" {
    pub fn g_task_set_static_name(task: *mut GTask, name: *const gchar);
}
extern "C" {
    pub fn g_task_get_source_object(task: *mut GTask) -> gpointer;
}
extern "C" {
    pub fn g_task_get_task_data(task: *mut GTask) -> gpointer;
}
extern "C" {
    pub fn g_task_get_priority(task: *mut GTask) -> gint;
}
extern "C" {
    pub fn g_task_get_context(task: *mut GTask) -> *mut GMainContext;
}
extern "C" {
    pub fn g_task_get_cancellable(task: *mut GTask) -> *mut GCancellable;
}
extern "C" {
    pub fn g_task_get_check_cancellable(task: *mut GTask) -> gboolean;
}
extern "C" {
    pub fn g_task_get_source_tag(task: *mut GTask) -> gpointer;
}
extern "C" {
    pub fn g_task_get_name(task: *mut GTask) -> *const gchar;
}
extern "C" {
    pub fn g_task_is_valid(result: gpointer, source_object: gpointer) -> gboolean;
}
pub type GTaskThreadFunc = ::std::option::Option<
    unsafe extern "C" fn(
        task: *mut GTask,
        source_object: gpointer,
        task_data: gpointer,
        cancellable: *mut GCancellable,
    ),
>;
extern "C" {
    pub fn g_task_run_in_thread(task: *mut GTask, task_func: GTaskThreadFunc);
}
extern "C" {
    pub fn g_task_run_in_thread_sync(task: *mut GTask, task_func: GTaskThreadFunc);
}
extern "C" {
    pub fn g_task_set_return_on_cancel(task: *mut GTask, return_on_cancel: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_task_get_return_on_cancel(task: *mut GTask) -> gboolean;
}
extern "C" {
    pub fn g_task_attach_source(task: *mut GTask, source: *mut GSource, callback: GSourceFunc);
}
extern "C" {
    pub fn g_task_return_pointer(
        task: *mut GTask,
        result: gpointer,
        result_destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_task_return_boolean(task: *mut GTask, result: gboolean);
}
extern "C" {
    pub fn g_task_return_int(task: *mut GTask, result: gssize);
}
extern "C" {
    pub fn g_task_return_error(task: *mut GTask, error: *mut GError);
}
extern "C" {
    pub fn g_task_return_new_error(
        task: *mut GTask,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn g_task_return_value(task: *mut GTask, result: *mut GValue);
}
extern "C" {
    pub fn g_task_return_error_if_cancelled(task: *mut GTask) -> gboolean;
}
extern "C" {
    pub fn g_task_propagate_pointer(task: *mut GTask, error: *mut *mut GError) -> gpointer;
}
extern "C" {
    pub fn g_task_propagate_boolean(task: *mut GTask, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_task_propagate_int(task: *mut GTask, error: *mut *mut GError) -> gssize;
}
extern "C" {
    pub fn g_task_propagate_value(
        task: *mut GTask,
        value: *mut GValue,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_task_had_error(task: *mut GTask) -> gboolean;
}
extern "C" {
    pub fn g_task_get_completed(task: *mut GTask) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpConnectionPrivate {
    _unused: [u8; 0],
}
pub type GTcpConnectionPrivate = _GTcpConnectionPrivate;
pub type GTcpConnectionClass = _GTcpConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpConnectionClass {
    pub parent_class: GSocketConnectionClass,
}
#[test]
fn bindgen_test_layout__GTcpConnectionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTcpConnectionClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTcpConnectionClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GTcpConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTcpConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTcpConnectionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpConnection {
    pub parent_instance: GSocketConnection,
    pub priv_: *mut GTcpConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GTcpConnection() {
    const UNINIT: ::std::mem::MaybeUninit<_GTcpConnection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTcpConnection>(),
        48usize,
        concat!("Size of: ", stringify!(_GTcpConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTcpConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTcpConnection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpConnection),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_tcp_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_tcp_connection_set_graceful_disconnect(
        connection: *mut GTcpConnection,
        graceful_disconnect: gboolean,
    );
}
extern "C" {
    pub fn g_tcp_connection_get_graceful_disconnect(connection: *mut GTcpConnection) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpWrapperConnectionPrivate {
    _unused: [u8; 0],
}
pub type GTcpWrapperConnectionPrivate = _GTcpWrapperConnectionPrivate;
pub type GTcpWrapperConnectionClass = _GTcpWrapperConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpWrapperConnectionClass {
    pub parent_class: GTcpConnectionClass,
}
#[test]
fn bindgen_test_layout__GTcpWrapperConnectionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTcpWrapperConnectionClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTcpWrapperConnectionClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GTcpWrapperConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTcpWrapperConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTcpWrapperConnectionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpWrapperConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpWrapperConnection {
    pub parent_instance: GTcpConnection,
    pub priv_: *mut GTcpWrapperConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GTcpWrapperConnection() {
    const UNINIT: ::std::mem::MaybeUninit<_GTcpWrapperConnection> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTcpWrapperConnection>(),
        56usize,
        concat!("Size of: ", stringify!(_GTcpWrapperConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTcpWrapperConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTcpWrapperConnection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpWrapperConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpWrapperConnection),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_tcp_wrapper_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_tcp_wrapper_connection_new(
        base_io_stream: *mut GIOStream,
        socket: *mut GSocket,
    ) -> *mut GSocketConnection;
}
extern "C" {
    pub fn g_tcp_wrapper_connection_get_base_io_stream(
        conn: *mut GTcpWrapperConnection,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_test_dbus_get_type() -> GType;
}
extern "C" {
    pub fn g_test_dbus_new(flags: GTestDBusFlags) -> *mut GTestDBus;
}
extern "C" {
    pub fn g_test_dbus_get_flags(self_: *mut GTestDBus) -> GTestDBusFlags;
}
extern "C" {
    pub fn g_test_dbus_get_bus_address(self_: *mut GTestDBus) -> *const gchar;
}
extern "C" {
    pub fn g_test_dbus_add_service_dir(self_: *mut GTestDBus, path: *const gchar);
}
extern "C" {
    pub fn g_test_dbus_up(self_: *mut GTestDBus);
}
extern "C" {
    pub fn g_test_dbus_stop(self_: *mut GTestDBus);
}
extern "C" {
    pub fn g_test_dbus_down(self_: *mut GTestDBus);
}
extern "C" {
    pub fn g_test_dbus_unset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThemedIconClass {
    _unused: [u8; 0],
}
#[doc = " GThemedIcon:\n\n An implementation of #GIcon for themed icons."]
pub type GThemedIconClass = _GThemedIconClass;
extern "C" {
    pub fn g_themed_icon_get_type() -> GType;
}
extern "C" {
    pub fn g_themed_icon_new(iconname: *const ::std::os::raw::c_char) -> *mut GIcon;
}
extern "C" {
    pub fn g_themed_icon_new_with_default_fallbacks(
        iconname: *const ::std::os::raw::c_char,
    ) -> *mut GIcon;
}
extern "C" {
    pub fn g_themed_icon_new_from_names(
        iconnames: *mut *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut GIcon;
}
extern "C" {
    pub fn g_themed_icon_prepend_name(
        icon: *mut GThemedIcon,
        iconname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_themed_icon_append_name(
        icon: *mut GThemedIcon,
        iconname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn g_themed_icon_get_names(icon: *mut GThemedIcon) -> *const *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadedSocketServicePrivate {
    _unused: [u8; 0],
}
pub type GThreadedSocketServicePrivate = _GThreadedSocketServicePrivate;
pub type GThreadedSocketServiceClass = _GThreadedSocketServiceClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadedSocketServiceClass {
    pub parent_class: GSocketServiceClass,
    pub run: ::std::option::Option<
        unsafe extern "C" fn(
            service: *mut GThreadedSocketService,
            connection: *mut GSocketConnection,
            source_object: *mut GObject,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GThreadedSocketServiceClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GThreadedSocketServiceClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThreadedSocketServiceClass>(),
        296usize,
        concat!("Size of: ", stringify!(_GThreadedSocketServiceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadedSocketServiceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadedSocketServiceClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).run) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(run)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadedSocketService {
    pub parent_instance: GSocketService,
    pub priv_: *mut GThreadedSocketServicePrivate,
}
#[test]
fn bindgen_test_layout__GThreadedSocketService() {
    const UNINIT: ::std::mem::MaybeUninit<_GThreadedSocketService> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GThreadedSocketService>(),
        48usize,
        concat!("Size of: ", stringify!(_GThreadedSocketService))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadedSocketService>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadedSocketService))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketService),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketService),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_threaded_socket_service_get_type() -> GType;
}
extern "C" {
    pub fn g_threaded_socket_service_new(max_threads: ::std::os::raw::c_int)
        -> *mut GSocketService;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsBackend {
    _unused: [u8; 0],
}
pub type GTlsBackend = _GTlsBackend;
#[doc = " GTlsBackendInterface:\n @g_iface: The parent interface.\n @supports_tls: returns whether the backend supports TLS.\n @supports_dtls: returns whether the backend supports DTLS\n @get_default_database: returns a default #GTlsDatabase instance.\n @get_certificate_type: returns the #GTlsCertificate implementation type\n @get_client_connection_type: returns the #GTlsClientConnection implementation type\n @get_server_connection_type: returns the #GTlsServerConnection implementation type\n @get_file_database_type: returns the #GTlsFileDatabase implementation type.\n @get_dtls_client_connection_type: returns the #GDtlsClientConnection implementation type\n @get_dtls_server_connection_type: returns the #GDtlsServerConnection implementation type\n\n Provides an interface for describing TLS-related types.\n\n Since: 2.28"]
pub type GTlsBackendInterface = _GTlsBackendInterface;
#[doc = " GTlsBackendInterface:\n @g_iface: The parent interface.\n @supports_tls: returns whether the backend supports TLS.\n @supports_dtls: returns whether the backend supports DTLS\n @get_default_database: returns a default #GTlsDatabase instance.\n @get_certificate_type: returns the #GTlsCertificate implementation type\n @get_client_connection_type: returns the #GTlsClientConnection implementation type\n @get_server_connection_type: returns the #GTlsServerConnection implementation type\n @get_file_database_type: returns the #GTlsFileDatabase implementation type.\n @get_dtls_client_connection_type: returns the #GDtlsClientConnection implementation type\n @get_dtls_server_connection_type: returns the #GDtlsServerConnection implementation type\n\n Provides an interface for describing TLS-related types.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsBackendInterface {
    pub g_iface: GTypeInterface,
    pub supports_tls:
        ::std::option::Option<unsafe extern "C" fn(backend: *mut GTlsBackend) -> gboolean>,
    pub get_certificate_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_client_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_server_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_file_database_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_default_database:
        ::std::option::Option<unsafe extern "C" fn(backend: *mut GTlsBackend) -> *mut GTlsDatabase>,
    pub supports_dtls:
        ::std::option::Option<unsafe extern "C" fn(backend: *mut GTlsBackend) -> gboolean>,
    pub get_dtls_client_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_dtls_server_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
}
#[test]
fn bindgen_test_layout__GTlsBackendInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsBackendInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsBackendInterface>(),
        88usize,
        concat!("Size of: ", stringify!(_GTlsBackendInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsBackendInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsBackendInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_tls) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(supports_tls)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_certificate_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_certificate_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_client_connection_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_client_connection_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_server_connection_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_server_connection_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_file_database_type) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_file_database_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_default_database) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_default_database)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supports_dtls) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(supports_dtls)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_dtls_client_connection_type) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_dtls_client_connection_type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).get_dtls_server_connection_type) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_dtls_server_connection_type)
        )
    );
}
extern "C" {
    pub fn g_tls_backend_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_backend_get_default() -> *mut GTlsBackend;
}
extern "C" {
    pub fn g_tls_backend_get_default_database(backend: *mut GTlsBackend) -> *mut GTlsDatabase;
}
extern "C" {
    pub fn g_tls_backend_set_default_database(
        backend: *mut GTlsBackend,
        database: *mut GTlsDatabase,
    );
}
extern "C" {
    pub fn g_tls_backend_supports_tls(backend: *mut GTlsBackend) -> gboolean;
}
extern "C" {
    pub fn g_tls_backend_supports_dtls(backend: *mut GTlsBackend) -> gboolean;
}
extern "C" {
    pub fn g_tls_backend_get_certificate_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    pub fn g_tls_backend_get_client_connection_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    pub fn g_tls_backend_get_server_connection_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    pub fn g_tls_backend_get_file_database_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    pub fn g_tls_backend_get_dtls_client_connection_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    pub fn g_tls_backend_get_dtls_server_connection_type(backend: *mut GTlsBackend) -> GType;
}
pub type GTlsCertificateClass = _GTlsCertificateClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsCertificatePrivate {
    _unused: [u8; 0],
}
pub type GTlsCertificatePrivate = _GTlsCertificatePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsCertificate {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsCertificatePrivate,
}
#[test]
fn bindgen_test_layout__GTlsCertificate() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsCertificate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsCertificate>(),
        32usize,
        concat!("Size of: ", stringify!(_GTlsCertificate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsCertificate>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsCertificate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificate),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificate),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsCertificateClass {
    pub parent_class: GObjectClass,
    pub verify: ::std::option::Option<
        unsafe extern "C" fn(
            cert: *mut GTlsCertificate,
            identity: *mut GSocketConnectable,
            trusted_ca: *mut GTlsCertificate,
        ) -> GTlsCertificateFlags,
    >,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GTlsCertificateClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsCertificateClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsCertificateClass>(),
        208usize,
        concat!("Size of: ", stringify!(_GTlsCertificateClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsCertificateClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsCertificateClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificateClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verify) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificateClass),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificateClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_tls_certificate_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_certificate_new_from_pem(
        data: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_new_from_pkcs12(
        data: *const guint8,
        length: gsize,
        password: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_new_from_file_with_password(
        file: *const gchar,
        password: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_new_from_file(
        file: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_new_from_files(
        cert_file: *const gchar,
        key_file: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_new_from_pkcs11_uris(
        pkcs11_uri: *const gchar,
        private_key_pkcs11_uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_list_new_from_file(
        file: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_tls_certificate_get_issuer(cert: *mut GTlsCertificate) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_certificate_verify(
        cert: *mut GTlsCertificate,
        identity: *mut GSocketConnectable,
        trusted_ca: *mut GTlsCertificate,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_tls_certificate_is_same(
        cert_one: *mut GTlsCertificate,
        cert_two: *mut GTlsCertificate,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tls_certificate_get_not_valid_before(cert: *mut GTlsCertificate) -> *mut GDateTime;
}
extern "C" {
    pub fn g_tls_certificate_get_not_valid_after(cert: *mut GTlsCertificate) -> *mut GDateTime;
}
extern "C" {
    pub fn g_tls_certificate_get_subject_name(cert: *mut GTlsCertificate) -> *mut gchar;
}
extern "C" {
    pub fn g_tls_certificate_get_issuer_name(cert: *mut GTlsCertificate) -> *mut gchar;
}
extern "C" {
    pub fn g_tls_certificate_get_dns_names(cert: *mut GTlsCertificate) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_tls_certificate_get_ip_addresses(cert: *mut GTlsCertificate) -> *mut GPtrArray;
}
#[doc = " GTlsConnectionClass:\n @parent_class: The parent class.\n @accept_certificate: Check whether to accept a certificate.\n @handshake: Perform a handshake operation.\n @handshake_async: Start an asynchronous handshake operation.\n @handshake_finish: Finish an asynchronous handshake operation.\n @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)\n @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.70)\n\n The class structure for the #GTlsConnection type.\n\n Since: 2.28"]
pub type GTlsConnectionClass = _GTlsConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsConnectionPrivate {
    _unused: [u8; 0],
}
pub type GTlsConnectionPrivate = _GTlsConnectionPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsConnection {
    pub parent_instance: GIOStream,
    pub priv_: *mut GTlsConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GTlsConnection() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsConnection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsConnection>(),
        40usize,
        concat!("Size of: ", stringify!(_GTlsConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsConnection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnection),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GTlsConnectionClass:\n @parent_class: The parent class.\n @accept_certificate: Check whether to accept a certificate.\n @handshake: Perform a handshake operation.\n @handshake_async: Start an asynchronous handshake operation.\n @handshake_finish: Finish an asynchronous handshake operation.\n @get_binding_data: Retrieve TLS channel binding data (Since: 2.66)\n @get_negotiated_protocol: Get ALPN-negotiated protocol (Since: 2.70)\n\n The class structure for the #GTlsConnection type.\n\n Since: 2.28"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsConnectionClass {
    pub parent_class: GIOStreamClass,
    pub accept_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            connection: *mut GTlsConnection,
            peer_cert: *mut GTlsCertificate,
            errors: GTlsCertificateFlags,
        ) -> gboolean,
    >,
    pub handshake: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub handshake_async: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub handshake_finish: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_binding_data: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            type_: GTlsChannelBindingType,
            data: *mut GByteArray,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_negotiated_protocol:
        ::std::option::Option<unsafe extern "C" fn(conn: *mut GTlsConnection) -> *const gchar>,
    pub padding: [gpointer; 6usize],
}
#[test]
fn bindgen_test_layout__GTlsConnectionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsConnectionClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsConnectionClass>(),
        352usize,
        concat!("Size of: ", stringify!(_GTlsConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsConnectionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accept_certificate) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(accept_certificate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(handshake)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake_async) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(handshake_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handshake_finish) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(handshake_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_binding_data) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(get_binding_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_negotiated_protocol) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(get_negotiated_protocol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_tls_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_connection_set_use_system_certdb(
        conn: *mut GTlsConnection,
        use_system_certdb: gboolean,
    );
}
extern "C" {
    pub fn g_tls_connection_get_use_system_certdb(conn: *mut GTlsConnection) -> gboolean;
}
extern "C" {
    pub fn g_tls_connection_set_database(conn: *mut GTlsConnection, database: *mut GTlsDatabase);
}
extern "C" {
    pub fn g_tls_connection_get_database(conn: *mut GTlsConnection) -> *mut GTlsDatabase;
}
extern "C" {
    pub fn g_tls_connection_set_certificate(
        conn: *mut GTlsConnection,
        certificate: *mut GTlsCertificate,
    );
}
extern "C" {
    pub fn g_tls_connection_get_certificate(conn: *mut GTlsConnection) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_connection_set_interaction(
        conn: *mut GTlsConnection,
        interaction: *mut GTlsInteraction,
    );
}
extern "C" {
    pub fn g_tls_connection_get_interaction(conn: *mut GTlsConnection) -> *mut GTlsInteraction;
}
extern "C" {
    pub fn g_tls_connection_get_peer_certificate(conn: *mut GTlsConnection)
        -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_connection_get_peer_certificate_errors(
        conn: *mut GTlsConnection,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_tls_connection_set_require_close_notify(
        conn: *mut GTlsConnection,
        require_close_notify: gboolean,
    );
}
extern "C" {
    pub fn g_tls_connection_get_require_close_notify(conn: *mut GTlsConnection) -> gboolean;
}
extern "C" {
    pub fn g_tls_connection_set_rehandshake_mode(
        conn: *mut GTlsConnection,
        mode: GTlsRehandshakeMode,
    );
}
extern "C" {
    pub fn g_tls_connection_get_rehandshake_mode(conn: *mut GTlsConnection) -> GTlsRehandshakeMode;
}
extern "C" {
    pub fn g_tls_connection_set_advertised_protocols(
        conn: *mut GTlsConnection,
        protocols: *const *const gchar,
    );
}
extern "C" {
    pub fn g_tls_connection_get_negotiated_protocol(conn: *mut GTlsConnection) -> *const gchar;
}
extern "C" {
    pub fn g_tls_connection_get_channel_binding_data(
        conn: *mut GTlsConnection,
        type_: GTlsChannelBindingType,
        data: *mut GByteArray,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tls_connection_handshake(
        conn: *mut GTlsConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tls_connection_handshake_async(
        conn: *mut GTlsConnection,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_connection_handshake_finish(
        conn: *mut GTlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tls_connection_get_protocol_version(conn: *mut GTlsConnection) -> GTlsProtocolVersion;
}
extern "C" {
    pub fn g_tls_connection_get_ciphersuite_name(conn: *mut GTlsConnection) -> *mut gchar;
}
extern "C" {
    pub fn g_tls_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_tls_channel_binding_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_tls_connection_emit_accept_certificate(
        conn: *mut GTlsConnection,
        peer_cert: *mut GTlsCertificate,
        errors: GTlsCertificateFlags,
    ) -> gboolean;
}
#[doc = " GTlsClientConnectionInterface:\n @g_iface: The parent interface.\n @copy_session_state: Copies session state from one #GTlsClientConnection to another.\n\n vtable for a #GTlsClientConnection implementation.\n\n Since: 2.26"]
pub type GTlsClientConnectionInterface = _GTlsClientConnectionInterface;
#[doc = " GTlsClientConnectionInterface:\n @g_iface: The parent interface.\n @copy_session_state: Copies session state from one #GTlsClientConnection to another.\n\n vtable for a #GTlsClientConnection implementation.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsClientConnectionInterface {
    pub g_iface: GTypeInterface,
    pub copy_session_state: ::std::option::Option<
        unsafe extern "C" fn(conn: *mut GTlsClientConnection, source: *mut GTlsClientConnection),
    >,
}
#[test]
fn bindgen_test_layout__GTlsClientConnectionInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsClientConnectionInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsClientConnectionInterface>(),
        24usize,
        concat!("Size of: ", stringify!(_GTlsClientConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsClientConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsClientConnectionInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsClientConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).copy_session_state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsClientConnectionInterface),
            "::",
            stringify!(copy_session_state)
        )
    );
}
extern "C" {
    pub fn g_tls_client_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_client_connection_new(
        base_io_stream: *mut GIOStream,
        server_identity: *mut GSocketConnectable,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    pub fn g_tls_client_connection_get_validation_flags(
        conn: *mut GTlsClientConnection,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_tls_client_connection_set_validation_flags(
        conn: *mut GTlsClientConnection,
        flags: GTlsCertificateFlags,
    );
}
extern "C" {
    pub fn g_tls_client_connection_get_server_identity(
        conn: *mut GTlsClientConnection,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    pub fn g_tls_client_connection_set_server_identity(
        conn: *mut GTlsClientConnection,
        identity: *mut GSocketConnectable,
    );
}
extern "C" {
    pub fn g_tls_client_connection_get_use_ssl3(conn: *mut GTlsClientConnection) -> gboolean;
}
extern "C" {
    pub fn g_tls_client_connection_set_use_ssl3(
        conn: *mut GTlsClientConnection,
        use_ssl3: gboolean,
    );
}
extern "C" {
    pub fn g_tls_client_connection_get_accepted_cas(conn: *mut GTlsClientConnection) -> *mut GList;
}
extern "C" {
    pub fn g_tls_client_connection_copy_session_state(
        conn: *mut GTlsClientConnection,
        source: *mut GTlsClientConnection,
    );
}
pub type GTlsDatabaseClass = _GTlsDatabaseClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsDatabasePrivate {
    _unused: [u8; 0],
}
pub type GTlsDatabasePrivate = _GTlsDatabasePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsDatabase {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsDatabasePrivate,
}
#[test]
fn bindgen_test_layout__GTlsDatabase() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsDatabase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsDatabase>(),
        32usize,
        concat!("Size of: ", stringify!(_GTlsDatabase))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsDatabase>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsDatabase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabase),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabase),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsDatabaseClass {
    pub parent_class: GObjectClass,
    pub verify_chain: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            chain: *mut GTlsCertificate,
            purpose: *const gchar,
            identity: *mut GSocketConnectable,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseVerifyFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> GTlsCertificateFlags,
    >,
    pub verify_chain_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            chain: *mut GTlsCertificate,
            purpose: *const gchar,
            identity: *mut GSocketConnectable,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseVerifyFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub verify_chain_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> GTlsCertificateFlags,
    >,
    pub create_certificate_handle: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            certificate: *mut GTlsCertificate,
        ) -> *mut gchar,
    >,
    pub lookup_certificate_for_handle: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            handle: *const gchar,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificate_for_handle_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            handle: *const gchar,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_certificate_for_handle_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificate_issuer: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            certificate: *mut GTlsCertificate,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificate_issuer_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            certificate: *mut GTlsCertificate,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_certificate_issuer_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificates_issued_by: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            issuer_raw_dn: *mut GByteArray,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_certificates_issued_by_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            issuer_raw_dn: *mut GByteArray,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_certificates_issued_by_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub padding: [gpointer; 16usize],
}
#[test]
fn bindgen_test_layout__GTlsDatabaseClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsDatabaseClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsDatabaseClass>(),
        368usize,
        concat!("Size of: ", stringify!(_GTlsDatabaseClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsDatabaseClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsDatabaseClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verify_chain) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(verify_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verify_chain_async) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(verify_chain_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).verify_chain_finish) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(verify_chain_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_certificate_handle) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(create_certificate_handle)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificate_for_handle) as usize - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_for_handle)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificate_for_handle_async) as usize - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_for_handle_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificate_for_handle_finish) as usize
                - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_for_handle_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lookup_certificate_issuer) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_issuer)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificate_issuer_async) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_issuer_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificate_issuer_finish) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_issuer_finish)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificates_issued_by) as usize - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificates_issued_by)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificates_issued_by_async) as usize - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificates_issued_by_async)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).lookup_certificates_issued_by_finish) as usize
                - ptr as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificates_issued_by_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_tls_database_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_database_verify_chain(
        self_: *mut GTlsDatabase,
        chain: *mut GTlsCertificate,
        purpose: *const gchar,
        identity: *mut GSocketConnectable,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseVerifyFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_tls_database_verify_chain_async(
        self_: *mut GTlsDatabase,
        chain: *mut GTlsCertificate,
        purpose: *const gchar,
        identity: *mut GSocketConnectable,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseVerifyFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_database_verify_chain_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    pub fn g_tls_database_create_certificate_handle(
        self_: *mut GTlsDatabase,
        certificate: *mut GTlsCertificate,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_tls_database_lookup_certificate_for_handle(
        self_: *mut GTlsDatabase,
        handle: *const gchar,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_database_lookup_certificate_for_handle_async(
        self_: *mut GTlsDatabase,
        handle: *const gchar,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_database_lookup_certificate_for_handle_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_database_lookup_certificate_issuer(
        self_: *mut GTlsDatabase,
        certificate: *mut GTlsCertificate,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_database_lookup_certificate_issuer_async(
        self_: *mut GTlsDatabase,
        certificate: *mut GTlsCertificate,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_database_lookup_certificate_issuer_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    pub fn g_tls_database_lookup_certificates_issued_by(
        self_: *mut GTlsDatabase,
        issuer_raw_dn: *mut GByteArray,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_tls_database_lookup_certificates_issued_by_async(
        self_: *mut GTlsDatabase,
        issuer_raw_dn: *mut GByteArray,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_database_lookup_certificates_issued_by_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
#[doc = " GTlsFileDatabaseInterface:\n @g_iface: The parent interface.\n\n Provides an interface for #GTlsFileDatabase implementations.\n"]
pub type GTlsFileDatabaseInterface = _GTlsFileDatabaseInterface;
#[doc = " GTlsFileDatabaseInterface:\n @g_iface: The parent interface.\n\n Provides an interface for #GTlsFileDatabase implementations.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsFileDatabaseInterface {
    pub g_iface: GTypeInterface,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GTlsFileDatabaseInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsFileDatabaseInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsFileDatabaseInterface>(),
        80usize,
        concat!("Size of: ", stringify!(_GTlsFileDatabaseInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsFileDatabaseInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsFileDatabaseInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsFileDatabaseInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsFileDatabaseInterface),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_tls_file_database_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_file_database_new(
        anchors: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsDatabase;
}
pub type GTlsInteractionClass = _GTlsInteractionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsInteractionPrivate {
    _unused: [u8; 0],
}
pub type GTlsInteractionPrivate = _GTlsInteractionPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsInteraction {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsInteractionPrivate,
}
#[test]
fn bindgen_test_layout__GTlsInteraction() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsInteraction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsInteraction>(),
        32usize,
        concat!("Size of: ", stringify!(_GTlsInteraction))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsInteraction>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsInteraction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteraction),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteraction),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsInteractionClass {
    pub parent_class: GObjectClass,
    pub ask_password: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            password: *mut GTlsPassword,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub ask_password_async: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            password: *mut GTlsPassword,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub ask_password_finish: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub request_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            connection: *mut GTlsConnection,
            flags: GTlsCertificateRequestFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub request_certificate_async: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            connection: *mut GTlsConnection,
            flags: GTlsCertificateRequestFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub request_certificate_finish: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub padding: [gpointer; 21usize],
}
#[test]
fn bindgen_test_layout__GTlsInteractionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsInteractionClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsInteractionClass>(),
        352usize,
        concat!("Size of: ", stringify!(_GTlsInteractionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsInteractionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsInteractionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ask_password) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(ask_password)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ask_password_async) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(ask_password_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ask_password_finish) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(ask_password_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_certificate) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(request_certificate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_certificate_async) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(request_certificate_async)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).request_certificate_finish) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(request_certificate_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_tls_interaction_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_interaction_invoke_ask_password(
        interaction: *mut GTlsInteraction,
        password: *mut GTlsPassword,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    pub fn g_tls_interaction_ask_password(
        interaction: *mut GTlsInteraction,
        password: *mut GTlsPassword,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    pub fn g_tls_interaction_ask_password_async(
        interaction: *mut GTlsInteraction,
        password: *mut GTlsPassword,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_interaction_ask_password_finish(
        interaction: *mut GTlsInteraction,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    pub fn g_tls_interaction_invoke_request_certificate(
        interaction: *mut GTlsInteraction,
        connection: *mut GTlsConnection,
        flags: GTlsCertificateRequestFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    pub fn g_tls_interaction_request_certificate(
        interaction: *mut GTlsInteraction,
        connection: *mut GTlsConnection,
        flags: GTlsCertificateRequestFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    pub fn g_tls_interaction_request_certificate_async(
        interaction: *mut GTlsInteraction,
        connection: *mut GTlsConnection,
        flags: GTlsCertificateRequestFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tls_interaction_request_certificate_finish(
        interaction: *mut GTlsInteraction,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
#[doc = " GTlsPasswordClass:\n @get_value: virtual method for g_tls_password_get_value()\n @set_value: virtual method for g_tls_password_set_value()\n @get_default_warning: virtual method for g_tls_password_get_warning() if no\n  value has been set using g_tls_password_set_warning()\n\n Class structure for #GTlsPassword."]
pub type GTlsPasswordClass = _GTlsPasswordClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsPasswordPrivate {
    _unused: [u8; 0],
}
pub type GTlsPasswordPrivate = _GTlsPasswordPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsPassword {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsPasswordPrivate,
}
#[test]
fn bindgen_test_layout__GTlsPassword() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsPassword> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsPassword>(),
        32usize,
        concat!("Size of: ", stringify!(_GTlsPassword))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsPassword>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsPassword))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPassword),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPassword),
            "::",
            stringify!(priv_)
        )
    );
}
#[doc = " GTlsPasswordClass:\n @get_value: virtual method for g_tls_password_get_value()\n @set_value: virtual method for g_tls_password_set_value()\n @get_default_warning: virtual method for g_tls_password_get_warning() if no\n  value has been set using g_tls_password_set_warning()\n\n Class structure for #GTlsPassword."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsPasswordClass {
    pub parent_class: GObjectClass,
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(password: *mut GTlsPassword, length: *mut gsize) -> *const guchar,
    >,
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(
            password: *mut GTlsPassword,
            value: *mut guchar,
            length: gssize,
            destroy: GDestroyNotify,
        ),
    >,
    pub get_default_warning:
        ::std::option::Option<unsafe extern "C" fn(password: *mut GTlsPassword) -> *const gchar>,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GTlsPasswordClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsPasswordClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsPasswordClass>(),
        192usize,
        concat!("Size of: ", stringify!(_GTlsPasswordClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsPasswordClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsPasswordClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_value) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(get_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_value) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(set_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_default_warning) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(get_default_warning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn g_tls_password_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_password_new(
        flags: GTlsPasswordFlags,
        description: *const gchar,
    ) -> *mut GTlsPassword;
}
extern "C" {
    pub fn g_tls_password_get_value(
        password: *mut GTlsPassword,
        length: *mut gsize,
    ) -> *const guchar;
}
extern "C" {
    pub fn g_tls_password_set_value(
        password: *mut GTlsPassword,
        value: *const guchar,
        length: gssize,
    );
}
extern "C" {
    pub fn g_tls_password_set_value_full(
        password: *mut GTlsPassword,
        value: *mut guchar,
        length: gssize,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_tls_password_get_flags(password: *mut GTlsPassword) -> GTlsPasswordFlags;
}
extern "C" {
    pub fn g_tls_password_set_flags(password: *mut GTlsPassword, flags: GTlsPasswordFlags);
}
extern "C" {
    pub fn g_tls_password_get_description(password: *mut GTlsPassword) -> *const gchar;
}
extern "C" {
    pub fn g_tls_password_set_description(password: *mut GTlsPassword, description: *const gchar);
}
extern "C" {
    pub fn g_tls_password_get_warning(password: *mut GTlsPassword) -> *const gchar;
}
extern "C" {
    pub fn g_tls_password_set_warning(password: *mut GTlsPassword, warning: *const gchar);
}
#[doc = " GTlsServerConnection:\n\n TLS server-side connection. This is the server-side implementation\n of a #GTlsConnection.\n\n Since: 2.28"]
pub type GTlsServerConnectionInterface = _GTlsServerConnectionInterface;
#[doc = " GTlsServerConnectionInterface:\n @g_iface: The parent interface.\n\n vtable for a #GTlsServerConnection implementation.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsServerConnectionInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GTlsServerConnectionInterface() {
    const UNINIT: ::std::mem::MaybeUninit<_GTlsServerConnectionInterface> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GTlsServerConnectionInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GTlsServerConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsServerConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsServerConnectionInterface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsServerConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    pub fn g_tls_server_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_tls_server_connection_new(
        base_io_stream: *mut GIOStream,
        certificate: *mut GTlsCertificate,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
pub type GUnixConnection = _GUnixConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixConnectionPrivate {
    _unused: [u8; 0],
}
pub type GUnixConnectionPrivate = _GUnixConnectionPrivate;
pub type GUnixConnectionClass = _GUnixConnectionClass;
pub type GUnixConnection_autoptr = *mut GUnixConnection;
pub type GUnixConnection_listautoptr = *mut GList;
pub type GUnixConnection_slistautoptr = *mut GSList;
pub type GUnixConnection_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixConnectionClass {
    pub parent_class: GSocketConnectionClass,
}
#[test]
fn bindgen_test_layout__GUnixConnectionClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixConnectionClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixConnectionClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GUnixConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixConnectionClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixConnection {
    pub parent_instance: GSocketConnection,
    pub priv_: *mut GUnixConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GUnixConnection() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixConnection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixConnection>(),
        48usize,
        concat!("Size of: ", stringify!(_GUnixConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixConnection))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixConnection),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_unix_connection_get_type() -> GType;
}
extern "C" {
    pub fn g_unix_connection_send_fd(
        connection: *mut GUnixConnection,
        fd: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_unix_connection_receive_fd(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_unix_connection_send_credentials(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_unix_connection_send_credentials_async(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_unix_connection_send_credentials_finish(
        connection: *mut GUnixConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_unix_connection_receive_credentials(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GCredentials;
}
extern "C" {
    pub fn g_unix_connection_receive_credentials_async(
        connection: *mut GUnixConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_unix_connection_receive_credentials_finish(
        connection: *mut GUnixConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GCredentials;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixCredentialsMessagePrivate {
    _unused: [u8; 0],
}
pub type GUnixCredentialsMessagePrivate = _GUnixCredentialsMessagePrivate;
#[doc = " GUnixCredentialsMessageClass:\n\n Class structure for #GUnixCredentialsMessage.\n\n Since: 2.26"]
pub type GUnixCredentialsMessageClass = _GUnixCredentialsMessageClass;
pub type GUnixCredentialsMessage_autoptr = *mut GUnixCredentialsMessage;
pub type GUnixCredentialsMessage_listautoptr = *mut GList;
pub type GUnixCredentialsMessage_slistautoptr = *mut GSList;
pub type GUnixCredentialsMessage_queueautoptr = *mut GQueue;
#[doc = " GUnixCredentialsMessageClass:\n\n Class structure for #GUnixCredentialsMessage.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixCredentialsMessageClass {
    pub parent_class: GSocketControlMessageClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GUnixCredentialsMessageClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixCredentialsMessageClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixCredentialsMessageClass>(),
        232usize,
        concat!("Size of: ", stringify!(_GUnixCredentialsMessageClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixCredentialsMessageClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixCredentialsMessageClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixCredentialsMessageClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixCredentialsMessageClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixCredentialsMessageClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
}
#[doc = " GUnixCredentialsMessage:\n\n The #GUnixCredentialsMessage structure contains only private data\n and should only be accessed using the provided API.\n\n Since: 2.26"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixCredentialsMessage {
    pub parent_instance: GSocketControlMessage,
    pub priv_: *mut GUnixCredentialsMessagePrivate,
}
#[test]
fn bindgen_test_layout__GUnixCredentialsMessage() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixCredentialsMessage> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixCredentialsMessage>(),
        40usize,
        concat!("Size of: ", stringify!(_GUnixCredentialsMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixCredentialsMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixCredentialsMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixCredentialsMessage),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixCredentialsMessage),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_unix_credentials_message_get_type() -> GType;
}
extern "C" {
    pub fn g_unix_credentials_message_new() -> *mut GSocketControlMessage;
}
extern "C" {
    pub fn g_unix_credentials_message_new_with_credentials(
        credentials: *mut GCredentials,
    ) -> *mut GSocketControlMessage;
}
extern "C" {
    pub fn g_unix_credentials_message_get_credentials(
        message: *mut GUnixCredentialsMessage,
    ) -> *mut GCredentials;
}
extern "C" {
    pub fn g_unix_credentials_message_is_supported() -> gboolean;
}
pub type GUnixFDList_autoptr = *mut GUnixFDList;
pub type GUnixFDList_listautoptr = *mut GList;
pub type GUnixFDList_slistautoptr = *mut GSList;
pub type GUnixFDList_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixFDListPrivate {
    _unused: [u8; 0],
}
pub type GUnixFDListPrivate = _GUnixFDListPrivate;
pub type GUnixFDListClass = _GUnixFDListClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixFDListClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GUnixFDListClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixFDListClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixFDListClass>(),
        176usize,
        concat!("Size of: ", stringify!(_GUnixFDListClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixFDListClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixFDListClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDListClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDListClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDListClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDListClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDListClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDListClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixFDList {
    pub parent_instance: GObject,
    pub priv_: *mut GUnixFDListPrivate,
}
#[test]
fn bindgen_test_layout__GUnixFDList() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixFDList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixFDList>(),
        32usize,
        concat!("Size of: ", stringify!(_GUnixFDList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixFDList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixFDList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDList),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixFDList),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    pub fn g_unix_fd_list_get_type() -> GType;
}
extern "C" {
    pub fn g_unix_fd_list_new() -> *mut GUnixFDList;
}
extern "C" {
    pub fn g_unix_fd_list_new_from_array(fds: *const gint, n_fds: gint) -> *mut GUnixFDList;
}
extern "C" {
    pub fn g_unix_fd_list_append(list: *mut GUnixFDList, fd: gint, error: *mut *mut GError)
        -> gint;
}
extern "C" {
    pub fn g_unix_fd_list_get_length(list: *mut GUnixFDList) -> gint;
}
extern "C" {
    pub fn g_unix_fd_list_get(
        list: *mut GUnixFDList,
        index_: gint,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_unix_fd_list_peek_fds(list: *mut GUnixFDList, length: *mut gint) -> *const gint;
}
extern "C" {
    pub fn g_unix_fd_list_steal_fds(list: *mut GUnixFDList, length: *mut gint) -> *mut gint;
}
pub type GUnixSocketAddress = _GUnixSocketAddress;
pub type GUnixSocketAddressClass = _GUnixSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixSocketAddressPrivate {
    _unused: [u8; 0],
}
pub type GUnixSocketAddressPrivate = _GUnixSocketAddressPrivate;
pub type GUnixSocketAddress_autoptr = *mut GUnixSocketAddress;
pub type GUnixSocketAddress_listautoptr = *mut GList;
pub type GUnixSocketAddress_slistautoptr = *mut GSList;
pub type GUnixSocketAddress_queueautoptr = *mut GQueue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixSocketAddress {
    pub parent_instance: GSocketAddress,
    pub priv_: *mut GUnixSocketAddressPrivate,
}
#[test]
fn bindgen_test_layout__GUnixSocketAddress() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixSocketAddress> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixSocketAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GUnixSocketAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixSocketAddress))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixSocketAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixSocketAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}
#[test]
fn bindgen_test_layout__GUnixSocketAddressClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GUnixSocketAddressClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUnixSocketAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GUnixSocketAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUnixSocketAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GUnixSocketAddressClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUnixSocketAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_unix_socket_address_get_type() -> GType;
}
extern "C" {
    pub fn g_unix_socket_address_new(path: *const gchar) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_unix_socket_address_new_abstract(
        path: *const gchar,
        path_len: gint,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_unix_socket_address_new_with_type(
        path: *const gchar,
        path_len: gint,
        type_: GUnixSocketAddressType,
    ) -> *mut GSocketAddress;
}
extern "C" {
    pub fn g_unix_socket_address_get_path(
        address: *mut GUnixSocketAddress,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_unix_socket_address_get_path_len(address: *mut GUnixSocketAddress) -> gsize;
}
extern "C" {
    pub fn g_unix_socket_address_get_address_type(
        address: *mut GUnixSocketAddress,
    ) -> GUnixSocketAddressType;
}
extern "C" {
    pub fn g_unix_socket_address_get_is_abstract(address: *mut GUnixSocketAddress) -> gboolean;
}
extern "C" {
    pub fn g_unix_socket_address_abstract_names_supported() -> gboolean;
}
#[doc = " GVfsFileLookupFunc:\n @vfs: a #GVfs\n @identifier: the identifier to look up a #GFile for. This can either\n     be an URI or a parse name as returned by g_file_get_parse_name()\n @user_data: user data passed to the function\n\n This function type is used by g_vfs_register_uri_scheme() to make it\n possible for a client to associate an URI scheme to a different #GFile\n implementation.\n\n The client should return a reference to the new file that has been\n created for @uri, or %NULL to continue with the default implementation.\n\n Returns: (transfer full): a #GFile for @identifier.\n\n Since: 2.50"]
pub type GVfsFileLookupFunc = ::std::option::Option<
    unsafe extern "C" fn(
        vfs: *mut GVfs,
        identifier: *const ::std::os::raw::c_char,
        user_data: gpointer,
    ) -> *mut GFile,
>;
#[doc = " GVfs:\n\n Virtual File System object."]
pub type GVfsClass = _GVfsClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVfs {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__GVfs() {
    const UNINIT: ::std::mem::MaybeUninit<_GVfs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVfs>(),
        24usize,
        concat!("Size of: ", stringify!(_GVfs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVfs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVfs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfs),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVfsClass {
    pub parent_class: GObjectClass,
    pub is_active: ::std::option::Option<unsafe extern "C" fn(vfs: *mut GVfs) -> gboolean>,
    pub get_file_for_path: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, path: *const ::std::os::raw::c_char) -> *mut GFile,
    >,
    pub get_file_for_uri: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, uri: *const ::std::os::raw::c_char) -> *mut GFile,
    >,
    pub get_supported_uri_schemes:
        ::std::option::Option<unsafe extern "C" fn(vfs: *mut GVfs) -> *const *const gchar>,
    pub parse_name: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            parse_name: *const ::std::os::raw::c_char,
        ) -> *mut GFile,
    >,
    pub local_file_add_info: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            filename: *const ::std::os::raw::c_char,
            device: guint64,
            attribute_matcher: *mut GFileAttributeMatcher,
            info: *mut GFileInfo,
            cancellable: *mut GCancellable,
            extra_data: *mut gpointer,
            free_extra_data: *mut GDestroyNotify,
        ),
    >,
    pub add_writable_namespaces: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, list: *mut GFileAttributeInfoList),
    >,
    pub local_file_set_attributes: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            filename: *const ::std::os::raw::c_char,
            info: *mut GFileInfo,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub local_file_removed: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, filename: *const ::std::os::raw::c_char),
    >,
    pub local_file_moved: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            source: *const ::std::os::raw::c_char,
            dest: *const ::std::os::raw::c_char,
        ),
    >,
    pub deserialize_icon: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, value: *mut GVariant) -> *mut GIcon,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GVfsClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GVfsClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVfsClass>(),
        272usize,
        concat!("Size of: ", stringify!(_GVfsClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVfsClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVfsClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_active) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(is_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_file_for_path) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(get_file_for_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_file_for_uri) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(get_file_for_uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_supported_uri_schemes) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(get_supported_uri_schemes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parse_name) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(parse_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_file_add_info) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(local_file_add_info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).add_writable_namespaces) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(add_writable_namespaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_file_set_attributes) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(local_file_set_attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_file_removed) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(local_file_removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).local_file_moved) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(local_file_moved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deserialize_icon) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(deserialize_icon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved1) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved2) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved3) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved4) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved5) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._g_reserved6) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
extern "C" {
    pub fn g_vfs_get_type() -> GType;
}
extern "C" {
    pub fn g_vfs_is_active(vfs: *mut GVfs) -> gboolean;
}
extern "C" {
    pub fn g_vfs_get_file_for_path(
        vfs: *mut GVfs,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_vfs_get_file_for_uri(vfs: *mut GVfs, uri: *const ::std::os::raw::c_char)
        -> *mut GFile;
}
extern "C" {
    pub fn g_vfs_get_supported_uri_schemes(vfs: *mut GVfs) -> *const *const gchar;
}
extern "C" {
    pub fn g_vfs_parse_name(
        vfs: *mut GVfs,
        parse_name: *const ::std::os::raw::c_char,
    ) -> *mut GFile;
}
extern "C" {
    pub fn g_vfs_get_default() -> *mut GVfs;
}
extern "C" {
    pub fn g_vfs_get_local() -> *mut GVfs;
}
extern "C" {
    pub fn g_vfs_register_uri_scheme(
        vfs: *mut GVfs,
        scheme: *const ::std::os::raw::c_char,
        uri_func: GVfsFileLookupFunc,
        uri_data: gpointer,
        uri_destroy: GDestroyNotify,
        parse_name_func: GVfsFileLookupFunc,
        parse_name_data: gpointer,
        parse_name_destroy: GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_vfs_unregister_uri_scheme(
        vfs: *mut GVfs,
        scheme: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
#[doc = " GVolumeIface:\n @g_iface: The parent interface.\n @changed: Changed signal that is emitted when the volume's state has changed.\n @removed: The removed signal that is emitted when the #GVolume have been removed. If the recipient is holding references to the object they should release them so the object can be finalized.\n @get_name: Gets a string containing the name of the #GVolume.\n @get_icon: Gets a #GIcon for the #GVolume.\n @get_uuid: Gets the UUID for the #GVolume. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.\n @get_drive: Gets a #GDrive the volume is located on. Returns %NULL if the #GVolume is not associated with a #GDrive.\n @get_mount: Gets a #GMount representing the mounted volume. Returns %NULL if the #GVolume is not mounted.\n @can_mount: Returns %TRUE if the #GVolume can be mounted.\n @can_eject: Checks if a #GVolume can be ejected.\n @mount_fn: Mounts a given #GVolume.\n     #GVolume implementations must emit the #GMountOperation::aborted\n     signal before completing a mount operation that is aborted while\n     awaiting input from the user through a #GMountOperation instance.\n @mount_finish: Finishes a mount operation.\n @eject: Ejects a given #GVolume.\n @eject_finish: Finishes an eject operation.\n @get_identifier: Returns the [identifier][volume-identifier] of the given kind, or %NULL if\n    the #GVolume doesn't have one.\n @enumerate_identifiers: Returns an array strings listing the kinds\n    of [identifiers][volume-identifier] which the #GVolume has.\n @should_automount: Returns %TRUE if the #GVolume should be automatically mounted.\n @get_activation_root: Returns the activation root for the #GVolume if it is known in advance or %NULL if\n   it is not known.\n @eject_with_operation: Starts ejecting a #GVolume using a #GMountOperation. Since 2.22.\n @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.\n @get_sort_key: Gets a key used for sorting #GVolume instance or %NULL if no such key exists. Since 2.32.\n @get_symbolic_icon: Gets a symbolic #GIcon for the #GVolume. Since 2.34.\n\n Interface for implementing operations for mountable volumes."]
pub type GVolumeIface = _GVolumeIface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolumeIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume)>,
    pub removed: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume)>,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume) -> *mut ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GIcon>,
    pub get_uuid: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume) -> *mut ::std::os::raw::c_char,
    >,
    pub get_drive: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GDrive>,
    pub get_mount: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GMount>,
    pub can_mount: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> gboolean>,
    pub mount_fn: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub mount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_finish: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_identifier: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            kind: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub enumerate_identifiers: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume) -> *mut *mut ::std::os::raw::c_char,
    >,
    pub should_automount:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> gboolean>,
    pub get_activation_root:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GFile>,
    pub eject_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_sort_key:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *const gchar>,
    pub get_symbolic_icon:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GIcon>,
}
#[test]
fn bindgen_test_layout__GVolumeIface() {
    const UNINIT: ::std::mem::MaybeUninit<_GVolumeIface> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GVolumeIface>(),
        184usize,
        concat!("Size of: ", stringify!(_GVolumeIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVolumeIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVolumeIface))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g_iface) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).removed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(removed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_icon) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_icon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_uuid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_drive) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_drive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_mount) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_mount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_mount) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(can_mount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).can_eject) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(can_eject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_fn) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(mount_fn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mount_finish) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(mount_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(eject)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_finish) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(eject_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_identifier) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enumerate_identifiers) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(enumerate_identifiers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).should_automount) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(should_automount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_activation_root) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_activation_root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_with_operation) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(eject_with_operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eject_with_operation_finish) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(eject_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_sort_key) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_sort_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_symbolic_icon) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_symbolic_icon)
        )
    );
}
extern "C" {
    pub fn g_volume_get_type() -> GType;
}
extern "C" {
    pub fn g_volume_get_name(volume: *mut GVolume) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_volume_get_icon(volume: *mut GVolume) -> *mut GIcon;
}
extern "C" {
    pub fn g_volume_get_symbolic_icon(volume: *mut GVolume) -> *mut GIcon;
}
extern "C" {
    pub fn g_volume_get_uuid(volume: *mut GVolume) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_volume_get_drive(volume: *mut GVolume) -> *mut GDrive;
}
extern "C" {
    pub fn g_volume_get_mount(volume: *mut GVolume) -> *mut GMount;
}
extern "C" {
    pub fn g_volume_can_mount(volume: *mut GVolume) -> gboolean;
}
extern "C" {
    pub fn g_volume_can_eject(volume: *mut GVolume) -> gboolean;
}
extern "C" {
    pub fn g_volume_should_automount(volume: *mut GVolume) -> gboolean;
}
extern "C" {
    pub fn g_volume_mount(
        volume: *mut GVolume,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_volume_mount_finish(
        volume: *mut GVolume,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_volume_eject(
        volume: *mut GVolume,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_volume_eject_finish(
        volume: *mut GVolume,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_volume_get_identifier(
        volume: *mut GVolume,
        kind: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_volume_enumerate_identifiers(volume: *mut GVolume)
        -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn g_volume_get_activation_root(volume: *mut GVolume) -> *mut GFile;
}
extern "C" {
    pub fn g_volume_eject_with_operation(
        volume: *mut GVolume,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_volume_eject_with_operation_finish(
        volume: *mut GVolume,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_volume_get_sort_key(volume: *mut GVolume) -> *const gchar;
}
pub type GZlibCompressorClass = _GZlibCompressorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibCompressorClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GZlibCompressorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GZlibCompressorClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GZlibCompressorClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GZlibCompressorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GZlibCompressorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GZlibCompressorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GZlibCompressorClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_zlib_compressor_get_type() -> GType;
}
extern "C" {
    pub fn g_zlib_compressor_new(
        format: GZlibCompressorFormat,
        level: ::std::os::raw::c_int,
    ) -> *mut GZlibCompressor;
}
extern "C" {
    pub fn g_zlib_compressor_get_file_info(compressor: *mut GZlibCompressor) -> *mut GFileInfo;
}
extern "C" {
    pub fn g_zlib_compressor_set_file_info(
        compressor: *mut GZlibCompressor,
        file_info: *mut GFileInfo,
    );
}
pub type GZlibDecompressorClass = _GZlibDecompressorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibDecompressorClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GZlibDecompressorClass() {
    const UNINIT: ::std::mem::MaybeUninit<_GZlibDecompressorClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GZlibDecompressorClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GZlibDecompressorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GZlibDecompressorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GZlibDecompressorClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GZlibDecompressorClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    pub fn g_zlib_decompressor_get_type() -> GType;
}
extern "C" {
    pub fn g_zlib_decompressor_new(format: GZlibCompressorFormat) -> *mut GZlibDecompressor;
}
extern "C" {
    pub fn g_zlib_decompressor_get_file_info(
        decompressor: *mut GZlibDecompressor,
    ) -> *mut GFileInfo;
}
pub type GAction_autoptr = *mut GAction;
pub type GAction_listautoptr = *mut GList;
pub type GAction_slistautoptr = *mut GSList;
pub type GAction_queueautoptr = *mut GQueue;
pub type GActionMap_autoptr = *mut GActionMap;
pub type GActionMap_listautoptr = *mut GList;
pub type GActionMap_slistautoptr = *mut GSList;
pub type GActionMap_queueautoptr = *mut GQueue;
pub type GAppInfo_autoptr = *mut GAppInfo;
pub type GAppInfo_listautoptr = *mut GList;
pub type GAppInfo_slistautoptr = *mut GSList;
pub type GAppInfo_queueautoptr = *mut GQueue;
pub type GAppLaunchContext_autoptr = *mut GAppLaunchContext;
pub type GAppLaunchContext_listautoptr = *mut GList;
pub type GAppLaunchContext_slistautoptr = *mut GSList;
pub type GAppLaunchContext_queueautoptr = *mut GQueue;
pub type GAppInfoMonitor_autoptr = *mut GAppInfoMonitor;
pub type GAppInfoMonitor_listautoptr = *mut GList;
pub type GAppInfoMonitor_slistautoptr = *mut GSList;
pub type GAppInfoMonitor_queueautoptr = *mut GQueue;
pub type GApplicationCommandLine_autoptr = *mut GApplicationCommandLine;
pub type GApplicationCommandLine_listautoptr = *mut GList;
pub type GApplicationCommandLine_slistautoptr = *mut GSList;
pub type GApplicationCommandLine_queueautoptr = *mut GQueue;
pub type GApplication_autoptr = *mut GApplication;
pub type GApplication_listautoptr = *mut GList;
pub type GApplication_slistautoptr = *mut GSList;
pub type GApplication_queueautoptr = *mut GQueue;
pub type GAsyncInitable_autoptr = *mut GAsyncInitable;
pub type GAsyncInitable_listautoptr = *mut GList;
pub type GAsyncInitable_slistautoptr = *mut GSList;
pub type GAsyncInitable_queueautoptr = *mut GQueue;
pub type GAsyncResult_autoptr = *mut GAsyncResult;
pub type GAsyncResult_listautoptr = *mut GList;
pub type GAsyncResult_slistautoptr = *mut GSList;
pub type GAsyncResult_queueautoptr = *mut GQueue;
pub type GBufferedInputStream_autoptr = *mut GBufferedInputStream;
pub type GBufferedInputStream_listautoptr = *mut GList;
pub type GBufferedInputStream_slistautoptr = *mut GSList;
pub type GBufferedInputStream_queueautoptr = *mut GQueue;
pub type GBufferedOutputStream_autoptr = *mut GBufferedOutputStream;
pub type GBufferedOutputStream_listautoptr = *mut GList;
pub type GBufferedOutputStream_slistautoptr = *mut GSList;
pub type GBufferedOutputStream_queueautoptr = *mut GQueue;
pub type GBytesIcon_autoptr = *mut GBytesIcon;
pub type GBytesIcon_listautoptr = *mut GList;
pub type GBytesIcon_slistautoptr = *mut GSList;
pub type GBytesIcon_queueautoptr = *mut GQueue;
pub type GCancellable_autoptr = *mut GCancellable;
pub type GCancellable_listautoptr = *mut GList;
pub type GCancellable_slistautoptr = *mut GSList;
pub type GCancellable_queueautoptr = *mut GQueue;
pub type GCharsetConverter_autoptr = *mut GCharsetConverter;
pub type GCharsetConverter_listautoptr = *mut GList;
pub type GCharsetConverter_slistautoptr = *mut GSList;
pub type GCharsetConverter_queueautoptr = *mut GQueue;
pub type GConverter_autoptr = *mut GConverter;
pub type GConverter_listautoptr = *mut GList;
pub type GConverter_slistautoptr = *mut GSList;
pub type GConverter_queueautoptr = *mut GQueue;
pub type GConverterInputStream_autoptr = *mut GConverterInputStream;
pub type GConverterInputStream_listautoptr = *mut GList;
pub type GConverterInputStream_slistautoptr = *mut GSList;
pub type GConverterInputStream_queueautoptr = *mut GQueue;
pub type GConverterOutputStream_autoptr = *mut GConverterOutputStream;
pub type GConverterOutputStream_listautoptr = *mut GList;
pub type GConverterOutputStream_slistautoptr = *mut GSList;
pub type GConverterOutputStream_queueautoptr = *mut GQueue;
pub type GCredentials_autoptr = *mut GCredentials;
pub type GCredentials_listautoptr = *mut GList;
pub type GCredentials_slistautoptr = *mut GSList;
pub type GCredentials_queueautoptr = *mut GQueue;
pub type GDatagramBased_autoptr = *mut GDatagramBased;
pub type GDatagramBased_listautoptr = *mut GList;
pub type GDatagramBased_slistautoptr = *mut GSList;
pub type GDatagramBased_queueautoptr = *mut GQueue;
pub type GDataInputStream_autoptr = *mut GDataInputStream;
pub type GDataInputStream_listautoptr = *mut GList;
pub type GDataInputStream_slistautoptr = *mut GSList;
pub type GDataInputStream_queueautoptr = *mut GQueue;
pub type GDataOutputStream_autoptr = *mut GDataOutputStream;
pub type GDataOutputStream_listautoptr = *mut GList;
pub type GDataOutputStream_slistautoptr = *mut GSList;
pub type GDataOutputStream_queueautoptr = *mut GQueue;
pub type GDBusActionGroup_autoptr = *mut GDBusActionGroup;
pub type GDBusActionGroup_listautoptr = *mut GList;
pub type GDBusActionGroup_slistautoptr = *mut GSList;
pub type GDBusActionGroup_queueautoptr = *mut GQueue;
pub type GDBusAuthObserver_autoptr = *mut GDBusAuthObserver;
pub type GDBusAuthObserver_listautoptr = *mut GList;
pub type GDBusAuthObserver_slistautoptr = *mut GSList;
pub type GDBusAuthObserver_queueautoptr = *mut GQueue;
pub type GDBusConnection_autoptr = *mut GDBusConnection;
pub type GDBusConnection_listautoptr = *mut GList;
pub type GDBusConnection_slistautoptr = *mut GSList;
pub type GDBusConnection_queueautoptr = *mut GQueue;
pub type GDBusInterface_autoptr = *mut GDBusInterface;
pub type GDBusInterface_listautoptr = *mut GList;
pub type GDBusInterface_slistautoptr = *mut GSList;
pub type GDBusInterface_queueautoptr = *mut GQueue;
pub type GDBusInterfaceSkeleton_autoptr = *mut GDBusInterfaceSkeleton;
pub type GDBusInterfaceSkeleton_listautoptr = *mut GList;
pub type GDBusInterfaceSkeleton_slistautoptr = *mut GSList;
pub type GDBusInterfaceSkeleton_queueautoptr = *mut GQueue;
pub type GDBusMenuModel_autoptr = *mut GDBusMenuModel;
pub type GDBusMenuModel_listautoptr = *mut GList;
pub type GDBusMenuModel_slistautoptr = *mut GSList;
pub type GDBusMenuModel_queueautoptr = *mut GQueue;
pub type GDBusMessage_autoptr = *mut GDBusMessage;
pub type GDBusMessage_listautoptr = *mut GList;
pub type GDBusMessage_slistautoptr = *mut GSList;
pub type GDBusMessage_queueautoptr = *mut GQueue;
pub type GDBusMethodInvocation_autoptr = *mut GDBusMethodInvocation;
pub type GDBusMethodInvocation_listautoptr = *mut GList;
pub type GDBusMethodInvocation_slistautoptr = *mut GSList;
pub type GDBusMethodInvocation_queueautoptr = *mut GQueue;
pub type GDBusNodeInfo_autoptr = *mut GDBusNodeInfo;
pub type GDBusNodeInfo_listautoptr = *mut GList;
pub type GDBusNodeInfo_slistautoptr = *mut GSList;
pub type GDBusNodeInfo_queueautoptr = *mut GQueue;
pub type GDBusObject_autoptr = *mut GDBusObject;
pub type GDBusObject_listautoptr = *mut GList;
pub type GDBusObject_slistautoptr = *mut GSList;
pub type GDBusObject_queueautoptr = *mut GQueue;
pub type GDBusObjectManagerClient_autoptr = *mut GDBusObjectManagerClient;
pub type GDBusObjectManagerClient_listautoptr = *mut GList;
pub type GDBusObjectManagerClient_slistautoptr = *mut GSList;
pub type GDBusObjectManagerClient_queueautoptr = *mut GQueue;
pub type GDBusObjectManager_autoptr = *mut GDBusObjectManager;
pub type GDBusObjectManager_listautoptr = *mut GList;
pub type GDBusObjectManager_slistautoptr = *mut GSList;
pub type GDBusObjectManager_queueautoptr = *mut GQueue;
pub type GDBusObjectManagerServer_autoptr = *mut GDBusObjectManagerServer;
pub type GDBusObjectManagerServer_listautoptr = *mut GList;
pub type GDBusObjectManagerServer_slistautoptr = *mut GSList;
pub type GDBusObjectManagerServer_queueautoptr = *mut GQueue;
pub type GDBusObjectProxy_autoptr = *mut GDBusObjectProxy;
pub type GDBusObjectProxy_listautoptr = *mut GList;
pub type GDBusObjectProxy_slistautoptr = *mut GSList;
pub type GDBusObjectProxy_queueautoptr = *mut GQueue;
pub type GDBusObjectSkeleton_autoptr = *mut GDBusObjectSkeleton;
pub type GDBusObjectSkeleton_listautoptr = *mut GList;
pub type GDBusObjectSkeleton_slistautoptr = *mut GSList;
pub type GDBusObjectSkeleton_queueautoptr = *mut GQueue;
pub type GDBusProxy_autoptr = *mut GDBusProxy;
pub type GDBusProxy_listautoptr = *mut GList;
pub type GDBusProxy_slistautoptr = *mut GSList;
pub type GDBusProxy_queueautoptr = *mut GQueue;
pub type GDBusServer_autoptr = *mut GDBusServer;
pub type GDBusServer_listautoptr = *mut GList;
pub type GDBusServer_slistautoptr = *mut GSList;
pub type GDBusServer_queueautoptr = *mut GQueue;
pub type GDrive_autoptr = *mut GDrive;
pub type GDrive_listautoptr = *mut GList;
pub type GDrive_slistautoptr = *mut GSList;
pub type GDrive_queueautoptr = *mut GQueue;
pub type GEmblemedIcon_autoptr = *mut GEmblemedIcon;
pub type GEmblemedIcon_listautoptr = *mut GList;
pub type GEmblemedIcon_slistautoptr = *mut GSList;
pub type GEmblemedIcon_queueautoptr = *mut GQueue;
pub type GEmblem_autoptr = *mut GEmblem;
pub type GEmblem_listautoptr = *mut GList;
pub type GEmblem_slistautoptr = *mut GSList;
pub type GEmblem_queueautoptr = *mut GQueue;
pub type GFileEnumerator_autoptr = *mut GFileEnumerator;
pub type GFileEnumerator_listautoptr = *mut GList;
pub type GFileEnumerator_slistautoptr = *mut GSList;
pub type GFileEnumerator_queueautoptr = *mut GQueue;
pub type GFile_autoptr = *mut GFile;
pub type GFile_listautoptr = *mut GList;
pub type GFile_slistautoptr = *mut GSList;
pub type GFile_queueautoptr = *mut GQueue;
pub type GFileAttributeInfoList_autoptr = *mut GFileAttributeInfoList;
pub type GFileAttributeInfoList_listautoptr = *mut GList;
pub type GFileAttributeInfoList_slistautoptr = *mut GSList;
pub type GFileAttributeInfoList_queueautoptr = *mut GQueue;
pub type GFileIcon_autoptr = *mut GFileIcon;
pub type GFileIcon_listautoptr = *mut GList;
pub type GFileIcon_slistautoptr = *mut GSList;
pub type GFileIcon_queueautoptr = *mut GQueue;
pub type GFileInfo_autoptr = *mut GFileInfo;
pub type GFileInfo_listautoptr = *mut GList;
pub type GFileInfo_slistautoptr = *mut GSList;
pub type GFileInfo_queueautoptr = *mut GQueue;
pub type GFileInputStream_autoptr = *mut GFileInputStream;
pub type GFileInputStream_listautoptr = *mut GList;
pub type GFileInputStream_slistautoptr = *mut GSList;
pub type GFileInputStream_queueautoptr = *mut GQueue;
pub type GFileIOStream_autoptr = *mut GFileIOStream;
pub type GFileIOStream_listautoptr = *mut GList;
pub type GFileIOStream_slistautoptr = *mut GSList;
pub type GFileIOStream_queueautoptr = *mut GQueue;
pub type GFileMonitor_autoptr = *mut GFileMonitor;
pub type GFileMonitor_listautoptr = *mut GList;
pub type GFileMonitor_slistautoptr = *mut GSList;
pub type GFileMonitor_queueautoptr = *mut GQueue;
pub type GFilenameCompleter_autoptr = *mut GFilenameCompleter;
pub type GFilenameCompleter_listautoptr = *mut GList;
pub type GFilenameCompleter_slistautoptr = *mut GSList;
pub type GFilenameCompleter_queueautoptr = *mut GQueue;
pub type GFileOutputStream_autoptr = *mut GFileOutputStream;
pub type GFileOutputStream_listautoptr = *mut GList;
pub type GFileOutputStream_slistautoptr = *mut GSList;
pub type GFileOutputStream_queueautoptr = *mut GQueue;
pub type GFilterInputStream_autoptr = *mut GFilterInputStream;
pub type GFilterInputStream_listautoptr = *mut GList;
pub type GFilterInputStream_slistautoptr = *mut GSList;
pub type GFilterInputStream_queueautoptr = *mut GQueue;
pub type GFilterOutputStream_autoptr = *mut GFilterOutputStream;
pub type GFilterOutputStream_listautoptr = *mut GList;
pub type GFilterOutputStream_slistautoptr = *mut GSList;
pub type GFilterOutputStream_queueautoptr = *mut GQueue;
pub type GIcon_autoptr = *mut GIcon;
pub type GIcon_listautoptr = *mut GList;
pub type GIcon_slistautoptr = *mut GSList;
pub type GIcon_queueautoptr = *mut GQueue;
pub type GInetAddress_autoptr = *mut GInetAddress;
pub type GInetAddress_listautoptr = *mut GList;
pub type GInetAddress_slistautoptr = *mut GSList;
pub type GInetAddress_queueautoptr = *mut GQueue;
pub type GInetAddressMask_autoptr = *mut GInetAddressMask;
pub type GInetAddressMask_listautoptr = *mut GList;
pub type GInetAddressMask_slistautoptr = *mut GSList;
pub type GInetAddressMask_queueautoptr = *mut GQueue;
pub type GInetSocketAddress_autoptr = *mut GInetSocketAddress;
pub type GInetSocketAddress_listautoptr = *mut GList;
pub type GInetSocketAddress_slistautoptr = *mut GSList;
pub type GInetSocketAddress_queueautoptr = *mut GQueue;
pub type GInitable_autoptr = *mut GInitable;
pub type GInitable_listautoptr = *mut GList;
pub type GInitable_slistautoptr = *mut GSList;
pub type GInitable_queueautoptr = *mut GQueue;
pub type GInputStream_autoptr = *mut GInputStream;
pub type GInputStream_listautoptr = *mut GList;
pub type GInputStream_slistautoptr = *mut GSList;
pub type GInputStream_queueautoptr = *mut GQueue;
pub type GIOModule_autoptr = *mut GIOModule;
pub type GIOModule_listautoptr = *mut GList;
pub type GIOModule_slistautoptr = *mut GSList;
pub type GIOModule_queueautoptr = *mut GQueue;
pub type GIOStream_autoptr = *mut GIOStream;
pub type GIOStream_listautoptr = *mut GList;
pub type GIOStream_slistautoptr = *mut GSList;
pub type GIOStream_queueautoptr = *mut GQueue;
pub type GLoadableIcon_autoptr = *mut GLoadableIcon;
pub type GLoadableIcon_listautoptr = *mut GList;
pub type GLoadableIcon_slistautoptr = *mut GSList;
pub type GLoadableIcon_queueautoptr = *mut GQueue;
pub type GMemoryInputStream_autoptr = *mut GMemoryInputStream;
pub type GMemoryInputStream_listautoptr = *mut GList;
pub type GMemoryInputStream_slistautoptr = *mut GSList;
pub type GMemoryInputStream_queueautoptr = *mut GQueue;
pub type GMemoryOutputStream_autoptr = *mut GMemoryOutputStream;
pub type GMemoryOutputStream_listautoptr = *mut GList;
pub type GMemoryOutputStream_slistautoptr = *mut GSList;
pub type GMemoryOutputStream_queueautoptr = *mut GQueue;
pub type GMenu_autoptr = *mut GMenu;
pub type GMenu_listautoptr = *mut GList;
pub type GMenu_slistautoptr = *mut GSList;
pub type GMenu_queueautoptr = *mut GQueue;
pub type GMenuItem_autoptr = *mut GMenuItem;
pub type GMenuItem_listautoptr = *mut GList;
pub type GMenuItem_slistautoptr = *mut GSList;
pub type GMenuItem_queueautoptr = *mut GQueue;
pub type GMenuModel_autoptr = *mut GMenuModel;
pub type GMenuModel_listautoptr = *mut GList;
pub type GMenuModel_slistautoptr = *mut GSList;
pub type GMenuModel_queueautoptr = *mut GQueue;
pub type GMenuAttributeIter_autoptr = *mut GMenuAttributeIter;
pub type GMenuAttributeIter_listautoptr = *mut GList;
pub type GMenuAttributeIter_slistautoptr = *mut GSList;
pub type GMenuAttributeIter_queueautoptr = *mut GQueue;
pub type GMenuLinkIter_autoptr = *mut GMenuLinkIter;
pub type GMenuLinkIter_listautoptr = *mut GList;
pub type GMenuLinkIter_slistautoptr = *mut GSList;
pub type GMenuLinkIter_queueautoptr = *mut GQueue;
pub type GMount_autoptr = *mut GMount;
pub type GMount_listautoptr = *mut GList;
pub type GMount_slistautoptr = *mut GSList;
pub type GMount_queueautoptr = *mut GQueue;
pub type GMountOperation_autoptr = *mut GMountOperation;
pub type GMountOperation_listautoptr = *mut GList;
pub type GMountOperation_slistautoptr = *mut GSList;
pub type GMountOperation_queueautoptr = *mut GQueue;
pub type GNativeVolumeMonitor_autoptr = *mut GNativeVolumeMonitor;
pub type GNativeVolumeMonitor_listautoptr = *mut GList;
pub type GNativeVolumeMonitor_slistautoptr = *mut GSList;
pub type GNativeVolumeMonitor_queueautoptr = *mut GQueue;
pub type GNetworkAddress_autoptr = *mut GNetworkAddress;
pub type GNetworkAddress_listautoptr = *mut GList;
pub type GNetworkAddress_slistautoptr = *mut GSList;
pub type GNetworkAddress_queueautoptr = *mut GQueue;
pub type GNetworkMonitor_autoptr = *mut GNetworkMonitor;
pub type GNetworkMonitor_listautoptr = *mut GList;
pub type GNetworkMonitor_slistautoptr = *mut GSList;
pub type GNetworkMonitor_queueautoptr = *mut GQueue;
pub type GNetworkService_autoptr = *mut GNetworkService;
pub type GNetworkService_listautoptr = *mut GList;
pub type GNetworkService_slistautoptr = *mut GSList;
pub type GNetworkService_queueautoptr = *mut GQueue;
pub type GNotification_autoptr = *mut GNotification;
pub type GNotification_listautoptr = *mut GList;
pub type GNotification_slistautoptr = *mut GSList;
pub type GNotification_queueautoptr = *mut GQueue;
pub type GOutputStream_autoptr = *mut GOutputStream;
pub type GOutputStream_listautoptr = *mut GList;
pub type GOutputStream_slistautoptr = *mut GSList;
pub type GOutputStream_queueautoptr = *mut GQueue;
pub type GPermission_autoptr = *mut GPermission;
pub type GPermission_listautoptr = *mut GList;
pub type GPermission_slistautoptr = *mut GSList;
pub type GPermission_queueautoptr = *mut GQueue;
pub type GPollableInputStream_autoptr = *mut GPollableInputStream;
pub type GPollableInputStream_listautoptr = *mut GList;
pub type GPollableInputStream_slistautoptr = *mut GSList;
pub type GPollableInputStream_queueautoptr = *mut GQueue;
pub type GPollableOutputStream_autoptr = *mut GPollableOutputStream;
pub type GPollableOutputStream_listautoptr = *mut GList;
pub type GPollableOutputStream_slistautoptr = *mut GSList;
pub type GPollableOutputStream_queueautoptr = *mut GQueue;
pub type GPropertyAction_autoptr = *mut GPropertyAction;
pub type GPropertyAction_listautoptr = *mut GList;
pub type GPropertyAction_slistautoptr = *mut GSList;
pub type GPropertyAction_queueautoptr = *mut GQueue;
pub type GProxyAddressEnumerator_autoptr = *mut GProxyAddressEnumerator;
pub type GProxyAddressEnumerator_listautoptr = *mut GList;
pub type GProxyAddressEnumerator_slistautoptr = *mut GSList;
pub type GProxyAddressEnumerator_queueautoptr = *mut GQueue;
pub type GProxyAddress_autoptr = *mut GProxyAddress;
pub type GProxyAddress_listautoptr = *mut GList;
pub type GProxyAddress_slistautoptr = *mut GSList;
pub type GProxyAddress_queueautoptr = *mut GQueue;
pub type GProxy_autoptr = *mut GProxy;
pub type GProxy_listautoptr = *mut GList;
pub type GProxy_slistautoptr = *mut GSList;
pub type GProxy_queueautoptr = *mut GQueue;
pub type GProxyResolver_autoptr = *mut GProxyResolver;
pub type GProxyResolver_listautoptr = *mut GList;
pub type GProxyResolver_slistautoptr = *mut GSList;
pub type GProxyResolver_queueautoptr = *mut GQueue;
pub type GRemoteActionGroup_autoptr = *mut GRemoteActionGroup;
pub type GRemoteActionGroup_listautoptr = *mut GList;
pub type GRemoteActionGroup_slistautoptr = *mut GSList;
pub type GRemoteActionGroup_queueautoptr = *mut GQueue;
pub type GResolver_autoptr = *mut GResolver;
pub type GResolver_listautoptr = *mut GList;
pub type GResolver_slistautoptr = *mut GSList;
pub type GResolver_queueautoptr = *mut GQueue;
pub type GResource_autoptr = *mut GResource;
pub type GResource_listautoptr = *mut GList;
pub type GResource_slistautoptr = *mut GSList;
pub type GResource_queueautoptr = *mut GQueue;
pub type GSeekable_autoptr = *mut GSeekable;
pub type GSeekable_listautoptr = *mut GList;
pub type GSeekable_slistautoptr = *mut GSList;
pub type GSeekable_queueautoptr = *mut GQueue;
pub type GSettingsBackend_autoptr = *mut GSettingsBackend;
pub type GSettingsBackend_listautoptr = *mut GList;
pub type GSettingsBackend_slistautoptr = *mut GSList;
pub type GSettingsBackend_queueautoptr = *mut GQueue;
pub type GSettingsSchema_autoptr = *mut GSettingsSchema;
pub type GSettingsSchema_listautoptr = *mut GList;
pub type GSettingsSchema_slistautoptr = *mut GSList;
pub type GSettingsSchema_queueautoptr = *mut GQueue;
pub type GSettingsSchemaKey_autoptr = *mut GSettingsSchemaKey;
pub type GSettingsSchemaKey_listautoptr = *mut GList;
pub type GSettingsSchemaKey_slistautoptr = *mut GSList;
pub type GSettingsSchemaKey_queueautoptr = *mut GQueue;
pub type GSettingsSchemaSource_autoptr = *mut GSettingsSchemaSource;
pub type GSettingsSchemaSource_listautoptr = *mut GList;
pub type GSettingsSchemaSource_slistautoptr = *mut GSList;
pub type GSettingsSchemaSource_queueautoptr = *mut GQueue;
pub type GSettings_autoptr = *mut GSettings;
pub type GSettings_listautoptr = *mut GList;
pub type GSettings_slistautoptr = *mut GSList;
pub type GSettings_queueautoptr = *mut GQueue;
pub type GSimpleActionGroup_autoptr = *mut GSimpleActionGroup;
pub type GSimpleActionGroup_listautoptr = *mut GList;
pub type GSimpleActionGroup_slistautoptr = *mut GSList;
pub type GSimpleActionGroup_queueautoptr = *mut GQueue;
pub type GSimpleAction_autoptr = *mut GSimpleAction;
pub type GSimpleAction_listautoptr = *mut GList;
pub type GSimpleAction_slistautoptr = *mut GSList;
pub type GSimpleAction_queueautoptr = *mut GQueue;
pub type GSimpleAsyncResult_autoptr = *mut GSimpleAsyncResult;
pub type GSimpleAsyncResult_listautoptr = *mut GList;
pub type GSimpleAsyncResult_slistautoptr = *mut GSList;
pub type GSimpleAsyncResult_queueautoptr = *mut GQueue;
pub type GSimplePermission_autoptr = *mut GSimplePermission;
pub type GSimplePermission_listautoptr = *mut GList;
pub type GSimplePermission_slistautoptr = *mut GSList;
pub type GSimplePermission_queueautoptr = *mut GQueue;
pub type GSimpleProxyResolver_autoptr = *mut GSimpleProxyResolver;
pub type GSimpleProxyResolver_listautoptr = *mut GList;
pub type GSimpleProxyResolver_slistautoptr = *mut GSList;
pub type GSimpleProxyResolver_queueautoptr = *mut GQueue;
pub type GSocketAddressEnumerator_autoptr = *mut GSocketAddressEnumerator;
pub type GSocketAddressEnumerator_listautoptr = *mut GList;
pub type GSocketAddressEnumerator_slistautoptr = *mut GSList;
pub type GSocketAddressEnumerator_queueautoptr = *mut GQueue;
pub type GSocketAddress_autoptr = *mut GSocketAddress;
pub type GSocketAddress_listautoptr = *mut GList;
pub type GSocketAddress_slistautoptr = *mut GSList;
pub type GSocketAddress_queueautoptr = *mut GQueue;
pub type GSocketClient_autoptr = *mut GSocketClient;
pub type GSocketClient_listautoptr = *mut GList;
pub type GSocketClient_slistautoptr = *mut GSList;
pub type GSocketClient_queueautoptr = *mut GQueue;
pub type GSocketConnectable_autoptr = *mut GSocketConnectable;
pub type GSocketConnectable_listautoptr = *mut GList;
pub type GSocketConnectable_slistautoptr = *mut GSList;
pub type GSocketConnectable_queueautoptr = *mut GQueue;
pub type GSocketConnection_autoptr = *mut GSocketConnection;
pub type GSocketConnection_listautoptr = *mut GList;
pub type GSocketConnection_slistautoptr = *mut GSList;
pub type GSocketConnection_queueautoptr = *mut GQueue;
pub type GSocketControlMessage_autoptr = *mut GSocketControlMessage;
pub type GSocketControlMessage_listautoptr = *mut GList;
pub type GSocketControlMessage_slistautoptr = *mut GSList;
pub type GSocketControlMessage_queueautoptr = *mut GQueue;
pub type GSocket_autoptr = *mut GSocket;
pub type GSocket_listautoptr = *mut GList;
pub type GSocket_slistautoptr = *mut GSList;
pub type GSocket_queueautoptr = *mut GQueue;
pub type GSocketListener_autoptr = *mut GSocketListener;
pub type GSocketListener_listautoptr = *mut GList;
pub type GSocketListener_slistautoptr = *mut GSList;
pub type GSocketListener_queueautoptr = *mut GQueue;
pub type GSocketService_autoptr = *mut GSocketService;
pub type GSocketService_listautoptr = *mut GList;
pub type GSocketService_slistautoptr = *mut GSList;
pub type GSocketService_queueautoptr = *mut GQueue;
pub type GSubprocess_autoptr = *mut GSubprocess;
pub type GSubprocess_listautoptr = *mut GList;
pub type GSubprocess_slistautoptr = *mut GSList;
pub type GSubprocess_queueautoptr = *mut GQueue;
pub type GSubprocessLauncher_autoptr = *mut GSubprocessLauncher;
pub type GSubprocessLauncher_listautoptr = *mut GList;
pub type GSubprocessLauncher_slistautoptr = *mut GSList;
pub type GSubprocessLauncher_queueautoptr = *mut GQueue;
pub type GTask_autoptr = *mut GTask;
pub type GTask_listautoptr = *mut GList;
pub type GTask_slistautoptr = *mut GSList;
pub type GTask_queueautoptr = *mut GQueue;
pub type GTcpConnection_autoptr = *mut GTcpConnection;
pub type GTcpConnection_listautoptr = *mut GList;
pub type GTcpConnection_slistautoptr = *mut GSList;
pub type GTcpConnection_queueautoptr = *mut GQueue;
pub type GTcpWrapperConnection_autoptr = *mut GTcpWrapperConnection;
pub type GTcpWrapperConnection_listautoptr = *mut GList;
pub type GTcpWrapperConnection_slistautoptr = *mut GSList;
pub type GTcpWrapperConnection_queueautoptr = *mut GQueue;
pub type GTestDBus_autoptr = *mut GTestDBus;
pub type GTestDBus_listautoptr = *mut GList;
pub type GTestDBus_slistautoptr = *mut GSList;
pub type GTestDBus_queueautoptr = *mut GQueue;
pub type GThemedIcon_autoptr = *mut GThemedIcon;
pub type GThemedIcon_listautoptr = *mut GList;
pub type GThemedIcon_slistautoptr = *mut GSList;
pub type GThemedIcon_queueautoptr = *mut GQueue;
pub type GThreadedSocketService_autoptr = *mut GThreadedSocketService;
pub type GThreadedSocketService_listautoptr = *mut GList;
pub type GThreadedSocketService_slistautoptr = *mut GSList;
pub type GThreadedSocketService_queueautoptr = *mut GQueue;
pub type GTlsBackend_autoptr = *mut GTlsBackend;
pub type GTlsBackend_listautoptr = *mut GList;
pub type GTlsBackend_slistautoptr = *mut GSList;
pub type GTlsBackend_queueautoptr = *mut GQueue;
pub type GTlsCertificate_autoptr = *mut GTlsCertificate;
pub type GTlsCertificate_listautoptr = *mut GList;
pub type GTlsCertificate_slistautoptr = *mut GSList;
pub type GTlsCertificate_queueautoptr = *mut GQueue;
pub type GTlsClientConnection_autoptr = *mut GTlsClientConnection;
pub type GTlsClientConnection_listautoptr = *mut GList;
pub type GTlsClientConnection_slistautoptr = *mut GSList;
pub type GTlsClientConnection_queueautoptr = *mut GQueue;
pub type GTlsConnection_autoptr = *mut GTlsConnection;
pub type GTlsConnection_listautoptr = *mut GList;
pub type GTlsConnection_slistautoptr = *mut GSList;
pub type GTlsConnection_queueautoptr = *mut GQueue;
pub type GTlsDatabase_autoptr = *mut GTlsDatabase;
pub type GTlsDatabase_listautoptr = *mut GList;
pub type GTlsDatabase_slistautoptr = *mut GSList;
pub type GTlsDatabase_queueautoptr = *mut GQueue;
pub type GTlsFileDatabase_autoptr = *mut GTlsFileDatabase;
pub type GTlsFileDatabase_listautoptr = *mut GList;
pub type GTlsFileDatabase_slistautoptr = *mut GSList;
pub type GTlsFileDatabase_queueautoptr = *mut GQueue;
pub type GTlsInteraction_autoptr = *mut GTlsInteraction;
pub type GTlsInteraction_listautoptr = *mut GList;
pub type GTlsInteraction_slistautoptr = *mut GSList;
pub type GTlsInteraction_queueautoptr = *mut GQueue;
pub type GTlsPassword_autoptr = *mut GTlsPassword;
pub type GTlsPassword_listautoptr = *mut GList;
pub type GTlsPassword_slistautoptr = *mut GSList;
pub type GTlsPassword_queueautoptr = *mut GQueue;
pub type GTlsServerConnection_autoptr = *mut GTlsServerConnection;
pub type GTlsServerConnection_listautoptr = *mut GList;
pub type GTlsServerConnection_slistautoptr = *mut GSList;
pub type GTlsServerConnection_queueautoptr = *mut GQueue;
pub type GVfs_autoptr = *mut GVfs;
pub type GVfs_listautoptr = *mut GList;
pub type GVfs_slistautoptr = *mut GSList;
pub type GVfs_queueautoptr = *mut GQueue;
pub type GVolume_autoptr = *mut GVolume;
pub type GVolume_listautoptr = *mut GList;
pub type GVolume_slistautoptr = *mut GSList;
pub type GVolume_queueautoptr = *mut GQueue;
pub type GVolumeMonitor_autoptr = *mut GVolumeMonitor;
pub type GVolumeMonitor_listautoptr = *mut GList;
pub type GVolumeMonitor_slistautoptr = *mut GSList;
pub type GVolumeMonitor_queueautoptr = *mut GQueue;
pub type GZlibCompressor_autoptr = *mut GZlibCompressor;
pub type GZlibCompressor_listautoptr = *mut GList;
pub type GZlibCompressor_slistautoptr = *mut GSList;
pub type GZlibCompressor_queueautoptr = *mut GQueue;
pub type GZlibDecompressor_autoptr = *mut GZlibDecompressor;
pub type GZlibDecompressor_listautoptr = *mut GList;
pub type GZlibDecompressor_slistautoptr = *mut GSList;
pub type GZlibDecompressor_queueautoptr = *mut GQueue;
#[doc = " IBusProxy:\n\n An opaque data type representing an IBusProxy."]
pub type IBusProxy = _IBusProxy;
pub type IBusProxyClass = _IBusProxyClass;
#[doc = " IBusProxy:\n\n An opaque data type representing an IBusProxy."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusProxy {
    pub parent: GDBusProxy,
    pub flags: guint32,
    pub own: gboolean,
}
#[test]
fn bindgen_test_layout__IBusProxy() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusProxy> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusProxy>(),
        40usize,
        concat!("Size of: ", stringify!(_IBusProxy))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusProxy>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusProxy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusProxy),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusProxy),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).own) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusProxy),
            "::",
            stringify!(own)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusProxyClass {
    pub parent: GDBusProxyClass,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(proxy: *mut IBusProxy)>,
    pub pdummy: [gpointer; 7usize],
}
#[test]
fn bindgen_test_layout__IBusProxyClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusProxyClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusProxyClass>(),
        472usize,
        concat!("Size of: ", stringify!(_IBusProxyClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusProxyClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusProxyClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusProxyClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusProxyClass),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusProxyClass),
            "::",
            stringify!(pdummy)
        )
    );
}
extern "C" {
    pub fn ibus_proxy_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_proxy_destroy:\n @proxy: An #IBusProxy\n\n Dispose the proxy object. If the dbus connection is alive and the own\n variable above is TRUE (which is the default),\n org.freedesktop.IBus.Service.Destroy method will be called.\n Note that \"destroy\" signal might be emitted when ibus_proxy_destroy is\n called or the underlying dbus connection for the proxy is terminated.\n In the callback of the destroy signal, you might have to call something\n like 'g_object_unref(the_proxy);'."]
    pub fn ibus_proxy_destroy(proxy: *mut IBusProxy);
}
#[doc = " IBusService:\n\n An opaque data type representing an IBusService."]
pub type IBusService = _IBusService;
pub type IBusServiceClass = _IBusServiceClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusServicePrivate {
    _unused: [u8; 0],
}
pub type IBusServicePrivate = _IBusServicePrivate;
#[doc = " IBusService:\n\n An opaque data type representing an IBusService."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusService {
    pub parent: IBusObject,
    pub priv_: *mut IBusServicePrivate,
}
#[test]
fn bindgen_test_layout__IBusService() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusService> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusService>(),
        48usize,
        concat!("Size of: ", stringify!(_IBusService))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusService>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusService))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusService),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusService),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusServiceClass {
    pub parent: IBusObjectClass,
    #[doc = " IBusServiceClass::service_method_call:\n @service: An #IBusService.\n @connection: A dbus connection.\n @sender: A sender.\n @object_path: An object path.\n @interface_name: An interface name.\n @method_name: A method name.\n @parameters: A parameters.\n @invocation: A dbus method invocation.\n\n The ::service_method_call class method is to connect\n GDBusInterfaceMethodCallFunc()."]
    pub service_method_call: ::std::option::Option<
        unsafe extern "C" fn(
            service: *mut IBusService,
            connection: *mut GDBusConnection,
            sender: *const gchar,
            object_path: *const gchar,
            interface_name: *const gchar,
            method_name: *const gchar,
            parameters: *mut GVariant,
            invocation: *mut GDBusMethodInvocation,
        ),
    >,
    #[doc = " IBusServiceClass::service_get_property:\n @service: An #IBusService.\n @connection: A dbus connection.\n @sender: A sender.\n @object_path: An object path.\n @interface_name: An interface name.\n @property_name: A property name.\n @error: Return location for error or %NULL.\n\n The ::service_get_property class method is to connect\n GDBusInterfaceGetPropertyFunc().\n\n Returns: (nullable) (transfer full): A variant."]
    pub service_get_property: ::std::option::Option<
        unsafe extern "C" fn(
            service: *mut IBusService,
            connection: *mut GDBusConnection,
            sender: *const gchar,
            object_path: *const gchar,
            interface_name: *const gchar,
            property_name: *const gchar,
            error: *mut *mut GError,
        ) -> *mut GVariant,
    >,
    #[doc = " IBusServiceClass::service_set_property:\n @service: An #IBusService.\n @connection: A dbus connection.\n @sender: A sender.\n @object_path: An object path.\n @interface_name: An interface name.\n @property_name: An property name.\n @value: An property value.\n @error: Return location for error or %NULL.\n\n The ::service_set_property class method is to connect\n GDBusInterfaceSetPropertyFunc().\n\n Returns: %TRUE if set the value else %FALSE."]
    pub service_set_property: ::std::option::Option<
        unsafe extern "C" fn(
            service: *mut IBusService,
            connection: *mut GDBusConnection,
            sender: *const gchar,
            object_path: *const gchar,
            interface_name: *const gchar,
            property_name: *const gchar,
            value: *mut GVariant,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub interfaces: *mut GArray,
    pub pdummy: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__IBusServiceClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusServiceClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusServiceClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusServiceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusServiceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusServiceClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusServiceClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_method_call) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusServiceClass),
            "::",
            stringify!(service_method_call)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_get_property) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusServiceClass),
            "::",
            stringify!(service_get_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_set_property) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusServiceClass),
            "::",
            stringify!(service_set_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interfaces) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusServiceClass),
            "::",
            stringify!(interfaces)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusServiceClass),
            "::",
            stringify!(pdummy)
        )
    );
}
extern "C" {
    pub fn ibus_service_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_service_new:\n @connection: A GDBusConnection.\n @path: Object path.\n\n Creantes a new #IBusService.\n\n Returns: A newly allocated #IBusService"]
    pub fn ibus_service_new(
        connection: *mut GDBusConnection,
        path: *const gchar,
    ) -> *mut IBusService;
}
extern "C" {
    #[doc = " ibus_service_get_object_path:\n @service: An IBusService.\n\n Gets the object path of an IBusService.\n\n Returns: The object path of @service"]
    pub fn ibus_service_get_object_path(service: *mut IBusService) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_service_get_connection:\n @service: An IBusService.\n\n Gets a connections.\n\n Returns: (transfer none): A #GDBusConnection of an #IBusService instance."]
    pub fn ibus_service_get_connection(service: *mut IBusService) -> *mut GDBusConnection;
}
extern "C" {
    #[doc = " ibus_service_register:\n @service: An IBusService.\n @connection: A GDBusConnection the service will be registered to.\n @error: Return location for error or NULL.\n\n Registers service to a connection.\n\n Returns: %TRUE if the service was registered, %FALSE otherwise."]
    pub fn ibus_service_register(
        service: *mut IBusService,
        connection: *mut GDBusConnection,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_service_unregister:\n @service: An IBusService.\n @connection: A GDBusConnection the service was registered with.\n\n Unregisters service from a connection."]
    pub fn ibus_service_unregister(service: *mut IBusService, connection: *mut GDBusConnection);
}
extern "C" {
    #[doc = " ibus_service_send_signal:\n @service: An IBusService.\n @interface: The interface the signal is emitted from.\n @name: Name of the signal.\n @first_arg_type: Type of first argument.\n @...: Rest of arguments, NULL to mark the end.\n\n Sends signal to all the #IBusConnections of an #IBusService.\n\n Returns: %TRUE if succeed; %FALSE otherwise.\n\n see_also: g_dbus_connection_emit_signal()"]
    pub fn ibus_service_emit_signal(
        service: *mut IBusService,
        dest_bus_name: *const gchar,
        interface_name: *const gchar,
        signal_name: *const gchar,
        parameters: *mut GVariant,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_service_class_add_interfaces:\n @klass: An IBusServiceClass.\n @xml_data: The introspection xml data.\n\n Set the interface introspection information with the service class.\n\n Returns: %TRUE if @xml_data is valid and succeeded to be added;\n          %FALSE otherwise."]
    pub fn ibus_service_class_add_interfaces(
        klass: *mut IBusServiceClass,
        xml_data: *const gchar,
    ) -> gboolean;
}
#[doc = " IBusLookupTable:\n @page_size: number of candidate shown per page.\n @cursor_pos: position index of cursor.\n @cursor_visible: whether the cursor is visible.\n @round: TRUE for lookup table wrap around.\n @orientation: orientation of the table.\n @candidates: Candidate words/phrases.\n @labels: Candidate labels which identify individual candidates in the same page. Default is 1, 2, 3, 4 ...\n\n An IBusLookuptable stores the candidate words or phrases for users to choose from.\n Note that some input methods allow you to select candidate by pressing non-numeric\n keys such as \"asdfghjkl;\".\n Developers of these input methods should change the labels with\n ibus_lookup_table_append_label()."]
pub type IBusLookupTable = _IBusLookupTable;
pub type IBusLookupTableClass = _IBusLookupTableClass;
#[doc = " IBusLookupTable:\n @page_size: number of candidate shown per page.\n @cursor_pos: position index of cursor.\n @cursor_visible: whether the cursor is visible.\n @round: TRUE for lookup table wrap around.\n @orientation: orientation of the table.\n @candidates: Candidate words/phrases.\n @labels: Candidate labels which identify individual candidates in the same page. Default is 1, 2, 3, 4 ...\n\n An IBusLookuptable stores the candidate words or phrases for users to choose from.\n Note that some input methods allow you to select candidate by pressing non-numeric\n keys such as \"asdfghjkl;\".\n Developers of these input methods should change the labels with\n ibus_lookup_table_append_label()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusLookupTable {
    pub parent: IBusSerializable,
    pub page_size: guint,
    pub cursor_pos: guint,
    pub cursor_visible: gboolean,
    pub round: gboolean,
    pub orientation: gint,
    pub candidates: *mut GArray,
    pub labels: *mut GArray,
}
#[test]
fn bindgen_test_layout__IBusLookupTable() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusLookupTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusLookupTable>(),
        88usize,
        concat!("Size of: ", stringify!(_IBusLookupTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusLookupTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusLookupTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusLookupTable),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_size) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusLookupTable),
            "::",
            stringify!(page_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_pos) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusLookupTable),
            "::",
            stringify!(cursor_pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_visible) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusLookupTable),
            "::",
            stringify!(cursor_visible)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).round) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusLookupTable),
            "::",
            stringify!(round)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orientation) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusLookupTable),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).candidates) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusLookupTable),
            "::",
            stringify!(candidates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).labels) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusLookupTable),
            "::",
            stringify!(labels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusLookupTableClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusLookupTableClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusLookupTableClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusLookupTableClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusLookupTableClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusLookupTableClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusLookupTableClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusLookupTableClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_lookup_table_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_lookup_table_new:\n @page_size: number of candidate shown per page, the max value is 16.\n @cursor_pos: position index of cursor.\n @cursor_visible: whether the cursor is visible.\n @round: TRUE for lookup table wrap around.\n\n Craetes a new #IBusLookupTable.\n\n Returns: A newly allocated #IBusLookupTable."]
    pub fn ibus_lookup_table_new(
        page_size: guint,
        cursor_pos: guint,
        cursor_visible: gboolean,
        round: gboolean,
    ) -> *mut IBusLookupTable;
}
extern "C" {
    #[doc = " ibus_lookup_table_append_candidate:\n @table: An IBusLookupTable.\n @text: candidate word/phrase to be appended (in IBusText format).\n\n Append a candidate word/phrase to IBusLookupTable, and increase reference."]
    pub fn ibus_lookup_table_append_candidate(table: *mut IBusLookupTable, text: *mut IBusText);
}
extern "C" {
    #[doc = " ibus_lookup_table_get_number_of_candidates:\n @table: An IBusLookupTable.\n\n Return the number of candidate in the table.\n\n Returns: The number of candidates in the table"]
    pub fn ibus_lookup_table_get_number_of_candidates(table: *mut IBusLookupTable) -> guint;
}
extern "C" {
    #[doc = " ibus_lookup_table_get_candidate:\n @table: An IBusLookupTable.\n @index: Index in the Lookup table.\n\n Return #IBusText at the given index. Borrowed reference.\n\n Returns: (transfer none): IBusText at the given index; NULL if no such\n         #IBusText."]
    pub fn ibus_lookup_table_get_candidate(
        table: *mut IBusLookupTable,
        index: guint,
    ) -> *mut IBusText;
}
extern "C" {
    #[doc = " ibus_lookup_table_append_label:\n @table: An IBusLookupTable.\n @text: A candidate label to be appended (in IBusText format).\n\n Append a candidate word/phrase to IBusLookupTable, and increase reference.\n This function is needed if the input method select candidate with\n non-numeric keys such as \"asdfghjkl;\"."]
    pub fn ibus_lookup_table_append_label(table: *mut IBusLookupTable, text: *mut IBusText);
}
extern "C" {
    #[doc = " ibus_lookup_table_set_label:\n @table: An IBusLookupTable.\n @index: Intex in the Lookup table.\n @text: A candidate label to be appended (in IBusText format).\n\n Append a candidate word/phrase to IBusLookupTable, and increase reference.\n This function is needed if the input method select candidate with\n non-numeric keys such as \"asdfghjkl;\"."]
    pub fn ibus_lookup_table_set_label(
        table: *mut IBusLookupTable,
        index: guint,
        text: *mut IBusText,
    );
}
extern "C" {
    #[doc = " ibus_lookup_table_get_label:\n @table: An IBusLookupTable.\n @index: Index in the Lookup table.\n\n Return #IBusText at the given index. Borrowed reference.\n\n Returns: (transfer none): #IBusText at the given index; %NULL if no such\n         #IBusText."]
    pub fn ibus_lookup_table_get_label(table: *mut IBusLookupTable, index: guint) -> *mut IBusText;
}
extern "C" {
    #[doc = " ibus_lookup_table_set_cursor_pos:\n @table: An IBusLookupTable.\n @cursor_pos: The position of cursor.\n\n Set the cursor position of IBusLookupTable."]
    pub fn ibus_lookup_table_set_cursor_pos(table: *mut IBusLookupTable, cursor_pos: guint);
}
extern "C" {
    #[doc = " ibus_lookup_table_get_cursor_pos:\n @table: An IBusLookupTable.\n\n Gets the cursor position of #IBusLookupTable.\n\n Returns: The position of cursor."]
    pub fn ibus_lookup_table_get_cursor_pos(table: *mut IBusLookupTable) -> guint;
}
extern "C" {
    #[doc = " ibus_lookup_table_set_cursor_visible:\n @table: An IBusLookupTable.\n @visible: Whether to make the cursor of @table visible.\n\n Set whether to make the cursor of an IBusLookupTable visible or not."]
    pub fn ibus_lookup_table_set_cursor_visible(table: *mut IBusLookupTable, visible: gboolean);
}
extern "C" {
    #[doc = " ibus_lookup_table_is_cursor_visible:\n @table: An #IBusLookupTable.\n\n Returns whether the cursor of an #IBusLookupTable is visible.\n\n Returns: Whether the cursor of @table is visible."]
    pub fn ibus_lookup_table_is_cursor_visible(table: *mut IBusLookupTable) -> gboolean;
}
extern "C" {
    #[doc = " ibus_lookup_table_get_cursor_in_page:\n @table: An IBusLookupTable.\n\n Gets the cursor position in current page of #IBusLookupTable.\n\n Returns: The position of cursor in current page."]
    pub fn ibus_lookup_table_get_cursor_in_page(table: *mut IBusLookupTable) -> guint;
}
extern "C" {
    #[doc = " ibus_lookup_table_set_page_size:\n @table: An IBusLookupTable.\n @page_size: number of candidate shown per page.\n\n Set the number of candidate shown per page."]
    pub fn ibus_lookup_table_set_page_size(table: *mut IBusLookupTable, page_size: guint);
}
extern "C" {
    #[doc = " ibus_lookup_table_get_page_size:\n @table: An IBusLookupTable.\n\n Gets the number of candidate shown per page.\n\n Returns: Page size, i.e., number of candidate shown per page.\ndd"]
    pub fn ibus_lookup_table_get_page_size(table: *mut IBusLookupTable) -> guint;
}
extern "C" {
    #[doc = " ibus_lookup_table_set_round:\n @table: An IBusLookupTable.\n @round: Whether to make @table round.\n\n Set whether to make the IBusLookupTable round or not."]
    pub fn ibus_lookup_table_set_round(table: *mut IBusLookupTable, round: gboolean);
}
extern "C" {
    #[doc = " ibus_lookup_table_is_round:\n @table: An IBusLookupTable.\n\n Returns whether the #IBusLookupTable is round.\n\n Returns: Whether the @table is round."]
    pub fn ibus_lookup_table_is_round(table: *mut IBusLookupTable) -> gboolean;
}
extern "C" {
    #[doc = " ibus_lookup_table_set_orientation:\n @table: An IBusLookupTable.\n @orientation: .\n\n Set the orientation."]
    pub fn ibus_lookup_table_set_orientation(table: *mut IBusLookupTable, orientation: gint);
}
extern "C" {
    #[doc = " ibus_lookup_table_get_orientation:\n @table: An IBusLookupTable.\n\n Returns the orientation of the #IBusLookupTable.\n\n Returns: The orientation of the @table."]
    pub fn ibus_lookup_table_get_orientation(table: *mut IBusLookupTable) -> gint;
}
extern "C" {
    #[doc = " ibus_lookup_table_clear:\n @table: An IBusLookupTable.\n\n Clear and remove all candidate from an IBusLookupTable."]
    pub fn ibus_lookup_table_clear(table: *mut IBusLookupTable);
}
extern "C" {
    #[doc = " ibus_lookup_table_page_up:\n @table: An IBusLookupTable.\n\n Go to previous page of an #IBusLookupTable.\n\n It returns FALSE if it is already at the first page,\n unless  <code>table&gt;-round==TRUE</code>, where it will go\n to the last page.\n\n Returns: %TRUE if succeed."]
    pub fn ibus_lookup_table_page_up(table: *mut IBusLookupTable) -> gboolean;
}
extern "C" {
    #[doc = " ibus_lookup_table_page_down:\n @table: An IBusLookupTable.\n\n Go to next page of an #IBusLookupTable.\n\n It returns FALSE if it is already at the last page,\n unless  <code>table&gt;-round==TRUE</code>, where it will go\n to the first page.\n\n Returns: %TRUE if succeed."]
    pub fn ibus_lookup_table_page_down(table: *mut IBusLookupTable) -> gboolean;
}
extern "C" {
    #[doc = " ibus_lookup_table_cursor_up:\n @table: An IBusLookupTable.\n\n Go to previous candidate of an #IBusLookupTable.\n\n It returns FALSE if it is already at the first candidate,\n unless  <code>table&gt;-round==TRUE</code>, where it will go\n to the last candidate.\n\n Returns: %TRUE if succeed."]
    pub fn ibus_lookup_table_cursor_up(table: *mut IBusLookupTable) -> gboolean;
}
extern "C" {
    #[doc = " ibus_lookup_table_cursor_down:\n @table: An IBusLookupTable.\n\n Go to next candidate of an #IBusLookupTable.\n\n It returns FALSE if it is already at the last candidate,\n unless  <code>table&gt;-round==TRUE</code>, where it will go\n to the first candidate.\n\n Returns: %TRUE if succeed."]
    pub fn ibus_lookup_table_cursor_down(table: *mut IBusLookupTable) -> gboolean;
}
pub const IBusPropType_PROP_TYPE_NORMAL: IBusPropType = 0;
pub const IBusPropType_PROP_TYPE_TOGGLE: IBusPropType = 1;
pub const IBusPropType_PROP_TYPE_RADIO: IBusPropType = 2;
pub const IBusPropType_PROP_TYPE_MENU: IBusPropType = 3;
pub const IBusPropType_PROP_TYPE_SEPARATOR: IBusPropType = 4;
#[doc = " IBusPropType:\n @PROP_TYPE_NORMAL: Property is shown as normal text.\n @PROP_TYPE_TOGGLE: Property is shown as a toggle button.\n @PROP_TYPE_RADIO: Property is shown as a radio selection option.\n @PROP_TYPE_MENU: Property is shown as a menu, usually imply it has sub menu\n items.\n @PROP_TYPE_SEPARATOR: A separator for menu.\n\n Type enumeration of IBusProperty."]
pub type IBusPropType = ::std::os::raw::c_uint;
pub const IBusPropState_PROP_STATE_UNCHECKED: IBusPropState = 0;
pub const IBusPropState_PROP_STATE_CHECKED: IBusPropState = 1;
pub const IBusPropState_PROP_STATE_INCONSISTENT: IBusPropState = 2;
#[doc = " IBusPropState:\n @PROP_STATE_UNCHECKED: Property option is unchecked.\n @PROP_STATE_CHECKED: Property option is checked.\n @PROP_STATE_INCONSISTENT: The state is inconsistent with the associated IME\n property.\n\n State of #IBusProperty. The actual effect depends on #IBusPropType of the\n IBusProperty.\n\n <variablelist>\n     <varlistentry>\n         <term>PROP_TYPE_TOGGLE</term>\n         <listitem><para>Emphasized if PROP_STATE_CHECKED, normal otherwise.</para></listitem>\n     </varlistentry>\n     <varlistentry>\n         <term>PROP_TYPE_RADIO</term>\n         <listitem><para>Option checked if PROP_STATE_CHECKED, unchecked otherwise.</para></listitem>\n     </varlistentry>\n </variablelist>\n No effect on other types."]
pub type IBusPropState = ::std::os::raw::c_uint;
#[doc = " IBusProperty:\n UI component for input method engine property."]
pub type IBusProperty = _IBusProperty;
pub type IBusPropertyClass = _IBusPropertyClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusPropertyPrivate {
    _unused: [u8; 0],
}
pub type IBusPropertyPrivate = _IBusPropertyPrivate;
#[doc = " IBusPropList:\n @properties: GArray that holds IBusProperties.\n\n An array of IBusProperties."]
pub type IBusPropList = _IBusPropList;
#[doc = " IBusPropListClass:\n @parent: The parent class.\n\n Class structure for #IBusPropList."]
pub type IBusPropListClass = _IBusPropListClass;
#[doc = " IBusProperty:\n UI component for input method engine property."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusProperty {
    pub parent: IBusSerializable,
    pub priv_: *mut IBusPropertyPrivate,
    pub pdummy: [gpointer; 7usize],
}
#[test]
fn bindgen_test_layout__IBusProperty() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusProperty> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusProperty>(),
        112usize,
        concat!("Size of: ", stringify!(_IBusProperty))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusProperty>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusProperty))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusProperty),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusProperty),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusProperty),
            "::",
            stringify!(pdummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusPropertyClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusPropertyClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusPropertyClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusPropertyClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusPropertyClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusPropertyClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusPropertyClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPropertyClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_property_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_property_new:\n @key: Unique Identity for the #IBusProperty.\n @type: #IBusPropType of #IBusProperty.\n @label: Text shown in UI.\n @icon: (allow-none): Icon file for the #IBusProperty.\n @tooltip: Message shown if mouse hovered the  #IBusProperty.\n @sensitive: Whether the #IBusProperty is sensitive to keyboard and mouse event.\n @visible: Whether the #IBusProperty is visible.\n @state: IBusPropState of #IBusProperty.\n @prop_list: (allow-none): #IBusPropList that contains sub IBusProperties.\n\n Creates a new #IBusProperty.\n\n Returns: A newly allocated #IBusProperty."]
    pub fn ibus_property_new(
        key: *const gchar,
        type_: IBusPropType,
        label: *mut IBusText,
        icon: *const gchar,
        tooltip: *mut IBusText,
        sensitive: gboolean,
        visible: gboolean,
        state: IBusPropState,
        prop_list: *mut IBusPropList,
    ) -> *mut IBusProperty;
}
extern "C" {
    #[doc = " ibus_property_new_varargs:\n @first_property_name: Name of the first property.\n @...: the NULL-terminated arguments of the properties and values.\n\n Creates a new #IBusProperty.\n ibus_property_new_varargs() supports the va_list format.\n name property is required. e.g.\n ibus_property_new_varargs(\"key\", \"TypingMode\", \"type\", PROP_TYPE_MENU, NULL)\n\n Returns: A newly allocated #IBusProperty."]
    pub fn ibus_property_new_varargs(first_property_name: *const gchar, ...) -> *mut IBusProperty;
}
extern "C" {
    #[doc = " ibus_property_get_key:\n @prop: An #IBusProperty.\n\n Get the key of #IBusProperty.\n\n Returns: the key of #IBusProperty. Should not be freed."]
    pub fn ibus_property_get_key(prop: *mut IBusProperty) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_property_get_label:\n @prop: An #IBusProperty.\n\n Get the label of #IBusProperty.\n\n Returns: (transfer none): the label of #IBusProperty. Should not be freed."]
    pub fn ibus_property_get_label(prop: *mut IBusProperty) -> *mut IBusText;
}
extern "C" {
    #[doc = " ibus_property_set_label:\n @prop: An #IBusProperty.\n @label: Text shown in UI.\n\n Set the label of #IBusProperty."]
    pub fn ibus_property_set_label(prop: *mut IBusProperty, label: *mut IBusText);
}
extern "C" {
    #[doc = " ibus_property_get_symbol:\n @prop: An #IBusProperty.\n\n Get the symbol of #IBusProperty.\n\n Returns: (transfer none): the symbol of #IBusProperty. Should not be freed."]
    pub fn ibus_property_get_symbol(prop: *mut IBusProperty) -> *mut IBusText;
}
extern "C" {
    #[doc = " ibus_property_set_symbol:\n @prop: An #IBusProperty.\n @symbol: Text shown in UI.\n\n Set the symbol of #IBusProperty."]
    pub fn ibus_property_set_symbol(prop: *mut IBusProperty, symbol: *mut IBusText);
}
extern "C" {
    #[doc = " ibus_property_get_icon:\n @prop: An #IBusProperty.\n\n Get the icon of #IBusProperty.\n\n Returns: the icon of #IBusProperty. Should not be freed."]
    pub fn ibus_property_get_icon(prop: *mut IBusProperty) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_property_set_icon:\n @prop: An #IBusProperty.\n @icon: Icon shown in UI. It could be a full path of an icon file or an icon name.\n\n Set the icon of #IBusProperty."]
    pub fn ibus_property_set_icon(prop: *mut IBusProperty, icon: *const gchar);
}
extern "C" {
    #[doc = " ibus_property_get_tooltip:\n @prop: An #IBusProperty.\n\n Get the tooltip of #IBusProperty.\n\n Returns: (transfer none): the tooltip of #IBusProperty. Should not be freed."]
    pub fn ibus_property_get_tooltip(prop: *mut IBusProperty) -> *mut IBusText;
}
extern "C" {
    #[doc = " ibus_property_set_tooltip:\n @prop: An #IBusProperty.\n @tooltip: Text of the tooltip.\n\n Set the tooltip of #IBusProperty."]
    pub fn ibus_property_set_tooltip(prop: *mut IBusProperty, tooltip: *mut IBusText);
}
extern "C" {
    #[doc = " ibus_property_get_sensitive:\n @prop: An #IBusProperty.\n\n Get the sensitive of #IBusProperty.\n\n Returns: the sensitive of #IBusProperty."]
    pub fn ibus_property_get_sensitive(prop: *mut IBusProperty) -> gboolean;
}
extern "C" {
    #[doc = " ibus_property_set_sensitive:\n @prop: An #IBusProperty.\n @sensitive: Whether the #IBusProperty is sensitive.\n\n Set whether the #IBusProperty is sensitive."]
    pub fn ibus_property_set_sensitive(prop: *mut IBusProperty, sensitive: gboolean);
}
extern "C" {
    #[doc = " ibus_property_get_visible:\n @prop: An #IBusProperty.\n\n Get the visible of #IBusProperty.\n\n Returns: the visible of #IBusProperty."]
    pub fn ibus_property_get_visible(prop: *mut IBusProperty) -> gboolean;
}
extern "C" {
    #[doc = " ibus_property_set_visible:\n @prop: An #IBusProperty.\n @visible: Whether the #IBusProperty is visible.\n\n Set whether the #IBusProperty is visible."]
    pub fn ibus_property_set_visible(prop: *mut IBusProperty, visible: gboolean);
}
extern "C" {
    #[doc = " ibus_property_get_property_type:\n @prop: An #IBusProperty.\n\n Get the type of #IBusProperty.\n\n Returns: the type of #IBusProperty."]
    pub fn ibus_property_get_prop_type(prop: *mut IBusProperty) -> IBusPropType;
}
extern "C" {
    #[doc = " ibus_property_get_state:\n @prop: An #IBusProperty.\n\n Get the state of #IBusProperty.\n\n Returns: the state of #IBusProperty."]
    pub fn ibus_property_get_state(prop: *mut IBusProperty) -> IBusPropState;
}
extern "C" {
    #[doc = " ibus_property_set_state:\n @prop: An #IBusProperty.\n @state: The state of the #IBusProperty.\n\n Set the state of the #IBusProperty."]
    pub fn ibus_property_set_state(prop: *mut IBusProperty, state: IBusPropState);
}
extern "C" {
    #[doc = " ibus_property_get_sub_props:\n @prop: An #IBusProperty.\n\n Get the IBusPropList of #IBusProperty.\n\n Returns: (transfer none): the IBusPropList of #IBusProperty.\n     Should not be freed."]
    pub fn ibus_property_get_sub_props(prop: *mut IBusProperty) -> *mut IBusPropList;
}
extern "C" {
    #[doc = " ibus_property_set_sub_props:\n @prop: An #IBusProperty.\n @prop_list: #IBusPropList that contains sub IBusProperties.\n\n Set the sub IBusProperties."]
    pub fn ibus_property_set_sub_props(prop: *mut IBusProperty, prop_list: *mut IBusPropList);
}
extern "C" {
    #[doc = " ibus_property_update:\n @prop: An #IBusProperty.\n @prop_update: #IBusPropList that contains sub IBusProperties.\n\n Update the content of an #IBusProperty.\n #IBusProperty @prop_update can either be sub-property of @prop,\n or holds new values for @prop.\n\n Returns: TRUE if update succeeded; FALSE otherwise."]
    pub fn ibus_property_update(
        prop: *mut IBusProperty,
        prop_update: *mut IBusProperty,
    ) -> gboolean;
}
#[doc = " IBusPropList:\n @properties: GArray that holds IBusProperties.\n\n An array of IBusProperties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusPropList {
    pub parent: IBusSerializable,
    pub properties: *mut GArray,
}
#[test]
fn bindgen_test_layout__IBusPropList() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusPropList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusPropList>(),
        56usize,
        concat!("Size of: ", stringify!(_IBusPropList))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusPropList>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusPropList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPropList),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPropList),
            "::",
            stringify!(properties)
        )
    );
}
#[doc = " IBusPropListClass:\n @parent: The parent class.\n\n Class structure for #IBusPropList."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusPropListClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusPropListClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusPropListClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusPropListClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusPropListClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusPropListClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusPropListClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPropListClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_prop_list_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_prop_list_new:\n\n Create a new #IBusPropList.\n\n Returns: A newly allocated #IBusPropList."]
    pub fn ibus_prop_list_new() -> *mut IBusPropList;
}
extern "C" {
    #[doc = " ibus_prop_list_append:\n @prop_list: An IBusPropList.\n @prop: IBusProperty to be append to @prop_list.\n\n Append an IBusProperty to an IBusPropList, and increase reference."]
    pub fn ibus_prop_list_append(prop_list: *mut IBusPropList, prop: *mut IBusProperty);
}
extern "C" {
    #[doc = " ibus_prop_list_get:\n @prop_list: An IBusPropList.\n @index: Index of an IBusPropList.\n\n Gets #IBusProperty at given index. Borrowed reference.\n\n Returns: (transfer none): #IBusProperty at given index, %NULL if no such\n     #IBusProperty."]
    pub fn ibus_prop_list_get(prop_list: *mut IBusPropList, index: guint) -> *mut IBusProperty;
}
extern "C" {
    #[doc = " ibus_prop_list_update_property:\n @prop_list: An IBusPropList.\n @prop: IBusProperty to be update.\n\n Update an IBusProperty in IBusPropList.\n\n Returns: %TRUE if succeeded, %FALSE otherwise."]
    pub fn ibus_prop_list_update_property(
        prop_list: *mut IBusPropList,
        prop: *mut IBusProperty,
    ) -> gboolean;
}
#[doc = " IBusEngine:\n @enabled: Whether the engine is enabled.\n @has_focus: Whether the engine has focus.\n @cursor_area: Area of cursor.\n @client_capabilities: IBusCapabilite (client capabilities) flags.\n\n IBusEngine properties."]
pub type IBusEngine = _IBusEngine;
pub type IBusEngineClass = _IBusEngineClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusEnginePrivate {
    _unused: [u8; 0],
}
pub type IBusEnginePrivate = _IBusEnginePrivate;
#[doc = " IBusEngine:\n @enabled: Whether the engine is enabled.\n @has_focus: Whether the engine has focus.\n @cursor_area: Area of cursor.\n @client_capabilities: IBusCapabilite (client capabilities) flags.\n\n IBusEngine properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusEngine {
    pub parent: IBusService,
    pub priv_: *mut IBusEnginePrivate,
    pub enabled: gboolean,
    pub has_focus: gboolean,
    pub cursor_area: IBusRectangle,
    pub client_capabilities: guint,
}
#[test]
fn bindgen_test_layout__IBusEngine() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusEngine> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusEngine>(),
        88usize,
        concat!("Size of: ", stringify!(_IBusEngine))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusEngine>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusEngine))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngine),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngine),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngine),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_focus) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngine),
            "::",
            stringify!(has_focus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_area) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngine),
            "::",
            stringify!(cursor_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client_capabilities) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngine),
            "::",
            stringify!(client_capabilities)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusEngineClass {
    pub parent: IBusServiceClass,
    pub process_key_event: ::std::option::Option<
        unsafe extern "C" fn(
            engine: *mut IBusEngine,
            keyval: guint,
            keycode: guint,
            state: guint,
        ) -> gboolean,
    >,
    pub focus_in: ::std::option::Option<unsafe extern "C" fn(engine: *mut IBusEngine)>,
    pub focus_out: ::std::option::Option<unsafe extern "C" fn(engine: *mut IBusEngine)>,
    pub reset: ::std::option::Option<unsafe extern "C" fn(engine: *mut IBusEngine)>,
    pub enable: ::std::option::Option<unsafe extern "C" fn(engine: *mut IBusEngine)>,
    pub disable: ::std::option::Option<unsafe extern "C" fn(engine: *mut IBusEngine)>,
    pub set_cursor_location: ::std::option::Option<
        unsafe extern "C" fn(engine: *mut IBusEngine, x: gint, y: gint, w: gint, h: gint),
    >,
    pub set_capabilities:
        ::std::option::Option<unsafe extern "C" fn(engine: *mut IBusEngine, caps: guint)>,
    pub page_up: ::std::option::Option<unsafe extern "C" fn(engine: *mut IBusEngine)>,
    pub page_down: ::std::option::Option<unsafe extern "C" fn(engine: *mut IBusEngine)>,
    pub cursor_up: ::std::option::Option<unsafe extern "C" fn(engine: *mut IBusEngine)>,
    pub cursor_down: ::std::option::Option<unsafe extern "C" fn(engine: *mut IBusEngine)>,
    pub property_activate: ::std::option::Option<
        unsafe extern "C" fn(engine: *mut IBusEngine, prop_name: *const gchar, prop_state: guint),
    >,
    pub property_show: ::std::option::Option<
        unsafe extern "C" fn(engine: *mut IBusEngine, prop_name: *const gchar),
    >,
    pub property_hide: ::std::option::Option<
        unsafe extern "C" fn(engine: *mut IBusEngine, prop_name: *const gchar),
    >,
    pub candidate_clicked: ::std::option::Option<
        unsafe extern "C" fn(engine: *mut IBusEngine, index: guint, button: guint, state: guint),
    >,
    pub set_surrounding_text: ::std::option::Option<
        unsafe extern "C" fn(
            engine: *mut IBusEngine,
            text: *mut IBusText,
            cursor_index: guint,
            anchor_pos: guint,
        ),
    >,
    pub process_hand_writing_event: ::std::option::Option<
        unsafe extern "C" fn(
            engine: *mut IBusEngine,
            coordinates: *const gdouble,
            coordinates_len: guint,
        ),
    >,
    pub cancel_hand_writing:
        ::std::option::Option<unsafe extern "C" fn(engine: *mut IBusEngine, n_strokes: guint)>,
    pub set_content_type: ::std::option::Option<
        unsafe extern "C" fn(engine: *mut IBusEngine, purpose: guint, hints: guint),
    >,
    pub focus_in_id: ::std::option::Option<
        unsafe extern "C" fn(
            engine: *mut IBusEngine,
            object_path: *const gchar,
            client: *const gchar,
        ),
    >,
    pub focus_out_id: ::std::option::Option<
        unsafe extern "C" fn(engine: *mut IBusEngine, object_path: *const gchar),
    >,
    pub pdummy: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__IBusEngineClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusEngineClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusEngineClass>(),
        456usize,
        concat!("Size of: ", stringify!(_IBusEngineClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusEngineClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusEngineClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process_key_event) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(process_key_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).focus_in) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(focus_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).focus_out) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(focus_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(disable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_cursor_location) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(set_cursor_location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_capabilities) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(set_capabilities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_up) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(page_up)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_down) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(page_down)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_up) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(cursor_up)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_down) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(cursor_down)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_activate) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(property_activate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_show) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(property_show)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_hide) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(property_hide)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).candidate_clicked) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(candidate_clicked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_surrounding_text) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(set_surrounding_text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process_hand_writing_event) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(process_hand_writing_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancel_hand_writing) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(cancel_hand_writing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_content_type) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(set_content_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).focus_in_id) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(focus_in_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).focus_out_id) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(focus_out_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineClass),
            "::",
            stringify!(pdummy)
        )
    );
}
extern "C" {
    pub fn ibus_engine_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_engine_new:\n @engine_name: Name of the IBusObject.\n @object_path: Path for IBusService.\n @connection: An opened GDBusConnection.\n\n Create a new #IBusEngine.\n\n Returns: A newly allocated IBusEngine."]
    pub fn ibus_engine_new(
        engine_name: *const gchar,
        object_path: *const gchar,
        connection: *mut GDBusConnection,
    ) -> *mut IBusEngine;
}
extern "C" {
    #[doc = " ibus_engine_new_with_type:\n @engine_type: GType of #IBusEngine.\n @engine_name: Name of the IBusObject.\n @object_path: Path for IBusService.\n @connection: An opened GDBusConnection.\n\n Create a new #IBusEngine.\n\n Returns: A newly allocated IBusEngine."]
    pub fn ibus_engine_new_with_type(
        engine_type: GType,
        engine_name: *const gchar,
        object_path: *const gchar,
        connection: *mut GDBusConnection,
    ) -> *mut IBusEngine;
}
extern "C" {
    #[doc = " ibus_engine_commit_text:\n @engine: An IBusEngine.\n @text: String commit to IBusEngine.\n\n Commit output of input method to IBus client.\n\n (Note: The text object will be released, if it is floating.\n  If caller want to keep the object, caller should make the object\n  sink by g_object_ref_sink.)"]
    pub fn ibus_engine_commit_text(engine: *mut IBusEngine, text: *mut IBusText);
}
extern "C" {
    #[doc = " ibus_engine_update_preedit_text:\n @engine: An IBusEngine.\n @text: Update content.\n @cursor_pos: Current position of cursor\n @visible: Whether the pre-edit buffer is visible.\n\n Update the pre-edit buffer.\n\n (Note: The text object will be released, if it is floating.\n  If caller want to keep the object, caller should make the object\n  sink by g_object_ref_sink.)"]
    pub fn ibus_engine_update_preedit_text(
        engine: *mut IBusEngine,
        text: *mut IBusText,
        cursor_pos: guint,
        visible: gboolean,
    );
}
extern "C" {
    #[doc = " ibus_engine_update_preedit_text_with_mode:\n @engine: An IBusEngine.\n @text: Update content.\n @cursor_pos: Current position of cursor\n @visible: Whether the pre-edit buffer is visible.\n @mode: Pre-edit commit mode when the focus is lost.\n\n Update the pre-edit buffer with commit mode. Similar to\n ibus_engine_update_preedit_text(), this function allows users to specify\n the behavior on focus out when the pre-edit buffer is visible.\n\n If @mode is IBUS_ENGINE_PREEDIT_COMMIT, contents of the pre-edit buffer\n will be committed and cleared.\n If @mode is IBUS_ENGINE_PREEDIT_CLEAR, contents of the pre-edit buffer\n will be cleared only.\n\n (Note: The text object will be released, if it is floating.\n  If caller want to keep the object, caller should make the object\n  sink by g_object_ref_sink.)"]
    pub fn ibus_engine_update_preedit_text_with_mode(
        engine: *mut IBusEngine,
        text: *mut IBusText,
        cursor_pos: guint,
        visible: gboolean,
        mode: IBusPreeditFocusMode,
    );
}
extern "C" {
    #[doc = " ibus_engine_show_preedit_text:\n @engine: An IBusEngine.\n\n Show the pre-edit buffer."]
    pub fn ibus_engine_show_preedit_text(engine: *mut IBusEngine);
}
extern "C" {
    #[doc = " ibus_engine_hide_preedit_text:\n @engine: An IBusEngine.\n\n Hide the pre-edit buffer."]
    pub fn ibus_engine_hide_preedit_text(engine: *mut IBusEngine);
}
extern "C" {
    #[doc = " ibus_engine_update_auxiliary_text:\n @engine: An IBusEngine.\n @text: Update content.\n @visible: Whether the auxiliary text bar is visible.\n\n Update the auxiliary bar.\n\n (Note: The text object will be released, if it is floating.\n  If caller want to keep the object, caller should make the object\n  sink by g_object_ref_sink.)"]
    pub fn ibus_engine_update_auxiliary_text(
        engine: *mut IBusEngine,
        text: *mut IBusText,
        visible: gboolean,
    );
}
extern "C" {
    #[doc = " ibus_engine_show_auxiliary_text:\n @engine: An IBusEngine.\n\n Show the auxiliary bar."]
    pub fn ibus_engine_show_auxiliary_text(engine: *mut IBusEngine);
}
extern "C" {
    #[doc = " ibus_engine_hide_auxiliary_text:\n @engine: An IBusEngine.\n\n Hide the auxiliary bar."]
    pub fn ibus_engine_hide_auxiliary_text(engine: *mut IBusEngine);
}
extern "C" {
    #[doc = " ibus_engine_update_lookup_table:\n @engine: An IBusEngine.\n @lookup_table: An lookup_table.\n @visible: Whether the lookup_table is visible.\n\n Update the lookup table.\n\n (Note: The table object will be released, if it is floating.\n  If caller want to keep the object, caller should make the object\n  sink by g_object_ref_sink.)"]
    pub fn ibus_engine_update_lookup_table(
        engine: *mut IBusEngine,
        lookup_table: *mut IBusLookupTable,
        visible: gboolean,
    );
}
extern "C" {
    #[doc = " ibus_engine_update_lookup_table_fast:\n @engine: An IBusEngine.\n @lookup_table: An lookup_table.\n @visible: Whether the lookup_table is visible.\n\n Fast update for big lookup table.\n\n If size of lookup table is not over table page size *4,\n then it calls ibus_engine_update_lookup_table().\n\n (Note: The table object will be released, if it is floating.\n  If caller want to keep the object, caller should make the object\n  sink by g_object_ref_sink.)"]
    pub fn ibus_engine_update_lookup_table_fast(
        engine: *mut IBusEngine,
        lookup_table: *mut IBusLookupTable,
        visible: gboolean,
    );
}
extern "C" {
    #[doc = " ibus_engine_show_lookup_table:\n @engine: An IBusEngine.\n\n Show the lookup table."]
    pub fn ibus_engine_show_lookup_table(engine: *mut IBusEngine);
}
extern "C" {
    #[doc = " ibus_engine_hide_lookup_table:\n @engine: An IBusEngine.\n\n Hide the lookup table."]
    pub fn ibus_engine_hide_lookup_table(engine: *mut IBusEngine);
}
extern "C" {
    #[doc = " ibus_engine_forward_key_event:\n @engine: An IBusEngine.\n @keyval: KeySym.\n @keycode: keyboard scancode.\n @state: Key modifier flags.\n\n Forward the key event."]
    pub fn ibus_engine_forward_key_event(
        engine: *mut IBusEngine,
        keyval: guint,
        keycode: guint,
        state: guint,
    );
}
extern "C" {
    #[doc = " ibus_engine_register_properties:\n @engine: An IBusEngine.\n @prop_list: Property List.\n\n Register and show properties in language bar.\n\n (Note: The prop_list object will be released, if it is floating.\n  If caller want to keep the object, caller should make the object\n  sink by g_object_ref_sink.)"]
    pub fn ibus_engine_register_properties(engine: *mut IBusEngine, prop_list: *mut IBusPropList);
}
extern "C" {
    #[doc = " ibus_engine_update_property:\n @engine: An IBusEngine.\n @prop: IBusProperty to be updated.\n\n Update the state displayed in language bar.\n\n (Note: The prop object will be released, if it is floating.\n  If caller want to keep the object, caller should make the object\n  sink by g_object_ref_sink.)"]
    pub fn ibus_engine_update_property(engine: *mut IBusEngine, prop: *mut IBusProperty);
}
extern "C" {
    #[doc = " ibus_engine_delete_surrounding_text:\n @engine: An IBusEngine.\n @offset: The offset of the first char.\n @nchars: Number of chars to be deleted.\n\n Delete surrounding text."]
    pub fn ibus_engine_delete_surrounding_text(
        engine: *mut IBusEngine,
        offset: gint,
        nchars: guint,
    );
}
extern "C" {
    #[doc = " ibus_engine_get_surrounding_text:\n @engine: An IBusEngine.\n @text: (out) (transfer none) (allow-none): Location to store surrounding text.\n @cursor_pos: (out) (allow-none): Cursor position in characters in @text.\n @anchor_pos: (out) (allow-none): Anchor position of selection in @text.\n\n Get surrounding text.\n\n It is also used to tell the input-context that the engine will\n utilize surrounding-text.  In that case, it must be called in\n #IBusEngine::enable handler, with both @text and @cursor set to\n %NULL.\n\n See also: #IBusEngine::set-surrounding-text"]
    pub fn ibus_engine_get_surrounding_text(
        engine: *mut IBusEngine,
        text: *mut *mut IBusText,
        cursor_pos: *mut guint,
        anchor_pos: *mut guint,
    );
}
extern "C" {
    #[doc = " ibus_engine_get_content_type:\n @engine: An #IBusEngine.\n @purpose: (out) (allow-none): Primary purpose of the input context.\n @hints: (out) (allow-none): Hints that augument @purpose.\n\n Get content-type (primary purpose and hints) of the current input\n context.\n\n See also: #IBusEngine::set-content-type"]
    pub fn ibus_engine_get_content_type(
        engine: *mut IBusEngine,
        purpose: *mut guint,
        hints: *mut guint,
    );
}
extern "C" {
    #[doc = " ibus_engine_get_name:\n @engine: An IBusEngine.\n\n Return the name of #IBusEngine.\n\n Returns: Name of #IBusEngine."]
    pub fn ibus_engine_get_name(engine: *mut IBusEngine) -> *const gchar;
}
#[doc = " IBusFactory:\n\n An opaque data type representing an IBusFactory."]
pub type IBusFactory = _IBusFactory;
pub type IBusFactoryClass = _IBusFactoryClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusFactoryPrivate {
    _unused: [u8; 0],
}
pub type IBusFactoryPrivate = _IBusFactoryPrivate;
#[doc = " IBusFactory:\n\n An opaque data type representing an IBusFactory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusFactory {
    pub parent: IBusService,
    pub priv_: *mut IBusFactoryPrivate,
}
#[test]
fn bindgen_test_layout__IBusFactory() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusFactory> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusFactory>(),
        56usize,
        concat!("Size of: ", stringify!(_IBusFactory))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusFactory>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusFactory))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusFactory),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusFactory),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusFactoryClass {
    pub parent: IBusServiceClass,
    pub create_engine: ::std::option::Option<
        unsafe extern "C" fn(
            factory: *mut IBusFactory,
            engine_name: *const gchar,
        ) -> *mut IBusEngine,
    >,
    pub pdummy: [gpointer; 7usize],
}
#[test]
fn bindgen_test_layout__IBusFactoryClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusFactoryClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusFactoryClass>(),
        328usize,
        concat!("Size of: ", stringify!(_IBusFactoryClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusFactoryClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusFactoryClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusFactoryClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).create_engine) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusFactoryClass),
            "::",
            stringify!(create_engine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusFactoryClass),
            "::",
            stringify!(pdummy)
        )
    );
}
extern "C" {
    #[doc = " ibus_factory_info_get_type:\n\n Gets GType of IBus factory information.\n\n Returns: GType of IBus factory information."]
    pub fn ibus_factory_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_factory_new:\n @connection: An GDBusConnection.\n\n Creates a new #IBusFactory.\n\n Returns: A newly allocated #IBusFactory."]
    pub fn ibus_factory_new(connection: *mut GDBusConnection) -> *mut IBusFactory;
}
extern "C" {
    #[doc = " ibus_factory_add_engine:\n @factory: An IBusFactory.\n @engine_name: Name of an engine.\n @engine_type: GType of an engine.\n\n Add an engine to the factory."]
    pub fn ibus_factory_add_engine(
        factory: *mut IBusFactory,
        engine_name: *const gchar,
        engine_type: GType,
    );
}
extern "C" {
    #[doc = " ibus_factory_create_engine:\n @factory: An #IBusFactory.\n @engine_name: Name of an engine.\n\n Creates an #IBusEngine with @engine_name.\n\n Returns: (transfer full): #IBusEngine with @engine_name."]
    pub fn ibus_factory_create_engine(
        factory: *mut IBusFactory,
        engine_name: *const gchar,
    ) -> *mut IBusEngine;
}
#[doc = " IBusEngineSimple:\n\n IBusEngineSimple properties."]
pub type IBusEngineSimple = _IBusEngineSimple;
pub type IBusEngineSimpleClass = _IBusEngineSimpleClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusEngineSimplePrivate {
    _unused: [u8; 0],
}
pub type IBusEngineSimplePrivate = _IBusEngineSimplePrivate;
#[doc = " IBusEngineSimple:\n\n IBusEngineSimple properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusEngineSimple {
    pub parent: IBusEngine,
    pub priv_: *mut IBusEngineSimplePrivate,
}
#[test]
fn bindgen_test_layout__IBusEngineSimple() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusEngineSimple> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusEngineSimple>(),
        96usize,
        concat!("Size of: ", stringify!(_IBusEngineSimple))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusEngineSimple>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusEngineSimple))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineSimple),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineSimple),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusEngineSimpleClass {
    pub parent: IBusEngineClass,
    pub pdummy: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__IBusEngineSimpleClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusEngineSimpleClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusEngineSimpleClass>(),
        520usize,
        concat!("Size of: ", stringify!(_IBusEngineSimpleClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusEngineSimpleClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusEngineSimpleClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineSimpleClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineSimpleClass),
            "::",
            stringify!(pdummy)
        )
    );
}
extern "C" {
    pub static IBUS_COMPOSE_IGNORE_KEYLIST: [guint16; 16usize];
}
extern "C" {
    pub fn ibus_engine_simple_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_engine_simple_add_table:\n @simple: An IBusEngineSimple.\n @data: (element-type guint16) (array): The table which must be available\n      during the whole life of the simple engine.\n @max_seq_len: Maximum length of a sequence in the table (cannot be greater\n      than %IBUS_MAX_COMPOSE_LEN)\n @n_seqs: number of sequences in the table\n\n Adds an additional table to search to the engine. Each row of the table\n consists of max_seq_len key symbols followed by two guint16 interpreted as\n the high and low words of a gunicode value. Tables are searched starting from\n the last added.\n\n The table must be sorted in dictionary order on the numeric value of the key\n symbol fields. (Values beyond the length of the sequence should be zero.)"]
    pub fn ibus_engine_simple_add_table(
        simple: *mut IBusEngineSimple,
        data: *const guint16,
        max_seq_len: gint,
        n_seqs: gint,
    );
}
extern "C" {
    #[doc = " ibus_engine_simple_add_table_by_locale:\n @simple: An IBusEngineSimple.\n @locale: (allow-none): The locale name. If the locale is %NULL,\n                        the current locale is used.\n\n Call ibus_engine_simple_add_table() internally by locale.\n\n Returns: %TRUE if the @locale is matched to the table."]
    pub fn ibus_engine_simple_add_table_by_locale(
        simple: *mut IBusEngineSimple,
        locale: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_engine_simple_add_compose_file:\n @simple: An IBusEngineSimple.\n @file: The compose file.\n\n Call ibus_engine_simple_add_table() internally by locale.\n\n Returns: %TRUE if the @file is loaded."]
    pub fn ibus_engine_simple_add_compose_file(
        simple: *mut IBusEngineSimple,
        file: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn ibus_error_quark() -> GQuark;
}
#[doc = " IBusXML:\n @name: Name of XML tag.\n @text: Text enclosed by XML start tag and end tag. i.e. <tag>text</tag>.\n @attributes: Attributes of the XML node.\n @sub_nodes: Children node of this XML node.\n\n A data type representing an XML node."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IBusXML {
    pub name: *mut gchar,
    pub text: *mut gchar,
    pub attributes: *mut *mut gchar,
    pub sub_nodes: *mut GList,
}
#[test]
fn bindgen_test_layout_IBusXML() {
    const UNINIT: ::std::mem::MaybeUninit<IBusXML> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<IBusXML>(),
        32usize,
        concat!("Size of: ", stringify!(IBusXML))
    );
    assert_eq!(
        ::std::mem::align_of::<IBusXML>(),
        8usize,
        concat!("Alignment of ", stringify!(IBusXML))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IBusXML),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IBusXML),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IBusXML),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sub_nodes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IBusXML),
            "::",
            stringify!(sub_nodes)
        )
    );
}
extern "C" {
    pub fn ibus_xml_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_xml_copy:\n @node: Root node of an XML tree.\n\n Creates a copy of @node, which should be freed with\n ibus_xml_free(). Primarily used by language bindings,\n not that useful otherwise (since @node can just be copied\n by assignment in C).\n\n Returns: the newly allocated #IBusXML, which should\n          be freed with ibus_xml_free(), or %NULL\n          if @node was %NULL."]
    pub fn ibus_xml_copy(node: *const IBusXML) -> *mut IBusXML;
}
extern "C" {
    #[doc = " ibus_xml_parse_file:\n @name: File name to be parsed.\n\n Parse an XML file and return a corresponding XML tree.\n\n Returns: Root node of parsed XML tree."]
    pub fn ibus_xml_parse_file(name: *const gchar) -> *mut IBusXML;
}
extern "C" {
    #[doc = " ibus_xml_parse_buffer:\n @buffer: Buffer to be parsed.\n\n Parse a string buffer which contains an XML-formatted string,\n and return a corresponding XML tree.\n\n Returns: Root node of parsed XML tree."]
    pub fn ibus_xml_parse_buffer(buffer: *const gchar) -> *mut IBusXML;
}
extern "C" {
    #[doc = " ibus_xml_free:\n @node: Root node of an XML tree.\n\n Free an XML tree."]
    pub fn ibus_xml_free(node: *mut IBusXML);
}
extern "C" {
    #[doc = " ibus_xml_output:\n @node: Root node of an XML tree.\n @output: GString which stores the output.\n\n Output an XML tree to a GString."]
    pub fn ibus_xml_output(node: *const IBusXML, output: *mut GString);
}
#[doc = " IBusEngineDesc:\n\n Input method engine description data.\n You can get extended values with g_object_get_properties."]
pub type IBusEngineDesc = _IBusEngineDesc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusEngineDescPrivate {
    _unused: [u8; 0],
}
pub type IBusEngineDescPrivate = _IBusEngineDescPrivate;
pub type IBusEngineDescClass = _IBusEngineDescClass;
#[doc = " IBusEngineDesc:\n\n Input method engine description data.\n You can get extended values with g_object_get_properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusEngineDesc {
    pub parent: IBusSerializable,
    pub priv_: *mut IBusEngineDescPrivate,
}
#[test]
fn bindgen_test_layout__IBusEngineDesc() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusEngineDesc> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusEngineDesc>(),
        56usize,
        concat!("Size of: ", stringify!(_IBusEngineDesc))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusEngineDesc>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusEngineDesc))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineDesc),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineDesc),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusEngineDescClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusEngineDescClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusEngineDescClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusEngineDescClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusEngineDescClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusEngineDescClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusEngineDescClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEngineDescClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_engine_desc_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_engine_desc_new:\n @name: Name of the engine.\n @longname: Long name of the input method engine.\n @description: Input method engine description.\n @language: Language (e.g. zh, jp) supported by this input method engine.\n @license: License of the input method engine.\n @author: Author of the input method engine.\n @icon: Icon file of this engine.\n @layout: Keyboard layout\n\n Creates a new #IBusEngineDesc.\n If layout is \"default\", the engine inherits the current layout and\n does not change the layout. The layouts \"default\" and \"\" are same.\n E.g. If you switch JP XKB engine and an input method engine (IME),\n the IME inherits the JP layout.\n\n Returns: A newly allocated IBusEngineDesc."]
    pub fn ibus_engine_desc_new(
        name: *const gchar,
        longname: *const gchar,
        description: *const gchar,
        language: *const gchar,
        license: *const gchar,
        author: *const gchar,
        icon: *const gchar,
        layout: *const gchar,
    ) -> *mut IBusEngineDesc;
}
extern "C" {
    #[doc = " ibus_engine_desc_new_varargs:\n @first_property_name: Name of the first property.\n @...: the NULL-terminated arguments of the properties and values.\n\n Creates a new #IBusEngineDesc.\n ibus_engine_desc_new_varargs() supports the va_list format.\n name property is required. e.g.\n ibus_engine_desc_new_varargs(\"name\", \"ibus-foo\", \"language\", \"us\", NULL)\n If layout is \"default\", the engine inherits the current layout and\n does not change the layout. The layouts \"default\" and \"\" are same.\n E.g. If you switch JP XKB engine and an input method engine (IME),\n the IME inherits the JP layout.\n\n Returns: A newly allocated IBusEngineDesc."]
    pub fn ibus_engine_desc_new_varargs(
        first_property_name: *const gchar,
        ...
    ) -> *mut IBusEngineDesc;
}
extern "C" {
    #[doc = " ibus_engine_desc_new_from_xml_node:\n @node: An XML node\n\n Creates a new IBusEngineDesc from an XML node.\n <note><para>This function is called by ibus_component_new_from_file(),\n  so developers normally do not need to call it directly.\n </para></note>\n\n Returns: A newly allocated IBusEngineDesc that contains description from\n @node."]
    pub fn ibus_engine_desc_new_from_xml_node(node: *mut IBusXML) -> *mut IBusEngineDesc;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_name:\n @info: An IBusEngineDesc\n\n Gets the name property in IBusEngineDesc. It should not be freed.\n\n Returns: name property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_name(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_longname:\n @info: An IBusEngineDesc\n\n Gets the longname property in IBusEngineDesc. It should not be freed.\n\n Returns: longname property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_longname(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_description:\n @info: An IBusEngineDesc\n\n Gets the description property in IBusEngineDesc. It should not be freed.\n\n Returns: description property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_description(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_language:\n @info: An IBusEngineDesc\n\n Gets the language property in IBusEngineDesc. It should not be freed.\n\n Returns: language property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_language(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_license:\n @info: An IBusEngineDesc\n\n Gets the license property in IBusEngineDesc. It should not be freed.\n\n Returns: license property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_license(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_author:\n @info: An IBusEngineDesc\n\n Gets the author property in IBusEngineDesc. It should not be freed.\n\n Returns: author property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_author(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_icon:\n @info: An IBusEngineDesc\n\n Gets the icon property in IBusEngineDesc. It should not be freed.\n\n Returns: icon property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_icon(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_layout:\n @info: An IBusEngineDesc\n\n Gets the layout property in IBusEngineDesc. It should not be freed.\n\n Returns: layout property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_layout(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_layout_variant:\n @info: An IBusEngineDesc\n\n Gets the keyboard variant property in IBusEngineDesc. It should not be freed.\n\n Returns: keyboard variant property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_layout_variant(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_layout_option:\n @info: An IBusEngineDesc\n\n Gets the keyboard option property in IBusEngineDesc. It should not be freed.\n\n Returns: keyboard option property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_layout_option(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_rank:\n @info: An IBusEngineDesc\n\n Gets the rank property in IBusEngineDesc.\n\n Returns: rank property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_rank(info: *mut IBusEngineDesc) -> guint;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_hotkeys:\n @info: An IBusEngineDesc\n\n Gets the hotkeys property in IBusEngineDesc. It should not be freed.\n\n Returns: hotkeys property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_hotkeys(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_symbol:\n @info: An IBusEngineDesc\n\n Gets the symbol property in IBusEngineDesc. It should not be freed.\n\n Returns: symbol property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_symbol(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_setup:\n @info: An IBusEngineDesc\n\n Gets the setup property in IBusEngineDesc. It should not be freed.\n\n Returns: setup property in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_setup(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_version:\n @info: An IBusEngineDesc\n\n Gets the version property in IBusEngineDesc. It should not be freed.\n\n Returns: version in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_version(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_textdomain:\n @info: An IBusEngineDesc\n\n Gets the textdomain property in IBusEngineDesc. It should not be freed.\n\n Returns: textdomain in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_textdomain(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_get_icon_prop_key:\n @info: An IBusEngineDesc\n\n Gets the key of IBusProperty to load the panel icon dynamically\n in IBusEngineDesc. It should not be freed.\n\n Returns: IBusProperty.key for dynamic panel icon in IBusEngineDesc"]
    pub fn ibus_engine_desc_get_icon_prop_key(info: *mut IBusEngineDesc) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_engine_desc_output:\n @info: An IBusEngineDesc\n @output: XML-formatted Input method engine description.\n @indent: Number of indent (showed as 4 spaces).\n\n Output XML-formatted input method engine description.\n The result will be append to GString specified in @output."]
    pub fn ibus_engine_desc_output(info: *mut IBusEngineDesc, output: *mut GString, indent: gint);
}
#[doc = " IBusInputContext:\n\n An opaque data type representing an IBusInputContext."]
pub type IBusInputContext = _IBusInputContext;
pub type IBusInputContextClass = _IBusInputContextClass;
#[doc = " IBusInputContext:\n\n An opaque data type representing an IBusInputContext."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusInputContext {
    pub parent: IBusProxy,
}
#[test]
fn bindgen_test_layout__IBusInputContext() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusInputContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusInputContext>(),
        40usize,
        concat!("Size of: ", stringify!(_IBusInputContext))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusInputContext>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusInputContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusInputContext),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusInputContextClass {
    pub parent: IBusProxyClass,
    pub pdummy: [gpointer; 24usize],
}
#[test]
fn bindgen_test_layout__IBusInputContextClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusInputContextClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusInputContextClass>(),
        664usize,
        concat!("Size of: ", stringify!(_IBusInputContextClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusInputContextClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusInputContextClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusInputContextClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusInputContextClass),
            "::",
            stringify!(pdummy)
        )
    );
}
extern "C" {
    pub fn ibus_input_context_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_input_context_new:\n @path: The path to the object that emitting the signal.\n @connection: A #GDBusConnection.\n @cancellable: A #GCancellable or %NULL.\n @error: Return location for error or %NULL.\n\n Creates a new #IBusInputContext.\n\n Returns: A newly allocated #IBusInputContext."]
    pub fn ibus_input_context_new(
        path: *const gchar,
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut IBusInputContext;
}
extern "C" {
    #[doc = " ibus_input_context_new_async:\n @path: The path to the object that emitting the signal.\n @connection: A #GDBusConnection.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied.\n      The callback should not be %NULL.\n @user_data: The data to pass to callback.\n\n Creates a new #IBusInputContext asynchronously."]
    pub fn ibus_input_context_new_async(
        path: *const gchar,
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_input_context_new_async_finish:\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback pass to\n      ibus_input_context_new_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_input_context_new_async().\n\n Returns: A newly allocated #IBusInputContext."]
    pub fn ibus_input_context_new_async_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut IBusInputContext;
}
extern "C" {
    #[doc = " ibus_input_context_get_input_context:\n @path: The path to the object that emitting the signal.\n @connection: A GDBusConnection.\n\n Gets an existing IBusInputContext.\n\n Returns: (transfer none): An existing #IBusInputContext."]
    pub fn ibus_input_context_get_input_context(
        path: *const gchar,
        connection: *mut GDBusConnection,
    ) -> *mut IBusInputContext;
}
extern "C" {
    #[doc = " ibus_input_context_get_input_context_async:\n @path: The path to the object that emitting the signal.\n @connection: A #GDBusConnection.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied.\n      The callback should not be %NULL.\n @user_data: The data to pass to callback.\n\n Gets an existing #IBusInputContext asynchronously."]
    pub fn ibus_input_context_get_input_context_async(
        path: *const gchar,
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_input_context_get_input_context_async_finish:\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback pass to\n      ibus_input_context_get_input_context_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with\n ibus_input_context_get_input_context_async().\n\n Returns: (transfer none): An existing #IBusInputContext."]
    pub fn ibus_input_context_get_input_context_async_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut IBusInputContext;
}
extern "C" {
    #[doc = " ibus_input_context_process_hand_writing_event:\n @context: An IBusInputContext.\n @coordinates: An array of gdouble (0.0 to 1.0) which represents a stroke (i.e. [x1, y1, x2, y2, x3, y3, ...]).\n @coordinates_len: The number of elements in the array. The number should be even and >= 4.\n\n Pass a handwriting stroke to an input method engine.\n\n In this API, a coordinate (0.0, 0.0) represents the top-left corner of an area for\n handwriting, and (1.0, 1.0) does the bottom-right. Therefore, for example, if\n a user writes a character 'L', the array would be something like [0.0, 0.0, 0.0, 1.0, 1.0, 1.0]\n and coordinates_len would be 6.\n\n The function is usually called when a user releases the mouse button in a hand\n writing area.\n\n see_also: #IBusEngine::process-hand-writing-event"]
    pub fn ibus_input_context_process_hand_writing_event(
        context: *mut IBusInputContext,
        coordinates: *const gdouble,
        coordinates_len: guint,
    );
}
extern "C" {
    #[doc = " ibus_input_context_cancel_hand_writing:\n @context: An IBusInputContext.\n @n_strokes: The number of strokes to be removed. Pass 0 to remove all.\n\n Clear handwriting stroke(s) in the current input method engine.\n\n see_also: #IBusEngine::cancel-hand-writing"]
    pub fn ibus_input_context_cancel_hand_writing(context: *mut IBusInputContext, n_strokes: guint);
}
extern "C" {
    #[doc = " ibus_input_context_process_key_event_async:\n @context: An IBusInputContext.\n @keyval: Key symbol of a key event.\n @keycode: Keycode of a key event.\n @state: Key modifier flags.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A GCancellable or NULL.\n @callback: A GAsyncReadyCallback to call when the request is satisfied or NULL\n      if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Pass the key event to input method engine.\n\n Key symbols are characters/symbols produced by key press, for example,\n pressing \"s\" generates key symbol \"s\"; pressing shift-\"s\" generates key symbol \"S\".\n Same key on keyboard may produce different key symbols on different keyboard layout.\n e.g., \"s\" key on QWERTY keyboard produces \"o\" in DVORAK layout.\n\n Unlike key symbol, keycode is only determined by the location of the key, and\n irrelevant of the keyboard layout.\n\n Briefly speaking, input methods that expect certain keyboard layout should use\n keycode; otherwise keyval is sufficient.\n For example, Chewing, Cangjie, Wubi expect an en-US QWERTY keyboard, these should\n use keycode; while pinyin can rely on keyval only, as it is less sensitive to\n the keyboard layout change, DVORAK users can still use DVORAK layout to input pinyin.\n\n Use ibus_keymap_lookup_keysym() to convert keycode to keysym in given keyboard layout.\n\n see_also: #IBusEngine::process-key-event"]
    pub fn ibus_input_context_process_key_event_async(
        context: *mut IBusInputContext,
        keyval: guint32,
        keycode: guint32,
        state: guint32,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_input_context_process_key_event_async_finish:\n @context: An #IBusInputContext.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n      ibus_input_context_process_key_event_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with\n      ibus_input_context_process_key_event_async().\n\n Returns: %TRUE if the key event is processed;\n      %FALSE otherwise or some errors happen and the @error will be set."]
    pub fn ibus_input_context_process_key_event_async_finish(
        context: *mut IBusInputContext,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_input_context_process_key_event:\n @context: An #IBusInputContext.\n @keyval: Key symbol of a key event.\n @keycode: Keycode of a key event.\n @state: Key modifier flags.\n\n Pass the key event to input method engine and wait for the reply from\n ibus (i.e. synchronous IPC).\n\n Returns: %TRUE for successfully process the key; %FALSE otherwise.\n\n See also: ibus_input_context_process_key_event_async()"]
    pub fn ibus_input_context_process_key_event(
        context: *mut IBusInputContext,
        keyval: guint32,
        keycode: guint32,
        state: guint32,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_input_context_set_cursor_location:\n @context: An IBusInputContext.\n @x: X coordinate of the cursor.\n @y: Y coordinate of the cursor.\n @w: Width of the cursor.\n @h: Height of the cursor.\n\n Set the cursor location of IBus input context asynchronously.\n\n see_also: #IBusEngine::set-cursor-location"]
    pub fn ibus_input_context_set_cursor_location(
        context: *mut IBusInputContext,
        x: gint32,
        y: gint32,
        w: gint32,
        h: gint32,
    );
}
extern "C" {
    #[doc = " ibus_input_context_set_cursor_location_relative:\n @context: An IBusInputContext.\n @x: X coordinate of the cursor.\n @y: Y coordinate of the cursor.\n @w: Width of the cursor.\n @h: Height of the cursor.\n\n Set the relative cursor location of IBus input context asynchronously."]
    pub fn ibus_input_context_set_cursor_location_relative(
        context: *mut IBusInputContext,
        x: gint32,
        y: gint32,
        w: gint32,
        h: gint32,
    );
}
extern "C" {
    #[doc = " ibus_input_context_set_capabilities:\n @context: An IBusInputContext.\n @capabilities: Capabilities flags of IBusEngine, see #IBusCapabilite\n\n Set the capabilities flags of client application asynchronously.\n When IBUS_CAP_FOCUS is not set, IBUS_CAP_PREEDIT_TEXT, IBUS_CAP_AUXILIARY_TEXT, IBUS_CAP_LOOKUP_TABLE, and IBUS_CAP_PROPERTY have to be all set.\n The panel component does nothing for an application that doesn't support focus.\n\n see_also: #IBusEngine::set-capabilities"]
    pub fn ibus_input_context_set_capabilities(
        context: *mut IBusInputContext,
        capabilities: guint32,
    );
}
extern "C" {
    #[doc = " ibus_input_context_property_activate:\n @context: An #IBusInputContext.\n @prop_name: A property name (e.g. \"InputMode.WideLatin\")\n @state: A status of the property (e.g. PROP_STATE_CHECKED)\n\n Activate the property asynchronously.\n\n See also: #IBusEngine::property_activate"]
    pub fn ibus_input_context_property_activate(
        context: *mut IBusInputContext,
        prop_name: *const gchar,
        state: guint32,
    );
}
extern "C" {
    #[doc = " ibus_input_context_focus_in:\n @context: An #IBusInputContext.\n\n Invoked when the client application get focus. An asynchronous IPC will\n be performed.\n\n see_also: #IBusEngine::focus_in."]
    pub fn ibus_input_context_focus_in(context: *mut IBusInputContext);
}
extern "C" {
    #[doc = " ibus_input_context_focus_out:\n @context: An #IBusInputContext.\n\n Invoked when the client application get focus. An asynchronous IPC will be performed.\n\n see_also: #IBusEngine::focus_out."]
    pub fn ibus_input_context_focus_out(context: *mut IBusInputContext);
}
extern "C" {
    #[doc = " ibus_input_context_reset:\n @context: An #IBusInputContext.\n\n Invoked when the IME is reset. An asynchronous IPC will be performed.\n\n see_also: #IBusEngine::reset"]
    pub fn ibus_input_context_reset(context: *mut IBusInputContext);
}
extern "C" {
    #[doc = " ibus_input_context_get_engine_async:\n @context: An #IBusInputContext.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied or\n     %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n An asynchronous IPC will be performed."]
    pub fn ibus_input_context_get_engine_async(
        context: *mut IBusInputContext,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_input_context_get_engine_async_finish:\n @context: An #IBusInputContext.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_input_context_get_engine_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_input_context_get_engine_async().\n\n Returns: (transfer none): An IME engine description for the context, or\n     %NULL."]
    pub fn ibus_input_context_get_engine_async_finish(
        context: *mut IBusInputContext,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut IBusEngineDesc;
}
extern "C" {
    #[doc = " ibus_input_context_get_engine:\n @context: An #IBusInputContext.\n\n Gets an IME engine description for the context.\n A synchronous IPC will be performed.\n\n Returns: (transfer none): An IME engine description for the context, or NULL."]
    pub fn ibus_input_context_get_engine(context: *mut IBusInputContext) -> *mut IBusEngineDesc;
}
extern "C" {
    #[doc = " ibus_input_context_set_engine:\n @context: An #IBusInputContext.\n @name: A name of the engine.\n\n Invoked when the IME engine is changed.\n An asynchronous IPC will be performed."]
    pub fn ibus_input_context_set_engine(context: *mut IBusInputContext, name: *const gchar);
}
extern "C" {
    #[doc = " ibus_input_context_set_surrounding_text:\n @context: An #IBusInputContext.\n @text: An #IBusText surrounding the current cursor on the application.\n @cursor_pos: Current cursor position in characters in @text.\n @anchor_pos: Anchor position of selection in @text."]
    pub fn ibus_input_context_set_surrounding_text(
        context: *mut IBusInputContext,
        text: *mut IBusText,
        cursor_pos: guint32,
        anchor_pos: guint32,
    );
}
extern "C" {
    #[doc = " ibus_input_context_needs_surrounding_text:\n @context: An #IBusInputContext.\n\n Check whether the current engine requires surrounding-text.\n\n Returns: %TRUE if surrounding-text is needed by the current engine;\n %FALSE otherwise."]
    pub fn ibus_input_context_needs_surrounding_text(context: *mut IBusInputContext) -> gboolean;
}
extern "C" {
    #[doc = " ibus_input_context_set_content_type:\n @context: An #IBusInputContext.\n @purpose: Primary purpose of the input context, as an #IBusInputPurpose.\n @hints: Hints that augment @purpose, as an #IBusInputHints.\n\n Set content-type (primary purpose and hints) of the context.  This\n information is particularly useful to implement intelligent\n behavior in engines, such as automatic input-mode switch and text\n prediction.  For example, to restrict input to numbers, the client\n can call this function with @purpose set to\n #IBUS_INPUT_PURPOSE_NUMBER.\n\n See also: #IBusEngine::set-content-type"]
    pub fn ibus_input_context_set_content_type(
        context: *mut IBusInputContext,
        purpose: guint,
        hints: guint,
    );
}
extern "C" {
    #[doc = " ibus_input_context_set_client_commit_preedit:\n @context: An #IBusInputContext.\n @client_commit: %TRUE if your input context commits pre-edit texts\n     with Space or Enter key events or mouse click events. %FALSE if\n     ibus-daemon commits pre-edit texts with those events.\n     The default is %FALSE. The behavior is decided with\n     ibus_engine_update_preedit_text_with_mode() to commit, clear or\n     keep the pre-edit text and this API is important in ibus-hangul.\n\n Set whether #IBusInputContext commits pre-edit texts or not.\n If %TRUE, 'update-preedit-text-with-mode' signal is emitted\n instead of 'update-preedit-text' signal.\n If your client receives the 'update-preedit-text-with-mode' signal,\n the client needs to implement commit_text() of pre-edit text when\n GtkIMContextClass.focus_out() is called in case an IME desires that\n behavior but it depends on each IME.\n\n See also ibus_engine_update_preedit_text_with_mode()."]
    pub fn ibus_input_context_set_client_commit_preedit(
        context: *mut IBusInputContext,
        client_commit: gboolean,
    );
}
#[doc = " IBusConfig:\n\n An opaque data type representing an IBusConfig."]
pub type IBusConfig = _IBusConfig;
pub type IBusConfigClass = _IBusConfigClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusConfigPrivate {
    _unused: [u8; 0],
}
pub type IBusConfigPrivate = _IBusConfigPrivate;
#[doc = " IBusConfig:\n\n An opaque data type representing an IBusConfig."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusConfig {
    pub parent: IBusProxy,
    pub priv_: *mut IBusConfigPrivate,
}
#[test]
fn bindgen_test_layout__IBusConfig() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusConfig>(),
        48usize,
        concat!("Size of: ", stringify!(_IBusConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusConfig),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusConfig),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusConfigClass {
    pub parent: IBusProxyClass,
}
#[test]
fn bindgen_test_layout__IBusConfigClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusConfigClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusConfigClass>(),
        472usize,
        concat!("Size of: ", stringify!(_IBusConfigClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusConfigClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusConfigClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusConfigClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_config_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_config_new:\n @connection: A #GDBusConnection.\n @cancellable: A #GCancellable or %NULL.\n @error: Return location for error or %NULL.\n\n Create a new #IBusConfig from existing #GDBusConnection.\n\n Returns: A newly allocated #IBusConfig corresponding to @connection."]
    pub fn ibus_config_new(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut IBusConfig;
}
extern "C" {
    #[doc = " ibus_config_new_async:\n @connection: An #GDBusConnection.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied.\n      The callback should not be %NULL.\n @user_data: The data to pass to callback.\n\n New an #IBusConfig asynchronously."]
    pub fn ibus_config_new_async(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_config_new_async_finish:\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback pass to\n      ibus_config_new_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_config_new_async().\n\n Returns: A newly allocated #IBusConfig."]
    pub fn ibus_config_new_async_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut IBusConfig;
}
extern "C" {
    #[doc = " ibus_config_get_value:\n @config: An #IBusConfig\n @section: Section name of the configuration option.\n @name: Name of the configure option.\n\n Get the value of a configuration option synchronously.\n\n GConf stores configure options in a tree-like structure,\n and the IBus related setting is at /desktop/ibus,\n thus, @section here is a path from there,\n while @name is the key of that configuration option.\n\n ibus-chewing, for example, stores its setting in /desktop/ibus/engine/Chewing,\n so the section name for it is \"engine/Chewing\".\n See also: ibus_config_set_value().\n\n Returns: A #GVariant or %NULL. Free with g_variant_unref()."]
    pub fn ibus_config_get_value(
        config: *mut IBusConfig,
        section: *const gchar,
        name: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    #[doc = " ibus_config_get_value_async:\n @config: An #IBusConfig\n @section: Section name of the configuration option.\n @name: Name of the configure option.\n @timeout_ms: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: Callback function to invoke when the return value is ready.\n @user_data: The data to pass to callback.\n\n Get the value of a configuration option asynchronously.\n\n See also: ibus_config_get_value()."]
    pub fn ibus_config_get_value_async(
        config: *mut IBusConfig,
        section: *const gchar,
        name: *const gchar,
        timeout_ms: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_config_get_value_async_finish:\n @config: A #IBusConfig.\n @result: A #GAsyncResult.\n @error: Return location for error or %NULL.\n\n Finish get value of a configuration option.\n\n Returns: A #GVariant or %NULL if error is set. Free with g_variant_unref().\n\n See also: ibus_config_get_value_async()."]
    pub fn ibus_config_get_value_async_finish(
        config: *mut IBusConfig,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    #[doc = " ibus_config_get_values:\n @config: An #IBusConfig\n @section: Section name of the configuration option.\n\n Get all values in a section synchronously.\n\n Returns: A #GVariant or %NULL. Free with g_variant_unref().\n\n See also: ibus_config_set_value()."]
    pub fn ibus_config_get_values(config: *mut IBusConfig, section: *const gchar) -> *mut GVariant;
}
extern "C" {
    #[doc = " ibus_config_get_values_async:\n @config: An #IBusConfig\n @section: Section name of the configuration option.\n @timeout_ms: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: Callback function to invoke when the return value is ready.\n @user_data: The data to pass to callback.\n\n Get all values in a section asynchronously.\n\n See also: ibus_config_get_values()."]
    pub fn ibus_config_get_values_async(
        config: *mut IBusConfig,
        section: *const gchar,
        timeout_ms: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_config_get_values_async_finish:\n @config: A #IBusConfig.\n @result: A #GAsyncResult.\n @error: Return location for error or %NULL.\n\n Finish get values in a section.\n\n Returns: A #GVariant or %NULL if error is set. Free with g_variant_unref().\n\n See also: ibus_config_get_values_async()."]
    pub fn ibus_config_get_values_async_finish(
        config: *mut IBusConfig,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    #[doc = " ibus_config_set_value:\n @config: An #IBusConfig\n @section: Section name of the configuration option.\n @name: Name of the configure option its self.\n @value: A #GVariant that holds the value. If the value is floating, the\n function takes ownership of it.\n\n Set the value of a configuration option synchronously.\n\n Returns: %TRUE if succeed; %FALSE otherwise.\n\n See also: ibus_config_get_value()."]
    pub fn ibus_config_set_value(
        config: *mut IBusConfig,
        section: *const gchar,
        name: *const gchar,
        value: *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_config_set_value_async:\n @config: An #IBusConfig\n @section: Section name of the configuration option.\n @name: Name of the configure option.\n @value: A #GVariant that holds the value. If the value is floating, the\n function takes ownership of it.\n @timeout_ms: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: Callback function to invoke when the return value is ready.\n @user_data: The data to pass to callback.\n\n Set the value of a configuration option asynchronously.\n\n See also: ibus_config_set_value()."]
    pub fn ibus_config_set_value_async(
        config: *mut IBusConfig,
        section: *const gchar,
        name: *const gchar,
        value: *mut GVariant,
        timeout_ms: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_config_set_value_async_finish:\n @config: A #IBusConfig.\n @result: A #GAsyncResult.\n @error: Return location for error or %NULL.\n\n Finish set value of a configuration option.\n\n Returns: %TRUE or %FALSE if error is set.\n\n See also: ibus_config_set_value_async()."]
    pub fn ibus_config_set_value_async_finish(
        config: *mut IBusConfig,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_config_unset:\n @config: An #IBusConfig\n @section: Section name of the configuration option.\n @name: Name of the configure option its self.\n\n Remove an entry of a configuration option.\n\n Returns: %TRUE if succeed; %FALSE otherwise.\n\n See also: ibus_config_get_value()."]
    pub fn ibus_config_unset(
        config: *mut IBusConfig,
        section: *const gchar,
        name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_config_watch:\n @config: An #IBusConfig\n @section: (allow-none): Section name of the configuration option.\n @name: (allow-none): Name of the configure option its self.\n\n Subscribe to the configuration option change notification.\n\n Until this function is called, every change will be notified to the\n client through #IBusConfig::value-changed signal.  Clients should\n call ibus_config_watch() with the sections they are interested in,\n to reduce the number of D-Bus messages.\n\n Returns: %TRUE if succeed; %FALSE otherwise.\n\n See also: ibus_config_unwatch()."]
    pub fn ibus_config_watch(
        config: *mut IBusConfig,
        section: *const gchar,
        name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_config_unwatch:\n @config: An #IBusConfig\n @section: (allow-none): Section name of the configuration option.\n @name: (allow-none): Name of the configure option its self.\n\n Unsubscribe from the configuration option change notification.\n\n Returns: %TRUE if succeed; %FALSE otherwise.\n\n See also: ibus_config_watch."]
    pub fn ibus_config_unwatch(
        config: *mut IBusConfig,
        section: *const gchar,
        name: *const gchar,
    ) -> gboolean;
}
#[doc = " IBusObservedPath:\n @path: Path to be handled.\n @mtime: Modified time.\n @is_dir: Whether the file is the path directory.\n @is_exist: Whether the file exists.\n\n Data structure of IBusObservedPath."]
pub type IBusObservedPath = _IBusObservedPath;
pub type IBusObservedPathClass = _IBusObservedPathClass;
#[doc = " IBusObservedPath:\n @path: Path to be handled.\n @mtime: Modified time.\n @is_dir: Whether the file is the path directory.\n @is_exist: Whether the file exists.\n\n Data structure of IBusObservedPath."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusObservedPath {
    pub parent: IBusSerializable,
    pub path: *mut gchar,
    pub mtime: glong,
    pub is_dir: gboolean,
    pub is_exist: gboolean,
}
#[test]
fn bindgen_test_layout__IBusObservedPath() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusObservedPath> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusObservedPath>(),
        72usize,
        concat!("Size of: ", stringify!(_IBusObservedPath))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusObservedPath>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusObservedPath))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusObservedPath),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusObservedPath),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtime) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusObservedPath),
            "::",
            stringify!(mtime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_dir) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusObservedPath),
            "::",
            stringify!(is_dir)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_exist) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusObservedPath),
            "::",
            stringify!(is_exist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusObservedPathClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusObservedPathClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusObservedPathClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusObservedPathClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusObservedPathClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusObservedPathClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusObservedPathClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusObservedPathClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_observed_path_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_observed_path_new_from_xml_node:\n @node: An XML node that contain path.\n @fill_stat: Auto-fill the path status.\n\n Creates an new #IBusObservedPath from an XML node.\n\n Returns: A newly allocated #IBusObservedPath."]
    pub fn ibus_observed_path_new_from_xml_node(
        node: *mut IBusXML,
        fill_stat: gboolean,
    ) -> *mut IBusObservedPath;
}
extern "C" {
    #[doc = " ibus_observed_path_new:\n @path: The path string.\n @fill_stat: Auto-fill the path status.\n\n Creates a new #IBusObservedPath from an XML node.\n\n Returns: A newly allocated #IBusObservedPath."]
    pub fn ibus_observed_path_new(path: *const gchar, fill_stat: gboolean)
        -> *mut IBusObservedPath;
}
extern "C" {
    #[doc = " ibus_observed_path_traverse:\n @path: An IBusObservedPath.\n @dir_only: Only looks for subdirs, not files\n\n Recursively traverse the path and put the files and subdirectory in to\n a newly allocated\n GLists, if the @path is a directory. Otherwise returns NULL.\n\n Returns: (transfer full) (element-type IBusObservedPath): A newly allocate\n GList which holds content in path; NULL if @path is not directory."]
    pub fn ibus_observed_path_traverse(
        path: *mut IBusObservedPath,
        dir_only: gboolean,
    ) -> *mut GList;
}
extern "C" {
    #[doc = " ibus_observed_path_check_modification:\n @path: An IBusObservedPath.\n\n Checks whether the path is modified by comparing the mtime in object and\n mtime in file system.\n\n Returns: %TRUE if imtime is changed, otherwise %FALSE."]
    pub fn ibus_observed_path_check_modification(path: *mut IBusObservedPath) -> gboolean;
}
extern "C" {
    #[doc = " ibus_observed_path_output:\n @path: An IBusObservedPath.\n @output: Path is appended to.\n @indent: number of indent.\n\n Append the observed path to a string with following format:\n &lt;path mtime=\"&lt;i&gt;modified time&lt;/i&gt;\" &gt;&lt;i&gt;path&lt;/i&gt;&lt;/path&gt;"]
    pub fn ibus_observed_path_output(
        path: *mut IBusObservedPath,
        output: *mut GString,
        indent: gint,
    );
}
#[doc = " IBusComponent:\n\n An IBusComponent stores component information.\n You can get extended values with g_object_get_properties."]
pub type IBusComponent = _IBusComponent;
pub type IBusComponentClass = _IBusComponentClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusComponentPrivate {
    _unused: [u8; 0],
}
pub type IBusComponentPrivate = _IBusComponentPrivate;
#[doc = " IBusComponent:\n\n An IBusComponent stores component information.\n You can get extended values with g_object_get_properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusComponent {
    pub parent: IBusSerializable,
    pub priv_: *mut IBusComponentPrivate,
    pub pdummy: [gpointer; 7usize],
}
#[test]
fn bindgen_test_layout__IBusComponent() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusComponent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusComponent>(),
        112usize,
        concat!("Size of: ", stringify!(_IBusComponent))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusComponent>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusComponent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusComponent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusComponent),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusComponent),
            "::",
            stringify!(pdummy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusComponentClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusComponentClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusComponentClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusComponentClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusComponentClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusComponentClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusComponentClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusComponentClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_component_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_component_new:\n @name: Name of the component.\n @description: Detailed description of component.\n @version: Component version.\n @license: Distribution license of this component.\n @author: Author(s) of the component.\n @homepage: Homepage of the component.\n @command_line: path to component executable.\n @textdomain: Domain name for dgettext()\n\n Creates a new #IBusComponent.\n\n Returns: A newly allocated #IBusComponent."]
    pub fn ibus_component_new(
        name: *const gchar,
        description: *const gchar,
        version: *const gchar,
        license: *const gchar,
        author: *const gchar,
        homepage: *const gchar,
        command_line: *const gchar,
        textdomain: *const gchar,
    ) -> *mut IBusComponent;
}
extern "C" {
    #[doc = " ibus_component_new_varargs:\n @first_property_name: Name of the first property.\n @...: the NULL-terminated arguments of the properties and values.\n\n Creates a new #IBusComponent.\n ibus_component_new_varargs() supports the va_list format.\n name property is required. e.g.\n IBusComponent *component = ibus_component_new_varargs (\"name\", \"ibus-foo\",\n                                                        \"command_line\", \"/usr/libexec/ibus-engine-foo --ibus\",\n                                                     NULL)\n\n Returns: A newly allocated #IBusComponent."]
    pub fn ibus_component_new_varargs(first_property_name: *const gchar, ...)
        -> *mut IBusComponent;
}
extern "C" {
    #[doc = " ibus_component_new_from_xml_node:\n @node: Root node of component XML tree.\n\n Creates a new #IBusComponent from an XML tree.\n\n Returns: A newly allocated #IBusComponent."]
    pub fn ibus_component_new_from_xml_node(node: *mut IBusXML) -> *mut IBusComponent;
}
extern "C" {
    #[doc = " ibus_component_new_from_file:\n @filename: An XML file that contains component information.\n\n Creates a new #IBusComponent from an XML file.\n Note that a component file usually contains engine descriptions,\n if it does, ibus_engine_desc_new_from_xml_node() will be called\n to load the engine descriptions.\n\n Returns: A newly allocated #IBusComponent."]
    pub fn ibus_component_new_from_file(filename: *const gchar) -> *mut IBusComponent;
}
extern "C" {
    #[doc = " ibus_component_get_name:\n @component: An #IBusComponent\n\n Gets the name property in #IBusComponent. It should not be freed.\n\n Returns: name property in #IBusComponent"]
    pub fn ibus_component_get_name(component: *mut IBusComponent) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_component_get_description:\n @component: An #IBusComponent\n\n Gets the description property in #IBusComponent. It should not be freed.\n\n Returns: description property in #IBusComponent"]
    pub fn ibus_component_get_description(component: *mut IBusComponent) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_component_get_version:\n @component: An #IBusComponent\n\n Gets the version property in #IBusComponent. It should not be freed.\n\n Returns: version property in #IBusComponent"]
    pub fn ibus_component_get_version(component: *mut IBusComponent) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_component_get_license:\n @component: An #IBusComponent\n\n Gets the license property in #IBusComponent. It should not be freed.\n\n Returns: license property in #IBusComponent"]
    pub fn ibus_component_get_license(component: *mut IBusComponent) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_component_get_author:\n @component: An #IBusComponent\n\n Gets the author property in #IBusComponent. It should not be freed.\n\n Returns: author property in #IBusComponent"]
    pub fn ibus_component_get_author(component: *mut IBusComponent) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_component_get_homepage:\n @component: An #IBusComponent\n\n Gets the homepage property in #IBusComponent. It should not be freed.\n\n Returns: homepage property in #IBusComponent"]
    pub fn ibus_component_get_homepage(component: *mut IBusComponent) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_component_get_exec:\n @component: An #IBusComponent\n\n Gets the exec property in #IBusComponent. It should not be freed.\n\n Returns: exec property in #IBusComponent"]
    pub fn ibus_component_get_exec(component: *mut IBusComponent) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_component_get_textdomain:\n @component: An #IBusComponent\n\n Gets the textdomain property in #IBusComponent. It should not be freed.\n\n Returns: textdomain property in #IBusComponent"]
    pub fn ibus_component_get_textdomain(component: *mut IBusComponent) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_component_add_observed_path:\n @component: An #IBusComponent\n @path: Observed path to be added.\n @access_fs: %TRUE for filling the file status; %FALSE otherwise.\n\n Add an observed path to #IBusComponent."]
    pub fn ibus_component_add_observed_path(
        component: *mut IBusComponent,
        path: *const gchar,
        access_fs: gboolean,
    );
}
extern "C" {
    #[doc = " ibus_component_add_engine:\n @component: An #IBusComponent\n @engine: A description of an engine.\n\n Add an engine to #IBusComponent according to the description in @engine."]
    pub fn ibus_component_add_engine(component: *mut IBusComponent, engine: *mut IBusEngineDesc);
}
extern "C" {
    #[doc = " ibus_component_get_engines:\n @component: An #IBusComponent.\n\n Gets the engines of this component.\n\n Returns: (transfer container) (element-type IBusEngineDesc):\n A newly allocated GList that contains engines."]
    pub fn ibus_component_get_engines(component: *mut IBusComponent) -> *mut GList;
}
extern "C" {
    #[doc = " ibus_component_output:\n @component: An #IBusComponent.\n @output: GString that holds the result.\n @indent: level of indent.\n\n Output #IBusComponent as an XML-formatted string.\n The output string can be then shown on the screen or written to file."]
    pub fn ibus_component_output(component: *mut IBusComponent, output: *mut GString, indent: gint);
}
extern "C" {
    #[doc = " ibus_component_output_engines:\n @component: An #IBusComponent.\n @output: GString that holds the result.\n @indent: level of indent.\n\n Output engine description  as an XML-formatted string.\n The output string can be then shown on the screen or written to file."]
    pub fn ibus_component_output_engines(
        component: *mut IBusComponent,
        output: *mut GString,
        indent: gint,
    );
}
extern "C" {
    #[doc = " ibus_component_check_modification:\n @component: An #IBusComponent.\n\n Check whether the observed paths of component is modified.\n\n Returns: %TRUE if at least one of the observed paths is modified;\n %FALSE otherwise."]
    pub fn ibus_component_check_modification(component: *mut IBusComponent) -> gboolean;
}
extern "C" {
    #[doc = " ibus_component_get_observed_paths:\n @component: An #IBusComponent.\n\n Gets the observed paths of this component.\n\n Returns: (transfer container) (element-type IBusObservedPath): A\n newly allocated GList that contains observed paths."]
    pub fn ibus_component_get_observed_paths(component: *mut IBusComponent) -> *mut GList;
}
#[doc = " IBusBus:\n\n An opaque data type representing IBus bus (daemon communication) status."]
pub type IBusBus = _IBusBus;
pub type IBusBusClass = _IBusBusClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusBusPrivate {
    _unused: [u8; 0],
}
pub type IBusBusPrivate = _IBusBusPrivate;
#[doc = " IBusBus:\n\n An opaque data type representing IBus bus (daemon communication) status."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusBus {
    pub parent: IBusObject,
    pub priv_: *mut IBusBusPrivate,
}
#[test]
fn bindgen_test_layout__IBusBus() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusBus> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusBus>(),
        48usize,
        concat!("Size of: ", stringify!(_IBusBus))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusBus>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusBus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusBus),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusBus),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusBusClass {
    pub parent: IBusObjectClass,
}
#[test]
fn bindgen_test_layout__IBusBusClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusBusClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusBusClass>(),
        200usize,
        concat!("Size of: ", stringify!(_IBusBusClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusBusClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusBusClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusBusClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_bus_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_bus_new:\n\n Creates a new #IBusBus instance.\n\n Returns: A newly allocated #IBusBus instance, and the instance is not\n floating."]
    pub fn ibus_bus_new() -> *mut IBusBus;
}
extern "C" {
    #[doc = " ibus_bus_new_async:\n\n Creates a new #IBusBus instance. The instance will asynchronously connect\n to the IBus daemon.\n\n Returns: A newly allocated #IBusBus instance, and the instance is not\n floating."]
    pub fn ibus_bus_new_async() -> *mut IBusBus;
}
extern "C" {
    #[doc = " ibus_bus_new_async_client:\n\n Creates a new #IBusBus instance for client use only. It will possibly\n be limited in what it can do.\n\n The instance will asynchronously connect to the IBus daemon.\n\n Returns: A newly allocated #IBusBus instance, and the instance is not\n floating."]
    pub fn ibus_bus_new_async_client() -> *mut IBusBus;
}
extern "C" {
    #[doc = " ibus_bus_is_connected:\n @bus: An #IBusBus.\n\n Return %TRUE if @bus is connected to IBus daemon.\n\n Returns: %TRUE if @bus is connected, %FALSE otherwise."]
    pub fn ibus_bus_is_connected(bus: *mut IBusBus) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_get_connection:\n @bus: An #IBusBus.\n\n Gets a #GDBusConnection of an #IBusBus instance.\n\n Returns: (transfer none): A #GDBusConnection of an #IBusBus instance."]
    pub fn ibus_bus_get_connection(bus: *mut IBusBus) -> *mut GDBusConnection;
}
extern "C" {
    #[doc = " ibus_bus_get_service_name:\n @bus: An #IBusBus.\n\n Return the main service name to use for calls on the ibus connection.\n\n Returns: at dbus name."]
    pub fn ibus_bus_get_service_name(bus: *mut IBusBus) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_bus_hello:\n @bus: An #IBusBus.\n\n This function sends a \"HELLO\" message to DBus daemon,\n which replies the unique name of current IBus process.\n\n Returns: The unique name of IBus process in DBus."]
    pub fn ibus_bus_hello(bus: *mut IBusBus) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_bus_request_name:\n @bus: the IBusBus instance to be processed.\n @name: Name to be requested.\n @flags: IBusBusNameFlag.\n\n Request a name from IBus daemon synchronously.\n\n Returns: 0 if failed; IBusBusRequestNameReply otherwise."]
    pub fn ibus_bus_request_name(bus: *mut IBusBus, name: *const gchar, flags: guint32) -> guint32;
}
extern "C" {
    #[doc = " ibus_bus_request_name_async:\n @bus: An #IBusBus.\n @name: Name to be requested.\n @flags: Flags (FixMe).\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL\n      if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Request a name from IBus daemon asynchronously."]
    pub fn ibus_bus_request_name_async(
        bus: *mut IBusBus,
        name: *const gchar,
        flags: guint,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_request_name_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_request_name_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_request_name_async().\n\n Returns: 0 if failed; positive number otherwise."]
    pub fn ibus_bus_request_name_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    #[doc = " ibus_bus_release_name:\n @bus: An #IBusBus.\n @name: Name to be released.\n\n Release a name to IBus daemon synchronously.\n\n Returns: 0 if failed; positive number otherwise."]
    pub fn ibus_bus_release_name(bus: *mut IBusBus, name: *const gchar) -> guint;
}
extern "C" {
    #[doc = " ibus_bus_release_name_async:\n @bus: An #IBusBus.\n @name: Name to be released.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Release a name to IBus daemon asynchronously."]
    pub fn ibus_bus_release_name_async(
        bus: *mut IBusBus,
        name: *const gchar,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_release_name_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_release_name_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_release_name_async().\n\n Returns: 0 if failed; positive number otherwise."]
    pub fn ibus_bus_release_name_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    #[doc = " ibus_bus_list_queued_owners:\n @bus: An IBusBus.\n @name: Name to be queried.\n\n Lists the unique bus names of connections currently queued for a bus name.\n FIXME add an asynchronous version.\n\n Returns: (transfer full) (element-type utf8):\n           The unique bus names of connections currently queued for @name."]
    pub fn ibus_bus_list_queued_owners(bus: *mut IBusBus, name: *const gchar) -> *mut GList;
}
extern "C" {
    #[doc = " ibus_bus_name_has_owner:\n @bus: An #IBusBus.\n @name: Name to be checked.\n\n Checks whether the name has owner synchronously.\n\n Returns: %TRUE if the name has owner, %FALSE otherwise."]
    pub fn ibus_bus_name_has_owner(bus: *mut IBusBus, name: *const gchar) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_name_has_owner_async:\n @bus: An #IBusBus.\n @name: Name to be checked.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Checks whether the name has owner asynchronously."]
    pub fn ibus_bus_name_has_owner_async(
        bus: *mut IBusBus,
        name: *const gchar,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_name_has_owner_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_name_has_owner_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_name_has_owner_async().\n\n Returns: %TRUE if the name has owner, %FALSE otherwise."]
    pub fn ibus_bus_name_has_owner_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_list_names:\n @bus: An #IBusBus.\n\n Return lists that attached to @bus.\n <note><para>[FixMe] Not implemented yet, only return %NULL.</para></note>\n <note><para>[FixMe] Add async version.</para></note>\n\n Returns: (transfer full) (element-type utf8): Lists that attached to @bus."]
    pub fn ibus_bus_list_names(bus: *mut IBusBus) -> *mut GList;
}
extern "C" {
    #[doc = " ibus_bus_add_match:\n @bus: An #IBusBus.\n @rule: Match rule.\n\n Add a match rule to an #IBusBus synchronously.\n\n Returns: %TRUE if the rule is added. %FALSE otherwise."]
    pub fn ibus_bus_add_match(bus: *mut IBusBus, rule: *const gchar) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_add_match_async:\n @bus: An #IBusBus.\n @rule: Match rule.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Add a match rule to an #IBusBus asynchronously."]
    pub fn ibus_bus_add_match_async(
        bus: *mut IBusBus,
        rule: *const gchar,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_add_match_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_add_match_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_add_match_async().\n\n Returns: %TRUE if the rule is added. %FALSE otherwise."]
    pub fn ibus_bus_add_match_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_remove_match:\n @bus: An #IBusBus.\n @rule: Match rule.\n\n Remove a match rule to an #IBusBus synchronously.\n\n Returns: %TRUE if the rule is removed. %FALSE otherwise."]
    pub fn ibus_bus_remove_match(bus: *mut IBusBus, rule: *const gchar) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_remove_match_async:\n @bus: An #IBusBus.\n @rule: Match rule.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Remove a match rule to an IBusBus asynchronously."]
    pub fn ibus_bus_remove_match_async(
        bus: *mut IBusBus,
        rule: *const gchar,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_remove_match_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_remove_match_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_remove_match_async().\n\n Returns: %TRUE if the rule is removed. %FALSE otherwise."]
    pub fn ibus_bus_remove_match_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_get_name_owner:\n @bus: An #IBusBus.\n @name: Name.\n\n Return the name owner synchronously.\n\n Returns: Owner of the name. The returned value must be freed with g_free()."]
    pub fn ibus_bus_get_name_owner(bus: *mut IBusBus, name: *const gchar) -> *mut gchar;
}
extern "C" {
    #[doc = " ibus_bus_get_name_owner_async:\n @bus: An #IBusBus.\n @name: Name.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Return the name owner asynchronously."]
    pub fn ibus_bus_get_name_owner_async(
        bus: *mut IBusBus,
        name: *const gchar,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_get_name_owner_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_get_name_owner_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_get_name_owner_async().\n\n Returns: Owner of the name. The returned value must be freed with g_free()."]
    pub fn ibus_bus_get_name_owner_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " ibus_bus_exit:\n @bus: An #IBusBus.\n @restart: Whether restarting the ibus.\n\n Exit or restart ibus-daemon synchronously.\n\n Returns: %TRUE if the \"Exit\" call is successful, %FALSE otherwise."]
    pub fn ibus_bus_exit(bus: *mut IBusBus, restart: gboolean) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_exit_async:\n @bus: An #IBusBus.\n @restart: Whether restarting the ibus.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Exit or restart ibus-daemon asynchronously."]
    pub fn ibus_bus_exit_async(
        bus: *mut IBusBus,
        restart: gboolean,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_exit_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_exit_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_exit_async().\n\n Returns: %TRUE if the \"Exit\" call is successful, %FALSE otherwise."]
    pub fn ibus_bus_exit_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_create_input_context:\n @bus: An #IBusBus.\n @client_name: Name of client.\n\n Create an input context for client synchronously.\n\n Returns: (transfer full): A newly allocated #IBusInputContext if the\n      \"CreateInputContext\" call is succeeded, %NULL otherwise."]
    pub fn ibus_bus_create_input_context(
        bus: *mut IBusBus,
        client_name: *const gchar,
    ) -> *mut IBusInputContext;
}
extern "C" {
    #[doc = " ibus_bus_create_input_context_async:\n @bus: An #IBusBus.\n @client_name: Name of client.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied.\n      It should not be %NULL.\n @user_data: The data to pass to callback.\n\n Create an input context for client asynchronously."]
    pub fn ibus_bus_create_input_context_async(
        bus: *mut IBusBus,
        client_name: *const gchar,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_create_input_context_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_create_input_context_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_create_input_context_async().\n\n Returns: (transfer full): A newly allocated #IBusInputContext if the\n      \"CreateInputContext\" call is succeeded, %NULL otherwise."]
    pub fn ibus_bus_create_input_context_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut IBusInputContext;
}
extern "C" {
    #[doc = " ibus_bus_current_input_context:\n @bus: An #IBusBus.\n\n Get the current focused input context synchronously.\n\n Returns: Name of the currently focused #IBusInputContext if the\n          \"CurrentInputContext\" call succeeded, %NULL otherwise. The return\n          value must be freed with g_free()."]
    pub fn ibus_bus_current_input_context(bus: *mut IBusBus) -> *mut gchar;
}
extern "C" {
    #[doc = " ibus_bus_current_input_context_async:\n @bus: An #IBusBus.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Get the current focused input context asynchronously."]
    pub fn ibus_bus_current_input_context_async(
        bus: *mut IBusBus,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_current_input_context_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_current_input_context_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_current_input_context_async().\n\n Returns: Name of the currently focused IBusInputContext if the\n          \"CurrentInputContext\" call succeeded, %NULL otherwise. The return\n          value must be freed with g_free()."]
    pub fn ibus_bus_current_input_context_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[doc = " ibus_bus_register_component:\n @bus: An #IBusBus.\n @component: A input engine component.\n\n Register a component to an #IBusBus synchronously.\n\n Returns: %TRUE if the \"RegisterComponent\" call is successful, %FALSE otherwise."]
    pub fn ibus_bus_register_component(
        bus: *mut IBusBus,
        component: *mut IBusComponent,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_register_component_async:\n @bus: An #IBusBus.\n @component: A input engine component.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Register a component to an #IBusBus asynchronously."]
    pub fn ibus_bus_register_component_async(
        bus: *mut IBusBus,
        component: *mut IBusComponent,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_register_component_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_register_component_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_register_component_async().\n\n Returns: %TRUE if the \"RegisterComponent\" call is successful, %FALSE otherwise."]
    pub fn ibus_bus_register_component_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_list_engines:\n @bus: An #IBusBus.\n\n List engines synchronously.\n\n Returns: (transfer full) (element-type IBusEngineDesc):\n         A List of engines."]
    pub fn ibus_bus_list_engines(bus: *mut IBusBus) -> *mut GList;
}
extern "C" {
    #[doc = " ibus_bus_list_engines_async:\n @bus: An #IBusBus.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL\n      if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n List engines asynchronously."]
    pub fn ibus_bus_list_engines_async(
        bus: *mut IBusBus,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_list_engines_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_list_engines_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_list_engines_async().\n\n Returns: (transfer full) (element-type IBusEngineDesc):\n         A List of engines."]
    pub fn ibus_bus_list_engines_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    #[doc = " ibus_bus_list_active_engines:\n @bus: An #IBusBus.\n\n List active engines synchronously.\n\n Returns: (transfer full) (element-type IBusEngineDesc):\n        A List of active engines.\n\n Deprecated: 1.5.3: Read dconf value\n /desktop/ibus/general/preload-engines instead."]
    pub fn ibus_bus_list_active_engines(bus: *mut IBusBus) -> *mut GList;
}
extern "C" {
    #[doc = " ibus_bus_list_active_engines_async:\n @bus: An #IBusBus.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL\n      if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n List active engines asynchronously.\n\n Deprecated: 1.5.3: Read dconf value\n /desktop/ibus/general/preload-engines instead."]
    pub fn ibus_bus_list_active_engines_async(
        bus: *mut IBusBus,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_list_active_engines_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_list_active_engines_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_list_active_engines_async().\n\n Returns: (transfer full) (element-type IBusEngineDesc):\n         A List of active engines.\n\n Deprecated: 1.5.3: Read dconf value\n /desktop/ibus/general/preload-engines instead."]
    pub fn ibus_bus_list_active_engines_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    #[doc = " ibus_bus_get_engines_by_names:\n @bus: An #IBusBus.\n @names: (array zero-terminated=1): A %NULL-terminated array of names.\n\n Get engines by given names synchronously. If some engine names do not exist,\n this function will simply ignore them, and return rest of engines.\n TODO(penghuang): add asynchronous version\n\n Returns: (array zero-terminated=1) (transfer full):\n         A %NULL-terminated array of engines."]
    pub fn ibus_bus_get_engines_by_names(
        bus: *mut IBusBus,
        names: *const *const gchar,
    ) -> *mut *mut IBusEngineDesc;
}
extern "C" {
    #[doc = " ibus_bus_get_use_sys_layout:\n @bus: An #IBusBus.\n\n Check if the bus's \"use_sys_layout\" option is enabled or not synchronously.\n\n Returns: %TRUE if \"use_sys_layout\" option is enabled.\n\n Deprecated: 1.5.3: Read dconf value\n /desktop/ibus/general/use_system_keyboard_layout instead."]
    pub fn ibus_bus_get_use_sys_layout(bus: *mut IBusBus) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_get_use_sys_layout_async:\n @bus: An #IBusBus.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Check if the bus's \"use_sys_layout\" option is enabled or not asynchronously.\n\n Deprecated: 1.5.3: Read dconf value\n /desktop/ibus/general/use_system_keyboard_layout instead."]
    pub fn ibus_bus_get_use_sys_layout_async(
        bus: *mut IBusBus,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_get_use_sys_layout_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_get_use_sys_layout_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_get_use_sys_layout_async().\n\n Returns: TRUE if \"use_sys_layout\" option is enabled.\n\n Deprecated: 1.5.3: Read dconf value\n /desktop/ibus/general/use_system_keyboard_layout instead."]
    pub fn ibus_bus_get_use_sys_layout_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_get_use_global_engine:\n @bus: An #IBusBus.\n\n Check if the bus's \"use_global_engine\" option is enabled or not\n synchronously.\n\n Returns: TRUE if \"use_global_engine\" option is enabled.\n\n Deprecated: 1.5.3: Currently global engine is always used."]
    pub fn ibus_bus_get_use_global_engine(bus: *mut IBusBus) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_get_use_global_engine_async:\n @bus: An #IBusBus.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Check if the bus's \"use_global_engine\" option is enabled or not asynchronously.\n\n Deprecated: 1.5.3: Currently global engine is always used."]
    pub fn ibus_bus_get_use_global_engine_async(
        bus: *mut IBusBus,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_get_use_global_engine_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_get_use_global_engine_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_get_use_global_engine_async().\n\n Returns: %TRUE if \"use_global_engine\" option is enabled.\n\n Deprecated: 1.5.3: Currently global engine is always used."]
    pub fn ibus_bus_get_use_global_engine_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_is_global_engine_enabled:\n @bus: An #IBusBus.\n\n Check if the current global engine is enabled or not synchronously.\n\n Returns: %TRUE if the current global engine is enabled.\n\n Deprecated: 1.5.3: Probably this would be used for Chrome OS only.\n Currently global engine is always used and ibus_bus_get_global_engine()\n returns NULL until the first global engine is assigned.\n You can use ibus_set_log_handler() to disable a warning when\n ibus_bus_get_global_engine() returns NULL."]
    pub fn ibus_bus_is_global_engine_enabled(bus: *mut IBusBus) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_is_global_engine_enabled_async:\n @bus: An #IBusBus.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Check if the current global engine is enabled or not asynchronously.\n\n Deprecated: 1.5.3: Probably this would be used for Chrome OS only.\n Currently global engine is always used and ibus_bus_get_global_engine()\n returns NULL until the first global engine is assigned.\n You can use ibus_set_log_handler() to disable a warning when\n ibus_bus_get_global_engine() returns NULL."]
    pub fn ibus_bus_is_global_engine_enabled_async(
        bus: *mut IBusBus,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_is_global_engine_enabled_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_is_global_engine_enabled_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_is_global_engine_enabled_async().\n\n Returns: %TRUE if the current global engine is enabled.\n\n Deprecated: 1.5.3: Probably this would be used for Chrome OS only.\n Currently global engine is always used and ibus_bus_get_global_engine()\n returns NULL until the first global engine is assigned.\n You can use ibus_set_log_handler() to disable a warning when\n ibus_bus_get_global_engine() returns NULL."]
    pub fn ibus_bus_is_global_engine_enabled_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_get_global_engine:\n @bus: An #IBusBus.\n\n Get the description of current global engine synchronously.\n\n Returns: (transfer full): The description of current global engine,\n or %NULL if there is no global engine."]
    pub fn ibus_bus_get_global_engine(bus: *mut IBusBus) -> *mut IBusEngineDesc;
}
extern "C" {
    #[doc = " ibus_bus_get_global_engine_async:\n @bus: An #IBusBus.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL\n      if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Get the description of current global engine asynchronously."]
    pub fn ibus_bus_get_global_engine_async(
        bus: *mut IBusBus,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_get_global_engine_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_get_global_engine_async_finish().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_get_global_engine_async_finish().\n\n Returns: (transfer none): The description of current global engine,\n or %NULL if there is no global engine."]
    pub fn ibus_bus_get_global_engine_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut IBusEngineDesc;
}
extern "C" {
    #[doc = " ibus_bus_set_global_engine:\n @bus: An #IBusBus.\n @global_engine: A new engine name.\n\n Set current global engine synchronously.\n\n Returns: %TRUE if the global engine was set successfully."]
    pub fn ibus_bus_set_global_engine(bus: *mut IBusBus, global_engine: *const gchar) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_set_global_engine_async:\n @bus: An #IBusBus.\n @global_engine: A new engine name.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Set current global engine asynchronously."]
    pub fn ibus_bus_set_global_engine_async(
        bus: *mut IBusBus,
        global_engine: *const gchar,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_set_global_engine_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_set_global_engine_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_set_global_engine_async().\n\n Returns: %TRUE if no IPC errros. %FALSE otherwise."]
    pub fn ibus_bus_set_global_engine_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_set_watch_dbus_signal:\n @bus: An #IBusBus.\n @watch: %TRUE if you want ibusbus to emit \"name-owner-changed\" signal when\n ibus-daemon emits the NameOwnerChanged DBus signal.\n\n Start or stop watching the NameOwnerChanged DBus signal."]
    pub fn ibus_bus_set_watch_dbus_signal(bus: *mut IBusBus, watch: gboolean);
}
extern "C" {
    #[doc = " ibus_bus_set_watch_ibus_signal:\n @bus: An #IBusBus.\n @watch: %TRUE if you want ibusbus to emit \"global-engine-changed\" signal when\n ibus-daemon emits the GlobalEngineChanged IBus signal.\n\n Start or stop watching the GlobalEngineChanged IBus signal."]
    pub fn ibus_bus_set_watch_ibus_signal(bus: *mut IBusBus, watch: gboolean);
}
extern "C" {
    #[doc = " ibus_bus_get_config:\n @bus: An #IBusBus.\n\n Get the config instance from #IBusBus.\n\n Returns: (transfer none): An #IBusConfig object which is configurable with\n @bus."]
    pub fn ibus_bus_get_config(bus: *mut IBusBus) -> *mut IBusConfig;
}
extern "C" {
    #[doc = " ibus_bus_preload_engines:\n @bus: An #IBusBus.\n @names: (array zero-terminated=1): A %NULL-terminated array of engine names.\n\n Start bus components by engine names synchronously.\n\n Returns: %TRUE if components start. %FALSE otherwise."]
    pub fn ibus_bus_preload_engines(bus: *mut IBusBus, names: *const *const gchar) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_preload_engines_async:\n @bus: An #IBusBus.\n @names: (array zero-terminated=1): A %NULL-terminated array of engine names.\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Start bus components by engine names asynchronously."]
    pub fn ibus_bus_preload_engines_async(
        bus: *mut IBusBus,
        names: *const *const gchar,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_preload_engines_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_preload_engines_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_preload_engines_async().\n\n Returns: %TRUE if component starts. %FALSE otherwise."]
    pub fn ibus_bus_preload_engines_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_bus_get_ibus_property:\n @bus: An #IBusBus.\n @property_name: property name in org.freedesktop.DBus.Properties.Get\n\n Get org.freedesktop.DBus.Properties.\n\n Returns: (transfer full): The value in org.freedesktop.DBus.Properties.Get\n           The returned value must be freed with g_variant_unref()."]
    pub fn ibus_bus_get_ibus_property(
        bus: *mut IBusBus,
        property_name: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    #[doc = " ibus_bus_get_ibus_property_async:\n @bus: An #IBusBus.\n @property_name: property name in org.freedesktop.DBus.Properties.Get\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Get org.freedesktop.DBus.Properties asynchronously."]
    pub fn ibus_bus_get_ibus_property_async(
        bus: *mut IBusBus,
        property_name: *const gchar,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_get_ibus_property_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_get_ibus_property_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_get_ibus_property_async().\n\n Returns: (transfer full): The value in org.freedesktop.DBus.Properties.Get\n           The returned value must be freed with g_variant_unref()."]
    pub fn ibus_bus_get_ibus_property_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    #[doc = " ibus_bus_set_ibus_property:\n @bus: An #IBusBus.\n @property_name: property name in org.freedesktop.DBus.Properties.Set\n @value: value in org.freedesktop.DBus.Properties.Set\n\n Set org.freedesktop.DBus.Properties."]
    pub fn ibus_bus_set_ibus_property(
        bus: *mut IBusBus,
        property_name: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    #[doc = " ibus_bus_set_ibus_property_async:\n @bus: An #IBusBus.\n @property_name: property name in org.freedesktop.DBus.Properties.Set\n @value: value in org.freedesktop.DBus.Properties.Set\n @timeout_msec: The timeout in milliseconds or -1 to use the default timeout.\n @cancellable: A #GCancellable or %NULL.\n @callback: A #GAsyncReadyCallback to call when the request is satisfied\n      or %NULL if you don't care about the result of the method invocation.\n @user_data: The data to pass to callback.\n\n Set org.freedesktop.DBus.Properties asynchronously."]
    pub fn ibus_bus_set_ibus_property_async(
        bus: *mut IBusBus,
        property_name: *const gchar,
        value: *mut GVariant,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_bus_set_ibus_property_async_finish:\n @bus: An #IBusBus.\n @res: A #GAsyncResult obtained from the #GAsyncReadyCallback passed to\n   ibus_bus_set_ibus_property_async().\n @error: Return location for error or %NULL.\n\n Finishes an operation started with ibus_bus_set_ibus_property_async().\n\n Returns: %TRUE if property is set with async. %FALSE failed."]
    pub fn ibus_bus_set_ibus_property_async_finish(
        bus: *mut IBusBus,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[doc = " IBusKeymap:\n @name: The name of the keymap, such as 'us', 'jp'.\n @keymap: Keymap table. IME developers normally don have to touch this.\n\n A keymap object in IBus."]
pub type IBusKeymap = _IBusKeymap;
pub type IBusKeymapClass = _IBusKeymapClass;
#[doc = " IBusKeymap:\n @name: The name of the keymap, such as 'us', 'jp'.\n @keymap: Keymap table. IME developers normally don have to touch this.\n\n A keymap object in IBus."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusKeymap {
    pub parent: IBusObject,
    pub name: *mut gchar,
    pub keymap: [[guint; 7usize]; 256usize],
}
#[test]
fn bindgen_test_layout__IBusKeymap() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusKeymap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusKeymap>(),
        7216usize,
        concat!("Size of: ", stringify!(_IBusKeymap))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusKeymap>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusKeymap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusKeymap),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusKeymap),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keymap) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusKeymap),
            "::",
            stringify!(keymap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusKeymapClass {
    pub parent: IBusObjectClass,
}
#[test]
fn bindgen_test_layout__IBusKeymapClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusKeymapClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusKeymapClass>(),
        200usize,
        concat!("Size of: ", stringify!(_IBusKeymapClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusKeymapClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusKeymapClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusKeymapClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_keymap_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_keymap_new:\n @name: The keymap file to be loaded, such as 'us', 'jp'.\n\n Get an #IBusKeymap associated with the giving name.\n\n This function loads the keymap file specified in @name\n in the IBUS_DATA_DIR/keymaps directory.\n\n Returns: An #IBusKeymap associated with the giving name; or %NULL if failed.\n\n Deprecated: This function has been deprecated and should\n not be used in newly written code. Please use ibus_keymap_get()."]
    pub fn ibus_keymap_new(name: *const gchar) -> *mut IBusKeymap;
}
extern "C" {
    #[doc = " ibus_keymap_get:\n @name: The keymap file to be loaded, such as 'us', 'jp'.\n\n Get an IBusKeymap associated with the giving name.\n\n This function loads the keymap file specified in @name\n in the IBUS_DATA_DIR/keymaps directory.\n\n Returns: (transfer full): An #IBusKeymap associated with the giving name;\n or %NULL if failed."]
    pub fn ibus_keymap_get(name: *const gchar) -> *mut IBusKeymap;
}
extern "C" {
    #[doc = " ibus_keymap_lookup_keysym:\n @keymap: An IBusKeymap.\n @keycode: A scancode to be converted.\n @state: Modifier flags(such as Ctrl, Shift).\n\n Converts the scancode to keysym, given the keymap.\n\n Returns: Corresponding keysym."]
    pub fn ibus_keymap_lookup_keysym(
        keymap: *mut IBusKeymap,
        keycode: guint16,
        state: guint32,
    ) -> guint;
}
extern "C" {
    #[doc = " ibus_keyval_name:\n @keyval: Key symbol.\n\n Return the name of a key symbol.\n\n Note that the returned string is used internally, so don't free it.\n\n Returns: Corresponding key name. %NULL if no such key symbol."]
    pub fn ibus_keyval_name(keyval: guint) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_keyval_from_name:\n @keyval_name: Key name in #gdk_keys_by_name.\n\n Return the key symbol that associate with the key name.\n\n Returns: Corresponding key symbol."]
    pub fn ibus_keyval_from_name(keyval_name: *const gchar) -> guint;
}
extern "C" {
    #[doc = " ibus_unicode_to_keyval:\n @wc: a ISO10646 encoded character\n\n Convert from a ISO10646 character to a key symbol.\n\n Returns: the corresponding IBus key symbol, if one exists.\n          or, if there is no corresponding symbol,\n          wc | 0x01000000"]
    pub fn ibus_unicode_to_keyval(wc: gunichar) -> guint;
}
extern "C" {
    #[doc = " ibus_keyval_to_unicode:\n @keyval: an IBus key symbol\n\n Convert from an IBus key symbol to the corresponding ISO10646 (Unicode)\n character.\n\n Returns: the corresponding unicode character, or 0 if there\n          is no corresponding character."]
    pub fn ibus_keyval_to_unicode(keyval: guint) -> gunichar;
}
extern "C" {
    #[doc = " ibus_keyval_to_upper:\n @keyval: a key value.\n\n Converts a key value to upper case, if applicable.\n\n Returns: the upper case form of @keyval, or @keyval itself if it is already\n   in upper case or it is not subject to case conversion."]
    pub fn ibus_keyval_to_upper(keyval: guint) -> guint;
}
extern "C" {
    #[doc = " ibus_keyval_to_lower:\n @keyval: a key value.\n\n Converts a key value to lower case, if applicable.\n\n Returns: the lower case form of @keyval, or @keyval itself if it is already\n  in lower case or it is not subject to case conversion."]
    pub fn ibus_keyval_to_lower(keyval: guint) -> guint;
}
extern "C" {
    #[doc = " ibus_keyval_convert_case:\n @symbol: a keyval\n @lower: (out): return location for lowercase version of @symbol\n @upper: (out): return location for uppercase version of @symbol\n\n Obtains the upper- and lower-case versions of the keyval @symbol.\n Examples of keyvals are #IBUS_KEY_a, #IBUS_KEY_Return, #IBUS_KEY_F1, etc."]
    pub fn ibus_keyval_convert_case(symbol: guint, lower: *mut guint, upper: *mut guint);
}
extern "C" {
    #[doc = " ibus_attr_type_get_type:\n @returns: GType of IBUS_ATTR_TYPE\n\n Returns the type of IBUS_ATTR_TYPE as GType."]
    pub fn ibus_attr_type_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_attr_underline_get_type:\n @returns: GType of IBUS_ATTR_UNDERLINE\n\n Returns the type of IBUS_ATTR_UNDERLINE as GType."]
    pub fn ibus_attr_underline_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_object_flags_get_type:\n @returns: GType of IBUS_OBJECT_FLAGS\n\n Returns the type of IBUS_OBJECT_FLAGS as GType."]
    pub fn ibus_object_flags_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_prop_type_get_type:\n @returns: GType of IBUS_PROP_TYPE\n\n Returns the type of IBUS_PROP_TYPE as GType."]
    pub fn ibus_prop_type_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_prop_state_get_type:\n @returns: GType of IBUS_PROP_STATE\n\n Returns the type of IBUS_PROP_STATE as GType."]
    pub fn ibus_prop_state_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_modifier_type_get_type:\n @returns: GType of IBUS_MODIFIER_TYPE\n\n Returns the type of IBUS_MODIFIER_TYPE as GType."]
    pub fn ibus_modifier_type_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_capabilite_get_type:\n @returns: GType of IBUS_CAPABILITE\n\n Returns the type of IBUS_CAPABILITE as GType."]
    pub fn ibus_capabilite_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_preedit_focus_mode_get_type:\n @returns: GType of IBUS_PREEDIT_FOCUS_MODE\n\n Returns the type of IBUS_PREEDIT_FOCUS_MODE as GType."]
    pub fn ibus_preedit_focus_mode_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_orientation_get_type:\n @returns: GType of IBUS_ORIENTATION\n\n Returns the type of IBUS_ORIENTATION as GType."]
    pub fn ibus_orientation_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_bus_name_flag_get_type:\n @returns: GType of IBUS_BUS_NAME_FLAG\n\n Returns the type of IBUS_BUS_NAME_FLAG as GType."]
    pub fn ibus_bus_name_flag_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_bus_request_name_reply_get_type:\n @returns: GType of IBUS_BUS_REQUEST_NAME_REPLY\n\n Returns the type of IBUS_BUS_REQUEST_NAME_REPLY as GType."]
    pub fn ibus_bus_request_name_reply_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_bus_start_service_by_name_reply_get_type:\n @returns: GType of IBUS_BUS_START_SERVICE_BY_NAME_REPLY\n\n Returns the type of IBUS_BUS_START_SERVICE_BY_NAME_REPLY as GType."]
    pub fn ibus_bus_start_service_by_name_reply_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_error_get_type:\n @returns: GType of IBUS_ERROR\n\n Returns the type of IBUS_ERROR as GType."]
    pub fn ibus_error_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_input_purpose_get_type:\n @returns: GType of IBUS_INPUT_PURPOSE\n\n Returns the type of IBUS_INPUT_PURPOSE as GType."]
    pub fn ibus_input_purpose_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_input_hints_get_type:\n @returns: GType of IBUS_INPUT_HINTS\n\n Returns the type of IBUS_INPUT_HINTS as GType."]
    pub fn ibus_input_hints_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_xevent_type_get_type:\n @returns: GType of IBUS_XEVENT_TYPE\n\n Returns the type of IBUS_XEVENT_TYPE as GType."]
    pub fn ibus_xevent_type_get_type() -> GType;
}
#[doc = " IBusHotkeyProfile:\n\n An opaque data type representing an IBusHotkeyProfile."]
pub type IBusHotkeyProfile = _IBusHotkeyProfile;
pub type IBusHotkeyProfileClass = _IBusHotkeyProfileClass;
#[doc = " IBusHotkeyProfile:\n\n An opaque data type representing an IBusHotkeyProfile."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusHotkeyProfile {
    pub parent: IBusSerializable,
}
#[test]
fn bindgen_test_layout__IBusHotkeyProfile() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusHotkeyProfile> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusHotkeyProfile>(),
        48usize,
        concat!("Size of: ", stringify!(_IBusHotkeyProfile))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusHotkeyProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusHotkeyProfile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusHotkeyProfile),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusHotkeyProfileClass {
    pub parent: IBusSerializableClass,
    pub trigger: ::std::option::Option<
        unsafe extern "C" fn(profile: *mut IBusHotkeyProfile, event: GQuark, user_data: gpointer),
    >,
}
#[test]
fn bindgen_test_layout__IBusHotkeyProfileClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusHotkeyProfileClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusHotkeyProfileClass>(),
        272usize,
        concat!("Size of: ", stringify!(_IBusHotkeyProfileClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusHotkeyProfileClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusHotkeyProfileClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusHotkeyProfileClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trigger) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusHotkeyProfileClass),
            "::",
            stringify!(trigger)
        )
    );
}
extern "C" {
    pub fn ibus_hotkey_profile_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_hotkey_profile_new:\n\n Creates a new #IBusHotkeyProfile.\n\n Returns: A newly allocated #IBusHotkeyProfile."]
    pub fn ibus_hotkey_profile_new() -> *mut IBusHotkeyProfile;
}
extern "C" {
    #[doc = " ibus_hotkey_profile_add_hotkey :\n @profile: An IBusHotkeyProfile.\n @keyval: Keycode of the hotkey.\n @modifiers: Modifiers of the hotkey.\n @event: The event to be associated.\n\n Adds a hotkey and its associated event to an #IBusHotkeyProfile.\n\n Returns: Always %TRUE."]
    pub fn ibus_hotkey_profile_add_hotkey(
        profile: *mut IBusHotkeyProfile,
        keyval: guint,
        modifiers: guint,
        event: GQuark,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_hotkey_profile_add_hotkey_from_string:\n @profile: An IBusHotkeyProfile.\n @str: Key in string representation.  '+' is the separator.\n @event: The event to be associated.\n\n Adds a hotkey and its associated event to an #IBusHotkeyProfile.\n The hotkey is in string format, such like\n <constant>Control+Shift+A</constant>.\n\n Returns: FALSE if @str contains invalid symbol; TRUE otherwise."]
    pub fn ibus_hotkey_profile_add_hotkey_from_string(
        profile: *mut IBusHotkeyProfile,
        str_: *const gchar,
        event: GQuark,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_hotkey_profile_remove_hotkey:\n @profile: An IBusHotkeyProfile.\n @keyval: Keycode of the hotkey.\n @modifiers: Modifiers of the hotkey.\n\n Removes the hotkey for an #IBusHotkeyProfile.\n\n Returns: %FALSE if the key is not in @profile, %TRUE otherwise."]
    pub fn ibus_hotkey_profile_remove_hotkey(
        profile: *mut IBusHotkeyProfile,
        keyval: guint,
        modifiers: guint,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_hotkey_profile_remove_hotkey_by_event:\n @profile: An IBusHotkeyProfile.\n @event: The associated event.\n\n Removes the hotkey for an #IBusHotkeyProfile by event.\n\n Returns: %FALSE if no such event in @profile, %TRUE otherwise."]
    pub fn ibus_hotkey_profile_remove_hotkey_by_event(
        profile: *mut IBusHotkeyProfile,
        event: GQuark,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_hotkey_profile_filter_key_event:\n @profile: An IBusHotkeyProfile.\n @keyval: Keycode of the hotkey.\n @modifiers: Modifiers of the hotkey.\n @prev_keyval: Keycode of the hotkey.\n @prev_modifiers: Modifiers of the hotkey.\n @user_data: user data for signal \"trigger\".\n\n Emits a <constant>::trigger</constant> signal when a hotkey is in a profile.\n\n Returns: 0 if releasing a hotkey and the hotkey is not in the profile;\n an associated event otherwise.\n\n See also: ::trigger"]
    pub fn ibus_hotkey_profile_filter_key_event(
        profile: *mut IBusHotkeyProfile,
        keyval: guint,
        modifiers: guint,
        prev_keyval: guint,
        prev_modifiers: guint,
        user_data: gpointer,
    ) -> GQuark;
}
extern "C" {
    #[doc = " ibus_hotkey_profile_lookup_hotkey:\n @profile: An IBusHotkeyProfile.\n @keyval: Keycode of the hotkey.\n @modifiers: Modifiers of the hotkey.\n\n Returns: The event associated to the hotkey or 0 if the hotkey is not in the\n profile."]
    pub fn ibus_hotkey_profile_lookup_hotkey(
        profile: *mut IBusHotkeyProfile,
        keyval: guint,
        modifiers: guint,
    ) -> GQuark;
}
#[doc = " IBusConfigService:\n\n An opaque data type representing a configure service."]
pub type IBusConfigService = _IBusConfigService;
pub type IBusConfigServiceClass = _IBusConfigServiceClass;
#[doc = " IBusConfigService:\n\n An opaque data type representing a configure service."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusConfigService {
    pub parent: IBusService,
}
#[test]
fn bindgen_test_layout__IBusConfigService() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusConfigService> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusConfigService>(),
        48usize,
        concat!("Size of: ", stringify!(_IBusConfigService))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusConfigService>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusConfigService))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusConfigService),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusConfigServiceClass {
    pub parent: IBusServiceClass,
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(
            config: *mut IBusConfigService,
            section: *const gchar,
            name: *const gchar,
            value: *mut GVariant,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    #[doc = " get_value:\n @config: An #IBusConfig.\n @section: section name\n @name: value name\n\n Returns: (transfer full): The value in config associated with section\n         and name."]
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(
            config: *mut IBusConfigService,
            section: *const gchar,
            name: *const gchar,
            error: *mut *mut GError,
        ) -> *mut GVariant,
    >,
    pub unset_value: ::std::option::Option<
        unsafe extern "C" fn(
            config: *mut IBusConfigService,
            section: *const gchar,
            name: *const gchar,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_values: ::std::option::Option<
        unsafe extern "C" fn(
            config: *mut IBusConfigService,
            section: *const gchar,
            error: *mut *mut GError,
        ) -> *mut GVariant,
    >,
    pub pdummy: [gpointer; 12usize],
}
#[test]
fn bindgen_test_layout__IBusConfigServiceClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusConfigServiceClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusConfigServiceClass>(),
        392usize,
        concat!("Size of: ", stringify!(_IBusConfigServiceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusConfigServiceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusConfigServiceClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusConfigServiceClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_value) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusConfigServiceClass),
            "::",
            stringify!(set_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_value) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusConfigServiceClass),
            "::",
            stringify!(get_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unset_value) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusConfigServiceClass),
            "::",
            stringify!(unset_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_values) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusConfigServiceClass),
            "::",
            stringify!(get_values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusConfigServiceClass),
            "::",
            stringify!(pdummy)
        )
    );
}
extern "C" {
    pub fn ibus_config_service_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_config_service_new:\n @connection: An #GDBusConnection.\n\n Creates an new #IBusConfigService from an #GDBusConnection.\n\n Returns: A newly allocated #IBusConfigServices."]
    pub fn ibus_config_service_new(connection: *mut GDBusConnection) -> *mut IBusConfigService;
}
extern "C" {
    #[doc = " ibus_config_service_value_changed:\n @config: An IBusConfigService.\n @section: Section name of the configuration option.\n @name: Name of the configure option.\n @value: GVariant that holds the value.\n\n Change a value of a configuration option\n by sending a \"ValueChanged\" message to IBus service."]
    pub fn ibus_config_service_value_changed(
        config: *mut IBusConfigService,
        section: *const gchar,
        name: *const gchar,
        value: *mut GVariant,
    );
}
#[doc = " IBusProcessKeyEventData:\n\n IBuProcessKeyEventData properties."]
pub type IBusProcessKeyEventData = _IBusProcessKeyEventData;
#[doc = " IBusExtensionEvent:\n\n IBusExtensionEvent properties."]
pub type IBusExtensionEvent = _IBusExtensionEvent;
pub type IBusExtensionEventClass = _IBusExtensionEventClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusExtensionEventPrivate {
    _unused: [u8; 0],
}
pub type IBusExtensionEventPrivate = _IBusExtensionEventPrivate;
#[doc = " IBusXEvent:\n @type: event type\n\n IBusXEvent properties."]
pub type IBusXEvent = _IBusXEvent;
pub type IBusXEventClass = _IBusXEventClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusXEventPrivate {
    _unused: [u8; 0],
}
pub type IBusXEventPrivate = _IBusXEventPrivate;
#[doc = " IBusProcessKeyEventData:\n\n IBuProcessKeyEventData properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusProcessKeyEventData {
    pub keyval: guint,
    pub keycode: guint,
    pub state: guint,
}
#[test]
fn bindgen_test_layout__IBusProcessKeyEventData() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusProcessKeyEventData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusProcessKeyEventData>(),
        12usize,
        concat!("Size of: ", stringify!(_IBusProcessKeyEventData))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusProcessKeyEventData>(),
        4usize,
        concat!("Alignment of ", stringify!(_IBusProcessKeyEventData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusProcessKeyEventData),
            "::",
            stringify!(keyval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keycode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusProcessKeyEventData),
            "::",
            stringify!(keycode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusProcessKeyEventData),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " IBusExtensionEvent:\n\n IBusExtensionEvent properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusExtensionEvent {
    pub parent: IBusSerializable,
    pub priv_: *mut IBusExtensionEventPrivate,
}
#[test]
fn bindgen_test_layout__IBusExtensionEvent() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusExtensionEvent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusExtensionEvent>(),
        56usize,
        concat!("Size of: ", stringify!(_IBusExtensionEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusExtensionEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusExtensionEvent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusExtensionEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusExtensionEvent),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusExtensionEventClass {
    pub parent: IBusSerializableClass,
    pub pdummy: [gpointer; 10usize],
}
#[test]
fn bindgen_test_layout__IBusExtensionEventClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusExtensionEventClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusExtensionEventClass>(),
        344usize,
        concat!("Size of: ", stringify!(_IBusExtensionEventClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusExtensionEventClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusExtensionEventClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusExtensionEventClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusExtensionEventClass),
            "::",
            stringify!(pdummy)
        )
    );
}
extern "C" {
    pub fn ibus_extension_event_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_extension_event_new:\n @first_property_name: Name of the first property.\n @...: the NULL-terminated arguments of the properties and values.\n\n Create a new #IBusExtensionEvent.\n\n Returns: A newly allocated #IBusExtensionEvent. E.g.\n ibus_extension_event_new (\"name\", \"emoji\", \"is-enabled\", TRUE, NULL);"]
    pub fn ibus_extension_event_new(
        first_property_name: *const gchar,
        ...
    ) -> *mut IBusExtensionEvent;
}
extern "C" {
    #[doc = " ibus_extension_event_get_version:\n @event: An #IBusExtensionEvent.\n\n Returns: Version of #IBusExtensionEvent"]
    pub fn ibus_extension_event_get_version(event: *mut IBusExtensionEvent) -> guint;
}
extern "C" {
    #[doc = " ibus_extension_event_get_purpose:\n @event: An #IBusExtensionEvent.\n\n Returns: name of the extension for #IBusXEvent"]
    pub fn ibus_extension_event_get_name(event: *mut IBusExtensionEvent) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_extension_event_is_enabled:\n @event: An #IBusExtensionEvent.\n\n Returns: %TRUE if the extension is enabled for #IBusExtensionEvent"]
    pub fn ibus_extension_event_is_enabled(event: *mut IBusExtensionEvent) -> gboolean;
}
extern "C" {
    #[doc = " ibus_extension_event_is_extension:\n @event: An #IBusExtensionEvent.\n\n Returns: %TRUE if the #IBusExtensionEvent is called by an extension.\n %FALSE if the #IBusExtensionEvent is called by an active engine or\n panel.\n If this value is %TRUE, the event is send to ibus-daemon, an active\n engine. If it's %FALSE, the event is sned to ibus-daemon, panels."]
    pub fn ibus_extension_event_is_extension(event: *mut IBusExtensionEvent) -> gboolean;
}
extern "C" {
    #[doc = " ibus_extension_event_get_params:\n @event: An #IBusExtensionEvent.\n\n Returns: Parameters to enable the extension for #IBusXEvent"]
    pub fn ibus_extension_event_get_params(event: *mut IBusExtensionEvent) -> *const gchar;
}
pub const IBusXEventType_IBUS_X_EVENT_NOTHING: IBusXEventType = -1;
pub const IBusXEventType_IBUS_X_EVENT_KEY_PRESS: IBusXEventType = 0;
pub const IBusXEventType_IBUS_X_EVENT_KEY_RELEASE: IBusXEventType = 1;
pub const IBusXEventType_IBUS_X_EVENT_OTHER: IBusXEventType = 2;
pub const IBusXEventType_IBUS_X_EVENT_EVENT_LAST: IBusXEventType = 3;
pub type IBusXEventType = ::std::os::raw::c_int;
#[doc = " IBusXEvent:\n @type: event type\n\n IBusXEvent properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusXEvent {
    pub parent: IBusSerializable,
    pub priv_: *mut IBusXEventPrivate,
    pub event_type: IBusXEventType,
    pub window: guint,
    pub send_event: gint8,
    pub serial: gulong,
}
#[test]
fn bindgen_test_layout__IBusXEvent() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusXEvent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusXEvent>(),
        80usize,
        concat!("Size of: ", stringify!(_IBusXEvent))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusXEvent>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusXEvent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusXEvent),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusXEvent),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_type) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusXEvent),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusXEvent),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).send_event) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusXEvent),
            "::",
            stringify!(send_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusXEvent),
            "::",
            stringify!(serial)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusXEventClass {
    pub parent: IBusSerializableClass,
    pub pdummy: [gpointer; 10usize],
}
#[test]
fn bindgen_test_layout__IBusXEventClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusXEventClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusXEventClass>(),
        344usize,
        concat!("Size of: ", stringify!(_IBusXEventClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusXEventClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusXEventClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusXEventClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusXEventClass),
            "::",
            stringify!(pdummy)
        )
    );
}
extern "C" {
    pub fn ibus_x_event_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_x_event_new:\n @first_property_name: Name of the first property.\n @...: the NULL-terminated arguments of the properties and values.\n\n Create a new #IBusXEvent.\n\n Returns: A newly allocated #IBusXEvent. E.g.\n ibus_x_event_new (\"event-type\", IBUS_X_EVENT_KEY_PRESS, NULL);"]
    pub fn ibus_x_event_new(first_property_name: *const gchar, ...) -> *mut IBusXEvent;
}
extern "C" {
    #[doc = " ibus_x_event_get_version:\n @event: An #IBusXEvent.\n\n Returns: Version of #IBusXEvent"]
    pub fn ibus_x_event_get_version(event: *mut IBusXEvent) -> guint;
}
extern "C" {
    #[doc = " ibus_x_event_get_event_type:\n @event: An #IBusXEvent.\n\n Returns: IBusXEventType of #IBusXEvent"]
    pub fn ibus_x_event_get_event_type(event: *mut IBusXEvent) -> IBusXEventType;
}
extern "C" {
    #[doc = " ibus_x_event_get_window:\n @event: An #IBusXEvent.\n\n Returns: XID of #IBusXEvent"]
    pub fn ibus_x_event_get_window(event: *mut IBusXEvent) -> guint32;
}
extern "C" {
    #[doc = " ibus_x_event_get_send_event:\n @event: An #IBusXEvent.\n\n Returns: send_event of #IBusXEvent"]
    pub fn ibus_x_event_get_send_event(event: *mut IBusXEvent) -> gint8;
}
extern "C" {
    #[doc = " ibus_x_event_get_serial:\n @event: An #IBusXEvent.\n\n Returns: serial of #IBusXEvent"]
    pub fn ibus_x_event_get_serial(event: *mut IBusXEvent) -> gulong;
}
extern "C" {
    #[doc = " ibus_x_event_get_time:\n @event: An #IBusXEvent.\n\n Returns: time of #IBusXEvent"]
    pub fn ibus_x_event_get_time(event: *mut IBusXEvent) -> guint32;
}
extern "C" {
    #[doc = " ibus_x_event_get_state:\n @event: An #IBusXEvent.\n\n Returns: state of #IBusXEvent"]
    pub fn ibus_x_event_get_state(event: *mut IBusXEvent) -> guint;
}
extern "C" {
    #[doc = " ibus_x_event_get_keyval:\n @event: An #IBusXEvent.\n\n Returns: keyval of #IBusXEvent"]
    pub fn ibus_x_event_get_keyval(event: *mut IBusXEvent) -> guint;
}
extern "C" {
    #[doc = " ibus_x_event_get_length:\n @event: An #IBusXEvent.\n\n Returns: length of #IBusXEvent"]
    pub fn ibus_x_event_get_length(event: *mut IBusXEvent) -> gint;
}
extern "C" {
    #[doc = " ibus_x_event_get_string:\n @event: An #IBusXEvent.\n\n Returns: string of #IBusXEvent"]
    pub fn ibus_x_event_get_string(event: *mut IBusXEvent) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_x_event_get_hardware_keycode:\n @event: An #IBusXEvent.\n\n Returns: hardware keycode of #IBusXEvent"]
    pub fn ibus_x_event_get_hardware_keycode(event: *mut IBusXEvent) -> guint16;
}
extern "C" {
    #[doc = " ibus_x_event_get_group:\n @event: An #IBusXEvent.\n\n Returns: group of #IBusXEvent"]
    pub fn ibus_x_event_get_group(event: *mut IBusXEvent) -> guint8;
}
extern "C" {
    #[doc = " ibus_x_event_get_is_modifier:\n @event: An #IBusXEvent.\n\n Returns: is_modifier of #IBusXEvent"]
    pub fn ibus_x_event_get_is_modifier(event: *mut IBusXEvent) -> gboolean;
}
extern "C" {
    #[doc = " ibus_x_event_get_subwindow:\n @event: An #IBusXEvent.\n\n Returns: subwindow of #IBusXEvent"]
    pub fn ibus_x_event_get_subwindow(event: *mut IBusXEvent) -> guint32;
}
extern "C" {
    #[doc = " ibus_x_event_get_root:\n @event: An #IBusXEvent.\n\n Returns: root window of #IBusXEvent"]
    pub fn ibus_x_event_get_root(event: *mut IBusXEvent) -> guint32;
}
extern "C" {
    #[doc = " ibus_x_event_get_x:\n @event: An #IBusXEvent.\n\n Returns: x of #IBusXEvent"]
    pub fn ibus_x_event_get_x(event: *mut IBusXEvent) -> gint;
}
extern "C" {
    #[doc = " ibus_x_event_get_y:\n @event: An #IBusXEvent.\n\n Returns: y of #IBusXEvent"]
    pub fn ibus_x_event_get_y(event: *mut IBusXEvent) -> gint;
}
extern "C" {
    #[doc = " ibus_x_event_get_x_root:\n @event: An #IBusXEvent.\n\n Returns: x-root of #IBusXEvent"]
    pub fn ibus_x_event_get_x_root(event: *mut IBusXEvent) -> gint;
}
extern "C" {
    #[doc = " ibus_x_event_get_y_root:\n @event: An #IBusXEvent.\n\n Returns: y-root of #IBusXEvent"]
    pub fn ibus_x_event_get_y_root(event: *mut IBusXEvent) -> gint;
}
extern "C" {
    #[doc = " ibus_x_event_get_same_screen:\n @event: An #IBusXEvent.\n\n Returns: same_screen of #IBusXEvent"]
    pub fn ibus_x_event_get_same_screen(event: *mut IBusXEvent) -> gboolean;
}
extern "C" {
    #[doc = " ibus_x_event_get_purpose:\n @event: An #IBusXEvent.\n\n Returns: purpose of #IBusXEvent"]
    pub fn ibus_x_event_get_purpose(event: *mut IBusXEvent) -> *const gchar;
}
#[doc = " IBusPanelService:\n\n An opaque data type representing an IBusPanelService."]
pub type IBusPanelService = _IBusPanelService;
pub type IBusPanelServiceClass = _IBusPanelServiceClass;
#[doc = " IBusPanelService:\n\n An opaque data type representing an IBusPanelService."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusPanelService {
    pub parent: IBusService,
}
#[test]
fn bindgen_test_layout__IBusPanelService() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusPanelService> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusPanelService>(),
        48usize,
        concat!("Size of: ", stringify!(_IBusPanelService))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusPanelService>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusPanelService))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelService),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusPanelServiceClass {
    pub parent: IBusServiceClass,
    pub focus_in: ::std::option::Option<
        unsafe extern "C" fn(panel: *mut IBusPanelService, input_context_path: *const gchar),
    >,
    pub focus_out: ::std::option::Option<
        unsafe extern "C" fn(panel: *mut IBusPanelService, input_context_path: *const gchar),
    >,
    pub register_properties: ::std::option::Option<
        unsafe extern "C" fn(panel: *mut IBusPanelService, prop_list: *mut IBusPropList),
    >,
    pub set_cursor_location: ::std::option::Option<
        unsafe extern "C" fn(panel: *mut IBusPanelService, x: gint, y: gint, w: gint, h: gint),
    >,
    pub update_auxiliary_text: ::std::option::Option<
        unsafe extern "C" fn(panel: *mut IBusPanelService, text: *mut IBusText, visible: gboolean),
    >,
    pub update_lookup_table: ::std::option::Option<
        unsafe extern "C" fn(
            panel: *mut IBusPanelService,
            lookup_table: *mut IBusLookupTable,
            visible: gboolean,
        ),
    >,
    pub update_preedit_text: ::std::option::Option<
        unsafe extern "C" fn(
            panel: *mut IBusPanelService,
            text: *mut IBusText,
            cursor_pos: guint,
            visible: gboolean,
        ),
    >,
    pub update_property: ::std::option::Option<
        unsafe extern "C" fn(panel: *mut IBusPanelService, prop: *mut IBusProperty),
    >,
    pub cursor_down_lookup_table:
        ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub cursor_up_lookup_table:
        ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub hide_auxiliary_text:
        ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub hide_language_bar:
        ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub hide_lookup_table:
        ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub hide_preedit_text:
        ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub page_down_lookup_table:
        ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub page_up_lookup_table:
        ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub reset: ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub show_auxiliary_text:
        ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub show_language_bar:
        ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub show_lookup_table:
        ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub show_preedit_text:
        ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub start_setup: ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub state_changed: ::std::option::Option<unsafe extern "C" fn(panel: *mut IBusPanelService)>,
    pub destroy_context: ::std::option::Option<
        unsafe extern "C" fn(panel: *mut IBusPanelService, input_context_path: *const gchar),
    >,
    pub set_content_type: ::std::option::Option<
        unsafe extern "C" fn(panel: *mut IBusPanelService, purpose: guint, hints: guint),
    >,
    pub set_cursor_location_relative: ::std::option::Option<
        unsafe extern "C" fn(panel: *mut IBusPanelService, x: gint, y: gint, w: gint, h: gint),
    >,
    pub panel_extension_received: ::std::option::Option<
        unsafe extern "C" fn(panel: *mut IBusPanelService, event: *mut IBusExtensionEvent),
    >,
    pub process_key_event: ::std::option::Option<
        unsafe extern "C" fn(
            panel: *mut IBusPanelService,
            keyval: guint,
            keycode: guint,
            state: guint,
        ) -> gboolean,
    >,
    pub commit_text_received: ::std::option::Option<
        unsafe extern "C" fn(panel: *mut IBusPanelService, text: *mut IBusText),
    >,
    pub candidate_clicked_lookup_table: ::std::option::Option<
        unsafe extern "C" fn(
            panel: *mut IBusPanelService,
            index: guint,
            button: guint,
            state: guint,
        ),
    >,
    pub pdummy: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__IBusPanelServiceClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusPanelServiceClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusPanelServiceClass>(),
        520usize,
        concat!("Size of: ", stringify!(_IBusPanelServiceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusPanelServiceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusPanelServiceClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).focus_in) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(focus_in)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).focus_out) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(focus_out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).register_properties) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(register_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_cursor_location) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(set_cursor_location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_auxiliary_text) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(update_auxiliary_text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_lookup_table) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(update_lookup_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_preedit_text) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(update_preedit_text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_property) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(update_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_down_lookup_table) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(cursor_down_lookup_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cursor_up_lookup_table) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(cursor_up_lookup_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hide_auxiliary_text) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(hide_auxiliary_text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hide_language_bar) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(hide_language_bar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hide_lookup_table) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(hide_lookup_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hide_preedit_text) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(hide_preedit_text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_down_lookup_table) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(page_down_lookup_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page_up_lookup_table) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(page_up_lookup_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_auxiliary_text) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(show_auxiliary_text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_language_bar) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(show_language_bar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_lookup_table) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(show_lookup_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_preedit_text) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(show_preedit_text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_setup) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(start_setup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state_changed) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(state_changed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destroy_context) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(destroy_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_content_type) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(set_content_type)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).set_cursor_location_relative) as usize - ptr as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(set_cursor_location_relative)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).panel_extension_received) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(panel_extension_received)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).process_key_event) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(process_key_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commit_text_received) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(commit_text_received)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).candidate_clicked_lookup_table) as usize - ptr as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(candidate_clicked_lookup_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdummy) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusPanelServiceClass),
            "::",
            stringify!(pdummy)
        )
    );
}
extern "C" {
    pub fn ibus_panel_service_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_panel_service_new:\n @connection: An GDBusConnection.\n\n Creates a new #IBusPanelService from an #GDBusConnection.\n\n Returns: A newly allocated #IBusPanelService."]
    pub fn ibus_panel_service_new(connection: *mut GDBusConnection) -> *mut IBusPanelService;
}
extern "C" {
    #[doc = " ibus_panel_service_candidate_clicked:\n @panel: An IBusPanelService\n @index: Index in the Lookup table\n @button: GdkEventButton::button (1: left button, etc.)\n @state: GdkEventButton::state (key modifier flags)\n\n Notify that a candidate is clicked\n by sending a \"CandidateClicked\" to IBus service."]
    pub fn ibus_panel_service_candidate_clicked(
        panel: *mut IBusPanelService,
        index: guint,
        button: guint,
        state: guint,
    );
}
extern "C" {
    #[doc = " ibus_panel_service_cursor_down:\n @panel: An IBusPanelService\n\n Notify that the cursor is down\n by sending a \"CursorDown\" to IBus service."]
    pub fn ibus_panel_service_cursor_down(panel: *mut IBusPanelService);
}
extern "C" {
    #[doc = " ibus_panel_service_cursor_up:\n @panel: An IBusPanelService\n\n Notify that the cursor is up\n by sending a \"CursorUp\" to IBus service."]
    pub fn ibus_panel_service_cursor_up(panel: *mut IBusPanelService);
}
extern "C" {
    #[doc = " ibus_panel_service_page_down:\n @panel: An IBusPanelService\n\n Notify that the page is down\n by sending a \"PageDown\" to IBus service."]
    pub fn ibus_panel_service_page_down(panel: *mut IBusPanelService);
}
extern "C" {
    #[doc = " ibus_panel_service_page_up:\n @panel: An IBusPanelService\n\n Notify that the page is up\n by sending a \"PageUp\" to IBus service."]
    pub fn ibus_panel_service_page_up(panel: *mut IBusPanelService);
}
extern "C" {
    #[doc = " ibus_panel_service_property_activate:\n @panel: An IBusPanelService\n @prop_name: A property name\n @prop_state: State of the property\n\n Notify that a property is active\n by sending a \"PropertyActivate\" message to IBus service."]
    pub fn ibus_panel_service_property_activate(
        panel: *mut IBusPanelService,
        prop_name: *const gchar,
        prop_state: guint,
    );
}
extern "C" {
    #[doc = " ibus_panel_service_property_show:\n @panel: An IBusPanelService\n @prop_name: A property name\n\n Notify that a property is shown\n by sending a \"ValueChanged\" message to IBus service."]
    pub fn ibus_panel_service_property_show(panel: *mut IBusPanelService, prop_name: *const gchar);
}
extern "C" {
    #[doc = " ibus_panel_service_property_hide:\n @panel: An IBusPanelService\n @prop_name: A property name\n\n Notify that a property is hidden\n by sending a \"ValueChanged\" message to IBus service."]
    pub fn ibus_panel_service_property_hide(panel: *mut IBusPanelService, prop_name: *const gchar);
}
extern "C" {
    #[doc = " ibus_panel_service_commit_text:\n @panel: An #IBusPanelService\n @text: An #IBusText\n\n Notify that a text is sent\n by sending a \"CommitText\" message to IBus service."]
    pub fn ibus_panel_service_commit_text(panel: *mut IBusPanelService, text: *mut IBusText);
}
extern "C" {
    #[doc = " ibus_panel_service_panel_extension:\n @panel: An #IBusPanelService\n @event: (transfer full): A #PanelExtensionEvent which is sent to a\n                          panel extension.\n\n Enable or disable a panel extension with #IBusExtensionEvent.\n Notify that a data is sent\n by sending a \"PanelExtension\" message to IBus panel extension service."]
    pub fn ibus_panel_service_panel_extension(
        panel: *mut IBusPanelService,
        event: *mut IBusExtensionEvent,
    );
}
extern "C" {
    #[doc = " ibus_panel_service_panel_extension_register_keys:\n @panel: An #IBusPanelService\n @first_property_name: the first name of the shortcut keys. This is %NULL\n\" terminated.\n\n Register shortcut keys to enable panel extensions with #IBusExtensionEvent.\n Notify that a data is sent\n by sending a \"PanelExtensionRegisterKeys\" message to IBus panel extension\n service. Seems Vala does not support uint[][3] and use\n IBusProcessKeyEventData[]. E.g.\n IBusProcessKeyEventData[] keys = {{\n         IBUS_KEY_e, 0, IBUS_SHIFT_MASK | IBUS_SUPER_MASK }};\n ibus_panel_service_panel_extension_register_keys(panel, \"emoji\", keys, NULL);"]
    pub fn ibus_panel_service_panel_extension_register_keys(
        panel: *mut IBusPanelService,
        first_property_name: *const gchar,
        ...
    );
}
extern "C" {
    #[doc = " ibus_panel_service_update_preedit_text_received:\n @panel: An #IBusPanelService\n @text: Update content.\n @cursor_pos: Current position of cursor\n @visible: Whether the pre-edit buffer is visible.\n\n Notify that the preedit is updated by the panel extension\n\n (Note: The table object will be released, if it is floating.\n  If caller want to keep the object, caller should make the object\n  sink by g_object_ref_sink.)"]
    pub fn ibus_panel_service_update_preedit_text_received(
        panel: *mut IBusPanelService,
        text: *mut IBusText,
        cursor_pos: guint,
        visible: gboolean,
    );
}
extern "C" {
    #[doc = " ibus_panel_service_show_preedit_text_received:\n @panel: An IBusPanelService\n\n Notify that the preedit is shown by the panel extension"]
    pub fn ibus_panel_service_show_preedit_text_received(panel: *mut IBusPanelService);
}
extern "C" {
    #[doc = " ibus_panel_service_hide_preedit_text_received:\n @panel: An IBusPanelService\n\n Notify that the preedit is hidden by the panel extension"]
    pub fn ibus_panel_service_hide_preedit_text_received(panel: *mut IBusPanelService);
}
extern "C" {
    #[doc = " ibus_panel_service_update_auxiliary_text_received:\n @panel: An #IBusPanelService\n @text: An #IBusText\n @visible: Whether the auxilirary text is visible.\n\n Notify that the auxilirary is updated by the panel extension.\n\n (Note: The table object will be released, if it is floating.\n  If caller want to keep the object, caller should make the object\n  sink by g_object_ref_sink.)"]
    pub fn ibus_panel_service_update_auxiliary_text_received(
        panel: *mut IBusPanelService,
        text: *mut IBusText,
        visible: gboolean,
    );
}
extern "C" {
    #[doc = " ibus_panel_service_update_lookup_table_received:\n @panel: An #IBusPanelService\n @table: An #IBusLookupTable\n @visible: Whether the lookup table is visible.\n\n Notify that the lookup table is updated by the panel extension.\n\n (Note: The table object will be released, if it is floating.\n  If caller want to keep the object, caller should make the object\n  sink by g_object_ref_sink.)"]
    pub fn ibus_panel_service_update_lookup_table_received(
        panel: *mut IBusPanelService,
        table: *mut IBusLookupTable,
        visible: gboolean,
    );
}
extern "C" {
    #[doc = " ibus_get_untranslated_language_name:\n @_locale: A const locale name.\n\n Returns: untranslated language name"]
    pub fn ibus_get_untranslated_language_name(_locale: *const gchar) -> *mut gchar;
}
extern "C" {
    #[doc = " ibus_get_language_name:\n @_locale: A const locale name.\n\n Returns: translated language name"]
    pub fn ibus_get_language_name(_locale: *const gchar) -> *mut gchar;
}
#[doc = " IBusRegistry:\n\n Registry cache handling.\n You can load the registry from compose files or a cache file."]
pub type IBusRegistry = _IBusRegistry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusRegistryPrivate {
    _unused: [u8; 0],
}
pub type IBusRegistryPrivate = _IBusRegistryPrivate;
pub type IBusRegistryClass = _IBusRegistryClass;
#[doc = " IBusRegistry:\n\n Registry cache handling.\n You can load the registry from compose files or a cache file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusRegistry {
    pub parent: IBusSerializable,
    pub priv_: *mut IBusRegistryPrivate,
}
#[test]
fn bindgen_test_layout__IBusRegistry() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusRegistry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusRegistry>(),
        56usize,
        concat!("Size of: ", stringify!(_IBusRegistry))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusRegistry>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusRegistry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusRegistry),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusRegistry),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusRegistryClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusRegistryClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusRegistryClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusRegistryClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusRegistryClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusRegistryClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusRegistryClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusRegistryClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_registry_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_registry_new:\n\n Creates a new #IBusRegistry\n\n Returns: A newly allocated #IBusRegistry."]
    pub fn ibus_registry_new() -> *mut IBusRegistry;
}
extern "C" {
    #[doc = " ibus_registry_load:\n @registry: An #IBusRegistry.\n\n Read all XML files in a IBus component directory (typically\n /usr/share/ibus/component/ *.xml) and update the registry object.\n IBUS_COMPONENT_PATH environment valuable is also available for\n the custom component directories, whose delimiter is ':'."]
    pub fn ibus_registry_load(registry: *mut IBusRegistry);
}
extern "C" {
    #[doc = " ibus_registry_load_in_dir:\n @registry: An #IBusRegistry.\n @dirname: IBus component directory which includes XML files.\n\n Read all XML files in @dirname, create a #IBusComponent object for each file,\n and add the component objects to the registry.\n If @dirname is \"/usr/share/ibus/component\", this API and\n ibus_registry_load() are same."]
    pub fn ibus_registry_load_in_dir(registry: *mut IBusRegistry, dirname: *const gchar);
}
extern "C" {
    #[doc = " ibus_registry_load_cache:\n @registry: An #IBusRegistry.\n @is_user: %TRUE if the registry cache is loaded in the user directory.\n\n Load the user or system registry cache.\n\n Returns: %TRUE if the cache exists and is loaded successfully,\n           %FALSE otherwise."]
    pub fn ibus_registry_load_cache(registry: *mut IBusRegistry, is_user: gboolean) -> gboolean;
}
extern "C" {
    #[doc = " ibus_registry_load_cache_file:\n @registry: An #IBusRegistry.\n @filename: The file path of the registry cache\n\n Load the registry cache @filename.\n\n Returns: %TRUE if the cache exists and is loaded successfully,\n           %FALSE otherwise."]
    pub fn ibus_registry_load_cache_file(
        registry: *mut IBusRegistry,
        filename: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_registry_save_cache:\n @registry: An #IBusRegistry.\n @is_user: %TRUE if the registry cache is saved in the user directory.\n\n Save the registry in a user directory or system directory.\n\n Returns: %TRUE if the cache is saved successfully, %FALSE otherwise."]
    pub fn ibus_registry_save_cache(registry: *mut IBusRegistry, is_user: gboolean) -> gboolean;
}
extern "C" {
    #[doc = " ibus_registry_save_cache_file:\n @registry: An #IBusRegistry.\n @filename: The file path of the registry cache\n\n Save the registry cache @filename.\n\n Returns: %TRUE if the cache is saved successfully, %FALSE otherwise."]
    pub fn ibus_registry_save_cache_file(
        registry: *mut IBusRegistry,
        filename: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[doc = " ibus_registry_output:\n @registry: An #IBusRegistry.\n @output: GString that holds the result.\n @indent: level of indent.\n\n Output #IBusRegistry as an XML-formatted string.\n The output string can be then shown on the screen or written to file."]
    pub fn ibus_registry_output(
        registry: *mut IBusRegistry,
        output: *mut GString,
        indent: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " ibus_registry_check_modification:\n @registry: An #IBusRegistry.\n\n Check if the registry is updated.\n\n Returns: %TRUE if mtime is changed; %FALSE otherwise."]
    pub fn ibus_registry_check_modification(registry: *mut IBusRegistry) -> gboolean;
}
extern "C" {
    #[doc = " ibus_registry_get_components:\n @registry: An #IBusRegistry.\n\n List components.\n\n Returns: (transfer container) (element-type IBusComponent):\n a list of #IBusComponent objects.\n The caller has to call g_list_free() for the returned list."]
    pub fn ibus_registry_get_components(registry: *mut IBusRegistry) -> *mut GList;
}
extern "C" {
    #[doc = " ibus_registry_get_observed_paths:\n @registry: An #IBusRegistry.\n\n List observed paths.\n\n Returns: (transfer container) (element-type IBusObservedPath):\n a list of #IBusObservedPath objects.\n The caller has to call g_list_free() for the returned list."]
    pub fn ibus_registry_get_observed_paths(registry: *mut IBusRegistry) -> *mut GList;
}
extern "C" {
    #[doc = " ibus_registry_start_monitor_changes:\n @registry: An #IBusRegistry.\n\n Start to monitor observed paths."]
    pub fn ibus_registry_start_monitor_changes(registry: *mut IBusRegistry);
}
#[doc = " IBusEmojiData:\n\n Emoji data likes emoji unicode, annotations, description, category.\n You can get extended values with g_object_get_properties."]
pub type IBusEmojiData = _IBusEmojiData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusEmojiDataPrivate {
    _unused: [u8; 0],
}
pub type IBusEmojiDataPrivate = _IBusEmojiDataPrivate;
pub type IBusEmojiDataClass = _IBusEmojiDataClass;
#[doc = " IBusEmojiData:\n\n Emoji data likes emoji unicode, annotations, description, category.\n You can get extended values with g_object_get_properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusEmojiData {
    pub parent: IBusSerializable,
    pub priv_: *mut IBusEmojiDataPrivate,
}
#[test]
fn bindgen_test_layout__IBusEmojiData() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusEmojiData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusEmojiData>(),
        56usize,
        concat!("Size of: ", stringify!(_IBusEmojiData))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusEmojiData>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusEmojiData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEmojiData),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEmojiData),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusEmojiDataClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusEmojiDataClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusEmojiDataClass> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusEmojiDataClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusEmojiDataClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusEmojiDataClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusEmojiDataClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusEmojiDataClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_emoji_data_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_emoji_data_new:\n @first_property_name: Name of the first property.\n @...: the NULL-terminated arguments of the properties and values.\n\n Creates a new #IBusEmojiData.\n emoji property is required. e.g.\n ibus_emoji_data_new (\"emoji\", \"\", NULL)\n\n Returns: A newly allocated #IBusEmojiData."]
    pub fn ibus_emoji_data_new(first_property_name: *const gchar, ...) -> *mut IBusEmojiData;
}
extern "C" {
    #[doc = " ibus_emoji_data_get_emoji:\n @emoji : An #IBusEmojiData\n\n Gets the emoji character in #IBusEmojiData. It should not be freed.\n\n Returns: emoji property in #IBusEmojiData"]
    pub fn ibus_emoji_data_get_emoji(emoji: *mut IBusEmojiData) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_emoji_data_get_annotations:\n @emoji : An #IBusEmojiData\n\n Gets the annotation list in #IBusEmojiData. It should not be freed.\n\n Returns: (transfer none) (element-type utf8):\n          annotation list property in #IBusEmojiData"]
    pub fn ibus_emoji_data_get_annotations(emoji: *mut IBusEmojiData) -> *mut GSList;
}
extern "C" {
    #[doc = " ibus_emoji_data_set_annotations:\n @emoji : An #IBusEmojiData\n @annotations: (transfer full) (element-type utf8): List of emoji annotations\n\n Sets the annotation list in #IBusEmojiData."]
    pub fn ibus_emoji_data_set_annotations(emoji: *mut IBusEmojiData, annotations: *mut GSList);
}
extern "C" {
    #[doc = " ibus_emoji_data_get_description:\n @emoji : An #IBusEmojiData\n\n Gets the emoji description in #IBusEmojiData. It should not be freed.\n\n Returns: description property in #IBusEmojiData"]
    pub fn ibus_emoji_data_get_description(emoji: *mut IBusEmojiData) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_emoji_data_set_description:\n @emoji : An #IBusEmojiData\n @description: An emoji description\n\n Sets the description in #IBusEmojiData."]
    pub fn ibus_emoji_data_set_description(emoji: *mut IBusEmojiData, description: *const gchar);
}
extern "C" {
    #[doc = " ibus_emoji_data_get_category:\n @emoji : An #IBusEmojiData\n\n Gets the emoji category in #IBusEmojiData. It should not be freed.\n\n Returns: category property in #IBusEmojiData"]
    pub fn ibus_emoji_data_get_category(emoji: *mut IBusEmojiData) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_emoji_dict_save:\n @path: A path of the saved dictionary file.\n @dict: (element-type utf8 gpointer) (transfer none): An Emoji dictionary\n\n Saves the Emoji dictionary to the cache file.\n Recommend to use ibus_emoji_data_save() instead becase GSList in\n GHashTable does not work with Gir and Vala.\n Calls ibus_emoji_data_save() internally. The format of the hash table\n changed and now is { emoji character, #IBusEmojiData object }."]
    pub fn ibus_emoji_dict_save(path: *const gchar, dict: *mut GHashTable);
}
extern "C" {
    #[doc = " ibus_emoji_dict_load:\n @path: A path of the saved dictionary file.\n\n Returns: (element-type utf8 gpointer) (transfer none): An Emoji dictionary\n file loaded from the saved cache file.\n\n A hash table of { emoji character, #IBusEmojiData object } is loaded\n from the saved cache file.\n Recommend to use ibus_emoji_data_load() instead becase GSList in\n GHashTable does not work with Gir and Vala.\n Calls ibus_emoji_data_load() internally."]
    pub fn ibus_emoji_dict_load(path: *const gchar) -> *mut GHashTable;
}
extern "C" {
    #[doc = " ibus_emoji_dict_lookup:\n @dict: (element-type utf8 IBusEmojiData) (transfer full): An Emoji dictionary\n @emoji: an emoji character\n\n Returns: (transfer none): An #IBusEmojiData of @emoji.\n This API was prepared for the old dict foramat with Gir and Vala\n but no longer needed.\n Use ibus_emoji_data_load() instead."]
    pub fn ibus_emoji_dict_lookup(dict: *mut GHashTable, emoji: *const gchar)
        -> *mut IBusEmojiData;
}
extern "C" {
    #[doc = " ibus_emoji_data_save:\n @path: A path of the saved emoji data.\n @list: (element-type IBusEmojiData) (transfer none): A list of emoji data.\n\n Save the list of #IBusEmojiData to the cache file."]
    pub fn ibus_emoji_data_save(path: *const gchar, list: *mut GSList);
}
extern "C" {
    #[doc = " ibus_emoji_data_load:\n @path: A path of the saved dictionary file.\n\n Returns: (element-type IBusEmojiData) (transfer full):\n An #IBusEmojiData list loaded from the saved cache file."]
    pub fn ibus_emoji_data_load(path: *const gchar) -> *mut GSList;
}
#[doc = " IBusUnicodeData:\n\n Unicode data likes code, name, alias, block-name.\n You can get extended values with g_object_get_properties."]
pub type IBusUnicodeData = _IBusUnicodeData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusUnicodeDataPrivate {
    _unused: [u8; 0],
}
pub type IBusUnicodeDataPrivate = _IBusUnicodeDataPrivate;
pub type IBusUnicodeDataClass = _IBusUnicodeDataClass;
pub type IBusUnicodeBlock = _IBusUnicodeBlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusUnicodeBlockPrivate {
    _unused: [u8; 0],
}
pub type IBusUnicodeBlockPrivate = _IBusUnicodeBlockPrivate;
pub type IBusUnicodeBlockClass = _IBusUnicodeBlockClass;
#[doc = " IBusUnicodeDataLoadAsyncFinish:\n @data_list: (transfer full) (element-type IBusUnicodeData):\n\n This callback can receive the list of #IBusUnicodeData."]
pub type IBusUnicodeDataLoadAsyncFinish =
    ::std::option::Option<unsafe extern "C" fn(data_list: *mut GSList, user_data: gpointer)>;
#[doc = " IBusUnicodeData:\n\n Unicode data likes code, name, alias, block-name.\n You can get extended values with g_object_get_properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusUnicodeData {
    pub parent: IBusSerializable,
    pub priv_: *mut IBusUnicodeDataPrivate,
}
#[test]
fn bindgen_test_layout__IBusUnicodeData() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusUnicodeData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusUnicodeData>(),
        56usize,
        concat!("Size of: ", stringify!(_IBusUnicodeData))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusUnicodeData>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusUnicodeData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusUnicodeData),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusUnicodeData),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusUnicodeDataClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusUnicodeDataClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusUnicodeDataClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusUnicodeDataClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusUnicodeDataClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusUnicodeDataClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusUnicodeDataClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusUnicodeDataClass),
            "::",
            stringify!(parent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusUnicodeBlock {
    pub parent: IBusSerializable,
    pub priv_: *mut IBusUnicodeBlockPrivate,
}
#[test]
fn bindgen_test_layout__IBusUnicodeBlock() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusUnicodeBlock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusUnicodeBlock>(),
        56usize,
        concat!("Size of: ", stringify!(_IBusUnicodeBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusUnicodeBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusUnicodeBlock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusUnicodeBlock),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusUnicodeBlock),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IBusUnicodeBlockClass {
    pub parent: IBusSerializableClass,
}
#[test]
fn bindgen_test_layout__IBusUnicodeBlockClass() {
    const UNINIT: ::std::mem::MaybeUninit<_IBusUnicodeBlockClass> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IBusUnicodeBlockClass>(),
        264usize,
        concat!("Size of: ", stringify!(_IBusUnicodeBlockClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_IBusUnicodeBlockClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_IBusUnicodeBlockClass))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IBusUnicodeBlockClass),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub fn ibus_unicode_data_get_type() -> GType;
}
extern "C" {
    pub fn ibus_unicode_block_get_type() -> GType;
}
extern "C" {
    #[doc = " ibus_unicode_data_new:\n @first_property_name: Name of the first property.\n @...: the NULL-terminated arguments of the properties and values.\n\n Creates a new #IBusUnicodeData.\n code property is required. e.g.\n ibus_unicode_data_new (\"code\", 0x3042, NULL)\n\n Returns: A newly allocated #IBusUnicodeData."]
    pub fn ibus_unicode_data_new(first_property_name: *const gchar, ...) -> *mut IBusUnicodeData;
}
extern "C" {
    #[doc = " ibus_unicode_data_get_code:\n @unicode: An #IBusUnicodeData\n\n Gets the code point in #IBusUnicodeData.\n\n Returns: code property in #IBusUnicodeData"]
    pub fn ibus_unicode_data_get_code(unicode: *mut IBusUnicodeData) -> gunichar;
}
extern "C" {
    #[doc = " ibus_unicode_data_get_name:\n @unicode: An #IBusUnicodeData\n\n Gets the name in #IBusUnicodeData. It should not be freed.\n\n Returns: name property in #IBusUnicodeData"]
    pub fn ibus_unicode_data_get_name(unicode: *mut IBusUnicodeData) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_unicode_data_get_alias:\n @unicode: An #IBusUnicodeData\n\n Gets the alias in #IBusUnicodeData. It should not be freed.\n\n Returns: alias property in #IBusUnicodeData"]
    pub fn ibus_unicode_data_get_alias(unicode: *mut IBusUnicodeData) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_unicode_data_get_block_name:\n @unicode: An #IBusUnicodeData\n\n Gets the block name in #IBusUnicodeData. It should not be freed.\n\n Returns: block-name property in #IBusUnicodeData"]
    pub fn ibus_unicode_data_get_block_name(unicode: *mut IBusUnicodeData) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_unicode_data_set_block_name:\n @unicode: An #IBusUnicodeData\n @block_name: A block name\n\n Sets the block name in #IBusUnicodeData."]
    pub fn ibus_unicode_data_set_block_name(
        unicode: *mut IBusUnicodeData,
        block_name: *const gchar,
    );
}
extern "C" {
    #[doc = " ibus_unicode_data_save:\n @path: A path of the saved Unicode data.\n @list: (element-type IBusUnicodeData) (transfer none): A list of unicode\n  data.\n\n Save the list of #IBusUnicodeData to the cache file."]
    pub fn ibus_unicode_data_save(path: *const gchar, list: *mut GSList);
}
extern "C" {
    #[doc = " ibus_unicode_data_load:\n @path: A path of the saved dictionary file.\n @object: (nullable): If the #GObject has \"unicode-deserialize-progress\"\n    signal, this function will emit (the number of desrialized\n    #IBusUnicodeData, * the total number of #IBusUnicodeData) of uint values\n    with that signal by 100 times. Otherwise %NULL.\n\n Returns: (element-type IBusUnicodeData) (transfer full):\n An #IBusUnicodeData list loaded from the saved cache file."]
    pub fn ibus_unicode_data_load(path: *const gchar, object: *mut GObject) -> *mut GSList;
}
extern "C" {
    #[doc = " ibus_unicode_data_load_async:\n @path: A path of the saved dictionary file.\n @object: (nullable): If the #GObject has \"unicode-deserialize-progress\"\n    signal, this function will emit (the number of desrialized\n    #IBusUnicodeData, * the total number of #IBusUnicodeData) of uint values\n    with that signal by 100 times. Otherwise %NULL.\n @cancellable: cancellable.\n @callback: (scope notified): IBusUnicodeDataLoadAsyncFinish.\n @user_data: User data.\n\n IBusUnicodeDataLoadAsyncFinish can receive the list of #IBusUnicodeData."]
    pub fn ibus_unicode_data_load_async(
        path: *const gchar,
        object: *mut GObject,
        cancellable: *mut GCancellable,
        callback: IBusUnicodeDataLoadAsyncFinish,
        user_data: gpointer,
    );
}
extern "C" {
    #[doc = " ibus_unicode_block_new:\n @first_property_name: Name of the first property.\n @...: the NULL-terminated arguments of the properties and values.\n\n Creates a new #IBusUnicodeBlock.\n block property is required. e.g.\n ibus_unicode_block_new (\"start\", 0x0000, \"end\", \"0x007f\", \"name\", \"basic\",\n NULL)\n\n Returns: A newly allocated #IBusUnicodeBlock."]
    pub fn ibus_unicode_block_new(first_property_name: *const gchar, ...) -> *mut IBusUnicodeBlock;
}
extern "C" {
    #[doc = " ibus_unicode_block_get_start:\n @block: An #IBusUnicodeData\n\n Gets the start code point in #IBusUnicodeBlock.\n\n Returns: start property in #IBusUnicodeBlock"]
    pub fn ibus_unicode_block_get_start(block: *mut IBusUnicodeBlock) -> gunichar;
}
extern "C" {
    #[doc = " ibus_unicode_block_get_end:\n @block: An #IBusUnicodeData\n\n Gets the end code point in #IBusUnicodeBlock.\n\n Returns: end property in #IBusUnicodeBlock"]
    pub fn ibus_unicode_block_get_end(block: *mut IBusUnicodeBlock) -> gunichar;
}
extern "C" {
    #[doc = " ibus_unicode_block_get_name:\n @block: An #IBusUnicodeBlock\n\n Gets the name in #IBusUnicodeBlock. It should not be freed.\n\n Returns: name property in #IBusUnicodeBlock"]
    pub fn ibus_unicode_block_get_name(block: *mut IBusUnicodeBlock) -> *const gchar;
}
extern "C" {
    #[doc = " ibus_unicode_block_save:\n @path: A path of the saved Unicode block.\n @list: (element-type IBusUnicodeBlock) (transfer none): A list of unicode\n  block.\n\n Save the list of #IBusUnicodeBlock to the cache file."]
    pub fn ibus_unicode_block_save(path: *const gchar, list: *mut GSList);
}
extern "C" {
    #[doc = " ibus_unicode_block_load:\n @path: A path of the saved dictionary file.\n\n Returns: (element-type IBusUnicodeBlock) (transfer full):\n An #IBusUnicodeBlock list loaded from the saved cache file."]
    pub fn ibus_unicode_block_load(path: *const gchar) -> *mut GSList;
}
extern "C" {
    pub fn ibus_accelerator_valid(keyval: guint, modifiers: IBusModifierType) -> gboolean;
}
extern "C" {
    pub fn ibus_accelerator_parse(
        accelerator: *const gchar,
        accelerator_key: *mut guint,
        accelerator_mods: *mut IBusModifierType,
    );
}
extern "C" {
    pub fn ibus_accelerator_name(
        accelerator_key: guint,
        accelerator_mods: IBusModifierType,
    ) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
