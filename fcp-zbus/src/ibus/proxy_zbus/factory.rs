//! # DBus interface proxies for: `org.freedesktop.IBus.Service`, `org.freedesktop.IBus.Factory`, `org.freedesktop.IBus.Service`, `org.freedesktop.IBus.Engine`, `org.freedesktop.IBus.Panel`
//!
//! This code was generated by `zbus-xmlgen` `3.1.0` from DBus introspection data.
//! Source: `interfaces.xml`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the
//! [Writing a client proxy](https://dbus.pages.freedesktop.org/zbus/client.html)
//! section of the zbus documentation.
//!
impl<'a> ::zbus::ProxyDefault for FactoryProxyBlocking<'a> {
    const INTERFACE: &'static str = "org.freedesktop.IBus.Factory";
    const DESTINATION: &'static str = "org.freedesktop.IBus.Factory";
    const PATH: &'static str = "/org/freedesktop/Factory";
}
pub struct FactoryProxyBlocking<'c>(::zbus::blocking::Proxy<'c>);
#[automatically_derived]
impl<'c> ::core::clone::Clone for FactoryProxyBlocking<'c> {
    #[inline]
    fn clone(&self) -> FactoryProxyBlocking<'c> {
        FactoryProxyBlocking(::core::clone::Clone::clone(&self.0))
    }
}
#[automatically_derived]
impl<'c> ::core::fmt::Debug for FactoryProxyBlocking<'c> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "FactoryProxyBlocking", &&self.0)
    }
}
impl<'c> FactoryProxyBlocking<'c> {
    #[doc = r" Creates a new proxy with the default service and path."]
    pub fn new(conn: &::zbus::blocking::Connection) -> ::zbus::Result<FactoryProxyBlocking<'c>> {
        Self::builder(conn).build()
    }
    #[doc = r" Returns a customizable builder for this proxy."]
    pub fn builder(
        conn: &::zbus::blocking::Connection,
    ) -> ::zbus::blocking::ProxyBuilder<'c, Self> {
        let mut builder = ::zbus::blocking::ProxyBuilder::new(conn);
        if false {
            let uncached = Vec::new();
            builder
                .cache_properties(::zbus::CacheProperties::default())
                .uncached_properties(&uncached)
        } else {
            builder.cache_properties(::zbus::CacheProperties::No)
        }
    }
    #[doc = r" Consumes `self`, returning the underlying `zbus::Proxy`."]
    pub fn into_inner(self) -> ::zbus::blocking::Proxy<'c> {
        self.0
    }
    #[doc = r" The reference to the underlying `zbus::Proxy`."]
    pub fn inner(&self) -> &::zbus::blocking::Proxy<'c> {
        &self.0
    }
    #[doc = " CreateEngine method"]
    pub fn create_engine(&self, name: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath> {
        let reply = self.0.call("CreateEngine", &(name,))?;
        ::std::result::Result::Ok(reply)
    }
}
impl<'c> ::std::convert::From<::zbus::Proxy<'c>> for FactoryProxyBlocking<'c> {
    fn from(proxy: ::zbus::Proxy<'c>) -> Self {
        FactoryProxyBlocking(::std::convert::Into::into(proxy))
    }
}
impl<'c> ::std::ops::Deref for FactoryProxyBlocking<'c> {
    type Target = ::zbus::blocking::Proxy<'c>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'c> ::std::ops::DerefMut for FactoryProxyBlocking<'c> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
impl<'c> ::std::convert::AsRef<::zbus::blocking::Proxy<'c>> for FactoryProxyBlocking<'c> {
    fn as_ref(&self) -> &::zbus::blocking::Proxy<'c> {
        &*self
    }
}
impl<'c> ::std::convert::AsMut<::zbus::blocking::Proxy<'c>> for FactoryProxyBlocking<'c> {
    fn as_mut(&mut self) -> &mut ::zbus::blocking::Proxy<'c> {
        &mut *self
    }
}
impl<'c> ::zbus::zvariant::Type for FactoryProxyBlocking<'c> {
    fn signature() -> ::zbus::zvariant::Signature<'static> {
        ::zbus::zvariant::OwnedObjectPath::signature()
    }
}
impl<'c> ::zbus::export::serde::ser::Serialize for FactoryProxyBlocking<'c> {
    fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
    where
        S: ::zbus::export::serde::ser::Serializer,
    {
        ::std::string::String::serialize(
            &::std::string::ToString::to_string(self.inner().path()),
            serializer,
        )
    }
}
impl<'a> ::zbus::ProxyDefault for FactoryProxy<'a> {
    const INTERFACE: &'static str = "org.freedesktop.IBus.Factory";
    const DESTINATION: &'static str = "org.freedesktop.IBus.Factory";
    const PATH: &'static str = "/org/freedesktop/Factory";
}
pub struct FactoryProxy<'c>(::zbus::Proxy<'c>);
#[automatically_derived]
impl<'c> ::core::clone::Clone for FactoryProxy<'c> {
    #[inline]
    fn clone(&self) -> FactoryProxy<'c> {
        FactoryProxy(::core::clone::Clone::clone(&self.0))
    }
}
#[automatically_derived]
impl<'c> ::core::fmt::Debug for FactoryProxy<'c> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_tuple_field1_finish(f, "FactoryProxy", &&self.0)
    }
}
impl<'c> FactoryProxy<'c> {
    #[doc = r" Creates a new proxy with the default service and path."]
    pub async fn new(conn: &::zbus::Connection) -> ::zbus::Result<FactoryProxy<'c>> {
        Self::builder(conn).build().await
    }
    #[doc = r" Returns a customizable builder for this proxy."]
    pub fn builder(conn: &::zbus::Connection) -> ::zbus::ProxyBuilder<'c, Self> {
        let mut builder = ::zbus::ProxyBuilder::new(conn);
        if false {
            let uncached = Vec::new();
            builder
                .cache_properties(::zbus::CacheProperties::default())
                .uncached_properties(&uncached)
        } else {
            builder.cache_properties(::zbus::CacheProperties::No)
        }
    }
    #[doc = r" Consumes `self`, returning the underlying `zbus::Proxy`."]
    pub fn into_inner(self) -> ::zbus::Proxy<'c> {
        self.0
    }
    #[doc = r" The reference to the underlying `zbus::Proxy`."]
    pub fn inner(&self) -> &::zbus::Proxy<'c> {
        &self.0
    }
    #[doc = " CreateEngine method"]
    pub async fn create_engine(&self, name: &str) -> zbus::Result<zbus::zvariant::OwnedObjectPath> {
        let reply = self.0.call("CreateEngine", &(name,)).await?;
        ::std::result::Result::Ok(reply)
    }
}
impl<'c> ::std::convert::From<::zbus::Proxy<'c>> for FactoryProxy<'c> {
    fn from(proxy: ::zbus::Proxy<'c>) -> Self {
        FactoryProxy(::std::convert::Into::into(proxy))
    }
}
impl<'c> ::std::ops::Deref for FactoryProxy<'c> {
    type Target = ::zbus::Proxy<'c>;
    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
impl<'c> ::std::ops::DerefMut for FactoryProxy<'c> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}
impl<'c> ::std::convert::AsRef<::zbus::Proxy<'c>> for FactoryProxy<'c> {
    fn as_ref(&self) -> &::zbus::Proxy<'c> {
        &*self
    }
}
impl<'c> ::std::convert::AsMut<::zbus::Proxy<'c>> for FactoryProxy<'c> {
    fn as_mut(&mut self) -> &mut ::zbus::Proxy<'c> {
        &mut *self
    }
}
impl<'c> ::zbus::zvariant::Type for FactoryProxy<'c> {
    fn signature() -> ::zbus::zvariant::Signature<'static> {
        ::zbus::zvariant::OwnedObjectPath::signature()
    }
}
impl<'c> ::zbus::export::serde::ser::Serialize for FactoryProxy<'c> {
    fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
    where
        S: ::zbus::export::serde::ser::Serializer,
    {
        ::std::string::String::serialize(
            &::std::string::ToString::to_string(self.inner().path()),
            serializer,
        )
    }
}
