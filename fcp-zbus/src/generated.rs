use std::prelude::rust_2021::*;

// # DBus interface proxies for: `org.freedesktop.IBus.Panel`, `org.freedesktop.IBus`
//
// This code was generated by `zbus-xmlgen` `3.1.0` from DBus introspection data.
// Source: `interfaces_you_call.xml`.
//
// You may prefer to adapt it, instead of using it verbatim.
//
// More information can be found in the
// [Writing a client proxy](https://dbus.pages.freedesktop.org/zbus/client.html)
// section of the zbus documentation.
//
// # DBus interface proxies for: `org.freedesktop.IBus.Panel`, `org.freedesktop.IBus`
//
// This code was generated by `zbus-xmlgen` `3.1.0` from DBus introspection data.
// Source: `interfaces_you_call.xml`.
//
// You may prefer to adapt it, instead of using it verbatim.
//
// More information can be found in the
// [Writing a client proxy](https://dbus.pages.freedesktop.org/zbus/client.html)
// section of the zbus documentation.
//

impl<'a> ::zbus::ProxyDefault for IBusProxyGen<'a> {
    const INTERFACE: &'static str = "org.freedesktop.IBus";
    const DESTINATION: &'static str = "org.freedesktop.IBus";
    const PATH: &'static str = "/org/freedesktop/IBus";
}

pub struct IBusProxyGen<'c>(::zbus::Proxy<'c>);

#[automatically_derived]
impl<'c> ::core::clone::Clone for IBusProxyGen<'c> {
    #[inline]

    fn clone(&self) -> IBusProxyGen<'c> {
        IBusProxyGen(::core::clone::Clone::clone(&self.0))
    }
}

#[automatically_derived]
impl<'c> ::core::fmt::Debug for IBusProxyGen<'c> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        f.debug_struct("IBusProxy").field("0", &&self.0).finish()
    }
}

impl<'c> IBusProxyGen<'c> {
    #[doc = r" Creates a new proxy with the default service and path."]
    pub async fn new(conn: &::zbus::Connection) -> ::zbus::Result<IBusProxyGen<'c>> {
        Self::builder(conn).build().await
    }

    #[doc = r" Returns a customizable builder for this proxy."]
    pub fn builder(conn: &::zbus::Connection) -> ::zbus::ProxyBuilder<'c, Self> {
        let builder = ::zbus::ProxyBuilder::new(conn);

        if true {
            let uncached = Vec::new();

            builder
                .cache_properties(::zbus::CacheProperties::default())
                .uncached_properties(&uncached)
        } else {
            builder.cache_properties(::zbus::CacheProperties::No)
        }
    }

    #[doc = r" Consumes `self`, returning the underlying `zbus::Proxy`."]
    pub fn into_inner(self) -> ::zbus::Proxy<'c> {
        self.0
    }

    #[doc = r" The reference to the underlying `zbus::Proxy`."]
    pub fn inner(&self) -> &::zbus::Proxy<'c> {
        &self.0
    }

    #[doc = " CreateInputContext method"]
    pub async fn create_input_context(
        &self,
        client_name: &str,
    ) -> zbus::Result<zbus::zvariant::OwnedObjectPath> {
        let reply = self.0.call("CreateInputContext", &(client_name,)).await?;

        ::std::result::Result::Ok(reply)
    }

    #[doc = " Exit method"]
    pub async fn exit(&self, restart: bool) -> zbus::Result<()> {
        let reply = self.0.call("Exit", &(restart,)).await?;

        ::std::result::Result::Ok(reply)
    }

    #[doc = " GetEnginesByNames method"]
    pub async fn get_engines_by_names(
        &self,
        names: &[&str],
    ) -> zbus::Result<Vec<zbus::zvariant::OwnedValue>> {
        let reply = self.0.call("GetEnginesByNames", &(names,)).await?;

        ::std::result::Result::Ok(reply)
    }

    #[doc = " Ping method"]
    pub async fn ping(
        &self,
        data: &zbus::zvariant::Value<'_>,
    ) -> zbus::Result<zbus::zvariant::OwnedValue> {
        let reply = self.0.call("Ping", &(data,)).await?;

        ::std::result::Result::Ok(reply)
    }

    #[doc = " RegisterComponent method"]
    pub async fn register_component(
        &self,
        component: &zbus::zvariant::Value<'_>,
    ) -> zbus::Result<()> {
        let reply = self.0.call("RegisterComponent", &(component,)).await?;

        ::std::result::Result::Ok(reply)
    }

    #[doc = " SetGlobalEngine method"]
    pub async fn set_global_engine(&self, engine_name: &str) -> zbus::Result<()> {
        let reply = self.0.call("SetGlobalEngine", &(engine_name,)).await?;

        ::std::result::Result::Ok(reply)
    }

    #[doc = " ActiveEngines property"]
    #[allow(clippy::needless_question_mark)]
    pub async fn active_engines(&self) -> zbus::Result<Vec<zbus::zvariant::OwnedValue>> {
        ::std::result::Result::Ok(self.0.get_property("ActiveEngines").await?)
    }

    #[doc = " Get the cached value of the `ActiveEngines` property, or `None` if the property is not cached."]
    pub fn cached_active_engines(
        &self,
    ) -> ::std::result::Result<
        ::std::option::Option<
            <zbus::Result<Vec<zbus::zvariant::OwnedValue>> as ::zbus::ResultAdapter>::Ok,
        >,
        <zbus::Result<Vec<zbus::zvariant::OwnedValue>> as ::zbus::ResultAdapter>::Err,
    > {
        self.0
            .cached_property("ActiveEngines")
            .map_err(::std::convert::Into::into)
    }

    #[doc = "Create a stream for the `ActiveEngines` property changes. This is a convenient wrapper around [`zbus::Proxy::receive_property_changed`]."]
    pub async fn receive_active_engines_changed(
        &self,
    ) -> ::zbus::PropertyStream<
        'c,
        <zbus::Result<Vec<zbus::zvariant::OwnedValue>> as ::zbus::ResultAdapter>::Ok,
    > {
        self.0.receive_property_changed("ActiveEngines").await
    }

    #[doc = " Address property"]
    #[allow(clippy::needless_question_mark)]
    pub async fn address(&self) -> zbus::Result<String> {
        ::std::result::Result::Ok(self.0.get_property("Address").await?)
    }

    #[doc = " Get the cached value of the `Address` property, or `None` if the property is not cached."]
    pub fn cached_address(
        &self,
    ) -> ::std::result::Result<
        ::std::option::Option<<zbus::Result<String> as ::zbus::ResultAdapter>::Ok>,
        <zbus::Result<String> as ::zbus::ResultAdapter>::Err,
    > {
        self.0
            .cached_property("Address")
            .map_err(::std::convert::Into::into)
    }

    #[doc = "Create a stream for the `Address` property changes. This is a convenient wrapper around [`zbus::Proxy::receive_property_changed`]."]
    pub async fn receive_address_changed(
        &self,
    ) -> ::zbus::PropertyStream<'c, <zbus::Result<String> as ::zbus::ResultAdapter>::Ok> {
        self.0.receive_property_changed("Address").await
    }

    #[doc = " EmbedPreeditText property"]
    #[allow(clippy::needless_question_mark)]
    pub async fn embed_preedit_text(&self) -> zbus::Result<bool> {
        ::std::result::Result::Ok(self.0.get_property("EmbedPreeditText").await?)
    }

    #[doc = " Get the cached value of the `EmbedPreeditText` property, or `None` if the property is not cached."]
    pub fn cached_embed_preedit_text(
        &self,
    ) -> ::std::result::Result<
        ::std::option::Option<<zbus::Result<bool> as ::zbus::ResultAdapter>::Ok>,
        <zbus::Result<bool> as ::zbus::ResultAdapter>::Err,
    > {
        self.0
            .cached_property("EmbedPreeditText")
            .map_err(::std::convert::Into::into)
    }

    #[doc = "Create a stream for the `EmbedPreeditText` property changes. This is a convenient wrapper around [`zbus::Proxy::receive_property_changed`]."]
    pub async fn receive_embed_preedit_text_changed(
        &self,
    ) -> ::zbus::PropertyStream<'c, <zbus::Result<bool> as ::zbus::ResultAdapter>::Ok> {
        self.0.receive_property_changed("EmbedPreeditText").await
    }

    pub async fn set_embed_preedit_text(&self, value: bool) -> zbus::Result<()> {
        let reply = self.0.call("SetEmbedPreeditText", &(value,)).await?;

        ::std::result::Result::Ok(reply)
    }

    #[doc = " Engines property"]
    #[allow(clippy::needless_question_mark)]
    pub async fn engines(&self) -> zbus::Result<Vec<zbus::zvariant::OwnedValue>> {
        ::std::result::Result::Ok(self.0.get_property("Engines").await?)
    }

    #[doc = " Get the cached value of the `Engines` property, or `None` if the property is not cached."]
    pub fn cached_engines(
        &self,
    ) -> ::std::result::Result<
        ::std::option::Option<
            <zbus::Result<Vec<zbus::zvariant::OwnedValue>> as ::zbus::ResultAdapter>::Ok,
        >,
        <zbus::Result<Vec<zbus::zvariant::OwnedValue>> as ::zbus::ResultAdapter>::Err,
    > {
        self.0
            .cached_property("Engines")
            .map_err(::std::convert::Into::into)
    }

    #[doc = "Create a stream for the `Engines` property changes. This is a convenient wrapper around [`zbus::Proxy::receive_property_changed`]."]
    pub async fn receive_engines_changed(
        &self,
    ) -> ::zbus::PropertyStream<
        'c,
        <zbus::Result<Vec<zbus::zvariant::OwnedValue>> as ::zbus::ResultAdapter>::Ok,
    > {
        self.0.receive_property_changed("Engines").await
    }

    #[doc = " GlobalEngine property"]
    #[allow(clippy::needless_question_mark)]
    pub async fn global_engine(&self) -> zbus::Result<zbus::zvariant::OwnedValue> {
        ::std::result::Result::Ok(self.0.get_property("GlobalEngine").await?)
    }

    #[doc = " Get the cached value of the `GlobalEngine` property, or `None` if the property is not cached."]
    pub fn cached_global_engine(
        &self,
    ) -> ::std::result::Result<
        ::std::option::Option<
            <zbus::Result<zbus::zvariant::OwnedValue> as ::zbus::ResultAdapter>::Ok,
        >,
        <zbus::Result<zbus::zvariant::OwnedValue> as ::zbus::ResultAdapter>::Err,
    > {
        self.0
            .cached_property("GlobalEngine")
            .map_err(::std::convert::Into::into)
    }

    #[doc = "Create a stream for the `GlobalEngine` property changes. This is a convenient wrapper around [`zbus::Proxy::receive_property_changed`]."]
    pub async fn global_engine_prop_changed(
        &self,
    ) -> ::zbus::PropertyStream<
        'c,
        <zbus::Result<zbus::zvariant::OwnedValue> as ::zbus::ResultAdapter>::Ok,
    > {
        self.0.receive_property_changed("GlobalEngine").await
    }

    #[doc = " PreloadEngines property"]
    #[allow(clippy::needless_question_mark)]
    pub async fn set_preload_engines(&self, value: &[&str]) -> zbus::Result<()> {
        ::std::result::Result::Ok(self.0.set_property("PreloadEngines", value).await?)
    }
}

impl<'c> ::std::convert::From<::zbus::Proxy<'c>> for IBusProxyGen<'c> {
    fn from(proxy: ::zbus::Proxy<'c>) -> Self {
        IBusProxyGen(::std::convert::Into::into(proxy))
    }
}

impl<'c> ::std::ops::Deref for IBusProxyGen<'c> {
    type Target = ::zbus::Proxy<'c>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<'c> ::std::ops::DerefMut for IBusProxyGen<'c> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl<'c> ::std::convert::AsRef<::zbus::Proxy<'c>> for IBusProxyGen<'c> {
    fn as_ref(&self) -> &::zbus::Proxy<'c> {
        &*self
    }
}

impl<'c> ::std::convert::AsMut<::zbus::Proxy<'c>> for IBusProxyGen<'c> {
    fn as_mut(&mut self) -> &mut ::zbus::Proxy<'c> {
        &mut *self
    }
}

impl<'c> ::zbus::zvariant::Type for IBusProxyGen<'c> {
    fn signature() -> ::zbus::zvariant::Signature<'static> {
        ::zbus::zvariant::OwnedObjectPath::signature()
    }
}

impl<'c> ::zbus::export::serde::ser::Serialize for IBusProxyGen<'c> {
    fn serialize<S>(&self, serializer: S) -> ::std::result::Result<S::Ok, S::Error>
    where
        S: ::zbus::export::serde::ser::Serializer,
    {
        ::std::string::String::serialize(
            &::std::string::ToString::to_string(self.inner().path()),
            serializer,
        )
    }
}

